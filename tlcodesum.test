{"id": "37963", "raw_code": "protected boolean[] datasetIntegrity(boolean nominalPredictor,boolean numericPredictor,boolean stringPredictor,boolean datePredictor,boolean relationalPredictor,boolean multiInstance,int classType,boolean predictorMissing,boolean classMissing){\n  print(\"kernel doesn't alter original datasets\");\n  printAttributeSummary(nominalPredictor,numericPredictor,stringPredictor,datePredictor,relationalPredictor,multiInstance,classType);\n  print(\"...\");\n  int numTrain=getNumInstances(), numClasses=2, missingLevel=20;\n  boolean[] result=new boolean[2];\n  Instances train=null;\n  Kernel kernel=null;\n  try {\n    train=makeTestDataset(42,numTrain,nominalPredictor ? getNumNominal() : 0,numericPredictor ? getNumNumeric() : 0,stringPredictor ? getNumString() : 0,datePredictor ? getNumDate() : 0,relationalPredictor ? getNumRelational() : 0,numClasses,classType,multiInstance);\n    if (missingLevel > 0) {\n      addMissing(train,missingLevel,predictorMissing,classMissing);\n    }\n    kernel=Kernel.makeCopies(getKernel(),1)[0];\n  }\n catch (  Exception ex) {\n    throw new Error(\"Error setting up for tests: \" + ex.getMessage());\n  }\n  try {\n    Instances trainCopy=new Instances(train);\n    kernel.buildKernel(trainCopy);\n    compareDatasets(train,trainCopy);\n    println(\"yes\");\n    result[0]=true;\n  }\n catch (  Exception ex) {\n    println(\"no\");\n    result[0]=false;\n    if (m_Debug) {\n      println(\"\\n=== Full Report ===\");\n      print(\"Problem during building\");\n      println(\": \" + ex.getMessage() + \"\\n\");\n      println(\"Here is the dataset:\\n\");\n      println(\"=== Train Dataset ===\\n\" + train.toString() + \"\\n\");\n    }\n  }\n  return result;\n}", "comment": "checks whether the scheme alters the training dataset during building .", "label": "what"}
{"id": "53306", "raw_code": "public static int unionSize(long[] x,long[] y){\n  final int lx=x.length, ly=y.length;\n  final int min=(lx < ly) ? lx : ly;\n  int i=0, res=0;\n  for (; i < min; i++) {\n    res+=Long.bitCount(x[i] | y[i]);\n  }\n  for (; i < lx; i++) {\n    res+=Long.bitCount(x[i]);\n  }\n  for (; i < ly; i++) {\n    res+=Long.bitCount(y[i]);\n  }\n  return res;\n}", "comment": "compute the union size of two bitsets .", "label": "what"}
{"id": "38468", "raw_code": "@Override public void closingOK(){\n  List<AddUserFields.AttributeSpec> specs=new ArrayList<AddUserFields.AttributeSpec>();\n  for (int i=0; i < m_listModel.size(); i++) {\n    AddUserFields.AttributeSpec a=(AddUserFields.AttributeSpec)m_listModel.elementAt(i);\n    specs.add(a);\n  }\n  if (m_modifyL != null) {\n    m_modifyL.setModifiedStatus(AddUserFieldsCustomizer.this,true);\n  }\n  m_filter.setAttributeSpecs(specs);\n}", "comment": "actions to perform when the user has closed the dialog with the ok button .", "label": "what"}
{"id": "20101", "raw_code": "private static boolean isDoubleEqual(double value,double valueToCompare){\n  return (Math.abs(value - valueToCompare) < 0.001);\n}", "comment": "checks if is double values are equal .", "label": "what"}
{"id": "7488", "raw_code": "@Override public void datasetChanged(DatasetChangeEvent event){\n  super.datasetChanged(event);\n  if (this.subplots == null) {\n    return;\n  }\n  XYDataset dataset=null;\n  if (event.getDataset() instanceof XYDataset) {\n    dataset=(XYDataset)event.getDataset();\n  }\n  for (  XYPlot subplot : this.subplots) {\n    if (subplot.indexOf(dataset) >= 0) {\n      subplot.configureRangeAxes();\n    }\n  }\n}", "comment": "receives notification of a change to the plot ' s dataset .", "label": "what"}
{"id": "26930", "raw_code": "public boolean onScheduleAsLibrary(Config config,Config runtime,IScheduler scheduler,PackingPlan packing){\n  boolean ret=false;\n  try {\n    scheduler.initialize(config,runtime);\n    ret=scheduler.onSchedule(packing);\n    if (ret) {\n      ret=SchedulerUtils.setLibSchedulerLocation(runtime,scheduler,false);\n    }\n else {\n      LOG.severe(\"Failed to invoke IScheduler as library\");\n    }\n  }\n  finally {\n    scheduler.close();\n  }\n  return ret;\n}", "comment": "invoke the onscheduler ( ) in ischeduler directly as a library", "label": "what"}
{"id": "56795", "raw_code": "private void validateSqlStatement(String sql,int jdbcStatementIndex){\n  Assert.isTrue(StringUtils.isNotBlank(sql),\"JDBC statement [\" + jdbcStatementIndex + \"] SQL is required\");\n}", "comment": "validates the given sql statement where its position in the list of statement is the given index .", "label": "what"}
{"id": "80601", "raw_code": "private static void useMissile(Player player){\n  StackableItem projectilesItem=null;\n  if (player.getRangeWeapon() != null) {\n    projectilesItem=player.getAmmunition();\n  }\n  if (projectilesItem == null) {\n    projectilesItem=player.getMissileIfNotHoldingOtherWeapon();\n  }\n  if (projectilesItem != null) {\n    projectilesItem.removeOne();\n  }\n}", "comment": "remove an used up missile from an attacking player .", "label": "what"}
{"id": "20694", "raw_code": "private int determineMaxLevelRec(int level,Node v){\n  int newLevel=level;\n  for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n    newLevel=Math.max(newLevel,determineMaxLevelRec(level,e.getTarget()) + 1);\n  }\n  return newLevel;\n}", "comment": "recursively does the work", "label": "what"}
{"id": "47090", "raw_code": "private void addWorkerFailed(Worker w){\n  final ReentrantLock mainLock=this.mainLock;\n  mainLock.lock();\n  try {\n    if (w != null)     workers.remove(w);\n    decrementWorkerCount();\n    tryTerminate();\n  }\n  finally {\n    mainLock.unlock();\n  }\n}", "comment": "rolls back the worker thread creation .", "label": "what"}
{"id": "25997", "raw_code": "private synchronized void putMapEntry(String localId,MapEntry entry){\n  if (!isLocalId(localId)) {\n    throw new IllegalStateException(\"Tried to get invalid local id: \\\"\" + localId + \"\\\".\");\n  }\n  JSONObject json=new JSONObject();\n  try {\n    json.put(\"retainCount\",entry.retainCount);\n    if (entry.objectId != null) {\n      json.put(\"objectId\",entry.objectId);\n    }\n  }\n catch (  JSONException je) {\n    throw new IllegalStateException(\"Error creating local id map entry.\",je);\n  }\n  File file=new File(diskPath,localId);\n  if (!diskPath.exists()) {\n    diskPath.mkdirs();\n  }\n  try {\n    ParseFileUtils.writeJSONObjectToFile(file,json);\n  }\n catch (  IOException e) {\n  }\n}", "comment": "writes one entry to the local id map on disk .", "label": "what"}
{"id": "61349", "raw_code": "public void endElement(String namespaceURI,String localName,String name) throws org.xml.sax.SAXException {\n  if (m_inEntityRef)   return;\n  m_prefixMap.popNamespaces(m_elemContext.m_currentElemDepth,null);\n  try {\n    final java.io.Writer writer=m_writer;\n    if (m_elemContext.m_startTagOpen) {\n      if (m_tracer != null)       super.fireStartElem(m_elemContext.m_elementName);\n      int nAttrs=m_attributes.getLength();\n      if (nAttrs > 0) {\n        processAttributes(m_writer,nAttrs);\n        m_attributes.clear();\n      }\n      if (m_spaceBeforeClose)       writer.write(\" />\");\n else       writer.write(\"/>\");\n    }\n else {\n      if (m_cdataTagOpen)       closeCDATA();\n      if (shouldIndent())       indent(m_elemContext.m_currentElemDepth - 1);\n      writer.write('<');\n      writer.write('/');\n      writer.write(name);\n      writer.write('>');\n    }\n  }\n catch (  IOException e) {\n    throw new SAXException(e);\n  }\n  if (!m_elemContext.m_startTagOpen && m_doIndent) {\n    m_ispreserve=m_preserves.isEmpty() ? false : m_preserves.pop();\n  }\n  m_isprevtext=false;\n  if (m_tracer != null)   super.fireEndElem(name);\n  m_elemContext=m_elemContext.m_prev;\n}", "comment": "receive notification of the end of an element .", "label": "what"}
{"id": "67965", "raw_code": "public static void f(String msg,Object... args){\n  if (!allowWtf)   return;\n  StackTraceElement caller=getCallerStackTraceElement();\n  String tag=generateTag(caller);\n  if (sLevel > LEVEL_FATAL) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.wtf(tag,msg);\n}", "comment": "send a fatal error log message", "label": "what"}
{"id": "4673", "raw_code": "protected boolean validate(final char[] component,final int soffset,int eoffset,final BitSet generous){\n  if (eoffset == -1) {\n    eoffset=component.length - 1;\n  }\n  for (int i=soffset; i <= eoffset; i++) {\n    if (!generous.get(component[i])) {\n      return false;\n    }\n  }\n  return true;\n}", "comment": "validate the uri characters within a specific component .", "label": "what"}
{"id": "35618", "raw_code": "private void buildPieces(){\n  pieces=new Piece[pathArray.size()];\n  Paint paint=new Paint();\n  Matrix matrix=new Matrix();\n  Canvas canvas=new Canvas();\n  for (int i=0; i < pieces.length; i++) {\n    int shadow=Utils.nextInt(Utils.dp2px(2),Utils.dp2px(9));\n    Path path=pathArray.get(i);\n    RectF r=new RectF();\n    path.computeBounds(r,true);\n    Bitmap pBitmap=Utils.createBitmapSafely((int)r.width() + shadow * 2,(int)r.height() + shadow * 2,Bitmap.Config.ARGB_4444,1);\n    if (pBitmap == null) {\n      pieces[i]=new Piece(-1,-1,null,shadow);\n      continue;\n    }\n    pieces[i]=new Piece((int)r.left + mTouchPoint.x - shadow,(int)r.top + mTouchPoint.y - shadow,pBitmap,shadow);\n    canvas.setBitmap(pieces[i].bitmap);\n    BitmapShader mBitmapShader=new BitmapShader(mBitmap,Shader.TileMode.CLAMP,Shader.TileMode.CLAMP);\n    matrix.reset();\n    matrix.setTranslate(-r.left - offsetX + shadow,-r.top - offsetY + shadow);\n    mBitmapShader.setLocalMatrix(matrix);\n    paint.reset();\n    Path offsetPath=new Path();\n    offsetPath.addPath(path,-r.left + shadow,-r.top + shadow);\n    paint.setStyle(Paint.Style.FILL);\n    paint.setShadowLayer(shadow,0,0,0xff333333);\n    canvas.drawPath(offsetPath,paint);\n    paint.setShadowLayer(0,0,0,0);\n    paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.XOR));\n    canvas.drawPath(offsetPath,paint);\n    paint.setXfermode(null);\n    paint.setShader(mBitmapShader);\n    paint.setAlpha(0xcc);\n    canvas.drawPath(offsetPath,paint);\n  }\n  Arrays.sort(pieces);\n}", "comment": "build the final bitmap - pieces to draw in animation", "label": "what"}
{"id": "42226", "raw_code": "public boolean removeShutdownHook(Thread hook){\n  SecurityManager sm=System.getSecurityManager();\n  if (sm != null) {\n    sm.checkPermission(RuntimePermissionCollection.SHUTDOWN_HOOKS_PERMISSION);\n  }\n  if (hook == null)   throw new NullPointerException(\"null is not allowed here\");\n  if (VMState > 0) {\n    throw new IllegalStateException();\n  }\nsynchronized (hooksList) {\n    return hooksList.remove(hook);\n  }\n}", "comment": "de - registers a previously - registered virtual - machine shutdown hook .", "label": "what"}
{"id": "84544", "raw_code": "public boolean boundScroll(){\n  float curScroll=getStackScroll();\n  float newScroll=getBoundedStackScroll(curScroll);\n  if (Float.compare(newScroll,curScroll) != 0) {\n    setStackScroll(newScroll);\n    return true;\n  }\n  return false;\n}", "comment": "bounds the current scroll if necessary", "label": "what"}
{"id": "22559", "raw_code": "public void waitForVolumesToBeVisible(CGRequestParams request){\n  scan(request.getCopies(),request.getRsets());\n}", "comment": "scans all sites until all volumes involved in the recoverpoint protection are visible", "label": "what"}
{"id": "66785", "raw_code": "public void updateView(){\n  if (fInputElement != null && fParentComposite != null) {\n    IndicatorViewState oldState=fStateMap.get(fInputElement);\n    boolean reload=fFilesToReoad.contains(fInputElement);\n    if (reload || oldState == null) {\n      JsonObject jsonObject=DroidsafePluginUtilities.parseIndicatorFile(fInputElement);\n      if (jsonObject == null)       return;\n      fFilesToReoad.remove(fInputElement);\n      fState=new IndicatorViewState(fInputElement,jsonObject,getSecuritySpec(),oldState);\n      fStateMap.put(fInputElement,fState);\n    }\n else {\n      fState=oldState;\n    }\n    setPartName(fState.indicatorType);\n    showPage(PAGE_VIEWER);\n    fTreeViewer.setInput(fState.jsonObject);\n    if (fTreeViewer.getSorter() == null)     sortByField(getSortByField());\n  }\n else {\n    setPartName(DEFAULT_PART_NAME);\n  }\n}", "comment": "update the content of the outline view .", "label": "what"}
{"id": "38443", "raw_code": "@Override public void paint(Graphics g){\n  g.drawImage(image,0,0,this);\n  if (!paintCalled) {\n    paintCalled=true;\nsynchronized (this) {\n      notifyAll();\n    }\n  }\n}", "comment": "paints the image on the window .", "label": "what"}
{"id": "71337", "raw_code": "public void releaseAnyConnection(Connection connection) throws SQLException {\n  try {\n    connection.close();\n  }\n catch (  Exception ex) {\n    throw new RuntimeException(ex);\n  }\n}", "comment": "release a non - shard - specific connection .", "label": "what"}
{"id": "29719", "raw_code": "protected <T extends AbstractOptionValue<?,?>>AbstractOptions(Function<T,T> valueFilter,AbstractOptions baseOptions,Iterable<T> values){\n  requireNonNull(baseOptions,\"baseOptions\");\n  requireNonNull(valueFilter,\"valueFilter\");\n  requireNonNull(values,\"values\");\n  valueMap=new IdentityHashMap<>(baseOptions.valueMap);\n  putAll(valueFilter,StreamSupport.stream(values.spliterator(),false));\n}", "comment": "creates a new instance .", "label": "what"}
{"id": "75393", "raw_code": "private void formatAndLogThrowable(LoggingLevel level,Color color,String msg,Throwable t){\n  if (!USE_COLORS) {\n    formatAndLogThrowable(level,msg,t);\n    return;\n  }\n  if (PhotonLogger.level.id < level.id) {\n    return;\n  }\n  LocalDateTime dateTime=LocalDateTime.now();\n  String formatted=formatLogLine(level,dateTime,msg);\n  LoggingService.logThrowable(dateTime,t,formatted,color);\n}", "comment": "formats and logs a message with a throwable .", "label": "what"}
{"id": "30048", "raw_code": "public static String constructQueueRedisKey(String queueName,String shardName,int priority,PinLaterJobState state){\n  return String.format(\"%s_%s_%s.p%1d_s%1d\",PINLATER_QUEUE_KEY_PREFIX,shardName,queueName,priority,state.getValue());\n}", "comment": "constructs the redis queue sorted set key name given a queue name , shard id and priority .", "label": "what"}
{"id": "14909", "raw_code": "public static String decodeCharset(String s,String charset){\n  if (s == null) {\n    return null;\n  }\n  try {\n    byte buf[]=s.getBytes(ASCII_CHARSET);\n    return (new String(buf,0,buf.length,charset));\n  }\n catch (  UnsupportedEncodingException uee) {\n    return s;\n  }\n}", "comment": "decodes the string into specified charset", "label": "what"}
{"id": "23610", "raw_code": "StoppableReadLock(ReadWriteLock lock,CancelCriterion stopper){\n  this.lock=lock.readLock();\n  this.stopper=stopper;\n}", "comment": "create a new read lock from the given lock", "label": "what"}
{"id": "50411", "raw_code": "public static void copy(byte[] in,OutputStream out) throws IOException {\n  Assert.notNull(in,\"No input byte array specified\");\n  Assert.notNull(out,\"No OutputStream specified\");\n  out.write(in);\n}", "comment": "copy the contents of the given byte array to the given outputstream .", "label": "what"}
{"id": "33756", "raw_code": "public RepeatedFieldBuilder<MType,BType,IType> addMessage(MType message){\n  if (message == null) {\n    throw new NullPointerException();\n  }\n  ensureMutableMessageList();\n  messages.add(message);\n  if (builders != null) {\n    builders.add(null);\n  }\n  onChanged();\n  incrementModCounts();\n  return this;\n}", "comment": "appends the specified element to the end of this list .", "label": "what"}
{"id": "46842", "raw_code": "private static boolean checkValue(String val) throws MalformedObjectNameException {\n  if (val == null)   throw new NullPointerException(\"Invalid value (null)\");\n  final int len=val.length();\n  if (len == 0)   return false;\n  final char[] s=val.toCharArray();\n  final int[] result=parseValue(s,0);\n  final int endValue=result[0];\n  final boolean value_pattern=result[1] == 1;\n  if (endValue < len)   throw new MalformedObjectNameException(\"Invalid character in value: `\" + s[endValue] + \"'\");\n  return value_pattern;\n}", "comment": "check if the supplied value is a valid value .", "label": "what"}
{"id": "35698", "raw_code": "private synchronized void rebuildJournal() throws IOException {\n  if (journalWriter != null) {\n    journalWriter.close();\n  }\n  Writer writer=new BufferedWriter(new FileWriter(journalFileTmp),IO_BUFFER_SIZE);\n  writer.write(MAGIC);\n  writer.write(\"\\n\");\n  writer.write(VERSION_1);\n  writer.write(\"\\n\");\n  writer.write(Integer.toString(appVersion));\n  writer.write(\"\\n\");\n  writer.write(Integer.toString(valueCount));\n  writer.write(\"\\n\");\n  writer.write(\"\\n\");\n  for (  Entry entry : lruEntries.values()) {\n    if (entry.currentEditor != null) {\n      writer.write(DIRTY + ' ' + entry.key+ '\\n');\n    }\n else {\n      writer.write(CLEAN + ' ' + entry.key+ entry.getLengths()+ '\\n');\n    }\n  }\n  writer.close();\n  journalFileTmp.renameTo(journalFile);\n  journalWriter=new BufferedWriter(new FileWriter(journalFile,true),IO_BUFFER_SIZE);\n}", "comment": "creates a new journal that omits redundant information .", "label": "what"}
{"id": "26525", "raw_code": "public void remove() throws RecurrenceInfoException {\n  List<RecurrenceRule> rulesList=new ArrayList<RecurrenceRule>();\n  rulesList.addAll(rRulesList);\n  rulesList.addAll(eRulesList);\n  try {\n    for (    RecurrenceRule rule : rulesList)     rule.remove();\n    info.remove();\n  }\n catch (  RecurrenceRuleException rre) {\n    throw new RecurrenceInfoException(rre.getMessage(),rre);\n  }\ncatch (  GenericEntityException gee) {\n    throw new RecurrenceInfoException(gee.getMessage(),gee);\n  }\n}", "comment": "removes the recurrence from persistant store .", "label": "what"}
{"id": "11867", "raw_code": "protected boolean needToRefetchData(){\n  long now=System.currentTimeMillis();\n  long last=lastDataFetchTime;\n  if ((last + fetchIntervalMillis) < now) {\n    lastDataFetchTime=now;\n    return true;\n  }\n  return false;\n}", "comment": "fetches data if it hasn ' t been fetched in a while .", "label": "what"}
{"id": "13027", "raw_code": "@Override public DocumentType createDocumentType(String qualifiedName,String publicID,String systemID){\n  checkQName(qualifiedName);\n  return new DocumentTypeImpl(null,qualifiedName,publicID,systemID);\n}", "comment": "introduced in dom level 2 .", "label": "what"}
{"id": "15457", "raw_code": "public void handleRequest(RequestContext rc) throws CLIException {\n  super.handleRequest(rc);\n  ldapLogin();\n  SSOToken adminSSOToken=getAdminSSOToken();\n  IOutput outputWriter=getOutputWriter();\n  String realm=getStringOptionValue(IArgument.REALM_NAME);\n  String patternType=getStringOptionValue(IArgument.AGENT_TYPE);\n  String filter=getStringOptionValue(IArgument.FILTER);\n  if (patternType == null) {\n    patternType=\"\";\n  }\n  if ((filter == null) || (filter.length() == 0)) {\n    filter=\"*\";\n  }\n  String[] params={realm,patternType,filter};\n  writeLog(LogWriter.LOG_ACCESS,Level.INFO,\"ATTEMPT_LIST_AGENTS\",params);\n  try {\n    AMIdentityRepository amir=new AMIdentityRepository(adminSSOToken,realm);\n    IdSearchResults isr=amir.searchIdentities(IdType.AGENTONLY,filter,new IdSearchControl());\n    Set results=isr.getSearchResults();\n    if ((results != null) && !results.isEmpty()) {\n      for (Iterator i=results.iterator(); i.hasNext(); ) {\n        AMIdentity amid=(AMIdentity)i.next();\n        if (!matchType(amid,patternType)) {\n          i.remove();\n        }\n      }\n    }\n    if ((results != null) && !results.isEmpty()) {\n      for (Iterator i=results.iterator(); i.hasNext(); ) {\n        AMIdentity amid=(AMIdentity)i.next();\n        Object[] args={amid.getName(),amid.getUniversalId()};\n        outputWriter.printlnMessage(MessageFormat.format(getResourceString(\"format-search-agent-results\"),args));\n      }\n    }\n else {\n      outputWriter.printlnMessage(getResourceString(\"search-agent-no-entries\"));\n    }\n    writeLog(LogWriter.LOG_ACCESS,Level.INFO,\"SUCCEED_LIST_AGENTS\",params);\n  }\n catch (  IdRepoException e) {\n    String[] args={realm,patternType,filter,e.getMessage()};\n    debugError(\"ListAgents.handleRequest\",e);\n    writeLog(LogWriter.LOG_ERROR,Level.INFO,\"FAILED_LIST_AGENTS\",args);\n    throw new CLIException(e,ExitCodes.REQUEST_CANNOT_BE_PROCESSED);\n  }\ncatch (  SSOException e) {\n    String[] args={realm,patternType,filter,e.getMessage()};\n    debugError(\"ListAgents.handleRequest\",e);\n    writeLog(LogWriter.LOG_ERROR,Level.INFO,\"FAILED_LIST_AGENTS\",args);\n    throw new CLIException(e,ExitCodes.REQUEST_CANNOT_BE_PROCESSED);\n  }\n}", "comment": "services a commandline request .", "label": "what"}
{"id": "21029", "raw_code": "public byte[] toBytes(){\n  try {\n    ByteArrayOutputStream out=new ByteArrayOutputStream();\n    _field.store(out,null);\n    return out.toByteArray();\n  }\n catch (  IOException e) {\n    throw new IllegalStateException(e);\n  }\n}", "comment": "serializes this nested object into byte [ ]", "label": "what"}
{"id": "25459", "raw_code": "@HLEUnimplemented @HLEFunction(nid=0x3C37A7A6,version=150,checkInsideInterrupt=true) public int sceMpegNextAvcRpAu(@CheckArgument(\"checkMpegHandle\") int mpeg,int streamUid){\n  if (!streamMap.containsKey(streamUid)) {\n    log.warn(String.format(\"sceMpegNextAvcRpAu bad stream 0x%X\",streamUid));\n    return -1;\n  }\n  int result=hleMpegGetAvcAu(null);\n  if (result != 0) {\n    if (log.isDebugEnabled()) {\n      log.debug(String.format(\"sceMpegNextAvcRpAu returning 0x%08X\",result));\n    }\n    return result;\n  }\n  videoFrameCount++;\n  startedMpeg=true;\n  return 0;\n}", "comment": "scempegnextavcrpau - skip one video frame", "label": "what"}
{"id": "63057", "raw_code": "public ImmutableArray2<K> insert(int index,K obj){\n  int len=length + 1;\n  int newLen=len;\n  boolean extendable;\n  if (index == len - 1) {\n    AtomicBoolean x=canExtend;\n    if (x != null) {\n      canExtend=null;\n      if (array.length > index && x.getAndSet(false)) {\n        array[index]=obj;\n        return new ImmutableArray2<K>(array,len,true);\n      }\n    }\n    extendable=true;\n    newLen=len + 4;\n  }\n else {\n    extendable=false;\n  }\n  @SuppressWarnings(\"unchecked\") K[] a2=(K[])new Object[newLen];\n  DataUtils.copyWithGap(array,a2,length,index);\n  a2[index]=obj;\n  return new ImmutableArray2<K>(a2,len,extendable);\n}", "comment": "insert an entry at this index .", "label": "what"}
{"id": "73994", "raw_code": "public void writeNoScale(Image c,Component i){\n  if (page == null) {\n    newpage();\n  }\n  int x=x0 + width - (c.getWidth(null) + charwidth);\n  int y=y0 + (linenum * lineheight) + lineascent;\n  if (page != null && pagenum >= prFirst) {\n    page.drawImage(c,x,y,c.getWidth(null),c.getHeight(null),null);\n  }\n}", "comment": "write a graphic to the printout .", "label": "what"}
{"id": "61293", "raw_code": "public void putDocumentInCache(int n,Source source){\n  int cachedNode=getNode(source);\n  if (DTM.NULL != cachedNode) {\n    if (!(cachedNode == n))     throw new RuntimeException(\"Programmer's Error!  \" + \"putDocumentInCache found reparse of doc: \" + source.getSystemId());\n    return;\n  }\n  if (null != source.getSystemId()) {\n    m_sourceTree.addElement(new SourceTree(n,source.getSystemId()));\n  }\n}", "comment": "put the source tree root node in the document cache .", "label": "what"}
{"id": "1102", "raw_code": "public static void copy(InputStream is,Resource out,boolean closeIS) throws IOException {\n  OutputStream os=null;\n  try {\n    os=toBufferedOutputStream(out.getOutputStream());\n  }\n catch (  IOException ioe) {\n    IOUtil.closeEL(os);\n    throw ioe;\n  }\n  copy(is,os,closeIS,true);\n}", "comment": "copy a input resource to a output resource", "label": "what"}
{"id": "43774", "raw_code": "public String fadeAudio(String path,String type,double fadeInLength,double stopTime,double fadeOutLength) throws IOException {\n  final List<String> curves=Arrays.asList(new String[]{\"q\",\"h\",\"t\",\"l\",\"p\"});\n  if (!curves.contains(type)) {\n    throw new RuntimeException(\"fadeAudio: passed invalid type: \" + type);\n  }\n  File file=new File(path);\n  String outFile=file.getCanonicalPath() + \"_faded.wav\";\n  ArrayList<String> cmd=new ArrayList<String>();\n  cmd.add(soxBin);\n  cmd.add(path);\n  cmd.add(outFile);\n  cmd.add(\"fade\");\n  cmd.add(type);\n  cmd.add(fadeInLength + \"\");\n  if (stopTime != -1)   cmd.add(stopTime + \"\");\n  if (fadeOutLength != -1)   cmd.add(fadeOutLength + \"\");\n  try {\n    int rc=execSox(cmd,callback);\n    if (rc != 0) {\n      outFile=null;\n    }\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\ncatch (  InterruptedException e) {\n    e.printStackTrace();\n  }\n  return outFile;\n}", "comment": "fade audio file sox outfile fade", "label": "what"}
{"id": "85085", "raw_code": "private static void fixGPSTimeStamp(XMPNode exifSchema) throws XMPException {\n  XMPNode gpsDateTime=XMPNodeUtils.findChildNode(exifSchema,\"exif:GPSTimeStamp\",false);\n  if (gpsDateTime == null) {\n    return;\n  }\n  try {\n    XMPDateTime binGPSStamp;\n    XMPDateTime binOtherDate;\n    binGPSStamp=XMPUtils.convertToDate(gpsDateTime.getValue());\n    if (binGPSStamp.getYear() != 0 || binGPSStamp.getMonth() != 0 || binGPSStamp.getDay() != 0) {\n      return;\n    }\n    XMPNode otherDate=XMPNodeUtils.findChildNode(exifSchema,\"exif:DateTimeOriginal\",false);\n    if (otherDate == null) {\n      otherDate=XMPNodeUtils.findChildNode(exifSchema,\"exif:DateTimeDigitized\",false);\n    }\n    binOtherDate=XMPUtils.convertToDate(otherDate.getValue());\n    Calendar cal=binGPSStamp.getCalendar();\n    cal.set(Calendar.YEAR,binOtherDate.getYear());\n    cal.set(Calendar.MONTH,binOtherDate.getMonth());\n    cal.set(Calendar.DAY_OF_MONTH,binOtherDate.getDay());\n    binGPSStamp=new XMPDateTimeImpl(cal);\n    gpsDateTime.setValue(XMPUtils.convertFromDate(binGPSStamp));\n  }\n catch (  XMPException e) {\n    return;\n  }\n}", "comment": "fixes the gps timestamp in exif .", "label": "what"}
{"id": "56925", "raw_code": "protected boolean cellConsumesEventType(Cell<?> cell,String eventType){\n  Set<String> consumedEvents=cell.getConsumedEvents();\n  return consumedEvents != null && consumedEvents.contains(eventType);\n}", "comment": "check if a cell consumes the specified event type .", "label": "what"}
{"id": "44270", "raw_code": "public int read() throws IOException {\n  int b0=fInputStream.read();\n  if (b0 > 0x80) {\n    throw new IOException(Localizer.getMessage(\"jsp.error.xml.invalidASCII\",Integer.toString(b0)));\n  }\n  return b0;\n}", "comment": "read a single character .", "label": "what"}
{"id": "35834", "raw_code": "protected void create_y_axis(int i){\n  Log.e(\"index vlaue\",i + \"\");\n  float ver_height=((graphheight / label_size) * i) + border;\n  if (i == largest_value_set.size() - 1)   canvas.drawLine(horstart,ver_height,width - (border),ver_height,paint);\n else   canvas.drawLine(horstart,ver_height,border,ver_height,paint);\n  paint.setColor(Color.BLACK);\n  int Y_labels=(int)size - 1 - i;\n  String y_labels=String.format(\"%.1f\",Y_labels * y_axis_ratio);\n  paint.setTextAlign(Paint.Align.RIGHT);\n  canvas.drawText(y_labels,horstart - 15,ver_height - 10,paint);\n  paint.setTextAlign(Paint.Align.LEFT);\n}", "comment": "this function is used to plot the y axis and its breakdown with value .", "label": "what"}
{"id": "76471", "raw_code": "public long max(){\n  return deltaMax.get();\n}", "comment": "get running - maximum time - delta , in nanoseconds .", "label": "what"}
{"id": "62019", "raw_code": "public void extend(RuleGrounding other){\n  if (other.isFailed()) {\n    groundings.clear();\n    return;\n  }\n  extend(other.getAlternatives());\n}", "comment": "extends the existing groundings with the alternative groundings", "label": "what"}
{"id": "25039", "raw_code": "public void removeSwipeListener(SwipeListener listener){\n  if (mListeners == null) {\n    return;\n  }\n  mListeners.remove(listener);\n}", "comment": "removes a listener from the set of listeners", "label": "what"}
{"id": "42446", "raw_code": "@Pure public Atom annotationInterfaceToAnnotationClass(){\n  byte[] annotationClassName_tmp=new byte[val.length + 2];\n  System.arraycopy(val,0,annotationClassName_tmp,0,val.length - 1);\n  annotationClassName_tmp[val.length - 1]='$';\n  annotationClassName_tmp[val.length]='$';\n  annotationClassName_tmp[val.length + 1]=';';\n  return Atom.findOrCreateUtf8Atom(annotationClassName_tmp);\n}", "comment": "creates an annotation name from a class name .", "label": "what"}
{"id": "22820", "raw_code": "public boolean resourceSupportAR(Integer id){\n  if (id == null) {\n    return false;\n  }\n  return resourceSupportAR(id.intValue());\n}", "comment": "checks whether a given resource id supports advanced reservations or not .", "label": "what"}
{"id": "63797", "raw_code": "public static int intersectLineLine(Line2D a,Line2D b,Point2D intersect){\n  double a1x=a.getX1(), a1y=a.getY1();\n  double a2x=a.getX2(), a2y=a.getY2();\n  double b1x=b.getX1(), b1y=b.getY1();\n  double b2x=b.getX2(), b2y=b.getY2();\n  return intersectLineLine(a1x,a1y,a2x,a2y,b1x,b1y,b2x,b2y,intersect);\n}", "comment": "compute the intersection of two line segments .", "label": "what"}
{"id": "76097", "raw_code": "protected void drawGridBackground(Canvas c){\n  if (mDrawGridBackground) {\n    c.drawRect(mViewPortHandler.getContentRect(),mGridBackgroundPaint);\n  }\n  if (mDrawBorders) {\n    c.drawRect(mViewPortHandler.getContentRect(),mBorderPaint);\n  }\n}", "comment": "draws the grid background", "label": "what"}
{"id": "3754", "raw_code": "public ZipStreamImpl openReadImpl(PathImpl path) throws IOException {\n  String pathName=path.getPath();\n  return openReadImpl(pathName);\n}", "comment": "opens a stream to an entry in the jar .", "label": "what"}
{"id": "38212", "raw_code": "private static char[] zzUnpackCMap(String packed){\n  char[] map=new char[0x10000];\n  int i=0;\n  int j=0;\n  while (i < 112) {\n    int count=packed.charAt(i++);\n    char value=packed.charAt(i++);\n    do     map[j++]=value;\n while (--count > 0);\n  }\n  return map;\n}", "comment": "unpacks the compressed character translation table .", "label": "what"}
{"id": "59553", "raw_code": "@Override public void onTmpFilesCopied(ResultCode result){\n  dismissLoadingDialog();\n  finish();\n}", "comment": "process the result of copyanduploadcontenturistask", "label": "what"}
{"id": "26163", "raw_code": "private boolean isFieldPackagePrivate(Element attribute){\n  Set<Modifier> modifiers=attribute.getModifiers();\n  return !modifiers.contains(PUBLIC) && !modifiers.contains(PROTECTED) && !modifiers.contains(PRIVATE);\n}", "comment": "checks if the given field has package - private visibility", "label": "what"}
{"id": "12611", "raw_code": "private void loadText(InputStream is){\n  BufferedReader reader;\n  String line;\n  unitList=new ArrayList();\n  unitTypesList=new ArrayList();\n  if (is == null) {\n    throw new Error(\"Can't load cluster db file.\");\n  }\n  reader=new BufferedReader(new InputStreamReader(is));\n  try {\n    line=reader.readLine();\n    lineCount++;\n    while (line != null) {\n      if (!line.startsWith(\"***\")) {\n        parseAndAdd(line,reader);\n      }\n      line=reader.readLine();\n    }\n    reader.close();\n    units=new DatabaseClusterUnit[unitList.size()];\n    units=(DatabaseClusterUnit[])unitList.toArray(units);\n    unitList=null;\n    unitTypes=new UnitType[unitTypesList.size()];\n    unitTypes=(UnitType[])unitTypesList.toArray(unitTypes);\n    unitTypesList=null;\n  }\n catch (  IOException e) {\n    throw new Error(e.getMessage() + \" at line \" + lineCount);\n  }\n finally {\n  }\n}", "comment": "loads the database from the given input stream .", "label": "what"}
{"id": "86104", "raw_code": "private int measureWidth(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=(int)mTextPaint.measureText(mText) + getPaddingLeft() + getPaddingRight();\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}", "comment": "determines the width of this view", "label": "what"}
{"id": "80128", "raw_code": "@Override public void onAdded(final RPObject object){\n  if (isUser(object)) {\n    if (object.has(\"adminlevel\")) {\n      adminlevel=object.getInt(\"adminlevel\");\n    }\n  }\n}", "comment": "an object was added .", "label": "what"}
{"id": "60129", "raw_code": "public void pathValuesToPixel(List<Path> paths){\n  for (int i=0; i < paths.size(); i++) {\n    pathValueToPixel(paths.get(i));\n  }\n}", "comment": "transforms multiple paths will all matrices .", "label": "what"}
{"id": "50127", "raw_code": "public static byte[] decode(String s){\n  return decode(s.toCharArray());\n}", "comment": "decodes a byte array from base64 format .", "label": "what"}
{"id": "16758", "raw_code": "public static void checkState(boolean expression,Object errorMessage){\n  if (ExoPlayerLibraryInfo.ASSERTIONS_ENABLED && !expression) {\n    throw new IllegalStateException(String.valueOf(errorMessage));\n  }\n}", "comment": "ensures the truth of an expression involving the state of the calling instance .", "label": "what"}
{"id": "30032", "raw_code": "public static void slideInFromTopAnimator(@NonNull List<Animator> animators,@NonNull View view,RecyclerView recyclerView){\n  alphaAnimator(animators,view,0f);\n  animators.add(ObjectAnimator.ofFloat(view,\"translationY\",-recyclerView.getMeasuredHeight() >> 1,0));\n  if (FlexibleAdapter.DEBUG)   Log.v(TAG,\"Added TOP Animator\");\n}", "comment": "item will slide from top of the screen to its natural position .", "label": "what"}
{"id": "47944", "raw_code": "MutableBigInteger(MutableBigInteger val){\n  intLen=val.intLen;\n  value=Arrays.copyOfRange(val.value,val.offset,val.offset + intLen);\n}", "comment": "construct a new mutablebiginteger with a magnitude equal to the specified mutablebiginteger .", "label": "what"}
{"id": "9857", "raw_code": "@RequestMapping(value=\"/SAML2/IDPSSO/{tenant:.*}\") public void ssoBindingError(Locale locale,@PathVariable(value=\"tenant\") String tenant,HttpServletResponse response) throws IOException {\n  logger.info(\"IDP SSO binding error! The client locale is \" + locale.toString() + \", tenant is \"+ tenant);\n  ssoDefaultTenantError(locale,response);\n}", "comment": "handle request sent with a wrong binding", "label": "what"}
{"id": "40230", "raw_code": "public CheckpointManager(NetworkParameters params,@Nullable InputStream inputStream) throws IOException {\n  this.params=checkNotNull(params);\n  if (inputStream == null)   inputStream=openStream(params);\n  checkNotNull(inputStream);\n  inputStream=new BufferedInputStream(inputStream);\n  inputStream.mark(1);\n  int first=inputStream.read();\n  inputStream.reset();\n  if (first == BINARY_MAGIC.charAt(0))   dataHash=readBinary(inputStream);\n else   if (first == TEXTUAL_MAGIC.charAt(0))   dataHash=readTextual(inputStream);\n else   throw new IOException(\"Unsupported format.\");\n}", "comment": "loads the checkpoints from the given stream", "label": "what"}
{"id": "27585", "raw_code": "public IndexSegmentIndex(IRawStore store,Checkpoint checkpoint,IndexMetadata metadata,boolean readOnly){\n  super(store,checkpoint,metadata,readOnly);\n}", "comment": "load from the store .", "label": "what"}
{"id": "20057", "raw_code": "private String liveness(){\n  boolean isClosed=false;\n  try {\n    if (isClosed()) {\n      isClosed=true;\n    }\n  }\n catch (  SQLException s) {\n    isClosed=true;\n  }\n  if (isClosed) {\n    return \"CLOSED\";\n  }\n  return \"OPEN\";\n}", "comment": "provides a string representation of whether this connection is closed or not", "label": "what"}
{"id": "52710", "raw_code": "public boolean select(int position){\n  View v=mAllList.get(position);\n  if (mMultiChoiceAdapter != null) {\n    performVibrate();\n    performSelect(v,position,true);\n    return true;\n  }\n  return false;\n}", "comment": "select a view from position in the adapter", "label": "what"}
{"id": "69646", "raw_code": "public static NSObject parse(InputStream in) throws ParseException, IOException {\n  byte[] buf=PropertyListParser.readAll(in);\n  in.close();\n  return parse(buf);\n}", "comment": "parses an ascii property list from an input stream .", "label": "what"}
{"id": "52179", "raw_code": "protected double currentScoreFunction(){\n  double score=0.;\n  for (int i=0; i < this.values[this.currentVar1].length; i++) {\n    for (int j=0; j < this.values[this.currentVar2].length; j++) {\n      score-=this.currentCounts[this.currentVar1][this.currentVar2][i][j] * Math.log(this.currentPi[i][j]);\n    }\n  }\n  return score;\n}", "comment": "function to be minimized : - loglikelihood .", "label": "what"}
{"id": "70752", "raw_code": "private int checkZoneLink(SpannableStringBuilder out,String in,int start){\n  int pos=start + 3;\n  StringBuilder temp=new StringBuilder();\n  String targetString=in.substring(pos,Math.min(in.length(),pos + 20));\n  boolean prevIsDash=false;\n  for (int i=0; i < targetString.length(); i++) {\n    char c=targetString.charAt(i);\n    if ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) {\n      temp.append(c);\n      prevIsDash=false;\n    }\n else     if (c == '-') {\n      if (i == 0) {\n        return -1;\n      }\n      if (prevIsDash) {\n        temp.deleteCharAt(temp.length() - 1);\n        break;\n      }\n      temp.append(c);\n      prevIsDash=true;\n    }\n else {\n      if (prevIsDash) {\n        temp.deleteCharAt(temp.length() - 1);\n      }\n      break;\n    }\n  }\n  String zone=temp.toString();\n  if (zone.length() < 3 || zone.equalsIgnoreCase(\"null\")) {\n    return -1;\n  }\n  out.append(zone);\n  return pos + zone.length() - 1;\n}", "comment": "change this should review zone . java", "label": "what"}
{"id": "81155", "raw_code": "final void layoutChildren(boolean queryAdapter){\n  final int paddingLeft=getPaddingLeft();\n  final int paddingRight=getPaddingRight();\n  final int itemMargin=mItemMargin;\n  final int colWidth=(getWidth() - paddingLeft - paddingRight- itemMargin * (mColCount - 1)) / mColCount;\n  mColWidth=colWidth;\n  int rebuildLayoutRecordsBefore=-1;\n  int rebuildLayoutRecordsAfter=-1;\n  Arrays.fill(mItemBottoms,Integer.MIN_VALUE);\n  final int childCount=getChildCount();\n  int amountRemoved=0;\n  for (int i=0; i < childCount; i++) {\n    View child=getChildAt(i);\n    LayoutParams lp=(LayoutParams)child.getLayoutParams();\n    final int col=lp.column;\n    final int position=mFirstPosition + i;\n    final boolean needsLayout=queryAdapter || child.isLayoutRequested();\n    if (queryAdapter) {\n      View newView=obtainView(position,child);\n      if (newView == null) {\n        removeViewAt(i);\n        if (i - 1 >= 0)         invalidateLayoutRecordsAfterPosition(i - 1);\n        amountRemoved++;\n        continue;\n      }\n else       if (newView != child) {\n        removeViewAt(i);\n        addView(newView,i);\n        child=newView;\n      }\n      lp=(LayoutParams)child.getLayoutParams();\n    }\n    final int span=Math.min(mColCount,lp.span);\n    final int widthSize=colWidth * span + itemMargin * (span - 1);\n    if (needsLayout) {\n      final int widthSpec=MeasureSpec.makeMeasureSpec(widthSize,MeasureSpec.EXACTLY);\n      final int heightSpec;\n      if (lp.height == LayoutParams.WRAP_CONTENT) {\n        heightSpec=MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED);\n      }\n else {\n        heightSpec=MeasureSpec.makeMeasureSpec(lp.height,MeasureSpec.EXACTLY);\n      }\n      child.measure(widthSpec,heightSpec);\n    }\n    int childTop=mItemBottoms[col] > Integer.MIN_VALUE ? mItemBottoms[col] + mItemMargin : child.getTop();\n    if (span > 1) {\n      int lowest=childTop;\n      for (int j=col + 1; j < col + span; j++) {\n        final int bottom=mItemBottoms[j] + mItemMargin;\n        if (bottom > lowest) {\n          lowest=bottom;\n        }\n      }\n      childTop=lowest;\n    }\n    final int childHeight=child.getMeasuredHeight();\n    final int childBottom=childTop + childHeight;\n    final int childLeft=paddingLeft + col * (colWidth + itemMargin);\n    final int childRight=childLeft + child.getMeasuredWidth();\n    child.layout(childLeft,childTop,childRight,childBottom);\n    for (int j=col; j < col + span; j++) {\n      mItemBottoms[j]=childBottom;\n    }\n    final LayoutRecord rec=mLayoutRecords.get(position);\n    if (rec != null && rec.height != childHeight) {\n      rec.height=childHeight;\n      rebuildLayoutRecordsBefore=position;\n    }\n    if (rec != null && rec.span != span) {\n      rec.span=span;\n      rebuildLayoutRecordsAfter=position;\n    }\n  }\n  for (int i=0; i < mColCount; i++) {\n    if (mItemBottoms[i] == Integer.MIN_VALUE) {\n      mItemBottoms[i]=mItemTops[i];\n    }\n  }\n  if (rebuildLayoutRecordsBefore >= 0 || rebuildLayoutRecordsAfter >= 0) {\n    if (rebuildLayoutRecordsBefore >= 0) {\n      invalidateLayoutRecordsBeforePosition(rebuildLayoutRecordsBefore);\n    }\n    if (rebuildLayoutRecordsAfter >= 0) {\n      invalidateLayoutRecordsAfterPosition(rebuildLayoutRecordsAfter);\n    }\n    for (int i=0; i < (childCount - amountRemoved); i++) {\n      final int position=mFirstPosition + i;\n      final View child=getChildAt(i);\n      final LayoutParams lp=(LayoutParams)child.getLayoutParams();\n      LayoutRecord rec=mLayoutRecords.get(position);\n      if (rec == null) {\n        rec=new LayoutRecord();\n        mLayoutRecords.put(position,rec);\n      }\n      rec.column=lp.column;\n      rec.height=child.getHeight();\n      rec.id=lp.id;\n      rec.span=Math.min(mColCount,lp.span);\n    }\n  }\n  if (this.mSelectorPosition != INVALID_POSITION) {\n    View child=getChildAt(mMotionPosition - mFirstPosition);\n    if (child != null)     positionSelector(mMotionPosition,child);\n  }\n else   if (mTouchMode > TOUCH_MODE_DOWN) {\n    View child=getChildAt(mMotionPosition - mFirstPosition);\n    if (child != null)     positionSelector(mMotionPosition,child);\n  }\n else {\n    mSelectorRect.setEmpty();\n  }\n}", "comment": "measure and layout all currently visible children .", "label": "what"}
{"id": "68311", "raw_code": "public double percentage(ConstantRange range){\n  SortedSet<Constant> sorted=values();\n  SortedSet<Constant> contained=new TreeSet<Constant>();\n  Constant prev=null;\n  for (  Constant pct : sorted) {\n    if (range.contains(pct))     contained.add(pct);\n else     if (contained.isEmpty())     prev=pct;\n  }\n  if (contained.size() == 0)   return 0.0;\n  double prevPercent=prev == null ? 0.0 : pcts.get(prev);\n  return pcts.get(contained.last()) - prevPercent;\n}", "comment": "gets the percent of values within the specified value range .", "label": "what"}
{"id": "32268", "raw_code": "public static void closeQuiet(@Nullable Closeable closeable){\n  if (closeable != null) {\n    try {\n      closeable.close();\n    }\n catch (    IOException ignored) {\n    }\n  }\n}", "comment": "closes resource without reporting any error .", "label": "what"}
{"id": "1227", "raw_code": "@Override public void releaseLuceePageContext(PageContext pc,boolean register){\n  if (pc.getId() < 0)   return;\n  pc.release();\n  ThreadLocalPageContext.release();\n  runningPcs.remove(Integer.valueOf(pc.getId()));\n  if (pcs.size() < 100 && pc.getRequestTimeoutException() == null)   pcs.push(pc);\n}", "comment": "similar to the releasepagecontext method , but take lucee pagecontext as entry", "label": "what"}
{"id": "53986", "raw_code": "public static Properties loadProperties(ClassLoader classLoader,String classpathResource){\n  return loadProperties(null,classpathResource);\n}", "comment": "atomically load the properties file at the given location within the designated class loader .", "label": "what"}
{"id": "28807", "raw_code": "public final static NameValuePair parseNameValuePair(final String value,HeaderValueParser parser) throws ParseException {\n  if (value == null) {\n    throw new IllegalArgumentException(\"Value to parse may not be null\");\n  }\n  if (parser == null)   parser=SaveHeaderValueParser.DEFAULT;\n  CharArrayBuffer buffer=new CharArrayBuffer(value.length());\n  buffer.append(value);\n  SaveParserCursor cursor=new SaveParserCursor(0,value.length());\n  return parser.parseNameValuePair(buffer,cursor);\n}", "comment": "parses a name - value - pair with the given parser .", "label": "what"}
{"id": "1464", "raw_code": "private void pullEvent(){\n  final int newScrollValue;\n  final int itemDimension;\n  final float initialMotionValue, lastMotionValue;\nswitch (getPullToRefreshScrollDirection()) {\ncase HORIZONTAL:\n    initialMotionValue=mInitialMotionX;\n  lastMotionValue=mLastMotionX;\nbreak;\ncase VERTICAL:\ndefault :\ninitialMotionValue=mInitialMotionY;\nlastMotionValue=mLastMotionY;\nbreak;\n}\nswitch (mCurrentMode) {\ncase PULL_FROM_END:\nnewScrollValue=Math.round(Math.max(initialMotionValue - lastMotionValue,0) / FRICTION);\nitemDimension=getFooterSize();\nbreak;\ncase PULL_FROM_START:\ndefault :\nnewScrollValue=Math.round(Math.min(initialMotionValue - lastMotionValue,0) / FRICTION);\nitemDimension=getHeaderSize();\nbreak;\n}\nsetHeaderScroll(newScrollValue);\nif (newScrollValue != 0 && !isRefreshing()) {\nfloat scale=Math.abs(newScrollValue) / (float)itemDimension;\nswitch (mCurrentMode) {\ncase PULL_FROM_END:\nmFooterLayout.onPull(scale);\nbreak;\ncase PULL_FROM_START:\ndefault :\nmHeaderLayout.onPull(scale);\nbreak;\n}\nif (mState != State.PULL_TO_REFRESH && itemDimension >= Math.abs(newScrollValue)) {\nsetState(State.PULL_TO_REFRESH);\n}\n else if (mState == State.PULL_TO_REFRESH && itemDimension < Math.abs(newScrollValue)) {\nsetState(State.RELEASE_TO_REFRESH);\n}\n}\n}", "comment": "actions a pull event", "label": "what"}
{"id": "44860", "raw_code": "public String parse(File file,JSON m){\n  try {\n    Template template=getTemplate(file);\n    if (template != null) {\n      StringWriter w=new StringWriter();\n      BufferedWriter writer=new BufferedWriter(w);\n      template.merge(new VelocityContext(m),writer);\n      writer.flush();\n      writer.close();\n      return w.toString();\n    }\n  }\n catch (  Exception e) {\n    log.error(e.getMessage(),e);\n  }\n  return null;\n}", "comment": "parse the file to string with the json", "label": "what"}
{"id": "68860", "raw_code": "private LinkedList<Diff> diff_main(String text1,String text2,boolean checklines,long deadline){\n  if (text1 == null || text2 == null) {\n    throw new IllegalArgumentException(\"Null inputs. (diff_main)\");\n  }\n  LinkedList<Diff> diffs;\n  if (text1.equals(text2)) {\n    diffs=new LinkedList<Diff>();\n    if (text1.length() != 0) {\n      diffs.add(new Diff(Operation.EQUAL,text1));\n    }\n    return diffs;\n  }\n  int commonlength=diff_commonPrefix(text1,text2);\n  String commonprefix=text1.substring(0,commonlength);\n  text1=text1.substring(commonlength);\n  text2=text2.substring(commonlength);\n  commonlength=diff_commonSuffix(text1,text2);\n  String commonsuffix=text1.substring(text1.length() - commonlength);\n  text1=text1.substring(0,text1.length() - commonlength);\n  text2=text2.substring(0,text2.length() - commonlength);\n  diffs=diff_compute(text1,text2,checklines,deadline);\n  if (commonprefix.length() != 0) {\n    diffs.addFirst(new Diff(Operation.EQUAL,commonprefix));\n  }\n  if (commonsuffix.length() != 0) {\n    diffs.addLast(new Diff(Operation.EQUAL,commonsuffix));\n  }\n  diff_cleanupMerge(diffs);\n  return diffs;\n}", "comment": "find the differences between two texts .", "label": "what"}
{"id": "45935", "raw_code": "public Repository(String domain,boolean fairLock){\n  lock=new ReentrantReadWriteLock(fairLock);\n  domainTb=new HashMap<String,Map<String,NamedObject>>(5);\n  if (domain != null && domain.length() != 0)   this.domain=domain.intern();\n else   this.domain=ServiceName.DOMAIN;\n  domainTb.put(this.domain,new HashMap<String,NamedObject>());\n}", "comment": "construct a new repository with the given default domain .", "label": "what"}
{"id": "75413", "raw_code": "protected void handle(Exception exception,String title,String message){\n  Utils.handleError(getShell(),exception,title,message);\n}", "comment": "shows the given errors to the user .", "label": "what"}
{"id": "82762", "raw_code": "private void paintForegroundEnabled(Graphics2D g,int width,int height){\n  Shape s=decodeArrowPath(width,height);\n  g.setPaint(enabledColor);\n  g.fill(s);\n}", "comment": "paint the arrow in enabled state .", "label": "what"}
{"id": "30788", "raw_code": "private static void logThrow(Level level,String className,String methodName,String message,Object[] args,Throwable thrown){\n  java.util.logging.LogRecord lr=new java.util.logging.LogRecord(level,message);\n  lr.setLoggerName(logger.getName());\n  lr.setSourceClassName(className);\n  lr.setSourceMethodName(methodName);\n  lr.setParameters(args);\n  lr.setThrown(thrown);\n  logger.log(lr);\n}", "comment": "logs a thrown exception .", "label": "what"}
{"id": "72151", "raw_code": "public boolean allowsTrailingArguments(){\n  return allowsTrailingArguments;\n}", "comment": "indicates whether this sub - command will allow unnamed trailing arguments .", "label": "what"}
{"id": "36600", "raw_code": "private void evaluatePopup(MouseEvent e){\n  if (e.isPopupTrigger()) {\n    JPopupMenu menu=createBookmarkPopupMenu();\n    if (menu != null) {\n      menu.show(this,e.getX(),e.getY());\n    }\n  }\n}", "comment": "checks if the given mouse event is a popup trigger and creates a new popup menu if necessary .", "label": "what"}
{"id": "30903", "raw_code": "private boolean removeTask(Task t,int min){\n  for (int i=tasks.size(); --i >= min; ) {\n    if (tasks.get(i) == t) {\n      tasks.remove(i);\n      if (i < firstPending) {\n        firstPending--;\n        for (int j=threads.size(); --j >= 0; ) {\n          TaskThread thread=threads.get(j);\n          if (thread.task == t) {\n            if (thread != Thread.currentThread())             thread.interrupt();\n            break;\n          }\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n}", "comment": "remove a task if it has index > = min .", "label": "what"}
{"id": "17268", "raw_code": "protected void ensurePathExists(String path){\n  String[] paths=path.split(\"/\");\n  StringBuffer spath=new StringBuffer(\"/\");\n  for (  String temp : paths) {\n    if (StringUtils.isBlank(temp)) {\n      continue;\n    }\n    spath.append(temp);\n    ensureExists(spath.toString(),null,acl,CreateMode.PERSISTENT);\n    spath.append(\"/\");\n  }\n}", "comment": "ensures that the given path exists with no data , the current acl and no flags", "label": "what"}
{"id": "62176", "raw_code": "private int measureShort(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=(int)(2 * mRadius + getPaddingTop() + getPaddingBottom() + 1);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}", "comment": "determines the height of this view", "label": "what"}
{"id": "8010", "raw_code": "private boolean isListChildUnderClipped(float x,float y){\n  final View listChild=findListChildUnder(x,y);\n  return listChild != null && isDescendantClipped(listChild);\n}", "comment": "this only checks clipping along the bottom edge .", "label": "what"}
{"id": "64140", "raw_code": "public static void writeByteArrayToFile(File file,byte[] data,boolean append) throws IOException {\n  OutputStream out=null;\n  try {\n    out=openOutputStream(file,append);\n    out.write(data);\n    out.close();\n  }\n  finally {\n    IOUtils.closeQuietly(out);\n  }\n}", "comment": "writes a byte array to a file creating the file if it does not exist .", "label": "what"}
{"id": "32415", "raw_code": "private void checkPendingCustomMessages(){\n  if (joiningNodes.isEmpty() && isLocalNodeCoordinator()) {\n    TcpDiscoveryCustomEventMessage msg;\n    while ((msg=pendingCustomMsgs.poll()) != null) {\n      processCustomMessage(msg);\n      if (msg.verified())       msgHist.add(msg);\n    }\n  }\n}", "comment": "checks and flushes custom event messages if no nodes are attempting to join the grid .", "label": "what"}
{"id": "35649", "raw_code": "private float calculateScrambleImageHeightMultiplier(float multiplier){\nswitch (currentPuzzle) {\ncase PuzzleUtils.TYPE_777:\ncase PuzzleUtils.TYPE_666:\ncase PuzzleUtils.TYPE_555:\ncase PuzzleUtils.TYPE_222:\ncase PuzzleUtils.TYPE_444:\ncase PuzzleUtils.TYPE_333:\n    return (multiplier / 4) * 3;\ncase PuzzleUtils.TYPE_CLOCK:\n  return multiplier / 2;\ncase PuzzleUtils.TYPE_MEGA:\nreturn (multiplier / 2);\ncase PuzzleUtils.TYPE_PYRA:\nreturn (float)(multiplier / Math.sqrt(1.25));\ncase PuzzleUtils.TYPE_SKEWB:\nreturn (multiplier / 4) * 3;\ncase PuzzleUtils.TYPE_SQUARE1:\nreturn multiplier;\n}\nreturn multiplier;\n}", "comment": "calculates scramble image height multiplier to respect aspect ratio", "label": "what"}
{"id": "64844", "raw_code": "public float realAbsolute(){\n  return Math.abs(mLeft);\n}", "comment": "absolute value of real component", "label": "what"}
{"id": "5469", "raw_code": "@Override public Generator<ICircle> construct(String[] args){\n  return new UniformGenerator(Double.valueOf(args[0]));\n}", "comment": "provide reflective behavior to construct instance of generator given an array of string arguments .", "label": "what"}
{"id": "2553", "raw_code": "private boolean yy_refill() throws java.io.IOException {\n  if (yy_startRead > 0) {\n    System.arraycopy(yy_buffer,yy_startRead,yy_buffer,0,yy_endRead - yy_startRead);\n    yy_endRead-=yy_startRead;\n    yy_currentPos-=yy_startRead;\n    yy_markedPos-=yy_startRead;\n    yy_pushbackPos-=yy_startRead;\n    yy_startRead=0;\n  }\n  if (yy_currentPos >= yy_buffer.length) {\n    char newBuffer[]=new char[yy_currentPos * 2];\n    System.arraycopy(yy_buffer,0,newBuffer,0,yy_buffer.length);\n    yy_buffer=newBuffer;\n  }\n  int numRead=yy_reader.read(yy_buffer,yy_endRead,yy_buffer.length - yy_endRead);\n  if (numRead < 0) {\n    return true;\n  }\n else {\n    yy_endRead+=numRead;\n    return false;\n  }\n}", "comment": "refills the input buffer .", "label": "what"}
{"id": "36852", "raw_code": "protected boolean hasAllTables() throws CouldntLoadDataException, InvalidDatabaseException {\n  NaviLogger.info(\"Checking the existence of the BinNavi database tables\");\n  final int counter=PostgreSQLHelpers.getTableCount(getConnection(),Lists.newArrayList(TABLES));\n  if (counter == 0) {\n    return false;\n  }\n else   if (counter == TABLES.length) {\n    return true;\n  }\n else {\n    throw new InvalidDatabaseException(String.format(\"Invalid database state (%d of %d tables found)\",counter,TABLES.length));\n  }\n}", "comment": "makes sure that all required binnavi database tables exist .", "label": "what"}
{"id": "34485", "raw_code": "public List<String> classify(List<List<Feature>> features) throws CleartkProcessingException {\n  String[][] featureStringArray=toStrings(features);\n  Pipe pipe=transducer.getInputPipe();\n  Instance instance=new Instance(featureStringArray,null,null,null);\n  instance=pipe.instanceFrom(instance);\n  Sequence<?> data=(Sequence<?>)instance.getData();\n  Sequence<?> untypedSequence=transducer.transduce(data);\n  Sequence<String> sequence=ReflectionUtil.uncheckedCast(untypedSequence);\n  List<String> returnValues=new ArrayList<String>();\n  for (int i=0; i < sequence.size(); i++) {\n    String encodedOutcome=sequence.get(i);\n    returnValues.add(outcomeEncoder.decode(encodedOutcome));\n  }\n  return returnValues;\n}", "comment": "this method classifies several instances at once", "label": "what"}
{"id": "62968", "raw_code": "public void onBindHeaderViewHolder(RecyclerView.ViewHolder holder,int position){\n  onBindHeaderViewHolder(holder,position,Collections.emptyList());\n}", "comment": "bind header with provided viewholder at specified position", "label": "what"}
{"id": "36397", "raw_code": "private void updateLineList(){\n  if (horizontalLineRadiobutton.isSelected()) {\n    setHorizontalLineSelected();\n  }\n else {\n    setVerticalLineSelected();\n  }\n  updateButtonStates();\n}", "comment": "updates the displayed list of lines .", "label": "what"}
{"id": "32926", "raw_code": "public void rectangle(double x,double y,double halfWidth,double halfHeight){\n  if (halfWidth < 0)   throw new IllegalArgumentException(\"half width can't be negative\");\n  if (halfHeight < 0)   throw new IllegalArgumentException(\"half height can't be negative\");\n  double xs=scaleX(x);\n  double ys=scaleY(y);\n  double ws=factorX(2 * halfWidth);\n  double hs=factorY(2 * halfHeight);\n  if (ws <= 1 && hs <= 1)   pixel(x,y);\n else   offscreen.draw(new Rectangle2D.Double(xs - ws / 2,ys - hs / 2,ws,hs));\n  draw();\n}", "comment": "draws a rectangle of given half width and half height , centered on ( x , y ) .", "label": "what"}
{"id": "43312", "raw_code": "public void replaceSplitElement(int aIndex,Fragment aSplitElement){\n  splits.set(aIndex,aSplitElement);\n}", "comment": "replaces a split element with another one", "label": "what"}
{"id": "51062", "raw_code": "public boolean hasSingleElement(){\n  return mSelectedWidgets.size() == 1;\n}", "comment": "check if the selection has a single element", "label": "what"}
{"id": "32342", "raw_code": "public IgfsPath(URI uri){\n  A.notNull(uri,\"uri\");\n  path=normalizePath(uri.getPath());\n}", "comment": "constructs a path from an uri", "label": "what"}
{"id": "1346", "raw_code": "public int toInt(Element el,String attributeName){\n  return Caster.toIntValue(el.getAttribute(attributeName),Integer.MIN_VALUE);\n}", "comment": "reads a xml element attribute ans cast it to a int value", "label": "what"}
{"id": "56191", "raw_code": "private void handleStateLeft(InetAddress endpoint,String[] pieces){\n  assert pieces.length >= 2;\n  Collection<Token> tokens=getTokensFor(endpoint);\n  if (logger.isDebugEnabled())   logger.debug(\"Node {} state left, tokens {}\",endpoint,tokens);\n  excise(tokens,endpoint,extractExpireTime(pieces));\n}", "comment": "handle node leaving the ring .", "label": "what"}
{"id": "45919", "raw_code": "public static void register(String algorithmURI,Class<? extends SignatureAlgorithmSpi> implementingClass) throws AlgorithmAlreadyRegisteredException, ClassNotFoundException, XMLSignatureException {\n  JavaUtils.checkRegisterPermission();\n  if (log.isLoggable(java.util.logging.Level.FINE)) {\n    log.log(java.util.logging.Level.FINE,\"Try to register \" + algorithmURI + \" \"+ implementingClass);\n  }\n  Class<? extends SignatureAlgorithmSpi> registeredClass=algorithmHash.get(algorithmURI);\n  if (registeredClass != null) {\n    Object exArgs[]={algorithmURI,registeredClass};\n    throw new AlgorithmAlreadyRegisteredException(\"algorithm.alreadyRegistered\",exArgs);\n  }\n  algorithmHash.put(algorithmURI,implementingClass);\n}", "comment": "registers implementing class of the transform algorithm with algorithmuri", "label": "what"}
{"id": "31807", "raw_code": "@SuppressWarnings(\"UnusedDeclaration\") public KeyValuePersistenceSettings(File settingsFile){\n  InputStream in;\n  try {\n    in=new FileInputStream(settingsFile);\n  }\n catch (  IOException e) {\n    throw new IgniteException(\"Failed to get input stream for Cassandra persistence settings file: \" + settingsFile.getAbsolutePath(),e);\n  }\n  init(loadSettings(in));\n}", "comment": "constructs ignite cache key / value persistence settings .", "label": "what"}
{"id": "70625", "raw_code": "private <T>UnaryOperator<T> compose(UnaryOperator<T> before,UnaryOperator<T> after){\n  return null;\n}", "comment": "compose two functions together into a single function", "label": "what"}
{"id": "19784", "raw_code": "private void addCdcColSpecs(ArrayList<ColumnSpec> cdcSpecs,OneRowChange cdcRowChangeData){\n  int cdcPos=cdcSpecs.size();\n  if (cdcColumnsAtFront)   cdcPos=0;\n  ColumnSpec spec=cdcRowChangeData.new ColumnSpec();\n  spec.setIndex(cdcPos + 1);\n  spec.setName(\"CDC_OP_TYPE\");\n  spec.setType(java.sql.Types.VARCHAR);\n  spec.setLength(1);\n  cdcSpecs.add(cdcPos,spec);\n  spec=cdcRowChangeData.new ColumnSpec();\n  spec.setIndex(cdcPos + 1 + 1);\n  spec.setName(\"CDC_TIMESTAMP\");\n  spec.setType(java.sql.Types.TIMESTAMP);\n  cdcSpecs.add(cdcPos + 1,spec);\n  spec=cdcRowChangeData.new ColumnSpec();\n  spec.setIndex(cdcPos + 1 + 2);\n  spec.setName(\"CDC_SEQUENCE_NUMBER\");\n  spec.setType(java.sql.Types.BIGINT);\n  cdcSpecs.add(cdcPos + 2,spec);\n}", "comment": "add cdc column specifications .", "label": "what"}
{"id": "25137", "raw_code": "public static void checkArgument(boolean expression,@Nullable Object errorMessage){\n  if (!expression) {\n    throw new IllegalArgumentException(String.valueOf(errorMessage));\n  }\n}", "comment": "ensures the truth of an expression involving one or more parameters to the calling method .", "label": "what"}
{"id": "83531", "raw_code": "private synchronized void rebuildJournal() throws IOException {\n  if (journalWriter != null) {\n    journalWriter.close();\n  }\n  Writer writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(journalFileTmp),Util.US_ASCII));\n  try {\n    writer.write(MAGIC);\n    writer.write(\"\\n\");\n    writer.write(VERSION_1);\n    writer.write(\"\\n\");\n    writer.write(Integer.toString(appVersion));\n    writer.write(\"\\n\");\n    writer.write(Integer.toString(valueCount));\n    writer.write(\"\\n\");\n    writer.write(\"\\n\");\n    for (    Entry entry : lruEntries.values()) {\n      if (entry.currentEditor != null) {\n        writer.write(DIRTY + ' ' + entry.key+ '\\n');\n      }\n else {\n        writer.write(CLEAN + ' ' + entry.key+ entry.getLengths()+ '\\n');\n      }\n    }\n  }\n  finally {\n    writer.close();\n  }\n  if (journalFile.exists()) {\n    renameTo(journalFile,journalFileBackup,true);\n  }\n  renameTo(journalFileTmp,journalFile,false);\n  journalFileBackup.delete();\n  journalWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(journalFile,true),Util.US_ASCII));\n}", "comment": "creates a new journal that omits redundant information .", "label": "what"}
{"id": "70344", "raw_code": "private void refreshDoneButton(boolean done){\n  butDone.setText(done ? Messages.getString(\"ChatLounge.notDone\") : Messages.getString(\"ChatLounge.imDone\"));\n}", "comment": "refreshes the done button .", "label": "what"}
{"id": "17376", "raw_code": "private void createMigrationTaskPage(){\n  MigrationTaskEditor migrationTaskEditor=new MigrationTaskEditor(migrationTask,getContainer());\n  int index=addPage(migrationTaskEditor.getControl());\n  setPageText(index,\"Task\");\n  taskListeners.add(migrationTaskEditor);\n}", "comment": "create the basic editor .", "label": "what"}
{"id": "71884", "raw_code": "private boolean hasNext(Pattern pattern){\n  if (!hasNext()) {\n    return false;\n  }\n  Matcher matcher=pattern.matcher(gserValue.substring(pos,length));\n  return matcher.find();\n}", "comment": "determines if the remaining gser string matches the provided pattern .", "label": "what"}
{"id": "76212", "raw_code": "void pushInt(int i){\nswitch (i) {\ncase -1:\n    mv.visitInsn(ICONST_M1);\n  return;\ncase 0:\nmv.visitInsn(ICONST_0);\nreturn;\ncase 1:\nmv.visitInsn(ICONST_1);\nreturn;\ncase 2:\nmv.visitInsn(ICONST_2);\nreturn;\ncase 3:\nmv.visitInsn(ICONST_3);\nreturn;\ncase 4:\nmv.visitInsn(ICONST_4);\nreturn;\ncase 5:\nmv.visitInsn(ICONST_5);\nreturn;\n}\nif (i >= Byte.MIN_VALUE && i <= Byte.MAX_VALUE) {\nmv.visitIntInsn(BIPUSH,i);\nreturn;\n}\nif (i >= Short.MIN_VALUE && i <= Short.MAX_VALUE) {\nmv.visitIntInsn(SIPUSH,i);\nreturn;\n}\nmv.visitLdcInsn(Integer.valueOf(i));\n}", "comment": "push i onto our operand stack", "label": "what"}
{"id": "63162", "raw_code": "public static String xmlNode(String name,String attributes,String content,boolean indent){\n  String start=attributes == null ? name : name + attributes;\n  if (content == null) {\n    return \"<\" + start + \"/>\\n\";\n  }\n  if (indent && content.indexOf('\\n') >= 0) {\n    content=\"\\n\" + indent(content);\n  }\n  return \"<\" + start + \">\"+ content+ \"</\"+ name+ \">\\n\";\n}", "comment": "create an xml node with optional attributes and content .", "label": "what"}
{"id": "33487", "raw_code": "void notifyFailure(Throwable exception){\nsynchronized (waitObject) {\n    isComplete=true;\n    if (exception instanceof MqttException) {\n      pendingException=(MqttException)exception;\n    }\n else {\n      pendingException=new MqttException(exception);\n    }\n    waitObject.notifyAll();\n    if (exception instanceof MqttException) {\n      lastException=(MqttException)exception;\n    }\n    if (listener != null) {\n      listener.onFailure(this,exception);\n    }\n  }\n}", "comment": "notify unsuccessful completion of the operation", "label": "what"}
{"id": "79355", "raw_code": "public static void transform(StreamSource src,StreamSource stylesheet,Fop fop) throws FOPException {\n  Result res=new SAXResult(fop.getDefaultHandler());\n  try {\n    TransformerFactory factory=TransformerFactory.newInstance();\n    Transformer transformer;\n    if (stylesheet == null) {\n      transformer=factory.newTransformer();\n    }\n else {\n      transformer=factory.newTransformer(stylesheet);\n    }\n    transformer.setURIResolver(new LocalResolver(transformer.getURIResolver()));\n    transformer.transform(src,res);\n  }\n catch (  Exception e) {\n    throw new FOPException(e);\n  }\n}", "comment": "transform an xsl - fo streamsource to the specified output format .", "label": "what"}
{"id": "60356", "raw_code": "protected final boolean readAvailableBlocking() throws IOException {\n  char[] buffer=myBuffer;\n  StringBuilder token=myTextBuffer;\n  token.setLength(0);\n  boolean read=false;\n  int n;\n  while ((n=myReader.read(buffer)) > 0) {\n    if (myScheduledSubmitter != null)     myScheduledSubmitter.cancel(true);\n    read=true;\nsynchronized (myTextBuffer) {\n      processLine(buffer,token,n);\n    }\n    myScheduledSubmitter=myExecutorService.submit(myTokenSubmitter);\n  }\n  submitToken();\n  return read;\n}", "comment": "reads data with blocking .", "label": "what"}
{"id": "29023", "raw_code": "public void deleteObligation(final Obligation obligation,int basicBlockId) throws ObligationAcquiredOrReleasedInLoopException {\n  Map<ObligationSet,State> updatedStateMap=new HashMap<ObligationSet,State>();\n  for (Iterator<State> i=stateIterator(); i.hasNext(); ) {\n    State state=i.next();\n    checkCircularity(state,obligation,basicBlockId);\n    ObligationSet obligationSet=state.getObligationSet();\n    obligationSet.remove(obligation);\n    if (!obligationSet.isEmpty()) {\n      updatedStateMap.put(obligationSet,state);\n    }\n  }\n  replaceMap(updatedStateMap);\n}", "comment": "remove an obligation from every state in the stateset .", "label": "what"}
{"id": "42174", "raw_code": "private Set<Integer> findValues(String string){\n  Set<Integer> results=new TreeSet<Integer>();\n  for (  String str : string.split(\",\")) {\n    if (!str.equals(\"\")) {\n      results.add(findValue(str));\n    }\n  }\n  return results;\n}", "comment": "search for a string in the enumeration .", "label": "what"}
{"id": "60696", "raw_code": "public boolean equals(Object obj){\n  if (obj == this) {\n    return true;\n  }\n  if (!(obj instanceof Certificate)) {\n    return false;\n  }\n  Certificate object=(Certificate)obj;\n  try {\n    return Arrays.equals(getEncoded(),object.getEncoded());\n  }\n catch (  CertificateEncodingException e) {\n    return false;\n  }\n}", "comment": "compares the argument to this certificate .", "label": "what"}
{"id": "7067", "raw_code": "public Statement between(Object former,Object later){\n  statement.append(\" BETWEEN \");\n  append(former);\n  statement.append(\" AND \");\n  append(later);\n  return this;\n}", "comment": "appending the between operator clause .", "label": "what"}
{"id": "27614", "raw_code": "public byte[] encode1(final String s){\n  final ByteArrayBuffer tmp=new ByteArrayBuffer(s.length());\n  final int nwritten=uc.encode(s,tmp);\n  final int npack=LongPacker.getByteLength(nwritten);\n  final byte[] a=new byte[npack + nwritten];\n  final DataOutputBuffer dob=new DataOutputBuffer(0,a);\n  try {\n    dob.packLong(nwritten);\n    dob.append(tmp.array(),0,tmp.pos());\n    return a;\n  }\n  finally {\n    try {\n      dob.close();\n    }\n catch (    IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n}", "comment": "encode a unicode string .", "label": "what"}
{"id": "53077", "raw_code": "private void computeWeights(Node node){\n  int wsum=0;\n  for (  Node child : node.children) {\n    computeWeights(child);\n    wsum+=child.weight;\n  }\n  node.weight=Math.max(1,wsum);\n}", "comment": "recursively assign node weights .", "label": "what"}
{"id": "28241", "raw_code": "public Searcher() throws IOException {\n  searcher=new IndexSearcher(DirectoryReader.open(FSDirectory.open(Paths.get(INDEX_DIR))));\n  parser=new QueryParser(CONTENT_FIELD,new StandardAnalyzer());\n}", "comment": "creates a new instance of searchengine", "label": "what"}
{"id": "56377", "raw_code": "public QueryStringQueryBuilder field(String field){\n  if (fields == null) {\n    fields=new ArrayList<>();\n  }\n  fields.add(field);\n  return this;\n}", "comment": "adds a field to run the query string against .", "label": "what"}
{"id": "55264", "raw_code": "public StreamInfoManager(TwitchApi api,StreamInfoListener listener){\n  this.listener=listener;\n  this.api=api;\n  pendingRequests=new HashMap<>();\n  invalidStreamInfo=new StreamInfo(\"invalid\",listener);\n  invalidStreamInfo.setRequested();\n}", "comment": "create a new manager object .", "label": "what"}
{"id": "80040", "raw_code": "public boolean isPronoun(){\n  return typeString.contains(SUFFIX_PRONOUN);\n}", "comment": "determine if the expression is a pronoun .", "label": "what"}
{"id": "81838", "raw_code": "public static Vector tokenizeString(String source,String separator){\n  if (separator.length() == 1) {\n    return tokenizeString(source,separator.charAt(0));\n  }\n  Vector tokenized=new Vector();\n  int len=source.length();\n  StringBuilder buf=new StringBuilder();\n  for (int iter=0; iter < len; iter++) {\n    char current=source.charAt(iter);\n    if (separator.indexOf(current) > -1) {\n      if (buf.length() > 0) {\n        tokenized.addElement(buf.toString());\n        buf=new StringBuilder();\n      }\n    }\n else {\n      buf.append(current);\n    }\n  }\n  if (buf.length() > 0) {\n    tokenized.addElement(buf.toString());\n  }\n  return tokenized;\n}", "comment": "breaks a string to multiple strings ( similar to string tokenizer )", "label": "what"}
{"id": "77831", "raw_code": "private void backupFavorites(BackupDataOutput data) throws IOException {\n  ContentResolver cr=mContext.getContentResolver();\n  Cursor cursor=cr.query(Favorites.CONTENT_URI,FAVORITE_PROJECTION,getUserSelectionArg(),null,null);\n  try {\n    cursor.moveToPosition(-1);\n    while (cursor.moveToNext()) {\n      final long id=cursor.getLong(ID_INDEX);\n      final long updateTime=cursor.getLong(ID_MODIFIED);\n      Key key=getKey(Key.FAVORITE,id);\n      mKeys.add(key);\n      final String backupKey=keyToBackupKey(key);\n      if (!mExistingKeys.contains(backupKey) || updateTime >= mLastBackupRestoreTime) {\n        writeRowToBackup(key,packFavorite(cursor),data);\n      }\n else {\n        if (DEBUG)         Log.d(TAG,\"favorite already backup up: \" + id);\n      }\n    }\n  }\n  finally {\n    cursor.close();\n  }\n}", "comment": "write all modified favorites to the data stream .", "label": "what"}
{"id": "59732", "raw_code": "public void update(){\n  if (lastTime != -1L) {\n    long delta=System.nanoTime() - lastTime;\n    rollingAverage.addValue(delta);\n  }\n  lastTime=System.nanoTime();\n}", "comment": "update the fps counter .", "label": "what"}
{"id": "84252", "raw_code": "CryptoResult(final T result,final List<K> masterKeys,final CiphertextHeaders headers){\n  result_=result;\n  masterKeys_=Collections.unmodifiableList(masterKeys);\n  headers_=headers;\n  encryptionContext_=headers_.getEncryptionContextMap();\n}", "comment": "note , does not make a defensive copy of any of the data .", "label": "what"}
{"id": "73376", "raw_code": "private void initializeLayout(){\n  GridLayout gl=new GridLayout(0,2);\n  gl.setVgap(5);\n  setLayout(gl);\n  add(new JLabel(\"Frozen: \"));\n  add(frozenDD);\n  add(new JLabel(\"Upper Bound:\"));\n  add(tfUpBound);\n  add(new JLabel(\"Lower Bound\"));\n  add(tfLowBound);\n  add(new JLabel(\"Increment:\"));\n  add(tfIncrement);\n  add(new JLabel(\"Delay:\"));\n  add(tfDelay);\n  setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n}", "comment": "lays out the panel", "label": "what"}
{"id": "10829", "raw_code": "public static MosaicDefinition createMosaicDefinition(final Account creator){\n  return createMosaicDefinition(creator,Utils.createMosaicId(\"alice.vouchers\",\"alice's gift vouchers\"),createMosaicProperties());\n}", "comment": "creates a default mosaic definition .", "label": "what"}
{"id": "82892", "raw_code": "public Result result(SqlNode node,Collection<Clause> clauses,RelNode rel){\n  final String alias2=SqlValidatorUtil.getAlias(node,-1);\n  final String alias3=alias2 != null ? alias2 : \"t\";\n  final String alias4=SqlValidatorUtil.uniquify(alias3,aliasSet,SqlValidatorUtil.EXPR_SUGGESTER);\n  final String alias5=alias2 == null || !alias2.equals(alias4) ? alias4 : null;\n  return new Result(node,clauses,alias5,Collections.singletonList(Pair.of(alias4,rel.getRowType())));\n}", "comment": "creates a result based on a single relational expression .", "label": "what"}
{"id": "73479", "raw_code": "private void addInternalListeners(){\n  cbDistribution.addItemListener(cbItemListener);\n}", "comment": "adds all internal listeners .", "label": "what"}
{"id": "71088", "raw_code": "public Node(Coordinate pt){\n  this(pt,new DirectedEdgeStar());\n}", "comment": "constructs a node with the given location .", "label": "what"}
{"id": "60260", "raw_code": "public void revert(final VirtualFile root,final List<FilePath> files) throws VcsException {\n  for (  List<String> paths : VcsFileUtil.chunkPaths(root,files)) {\n    GitSimpleHandler handler=new GitSimpleHandler(myProject,root,GitCommand.CHECKOUT);\n    handler.addParameters(\"HEAD\");\n    handler.endOptions();\n    handler.addParameters(paths);\n    handler.run();\n  }\n}", "comment": "reverts the list of files we are passed .", "label": "what"}
{"id": "1509", "raw_code": "public static float[] concatAllFloat(float[]... arrays){\n  int totalLength=0;\n  final int subArrayCount=arrays.length;\n  for (int i=0; i < subArrayCount; ++i) {\n    totalLength+=arrays[i].length;\n  }\n  float[] result=Arrays.copyOf(arrays[0],totalLength);\n  int offset=arrays[0].length;\n  for (int i=1; i < subArrayCount; ++i) {\n    System.arraycopy(arrays[i],0,result,offset,arrays[i].length);\n    offset+=arrays[i].length;\n  }\n  return result;\n}", "comment": "concatenates a list of float arrays into a single array .", "label": "what"}
{"id": "20801", "raw_code": "public TaggedValueIterator(final String aLine,final boolean attemptFirstWord,final String... tags){\n  this.aLine=aLine;\n  this.attemptFirstWord=attemptFirstWord;\n  this.tags=tags;\n  tagPos=0;\n  nextResult=getNextResult();\n  if (attemptFirstWord) {\n    int a=0;\n    while (a < aLine.length()) {\n      if (aLine.charAt(a) == '>' || aLine.charAt(a) == '@' || Character.isWhitespace(aLine.charAt(a)))       a++;\n else       break;\n    }\n    int b=a + 1;\n    while (b < aLine.length()) {\n      if (Character.isLetterOrDigit(aLine.charAt(b)) || aLine.charAt(b) == '_')       b++;\n else       break;\n    }\n    if (b - a > 4) {\n      nextResult=aLine.substring(a,b);\n    }\n    tagPos=b;\n  }\n}", "comment": "iterator over all values following an occurrence of tag in aline .", "label": "what"}
{"id": "17335", "raw_code": "public void ascendTree(){\n  if (null != parentPath) {\n    parentPath.append(PARENT_PATH);\n    return;\n  }\n  File parentTree=calcParentTree();\n  if (null != parentTree) {\n    treeFile=parentTree;\n    return;\n  }\n  parentPath=new StringBuilder(provideLastName());\n  parentPath.append(PARENT_PATH);\n}", "comment": "move higher in the tree , beyond even an apparent root of tree .", "label": "what"}
{"id": "82624", "raw_code": "void writeTo(byte[] b,int off){\n  System.arraycopy(buf,0,b,off,count);\n}", "comment": "writes the contents of the internal buffer to the given array starting at the given offset .", "label": "what"}
{"id": "1930", "raw_code": "void onItemDismissed(final int position){\n  final T removed=mData.get(position);\n  final boolean wasRemoved=remove(position);\n  if (wasRemoved && mDataChangeListener != null) {\n    mDataChangeListener.onItemRemoved(removed,position);\n  }\n}", "comment": "dismisses item from the given position .", "label": "what"}
{"id": "52628", "raw_code": "public synchronized void addZoomListener(ZoomListener listener){\n  mZoomListeners.add(listener);\n}", "comment": "adds a new zoom listener .", "label": "what"}
{"id": "36420", "raw_code": "public void fireAnnotationSelected(WorkflowAnnotation anno){\n  List<WorkflowAnnotation> list=new LinkedList<>();\n  list.add(anno);\n  fireAnnotationsChanged(AnnotationEvent.SELECTED_ANNOTATION_CHANGED,list);\n}", "comment": "fire when an annotation has been selected .", "label": "what"}
{"id": "46450", "raw_code": "public void handleText(String text){\n  if (skippingCharacters > 0) {\n    if (skippingCharacters >= text.length()) {\n      skippingCharacters-=text.length();\n      return;\n    }\n else {\n      text=text.substring(skippingCharacters);\n      skippingCharacters=0;\n    }\n  }\n  if (rtfDestination != null) {\n    rtfDestination.handleText(text);\n    return;\n  }\n  warning(\"Text with no destination. oops.\");\n}", "comment": "handles any pure text ( containing no control characters ) in the input stream .", "label": "what"}
{"id": "27328", "raw_code": "public final boolean remove(final URI serviceURI){\n  boolean modified=false;\nsynchronized (this) {\n    if (aliases.remove(serviceURI) != null) {\n      modified=true;\n    }\n    final ServiceFactory factory=services.remove(serviceURI);\n    if (factory != null) {\n      modified=true;\n      if (factory instanceof CustomServiceFactory) {\n        customServices.remove(factory);\n      }\n    }\n  }\n  return modified;\n}", "comment": "remove a service from the registry and / or set of known aliases .", "label": "what"}
{"id": "67083", "raw_code": "public EscapedWriter(Writer fos){\n  super(fos);\n}", "comment": "constructs an escapedwriter around the given writer .", "label": "what"}
{"id": "69142", "raw_code": "public void record(RecordBuilderImpl recordBuilder){\n  storeBitmap(recordBuilder);\n  OutputStream viewHierarchyDump=null;\n  try {\n    viewHierarchyDump=mAlbum.openViewHierarchyFile(recordBuilder.getName());\n    mViewHierarchy.deflate(recordBuilder.getView(),viewHierarchyDump);\n    mAlbum.addRecord(recordBuilder);\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n finally {\n    if (viewHierarchyDump != null) {\n      try {\n        viewHierarchyDump.close();\n      }\n catch (      IOException e) {\n        Log.e(\"ScreenshotImpl\",\"Exception closing viewHierarchyDump\",e);\n      }\n    }\n  }\n}", "comment": "records the recordbuilderimpl , and verifies if required", "label": "what"}
{"id": "69266", "raw_code": "public Metadata.Property.Builder clear(){\n  Metadata_Property_Builder _defaults=new Metadata.Property.Builder();\n  type=_defaults.type;\n  boxedType=_defaults.boxedType;\n  name=_defaults.name;\n  capitalizedName=_defaults.capitalizedName;\n  allCapsName=_defaults.allCapsName;\n  getterName=_defaults.getterName;\n  codeGenerator=_defaults.codeGenerator;\n  fullyCheckedCast=_defaults.fullyCheckedCast;\n  accessorAnnotations.clear();\n  _unsetProperties.clear();\n  _unsetProperties.addAll(_defaults._unsetProperties);\n  return (Metadata.Property.Builder)this;\n}", "comment": "resets the state of this builder .", "label": "what"}
{"id": "22206", "raw_code": "public void checkBackupInfo(final File backupInfoFile,boolean backupInMultiVdc){\n  try (InputStream fis=new FileInputStream(backupInfoFile)){\n    Properties properties=new Properties();\n    properties.load(fis);\n    checkVersion(properties);\n    checkHosts(properties,backupInMultiVdc);\n  }\n catch (  IOException ex) {\n    log.warn(\"Unable to check backup Info\",ex);\n  }\n}", "comment": "checks version and ips", "label": "what"}
{"id": "34295", "raw_code": "public static byte[] buildOpusComment(String comment){\n  byte[] data=new byte[28 + comment.length()];\n  writeOpusComment(data,0,comment);\n  return data;\n}", "comment": "builds and returns a opus comment .", "label": "what"}
{"id": "7206", "raw_code": "public static void assertProps(UniformPair<EventBean> received,String[] propertyNames,Object[] expectedInsert,Object[] expectedRemoved){\n  assertProps(received.getFirst(),propertyNames,expectedInsert);\n  assertProps(received.getSecond(),propertyNames,expectedRemoved);\n}", "comment": "assert that the property values of a new event and a removed event match the expected insert and removed values .", "label": "what"}
{"id": "52017", "raw_code": "public final Iterator<KnowledgeEdge> requiredEdgesIterator(){\n  Set<KnowledgeEdge> edges=new HashSet<>();\n  for (  OrderedPair<Set<MyNode>> o : requiredRulesSpecs) {\n    final Set<MyNode> first=o.getFirst();\n    for (    MyNode s1 : first) {\n      final Set<MyNode> second=o.getSecond();\n      for (      MyNode s2 : second) {\n        if (!s1.equals(s2)) {\n          edges.add(new KnowledgeEdge(s1.getName(),s2.getName()));\n        }\n      }\n    }\n  }\n  return edges.iterator();\n}", "comment": "iterator over the knowledgeedge ' s representing required edges .", "label": "what"}
{"id": "5964", "raw_code": "@Deprecated public void unlock(LockState<T> lockState){\n  if (lockState == null) {\n    throw new IllegalArgumentException(\"lockState is null\");\n  }\n  if (lockState.setLock != this) {\n    throw new IllegalArgumentException(\"The lockState passed was not from this instance\");\n  }\n  if (lockState.thread != Thread.currentThread()) {\n    throw new IllegalArgumentException(\"The thread that created this lockState is not the same as the one unlocking it\");\n  }\n  threadSet.remove(Thread.currentThread());\n  for (  ReentrantLock lock : lockState.locks) {\n    lock.unlock();\n  }\n}", "comment": "unlocks the objects acquired from locking .", "label": "what"}
{"id": "16842", "raw_code": "public void removeFromTags(String removeTag){\n  tags.remove(removeTag);\n  firePropertyChange(TAG,null,removeTag);\n  firePropertyChange(TAGS_AS_STRING,null,removeTag);\n}", "comment": "removes the from tags .", "label": "what"}
{"id": "180", "raw_code": "public static boolean verify(byte[] data,byte[] signature,byte[] pub){\n  Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n  ByteBuffer byteBuff=nativeECDSABuffer.get();\n  if (byteBuff == null) {\n    byteBuff=ByteBuffer.allocateDirect(32 + 8 + 520+ 520);\n    byteBuff.order(ByteOrder.nativeOrder());\n    nativeECDSABuffer.set(byteBuff);\n  }\n  byteBuff.rewind();\n  byteBuff.put(data);\n  byteBuff.putInt(signature.length);\n  byteBuff.putInt(pub.length);\n  byteBuff.put(signature);\n  byteBuff.put(pub);\n  return secp256k1_ecdsa_verify(byteBuff) == 1;\n}", "comment": "verifies the given secp256k1 signature in native code .", "label": "what"}
{"id": "5226", "raw_code": "protected void deleteDirectory(File webAppFile){\n  if (webAppFile.isDirectory()) {\n    File[] children=webAppFile.listFiles();\n    for (    File element : children) {\n      deleteDirectory(element);\n    }\n    webAppFile.delete();\n  }\n else {\n    webAppFile.delete();\n  }\n}", "comment": "recursively delete the webapp directory .", "label": "what"}
{"id": "67416", "raw_code": "public static String formattingFinishedPercentage(final RolloutGroup rolloutGroup,final float finishedPercentage){\n  float tmpFinishedPercentage=0;\nswitch (rolloutGroup.getStatus()) {\ncase READY:\ncase SCHEDULED:\ncase ERROR:\n    tmpFinishedPercentage=0.0F;\n  break;\ncase FINISHED:\ntmpFinishedPercentage=100.0F;\nbreak;\ncase RUNNING:\ntmpFinishedPercentage=finishedPercentage;\nbreak;\ndefault :\nbreak;\n}\nreturn String.format(\"%.1f\",tmpFinishedPercentage);\n}", "comment": "formats the finished percentage of a rollout group into a string with one digit after comma .", "label": "what"}
{"id": "10578", "raw_code": "private static String unwrap(String expression){\n  if (expression.startsWith(\"((\")) {\n    expression=expression.substring(expression.indexOf(\")\") + 1,expression.length() - 1);\n    if (expression.endsWith(\"]\")) {\n      expression=expression.substring(0,expression.lastIndexOf(\"[\"));\n    }\n else {\n      expression=expression.substring(0,expression.lastIndexOf(\".\"));\n    }\n  }\n  return expression;\n}", "comment": "removes the outermost property from a nested getter expression", "label": "what"}
{"id": "81893", "raw_code": "public boolean areAllSegmentPresent(int datasetSize){\n  return mPieSegmentList.size() == datasetSize;\n}", "comment": "if we have all piechart config then there is no point in reloading it", "label": "what"}
{"id": "55619", "raw_code": "protected int drawNextEventTimeDiff(){\n  int timeDiff=msgInterval[0] == msgInterval[1] ? 0 : rng.nextInt(msgInterval[1] - msgInterval[0]);\n  return msgInterval[0] + timeDiff;\n}", "comment": "generates a ( random ) time difference between two events", "label": "what"}
{"id": "19645", "raw_code": "public MessageTokenizer(IDiscordClient client,String content){\n  if (content == null)   throw new IllegalArgumentException(\"Content cannot be null!\");\n  if (content.length() == 0)   throw new IllegalArgumentException(\"Content must have length!\");\n  if (client == null)   throw new IllegalArgumentException(\"Client cannot be null!\");\n  this.content=content;\n  this.client=client;\n  stepForward(0);\n}", "comment": "initializes with the string contents .", "label": "what"}
{"id": "9401", "raw_code": "public void await(int ID) throws InterruptedException {\n  if (parties == 1)   return;\n  final boolean startCondition=competitionCondition;\n  int competingFor=(locks.length * 2 - 1 - ID) / 2;\n  while (competingFor >= 0) {\n    final Lock node=locks[competingFor];\n    if (node.tryLock()) {\nsynchronized (node) {\n        while (competitionCondition == startCondition)         node.wait();\n      }\n      node.unlock();\n      wakeUpTarget(competingFor * 2 + 1);\n      wakeUpTarget(competingFor * 2 + 2);\n      return;\n    }\n else {\n      if (competingFor == 0)       break;\n      competingFor=(competingFor - 1) / 2;\n    }\n  }\n  competitionCondition=!competitionCondition;\n  wakeUpTarget(0);\n}", "comment": "waits for all threads to reach this barrier .", "label": "what"}
{"id": "4395", "raw_code": "private void loadTranslationsCacheIfEmpty(){\n  if (translationCache.isEmpty()) {\n    for (    ObjectTranslation translation : translations) {\n      if (translation.getLocale() != null && translation.getProperty() != null && !StringUtils.isEmpty(translation.getValue())) {\n        String key=ObjectTranslation.getCacheKey(translation.getLocale(),translation.getProperty());\n        translationCache.put(key,translation.getValue());\n      }\n    }\n  }\n}", "comment": "populates the translationscache map unless it is already populated .", "label": "what"}
{"id": "11281", "raw_code": "public NavMouseMode(boolean shouldConsumeEvents){\n  super(modeID,shouldConsumeEvents);\n  setModeCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));\n  rectAttributes.setLinePaint(Color.GRAY);\n  rectAttributes.setMattingPaint(Color.LIGHT_GRAY);\n  rectAttributes.setMatted(true);\n}", "comment": "construct a navmousemode .", "label": "what"}
{"id": "42930", "raw_code": "public static void stopTimer(String name){\n  long stopTime=System.nanoTime();\n  Long startTime=openTimers.remove(name);\n  if (startTime == null) {\n    throw new IllegalArgumentException(\"timer does not exist\");\n  }\n  SummaryStatistics statistics=data.get(name);\n  if (statistics == null) {\n    statistics=new SummaryStatistics();\n    data.put(name,statistics);\n  }\n  statistics.addValue(stopTime - startTime);\n}", "comment": "stops the timer with the specified name .", "label": "what"}
{"id": "35910", "raw_code": "public static File createTempPath(String path) throws IOException {\n  String sep=File.separator;\n  File tempDir=new File(System.getProperty(\"java.io.tmpdir\") + sep + path);\n  if (!tempDir.exists())   if (!tempDir.mkdirs()) {\n    boolean status=tempDir.delete();\n    throw new IOException(\"creation failed for dir \" + tempDir + \"status = \"+ status);\n  }\n  tempDir.deleteOnExit();\n  return tempDir;\n}", "comment": "create a hierarchy of directories ( a path ) in the designated temp dir .", "label": "what"}
{"id": "5145", "raw_code": "public StateInteractive extent_to_whole_connections(){\n  Set<BrdItem> selected_items=new TreeSet<BrdItem>();\n  for (  BrdItem curr_item : items_list) {\n    if (curr_item instanceof BrdConnectable) {\n      selected_items.addAll(curr_item.get_connection_items());\n    }\n  }\n  if (selected_items.isEmpty()) {\n    return return_state;\n  }\n  items_list=selected_items;\n  actlog_start_scope(LogfileScope.EXTEND_TO_WHOLE_CONNECTIONS);\n  filter();\n  i_brd.repaint();\n  return this;\n}", "comment": "select also all items belonging to any connection of the current selected items .", "label": "what"}
{"id": "27368", "raw_code": "public static IKeyBuilder newInstance(int capacity,CollatorEnum collatorChoice,Locale locale,Object strength,DecompositionEnum mode){\n  if (collatorChoice == CollatorEnum.ASCII) {\n    return new KeyBuilder(capacity);\n  }\n  if (locale == null) {\n    locale=Locale.getDefault();\n    if (log.isInfoEnabled())     log.info(\"Using default locale: \" + locale.getDisplayName());\n  }\n  final boolean icu=collatorChoice == CollatorEnum.ICU;\n  if (icu && !DefaultKeyBuilderFactory.isICUAvailable()) {\n    throw new UnsupportedOperationException(DefaultKeyBuilderFactory.ICU_NOT_AVAILABLE);\n  }\n  final byte[] buf=createBuffer(capacity);\n  final int len=0;\nswitch (collatorChoice) {\ncase ICU:\n    return new KeyBuilder(new ICUSortKeyGenerator(locale,strength,mode),len,buf);\ncase JDK:\n  return new KeyBuilder(new JDKSortKeyGenerator(locale,strength,mode),len,buf);\ndefault :\nthrow new UnsupportedOperationException(\"Collator not supported: \" + collatorChoice);\n}\n}", "comment": "create a new instance that optionally supports unicode sort keys .", "label": "what"}
{"id": "52137", "raw_code": "private List<Node> possibleParents(Node x,List<Node> nodes,IKnowledge knowledge){\n  List<Node> possibleParents=new LinkedList<>();\n  String _x=x.getName();\n  for (  Node z : nodes) {\n    String _z=z.getName();\n    if (possibleParentOf(_z,_x,knowledge)) {\n      possibleParents.add(z);\n    }\n  }\n  return possibleParents;\n}", "comment": "removes from the list of nodes any that cannot be parents of x given the background knowledge .", "label": "what"}
{"id": "63539", "raw_code": "Connection openNewConnection() throws SQLException {\n  Connection newConn=DriverManager.getConnection(url,user,password);\n  if (url.startsWith(\"jdbc:derby:\")) {\n    try (Statement s=newConn.createStatement()){\n    }\n   }\n else   if (url.startsWith(\"jdbc:hsqldb:\")) {\n    try (Statement s=newConn.createStatement()){\n      s.execute(\"SET WRITE_DELAY 1\");\n    }\n   }\n  return newConn;\n}", "comment": "open a new database connection .", "label": "what"}
{"id": "45726", "raw_code": "@Override public void addRelations(Task task,Iterable<ObjectId> projectIds,String fieldName){\n  List<Project> newProjectList=new LinkedList<>();\n  Iterable<Project> projectsToAdd=projectRepository.findAll(projectIds,null);\n  for (  Project project : projectsToAdd) {\n    newProjectList.add(project);\n  }\n  try {\n    if (PropertyUtils.getProperty(task,fieldName) != null) {\n      Iterable<Project> projects=(Iterable<Project>)PropertyUtils.getProperty(task,fieldName);\n      for (      Project project : projects) {\n        newProjectList.add(project);\n      }\n    }\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n  try {\n    PropertyUtils.setProperty(task,fieldName,newProjectList);\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n  taskRepository.save(task);\n}", "comment": "a simple implementation of the addrelations method which presents the general concept of the method .", "label": "what"}
{"id": "57146", "raw_code": "protected void doFloodBDDP(long pinSwitch,OFPacketIn pi,FloodlightContext cntx){\n  TopologyInstance ti=getCurrentInstance(false);\n  Set<Long> switches=ti.getSwitchesInOpenflowDomain(pinSwitch);\n  if (switches == null) {\n    switches=new HashSet<Long>();\n    switches.add(pinSwitch);\n  }\n  for (  long sid : switches) {\n    IOFSwitch sw=floodlightProvider.getSwitch(sid);\n    if (sw == null)     continue;\n    Collection<Short> enabledPorts=sw.getEnabledPortNumbers();\n    if (enabledPorts == null)     continue;\n    Set<Short> ports=new HashSet<Short>();\n    ports.addAll(enabledPorts);\n    Set<Short> portsKnownToTopo=ti.getPortsWithLinks(sid);\n    if (portsKnownToTopo != null) {\n      for (      short p : portsKnownToTopo) {\n        NodePortTuple npt=new NodePortTuple(sid,p);\n        if (ti.isBroadcastDomainPort(npt) == false) {\n          ports.remove(p);\n        }\n      }\n    }\n    Set<Short> portsToEliminate=getPortsToEliminateForBDDP(sid);\n    if (portsToEliminate != null) {\n      ports.removeAll(portsToEliminate);\n    }\n    if (pinSwitch == sid) {\n      ports.remove(pi.getInPort());\n    }\n    doMultiActionPacketOut(pi.getPacketData(),sw,ports,cntx);\n  }\n}", "comment": "the bddp packets are forwarded out of all the ports out of an openflowdomain .", "label": "what"}
{"id": "80129", "raw_code": "public void sleepMillis(final long millis){\n  try {\n    Thread.sleep(millis);\n  }\n catch (  final InterruptedException e) {\n    logger.error(e,e);\n  }\n}", "comment": "waits the specified number of milliseconds .", "label": "what"}
{"id": "70013", "raw_code": "private static void verifyWriteSetNotFound(final BTree btree){\n  log.info(\"\");\n  for (int i=0; i < 1000; i++) {\n    if (btree.contains(i)) {\n      throw new RuntimeException(\"Not expecting: key=\" + i);\n    }\n  }\n}", "comment": "verify that the write set is not found ( no keys in [ 0 : 1000 ) ) .", "label": "what"}
{"id": "9194", "raw_code": "private double calculateEntropy(double... masses){\n  double res=0;\n  for (  double d : masses) {\n    res-=(d == 0) ? 0 : d * Math.log(d);\n  }\n  return res / LOG2;\n}", "comment": "calculates the entropy corresponding to the input masses .", "label": "what"}
{"id": "38365", "raw_code": "@Override public void mousePressed(MouseEvent e){\n  m_frameLimiter.setRepeats(true);\n  if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0 && !e.isAltDown() && m_mouseState == 0 && m_scaling == 0) {\n    if (((e.getModifiers() & InputEvent.CTRL_MASK) != 0) && ((e.getModifiers() & InputEvent.SHIFT_MASK) == 0)) {\n      m_mouseState=2;\n    }\n else     if (((e.getModifiers() & InputEvent.SHIFT_MASK) != 0) && ((e.getModifiers() & InputEvent.CTRL_MASK) == 0)) {\n      m_oldMousePos.width=e.getX();\n      m_oldMousePos.height=e.getY();\n      m_newMousePos.width=e.getX();\n      m_newMousePos.height=e.getY();\n      m_mouseState=3;\n      Graphics g=getGraphics();\n      if (m_ZoomBoxColor == null) {\n        g.setColor(Color.black);\n      }\n else {\n        g.setColor(m_ZoomBoxColor);\n      }\n      if (m_ZoomBoxXORColor == null) {\n        g.setXORMode(Color.white);\n      }\n else {\n        g.setXORMode(m_ZoomBoxXORColor);\n      }\n      g.drawRect(m_oldMousePos.width,m_oldMousePos.height,m_newMousePos.width - m_oldMousePos.width,m_newMousePos.height - m_oldMousePos.height);\n      g.dispose();\n    }\n else {\n      m_oldMousePos.width=e.getX();\n      m_oldMousePos.height=e.getY();\n      m_newMousePos.width=e.getX();\n      m_newMousePos.height=e.getY();\n      m_mouseState=1;\n      m_frameLimiter.start();\n    }\n  }\n else   if ((e.getButton() == MouseEvent.BUTTON1) && e.isAltDown() && e.isShiftDown()&& !e.isControlDown()) {\n    saveComponent();\n  }\n else   if (m_mouseState == 0 && m_scaling == 0) {\n  }\n}", "comment": "determines what action the user wants to perform .", "label": "what"}
{"id": "23018", "raw_code": "public void addRtcpListener(RtcpEventListener listener){\n  listeners.addElement(listener);\n}", "comment": "add a rtcp event listener", "label": "what"}
{"id": "36263", "raw_code": "@Override protected void ensureNumberOfColumns(int numberOfColumns){\n  if (data.length >= numberOfColumns) {\n    return;\n  }\n  double[] newData=new double[numberOfColumns];\n  System.arraycopy(data,0,newData,0,data.length);\n  data=newData;\n}", "comment": "creates a new array of the given size if necessary and copies the data into the new array .", "label": "what"}
{"id": "13063", "raw_code": "@Override public void error(String domain,String key,XMLParseException exception) throws XNIException {\n  if (fErrorHandler != null) {\n    SAXParseException saxException=createSAXParseException(exception);\n    try {\n      fErrorHandler.error(saxException);\n    }\n catch (    SAXParseException e) {\n      throw createXMLParseException(e);\n    }\ncatch (    SAXException e) {\n      throw createXNIException(e);\n    }\n  }\n}", "comment": "reports an error .", "label": "what"}
{"id": "17511", "raw_code": "public static boolean connect(FileDescriptor fd,InetAddress inetAddress,int port) throws SocketException {\n  try {\n    return IoBridge.connect(fd,inetAddress,port,0);\n  }\n catch (  SocketTimeoutException ex) {\n    throw new AssertionError(ex);\n  }\n}", "comment": "connects socket ' fd ' to ' inetaddress ' on ' port ' , with no timeout .", "label": "what"}
{"id": "58282", "raw_code": "public boolean isWhitespace(int nodeHandle){\n  int type=getNodeType(nodeHandle);\n  Node node=getNode(nodeHandle);\n  if (TEXT_NODE == type || CDATA_SECTION_NODE == type) {\n    FastStringBuffer buf=StringBufferPool.get();\n    while (node != null) {\n      buf.append(node.getNodeValue());\n      node=logicalNextDOMTextNode(node);\n    }\n    boolean b=buf.isWhitespace(0,buf.length());\n    StringBufferPool.free(buf);\n    return b;\n  }\n  return false;\n}", "comment": "determine if the string - value of a node is whitespace", "label": "what"}
{"id": "37245", "raw_code": "public CStatusPanel(final BackEndDebuggerProvider debuggerProvider){\n  super(new BorderLayout());\n  Preconditions.checkNotNull(debuggerProvider,\"IE1094: Debugger provider argument can not be null\");\n  m_label.setForeground(Color.BLACK);\n  add(m_label);\n  m_synchronizer=new CStatusLabelSynchronizer(m_label,debuggerProvider);\n}", "comment": "creates a new status panel .", "label": "what"}
{"id": "69034", "raw_code": "@Override public boolean open(String access){\n  if (access.equals(\"r\")) {\n    try {\n      iStream=new FileImageInputStream(new File(filePath));\n      parser=new LabelParser();\n      metadata=parser.parseHeader(iStream);\n      iStream.close();\n      iStream=null;\n    }\n catch (    IOException e) {\n      try {\n        iStream.close();\n      }\n catch (      Exception x) {\n      }\n      return (false);\n    }\n  }\n  return (super.open(access));\n}", "comment": "open the pds file .", "label": "what"}
{"id": "70258", "raw_code": "public void resetPSRs(){\n  pilotRolls.removeAllElements();\n}", "comment": "resets the psr list .", "label": "what"}
{"id": "51375", "raw_code": "public static void sort(byte[] array){\n  DualPivotQuicksort.sort(array);\n}", "comment": "sorts the specified array in ascending numerical order .", "label": "what"}
{"id": "33298", "raw_code": "public void closePopup(){\n  if (openedSubPopup != null) {\n    openedSubPopup.closePopup();\n  }\n  removeFromParent();\n}", "comment": "close this popup menu .", "label": "what"}
{"id": "63217", "raw_code": "public void freeObject(int id){\n  if (cacheId == id) {\n    cacheId=-1;\n    cache=null;\n  }\n  map.remove(id);\n}", "comment": "remove an object from the map .", "label": "what"}
{"id": "51518", "raw_code": "public double readDouble() throws IOException {\n  return primitiveTypes.readDouble();\n}", "comment": "reads a double ( 64 bit ) from the source stream .", "label": "what"}
{"id": "80316", "raw_code": "private boolean isAtMaximum(Adjustable bar){\n  return (bar.getValue() + bar.getVisibleAmount() >= bar.getMaximum());\n}", "comment": "check if a scroll bar is at its maximum value .", "label": "what"}
{"id": "24621", "raw_code": "public boolean matchesCS(String seq){\n  return queue.startsWith(seq,pos);\n}", "comment": "case sensitive match test .", "label": "what"}
{"id": "30249", "raw_code": "private int distBetweenPoints(int x1,int z1,int x2,int z2,boolean bAllowDiags){\n  int w=Math.abs(x2 - x1);\n  int h=Math.abs(z2 - z1);\n  if (bAllowDiags) {\n    if (w < h)     w=0;\n else     h=0;\n  }\n  return w + h + 1;\n}", "comment": "calculate the number of cells on the shortest path between ( x1 , z1 ) and ( x2 , z2 )", "label": "what"}
{"id": "60945", "raw_code": "public URL(String protocol,String host,int port,String file,URLStreamHandler handler) throws MalformedURLException {\n  if (port < -1) {\n    throw new MalformedURLException(\"port < -1: \" + port);\n  }\n  if (protocol == null) {\n    throw new NullPointerException(\"protocol == null\");\n  }\n  if (host != null && host.contains(\":\") && host.charAt(0) != '[') {\n    host=\"[\" + host + \"]\";\n  }\n  this.protocol=protocol;\n  this.host=host;\n  this.port=port;\n  file=UrlUtils.authoritySafePath(host,file);\n  int hash=file.indexOf(\"#\");\n  if (hash != -1) {\n    this.file=file.substring(0,hash);\n    this.ref=file.substring(hash + 1);\n  }\n else {\n    this.file=file;\n  }\n  fixURL(false);\n  if (handler == null) {\n    setupStreamHandler();\n    if (streamHandler == null) {\n      throw new MalformedURLException(\"Unknown protocol: \" + protocol);\n    }\n  }\n else {\n    streamHandler=handler;\n  }\n}", "comment": "creates a new url of the given component parts .", "label": "what"}
{"id": "78366", "raw_code": "public void init(GuiManualHerblore manual){\n  for (  ManualWidgetBase widget : widgets)   widget.init(manual);\n}", "comment": "initializes the widgets in this page", "label": "what"}
{"id": "68940", "raw_code": "private static SSLSocketFactory trustAllHosts(HttpsURLConnection connection){\n  SSLSocketFactory oldFactory=connection.getSSLSocketFactory();\n  try {\n    SSLContext sc=SSLContext.getInstance(\"TLS\");\n    sc.init(null,trustAllCerts,new java.security.SecureRandom());\n    SSLSocketFactory newFactory=sc.getSocketFactory();\n    connection.setSSLSocketFactory(newFactory);\n  }\n catch (  Exception e) {\n    Log.e(LOG_TAG,e.getMessage(),e);\n  }\n  return oldFactory;\n}", "comment": "this function will install a trust manager that will blindly trust all ssl certificates .", "label": "what"}
{"id": "3413", "raw_code": "public final double sampleMax(){\n  return _activeCountMax.getAndSet(_activeCount.get());\n}", "comment": "sample the active count", "label": "what"}
{"id": "49382", "raw_code": "@Override public boolean equals(Object other){\n  if (other == this) {\n    return true;\n  }\n  if (other instanceof ZoneOffsetTransition) {\n    ZoneOffsetTransition d=(ZoneOffsetTransition)other;\n    return transition.equals(d.transition) && offsetBefore.equals(d.offsetBefore) && offsetAfter.equals(d.offsetAfter);\n  }\n  return false;\n}", "comment": "checks if this object equals another .", "label": "what"}
{"id": "15563", "raw_code": "public void release(){\n  super.release();\n  init();\n}", "comment": "releases any resources we may have ( or inherit )", "label": "what"}
{"id": "68679", "raw_code": "public double unsafeSabrVolatility(final double strike,final double forward,final double expiryTime,final double alpha,final double beta,final double nu,final double rho){\n  final double oneMinusBeta=1.0 - beta;\n  final double A=Math.pow(forward * strike,oneMinusBeta);\n  final double sqrtA=Math.sqrt(A);\n  double logM;\n  if (!isClose(forward,strike))   logM=Math.log(forward / strike);\n else {\n    final double epsilon=(forward - strike) / strike;\n    logM=epsilon - .5 * epsilon * epsilon;\n  }\n  final double z=(nu / alpha) * sqrtA * logM;\n  final double B=1.0 - 2.0 * rho * z + z * z;\n  final double C=oneMinusBeta * oneMinusBeta * logM* logM;\n  final double tmp=(Math.sqrt(B) + z - rho) / (1.0 - rho);\n  final double xx=Math.log(tmp);\n  final double D=sqrtA * (1.0 + C / 24.0 + C * C / 1920.0);\n  final double d=1.0 + expiryTime * (oneMinusBeta * oneMinusBeta * alpha* alpha / (24.0 * A) + 0.25 * rho * beta* nu* alpha / sqrtA + (2.0 - 3.0 * rho * rho) * (nu * nu / 24.0));\n  double multiplier;\n  final double m=10;\n  if (Math.abs(z * z) > Constants.QL_EPSILON * m)   multiplier=z / xx;\n else {\n    final double talpha=(0.5 - rho * rho) / (1.0 - rho);\n    final double tbeta=alpha - .5;\n    final double tgamma=rho / (1 - rho);\n    multiplier=1.0 - beta * z + (tgamma - talpha + tbeta * tbeta * .5) * z * z;\n  }\n  return (alpha / D) * multiplier * d;\n}", "comment": "computes the black equivalent volatility without validating parameters", "label": "what"}
{"id": "62711", "raw_code": "public synchronized void reloadConfiguration(){\n  properties=null;\n  finalParameters.clear();\n}", "comment": "reload configuration from previously added resources .", "label": "what"}
{"id": "23111", "raw_code": "protected void removeMessageProcessor(MessageProcessor oldMessageProcessor){\nsynchronized (messageProcessors) {\n    if (messageProcessors.remove(oldMessageProcessor)) {\n      oldMessageProcessor.stop();\n    }\n  }\n}", "comment": "removes a messageprocessor from this sipstack .", "label": "what"}
{"id": "48303", "raw_code": "X509IssuerSerial(X509Certificate cert){\n  this(cert.getIssuerX500Principal(),cert.getSerialNumber());\n}", "comment": "construct an x509issuerserial from an x509certificate .", "label": "what"}
{"id": "19990", "raw_code": "public void putBytes(byte[] bytes){\n  ensureCapacity(bytes.length);\n  System.arraycopy(bytes,0,this.byteBuffer,this.position,bytes.length);\n  this.position+=bytes.length;\n}", "comment": "put an array of bytes in the buffer .", "label": "what"}
{"id": "79868", "raw_code": "public void clearAll(){\n  final List<EncodedImage> old;\nsynchronized (this) {\n    old=new ArrayList<>(mMap.values());\n    mMap.clear();\n  }\n  for (int i=0; i < old.size(); i++) {\n    EncodedImage encodedImage=old.get(i);\n    if (encodedImage != null) {\n      encodedImage.close();\n    }\n  }\n}", "comment": "removes all items from the stagingarea .", "label": "what"}
{"id": "66217", "raw_code": "public static CompiereColor parse(String attributes){\n  CompiereColor cc=new CompiereColor();\n  try {\n    if (attributes != null && attributes.length() > 0)     cc.parseAttributres(attributes);\n  }\n catch (  Exception e) {\n    log.severe(\"(\" + attributes + \") - \"+ e.toString());\n  }\n  return cc;\n}", "comment": "parse attributes and return adempierecolor", "label": "what"}
{"id": "35869", "raw_code": "public synchronized static LuaState newLuaState(){\n  int i=getNextStateIndex();\n  LuaState L=new LuaState(i);\n  states.add(i,L);\n  return L;\n}", "comment": "method that creates a new instance of luastate", "label": "what"}
{"id": "11501", "raw_code": "public int read() throws IOException {\n  if (inputStream == null) {\n    reopen();\n  }\n  count(1);\n  return inputStream.read();\n}", "comment": "read from the file .", "label": "what"}
{"id": "64288", "raw_code": "public void shutdown(){\n  final long begin=System.currentTimeMillis();\n  log.info(\"ThreadPoolManager: Shutting down.\");\n  log.info(\"\\t... executing \" + getTaskCount(scheduledPool) + \" scheduled tasks.\");\n  log.info(\"\\t... executing \" + getTaskCount(instantPool) + \" instant tasks.\");\n  log.info(\"\\t... executing \" + getTaskCount(longRunningPool) + \" long running tasks.\");\n  log.info(\"\\t... \" + (workStealingPool.getQueuedTaskCount() + workStealingPool.getQueuedSubmissionCount()) + \" forking tasks left.\");\n  scheduledPool.shutdown();\n  instantPool.shutdown();\n  longRunningPool.shutdown();\n  workStealingPool.shutdown();\n  boolean success=false;\n  try {\n    success|=awaitTermination(5000);\n    scheduledPool.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    scheduledPool.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n    success|=awaitTermination(10000);\n  }\n catch (  InterruptedException e) {\n    e.printStackTrace();\n  }\n  log.info(\"\\t... success: \" + success + \" in \"+ (System.currentTimeMillis() - begin)+ \" msec.\");\n  log.info(\"\\t... \" + getTaskCount(scheduledPool) + \" scheduled tasks left.\");\n  log.info(\"\\t... \" + getTaskCount(instantPool) + \" instant tasks left.\");\n  log.info(\"\\t... \" + getTaskCount(longRunningPool) + \" long running tasks left.\");\n  log.info(\"\\t... \" + (workStealingPool.getQueuedTaskCount() + workStealingPool.getQueuedSubmissionCount()) + \" forking tasks left.\");\n  workStealingPool.shutdownNow();\n}", "comment": "shutdown all thread pools .", "label": "what"}
{"id": "13971", "raw_code": "public static String removeNewLineChars(String s){\n  String retString=null;\n  if ((s != null) && (s.length() > 0) && (s.indexOf('\\n') != -1)) {\n    char[] chars=s.toCharArray();\n    int len=chars.length;\n    StringBuffer sb=new StringBuffer(len);\n    for (int i=0; i < len; i++) {\n      char c=chars[i];\n      if (c != '\\n') {\n        sb.append(c);\n      }\n    }\n    retString=sb.toString();\n  }\n else {\n    retString=s;\n  }\n  return retString;\n}", "comment": "removes new line charactors .", "label": "what"}
{"id": "19799", "raw_code": "public int retrieveRowCount(String tableName) throws SQLException {\n  ResultSet rs=null;\n  int rowCount=-1;\n  try {\n    rs=statement.executeQuery(\"SELECT COUNT(*) FROM \" + tableName);\n    rs.next();\n    rowCount=rs.getInt(1);\n  }\n  finally {\n    if (rs != null) {\n      rs.close();\n    }\n  }\n  return rowCount;\n}", "comment": "does a count on a given table .", "label": "what"}
{"id": "40484", "raw_code": "public JarModifier(File jarFile) throws JarException, IOException {\n  this.jarFile=jarFile;\n  JarFile jar=new JarFile(jarFile);\n  Enumeration<? extends JarEntry> enumerator=jar.entries();\n  while (enumerator.hasMoreElements()) {\n    JarEntry currentEntry=(JarEntry)enumerator.nextElement();\n    JarEntry resetEntry=new JarEntry(currentEntry.getName());\n    jarEntries.put(currentEntry.getName(),resetEntry);\n  }\n  String manifestPath=META_INF + SEPERATOR + \"MANIFEST.MF\";\n  JarEntry jarEntry=jar.getJarEntry(manifestPath);\n  if (jarEntry != null) {\n    Enumeration<JarEntry> entries=jar.entries();\n    while (entries.hasMoreElements()) {\n      jarEntry=(JarEntry)entries.nextElement();\n      if (manifestPath.equalsIgnoreCase(jarEntry.getName())) {\n        break;\n      }\n else {\n        jarEntry=null;\n      }\n    }\n  }\n  Manifest manifest=new Manifest();\n  if (jarEntry != null) {\n    manifest.read(jar.getInputStream(jarEntry));\n  }\n  this.manifest=manifest;\n  jar.close();\n}", "comment": "creates a new jarmodifier with the given archive to be modified", "label": "what"}
{"id": "54004", "raw_code": "default B with(String key,int value){\n  return with(key,Integer.toString(value));\n}", "comment": "associate the given value with the specified key .", "label": "what"}
{"id": "23131", "raw_code": "protected boolean isServerTransaction(){\n  return this instanceof SIPServerTransaction;\n}", "comment": "a shortcut way of telling if we are a server transaction .", "label": "what"}
{"id": "44999", "raw_code": "Object addMarkedOccurrenceHighlight(int start,int end,MarkOccurrencesHighlightPainter p) throws BadLocationException {\n  Document doc=textArea.getDocument();\n  TextUI mapper=textArea.getUI();\n  HighlightInfo i=new LayeredHighlightInfo();\n  i.painter=p;\n  i.p0=doc.createPosition(start);\n  i.p1=doc.createPosition(end - 1);\n  markedOccurrences.add(i);\n  mapper.damageRange(textArea,start,end);\n  return i;\n}", "comment": "adds a special \" marked occurrence \" highlight .", "label": "what"}
{"id": "29891", "raw_code": "private int skipFromPeekBuffer(int length){\n  int bytesSkipped=Math.min(peekBufferLength,length);\n  updatePeekBuffer(bytesSkipped);\n  return bytesSkipped;\n}", "comment": "skips from the peek buffer .", "label": "what"}
{"id": "23133", "raw_code": "public synchronized String generateCallIdentifier(String address){\n  String date=Long.toString(System.currentTimeMillis() + callIDCounter++ + rand.nextLong());\n  byte cid[]=digester.digest(date.getBytes());\n  String cidString=Utils.toHexString(cid);\n  return cidString + \"@\" + address;\n}", "comment": "generate a call identifier .", "label": "what"}
{"id": "81705", "raw_code": "int parseHour(String source,char patternChar,int offset) throws ParseException {\n  int min=(patternChar == HOUR_1_LETTER || patternChar == HOUR12_1_LETTER) ? 1 : 0;\n  int max=((patternChar == HOUR_LETTER || patternChar == HOUR_1_LETTER) ? 23 : 11) + min;\n  return parseNumber(source,offset,\"hour\",min,max) - min;\n}", "comment": "parse a hour value .", "label": "what"}
{"id": "38910", "raw_code": "public void doHistory(KeyEvent e){\n  if (e.getSource() == m_Input) {\nswitch (e.getKeyCode()) {\ncase KeyEvent.VK_UP:\n      if (m_HistoryPos > 0) {\n        m_HistoryPos--;\n        String command=m_CommandHistory.elementAt(m_HistoryPos);\n        m_Input.setText(command);\n      }\n    break;\ncase KeyEvent.VK_DOWN:\n  if (m_HistoryPos < m_CommandHistory.size()) {\n    m_HistoryPos++;\n    String command=\"\";\n    if (m_HistoryPos < m_CommandHistory.size()) {\n      command=m_CommandHistory.elementAt(m_HistoryPos);\n    }\n    m_Input.setText(command);\n  }\nbreak;\ndefault :\nbreak;\n}\n}\n}", "comment": "changes the currently displayed command line when certain keys are pressed .", "label": "what"}
{"id": "59586", "raw_code": "@RequestMapping(value=\"/hive\",method={RequestMethod.GET}) @ResponseBody private static List<String> showHiveDatabases() throws IOException {\n  IHiveClient hiveClient=HiveClientFactory.getHiveClient();\n  List<String> results=null;\n  try {\n    results=hiveClient.getHiveDbNames();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    throw new IOException(e);\n  }\n  return results;\n}", "comment": "show all databases in hive", "label": "what"}
{"id": "78148", "raw_code": "private static double hackyAdjuster(double f){\n  double tmp=Math.sqrt(1.0 - f);\n  return (f <= 0.5) ? tmp : tmp + (0.01 * (f - 0.5));\n}", "comment": "this hackyadjuster is tightly coupled with the width of the confidence interval normally specified with number of standard deviations .", "label": "what"}
{"id": "24770", "raw_code": "private static Object fromString(String s) throws IOException, ClassNotFoundException {\n  byte[] data=Base64.decode(s,Base64.DEFAULT);\n  ObjectInputStream ois=new ObjectInputStream(new ByteArrayInputStream(data));\n  Object o=ois.readObject();\n  ois.close();\n  return o;\n}", "comment": "read the object from base64 string .", "label": "what"}
{"id": "25591", "raw_code": "public SVDMatrix(Matrix Arg){\n  this(Arg,true,true,true);\n}", "comment": "construct the singular value decomposition", "label": "what"}
{"id": "60328", "raw_code": "private static int lastIndexOf(Object o,@NotNull Object[] elements,int index){\n  if (o == null) {\n    for (int i=index; i >= 0; i--) {\n      if (elements[i] == null) {\n        return i;\n      }\n    }\n  }\n else {\n    for (int i=index; i >= 0; i--) {\n      if (o.equals(elements[i])) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}", "comment": "static version of lastindexof .", "label": "what"}
{"id": "64768", "raw_code": "public void write(ByteBuffer buffer) throws IOException {\n  buffer.position(0);\n  if (mFileChannel.size() + buffer.capacity() < mMaxSize) {\n    while (buffer.hasRemaining()) {\n      mFileChannel.write(buffer);\n    }\n    updateWaveFileSize();\n  }\n else {\n    int remaining=(int)(mMaxSize - mFileChannel.size());\n    remaining-=(int)(remaining % mAudioFormat.getFrameSize());\n    byte[] bytes=buffer.array();\n    ByteBuffer current=ByteBuffer.wrap(Arrays.copyOf(bytes,remaining));\n    ByteBuffer next=ByteBuffer.wrap(Arrays.copyOfRange(bytes,remaining,bytes.length));\n    while (current.hasRemaining()) {\n      mFileChannel.write(current);\n    }\n    updateWaveFileSize();\n    rollover();\n    while (next.hasRemaining()) {\n      mFileChannel.write(next);\n    }\n    updateWaveFileSize();\n  }\n}", "comment": "writes the buffer contents to the file .", "label": "what"}
{"id": "38817", "raw_code": "private synchronized void block(boolean tf){\n  if (tf) {\n    try {\n      if (m_ioThread.isAlive() && m_state != IDLE) {\n        wait();\n      }\n    }\n catch (    InterruptedException ex) {\n    }\n  }\n else {\n    notifyAll();\n  }\n}", "comment": "function used to stop code that calls accepttrainingset .", "label": "what"}
{"id": "61500", "raw_code": "public final void dispatchCharactersEvents(int nodeHandle,ContentHandler ch,boolean normalize) throws SAXException {\n  int identity=makeNodeIdentity(nodeHandle);\n  if (identity == DTM.NULL)   return;\n  int type=_type2(identity);\n  if (type == DTM.ELEMENT_NODE || type == DTM.DOCUMENT_NODE) {\n    int startNode=identity;\n    identity=_firstch2(identity);\n    if (DTM.NULL != identity) {\n      int offset=-1;\n      int length=0;\n      do {\n        type=_exptype2(identity);\n        if (type == DTM.TEXT_NODE || type == DTM.CDATA_SECTION_NODE) {\n          int dataIndex=m_dataOrQName.elementAt(identity);\n          if (dataIndex >= 0) {\n            if (-1 == offset) {\n              offset=dataIndex >>> TEXT_LENGTH_BITS;\n            }\n            length+=dataIndex & TEXT_LENGTH_MAX;\n          }\n else {\n            if (-1 == offset) {\n              offset=m_data.elementAt(-dataIndex);\n            }\n            length+=m_data.elementAt(-dataIndex + 1);\n          }\n        }\n        identity++;\n      }\n while (_parent2(identity) >= startNode);\n      if (length > 0) {\n        if (normalize)         m_chars.sendNormalizedSAXcharacters(ch,offset,length);\n else         m_chars.sendSAXcharacters(ch,offset,length);\n      }\n    }\n  }\n else   if (DTM.TEXT_NODE == type || DTM.CDATA_SECTION_NODE == type) {\n    int dataIndex=m_dataOrQName.elementAt(identity);\n    if (dataIndex >= 0) {\n      if (normalize)       m_chars.sendNormalizedSAXcharacters(ch,dataIndex >>> TEXT_LENGTH_BITS,dataIndex & TEXT_LENGTH_MAX);\n else       m_chars.sendSAXcharacters(ch,dataIndex >>> TEXT_LENGTH_BITS,dataIndex & TEXT_LENGTH_MAX);\n    }\n else {\n      if (normalize)       m_chars.sendNormalizedSAXcharacters(ch,m_data.elementAt(-dataIndex),m_data.elementAt(-dataIndex + 1));\n else       m_chars.sendSAXcharacters(ch,m_data.elementAt(-dataIndex),m_data.elementAt(-dataIndex + 1));\n    }\n  }\n else {\n    int dataIndex=m_dataOrQName.elementAt(identity);\n    if (dataIndex < 0) {\n      dataIndex=-dataIndex;\n      dataIndex=m_data.elementAt(dataIndex + 1);\n    }\n    String str=(String)m_values.elementAt(dataIndex);\n    if (normalize)     FastStringBuffer.sendNormalizedSAXcharacters(str.toCharArray(),0,str.length(),ch);\n else     ch.characters(str.toCharArray(),0,str.length());\n  }\n}", "comment": "the optimized version of sax2dtm . dispatchcharactersevents ( int , contenthandler , boolean ) .", "label": "what"}
{"id": "57031", "raw_code": "public static boolean containIP(int cidrPrefix,int cidrMaskBits,int ip){\n  boolean matched=true;\n  int bitsToShift=32 - cidrMaskBits;\n  if (bitsToShift > 0) {\n    cidrPrefix=cidrPrefix >> bitsToShift;\n    ip=ip >> bitsToShift;\n    cidrPrefix=cidrPrefix << bitsToShift;\n    ip=ip << bitsToShift;\n  }\n  if (cidrPrefix != ip) {\n    matched=false;\n  }\n  return matched;\n}", "comment": "check whether the cidr address contains the ip address", "label": "what"}
{"id": "24371", "raw_code": "protected static Boolean lock(String serviceName,Object name){\n  DistributedLockService service=DistributedLockService.getServiceNamed(serviceName);\n  boolean locked=service.lock(name,1000,-1);\n  return Boolean.valueOf(locked);\n}", "comment": "accessed via reflection .", "label": "what"}
{"id": "15157", "raw_code": "protected int checkKnownCookie(){\n  int retVal=0;\n  debug.message(\"{}.checkKnownCookie:\",ADAPTIVE);\n  HttpServletRequest req=getHttpServletRequest();\n  if (req != null) {\n    Cookie cookie=CookieUtils.getCookieFromReq(req,knownCookieName);\n    if (cookie != null) {\n      if (knownCookieValue.equalsIgnoreCase(CookieUtils.getCookieValue(cookie))) {\n        retVal=knownCookieScore;\n      }\n    }\n  }\n  if (knownCookieValue == null) {\n    knownCookieValue=\"1\";\n  }\n  if (knownCookieSave) {\n    postAuthNMap.put(\"COOKIENAME\",knownCookieName);\n    postAuthNMap.put(\"COOKIEVALUE\",knownCookieValue);\n  }\n  if (!knownCookieInvert) {\n    retVal=knownCookieScore - retVal;\n  }\n  return retVal;\n}", "comment": "check to see if the client has a cookie with optional value", "label": "what"}
{"id": "84681", "raw_code": "public File[] selectImportFiles(final String title,boolean multipleSelection,FileNameExtensionFilter[] fileNameExtensionFilters){\n  if (Boolean.parseBoolean(System.getProperty(\"use.native.choosers\",Boolean.toString(OSType.isMac())))) {\n    FileDialog importDialog=fileDialogs.get(title);\n    if (importDialog == null) {\n      importDialog=new FileDialog(this,title,FileDialog.LOAD);\n      fileDialogs.put(title,importDialog);\n    }\n    importDialog.setVisible(true);\n    if (importDialog.getFile() != null) {\n      return new File[]{new File(importDialog.getDirectory(),importDialog.getFile())};\n    }\n  }\n else {\n    JFileChooser importChooser=fileChoosers.get(title);\n    if (importChooser == null) {\n      importChooser=new JFileChooser(Utils.getCWD());\n      importChooser.setMultiSelectionEnabled(multipleSelection);\n      for (      FileNameExtensionFilter fileNameExtensionFilter : fileNameExtensionFilters) {\n        importChooser.setFileFilter(fileNameExtensionFilter);\n      }\n      importChooser.setDialogTitle(title);\n      fileChoosers.put(title,importChooser);\n    }\n    int returnVal=importChooser.showOpenDialog(this);\n    if (returnVal == JFileChooser.APPROVE_OPTION) {\n      if (importChooser.isMultiSelectionEnabled()) {\n        return importChooser.getSelectedFiles();\n      }\n else {\n        return new File[]{importChooser.getSelectedFile()};\n      }\n    }\n  }\n  return null;\n}", "comment": "use the native file dialog on the mac because the swing one is bad .", "label": "what"}
{"id": "57377", "raw_code": "@Override public SSLEngineResult wrap(ByteBuffer[] srcs,int offset,int len,ByteBuffer dst) throws SSLException {\n  if (engine_was_shutteddown) {\n    return new SSLEngineResult(SSLEngineResult.Status.CLOSED,SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING,0,0);\n  }\n  if ((srcs == null) || (dst == null)) {\n    throw new IllegalStateException(\"Some of the input parameters are null\");\n  }\n  if (dst.isReadOnly()) {\n    throw new ReadOnlyBufferException();\n  }\n  if (!handshake_started) {\n    beginHandshake();\n  }\n  SSLEngineResult.HandshakeStatus handshakeStatus=getHandshakeStatus();\n  if ((session == null || engine_was_closed) && (handshakeStatus.equals(SSLEngineResult.HandshakeStatus.NEED_UNWRAP) || handshakeStatus.equals(SSLEngineResult.HandshakeStatus.NEED_TASK))) {\n    return new SSLEngineResult(getEngineStatus(),handshakeStatus,0,0);\n  }\n  int capacity=dst.remaining();\n  int produced=0;\n  if (alertProtocol.hasAlert()) {\n    if (capacity < recordProtocol.getRecordSize(2)) {\n      return new SSLEngineResult(SSLEngineResult.Status.BUFFER_OVERFLOW,handshakeStatus,0,0);\n    }\n    byte[] alert_data=alertProtocol.wrap();\n    dst.put(alert_data);\n    if (alertProtocol.isFatalAlert()) {\n      alertProtocol.setProcessed();\n      if (session != null) {\n        session.invalidate();\n      }\n      shutdown();\n      return new SSLEngineResult(SSLEngineResult.Status.CLOSED,SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING,0,alert_data.length);\n    }\n else {\n      alertProtocol.setProcessed();\n      if (close_notify_was_sent && close_notify_was_received) {\n        shutdown();\n        return new SSLEngineResult(SSLEngineResult.Status.CLOSED,SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING,0,alert_data.length);\n      }\n      return new SSLEngineResult(getEngineStatus(),getHandshakeStatus(),0,alert_data.length);\n    }\n  }\n  if (capacity < recordProtocol.getMinRecordSize()) {\n    if (logger != null) {\n      logger.println(\"Capacity of the destination(\" + capacity + \") < MIN_PACKET_SIZE(\"+ recordProtocol.getMinRecordSize()+ \")\");\n    }\n    return new SSLEngineResult(SSLEngineResult.Status.BUFFER_OVERFLOW,handshakeStatus,0,0);\n  }\n  try {\n    if (!handshakeStatus.equals(SSLEngineResult.HandshakeStatus.NEED_WRAP)) {\n      dataStream.setSourceBuffers(srcs,offset,len);\n      if ((capacity < SSLRecordProtocol.MAX_SSL_PACKET_SIZE) && (capacity < recordProtocol.getRecordSize(dataStream.available()))) {\n        if (logger != null) {\n          logger.println(\"The destination buffer(\" + capacity + \") can not take the resulting packet(\"+ recordProtocol.getRecordSize(dataStream.available())+ \")\");\n        }\n        return new SSLEngineResult(SSLEngineResult.Status.BUFFER_OVERFLOW,handshakeStatus,0,0);\n      }\n      if (remaining_wrapped_data == null) {\n        remaining_wrapped_data=recordProtocol.wrap(ContentType.APPLICATION_DATA,dataStream);\n      }\n      if (capacity < remaining_wrapped_data.length) {\n        return new SSLEngineResult(SSLEngineResult.Status.BUFFER_OVERFLOW,handshakeStatus,dataStream.consumed(),0);\n      }\n else {\n        dst.put(remaining_wrapped_data);\n        produced=remaining_wrapped_data.length;\n        remaining_wrapped_data=null;\n        return new SSLEngineResult(getEngineStatus(),handshakeStatus,dataStream.consumed(),produced);\n      }\n    }\n else {\n      if (remaining_hsh_data == null) {\n        remaining_hsh_data=handshakeProtocol.wrap();\n      }\n      if (capacity < remaining_hsh_data.length) {\n        return new SSLEngineResult(SSLEngineResult.Status.BUFFER_OVERFLOW,handshakeStatus,0,0);\n      }\n else {\n        dst.put(remaining_hsh_data);\n        produced=remaining_hsh_data.length;\n        remaining_hsh_data=null;\n        handshakeStatus=handshakeProtocol.getStatus();\n        if (handshakeStatus.equals(SSLEngineResult.HandshakeStatus.FINISHED)) {\n          session=recordProtocol.getSession();\n        }\n      }\n      return new SSLEngineResult(getEngineStatus(),getHandshakeStatus(),0,produced);\n    }\n  }\n catch (  AlertException e) {\n    alertProtocol.alert(AlertProtocol.FATAL,e.getDescriptionCode());\n    engine_was_closed=true;\n    if (session != null) {\n      session.invalidate();\n    }\n    throw e.getReason();\n  }\n}", "comment": "encodes the application data into ssl / tls record .", "label": "what"}
{"id": "48723", "raw_code": "final void putLong(int offset,long value){\n  unsafe.putLong(offset + address,value);\n}", "comment": "writes a long at the specified offset from this native object ' s base address .", "label": "what"}
{"id": "30305", "raw_code": "public StringBuffer numberToString(final String strNumberToConvert){\n  String strNumber=\"\", signBit=\"\";\n  if (strNumberToConvert.startsWith(\"-\")) {\n    strNumber=\"\" + strNumberToConvert.substring(1,strNumberToConvert.length());\n    signBit=\"-\";\n  }\n else   strNumber=\"\" + strNumberToConvert;\n  final DecimalFormat dft=new DecimalFormat(\"##############0.00\");\n  final String strtemp=\"\" + dft.format(Double.parseDouble(strNumber));\n  StringBuffer strbNumber=new StringBuffer(strtemp);\n  final int intLen=strbNumber.length();\n  for (int i=intLen - 6; i > 0; i=i - 2)   strbNumber.insert(i,',');\n  if (signBit.equals(\"-\"))   strbNumber=strbNumber.insert(0,\"-\");\n  return strbNumber;\n}", "comment": "function to format amount into to indaian rupees format", "label": "what"}
{"id": "8536", "raw_code": "private void runInitScriptIfRequired(String url,Connection connection) throws SQLException {\n  Matcher matcher=INITSCRIPT_MATCHING_PATTERN.matcher(url);\n  if (matcher.matches()) {\n    String initScriptPath=matcher.group(2);\n    try {\n      URL resource=Resources.getResource(initScriptPath);\n      String sql=Resources.toString(resource,Charsets.UTF_8);\n      ScriptUtils.executeSqlScript(connection,initScriptPath,sql);\n    }\n catch (    IOException|IllegalArgumentException e) {\n      LOGGER.warn(\"Could not load classpath init script: {}\",initScriptPath);\n      throw new SQLException(\"Could not load classpath init script: \" + initScriptPath,e);\n    }\ncatch (    ScriptException e) {\n      LOGGER.error(\"Error while executing init script: {}\",initScriptPath,e);\n      throw new SQLException(\"Error while executing init script: \" + initScriptPath,e);\n    }\n  }\n}", "comment": "run an init script from the classpath .", "label": "what"}
{"id": "55160", "raw_code": "private static int parseInt(String value,int beginIndex,int endIndex) throws NumberFormatException {\n  if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {\n    throw new NumberFormatException(value);\n  }\n  int i=beginIndex;\n  int result=0;\n  int digit;\n  if (i < endIndex) {\n    digit=Character.digit(value.charAt(i++),10);\n    if (digit < 0) {\n      throw new NumberFormatException(\"Invalid number: \" + value);\n    }\n    result=-digit;\n  }\n  while (i < endIndex) {\n    digit=Character.digit(value.charAt(i++),10);\n    if (digit < 0) {\n      throw new NumberFormatException(\"Invalid number: \" + value);\n    }\n    result*=10;\n    result-=digit;\n  }\n  return -result;\n}", "comment": "parse an integer located between 2 given offsets in a string", "label": "what"}
{"id": "72362", "raw_code": "public static void checkFinite(final double[] val) throws MathIllegalArgumentException {\n  for (int i=0; i < val.length; i++) {\n    final double x=val[i];\n    if (Double.isInfinite(x) || Double.isNaN(x)) {\n      throw new MathIllegalArgumentException(LocalizedCoreFormats.NOT_FINITE_NUMBER,x);\n    }\n  }\n}", "comment": "check that all the elements are real numbers .", "label": "what"}
{"id": "70884", "raw_code": "private void initKeyboardButtons(KeyboardView view){\n  mButtons=new ArrayList<>();\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_0));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_1));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_2));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_3));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_4));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_5));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_6));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_7));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_8));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_9));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_clear));\n  for (  View button : mButtons) {\n    button.setOnClickListener(this);\n  }\n}", "comment": "init the keyboard buttons ( onclicklistener )", "label": "what"}
{"id": "9172", "raw_code": "private static String findRelativePath(String filePath,String dirPath){\n  String relPath;\n  if (!dirPath.endsWith(File.separator)) {\n    dirPath=dirPath + File.separator;\n  }\n  if (filePath.startsWith(dirPath)) {\n    relPath=filePath.substring(dirPath.length());\n  }\n else {\n    relPath=filePath;\n  }\n  return relPath;\n}", "comment": "determine the path to the file relative to the given directory path .", "label": "what"}
{"id": "65624", "raw_code": "public boolean init(){\n  log.config(\"\");\n  MClient client=MClient.get(Env.getCtx());\n  String ASPFilter=\"\";\n  if (client.isUseASP())   ASPFilter=\"   AND (   p.AD_Process_Para_ID IN ( \" + \"              SELECT pp.AD_Process_Para_ID \" + \"                FROM ASP_Process_Para pp, ASP_Process p, ASP_Level l, ASP_ClientLevel cl \"+ \"               WHERE p.ASP_Level_ID = l.ASP_Level_ID \"+ \"                 AND cl.AD_Client_ID = \" + client.getAD_Client_ID() + \"                 AND cl.ASP_Level_ID = l.ASP_Level_ID \"+ \"                 AND pp.ASP_Process_ID = p.ASP_Process_ID \"+ \"                 AND pp.IsActive = 'Y' \"+ \"                 AND p.IsActive = 'Y' \"+ \"                 AND l.IsActive = 'Y' \"+ \"                 AND cl.IsActive = 'Y' \"+ \"                 AND pp.ASP_Status = 'S') \"+ \"        OR p.AD_Process_Para_ID IN ( \"+ \"              SELECT AD_Process_Para_ID \"+ \"                FROM ASP_ClientException ce \"+ \"               WHERE ce.AD_Client_ID = \"+ client.getAD_Client_ID()+ \"                 AND ce.IsActive = 'Y' \"+ \"                 AND ce.AD_Process_Para_ID IS NOT NULL \"+ \"                 AND ce.AD_Tab_ID IS NULL \"+ \"                 AND ce.AD_Field_ID IS NULL \"+ \"                 AND ce.ASP_Status = 'S') \"+ \"       ) \"+ \"   AND p.AD_Process_Para_ID NOT IN ( \"+ \"          SELECT AD_Process_Para_ID \"+ \"            FROM ASP_ClientException ce \"+ \"           WHERE ce.AD_Client_ID = \"+ client.getAD_Client_ID()+ \"             AND ce.IsActive = 'Y' \"+ \"             AND ce.AD_Process_Para_ID IS NOT NULL \"+ \"             AND ce.AD_Tab_ID IS NULL \"+ \"             AND ce.AD_Field_ID IS NULL \"+ \"             AND ce.ASP_Status = 'H')\";\n  String sql=null;\n  if (Env.isBaseLanguage(Env.getCtx(),\"AD_Process_Para\"))   sql=\"SELECT p.Name, p.Description, p.Help, \" + \"p.AD_Reference_ID, p.AD_Process_Para_ID, \" + \"p.FieldLength, p.IsMandatory, p.IsRange, p.ColumnName, \"+ \"p.DefaultValue, p.DefaultValue2, p.VFormat, p.ValueMin, p.ValueMax, \"+ \"p.SeqNo, p.AD_Reference_Value_ID, vr.Code AS ValidationCode, \"+ \"p.ReadOnlyLogic, p.DisplayLogic \"+ \"FROM AD_Process_Para p\"+ \" LEFT OUTER JOIN AD_Val_Rule vr ON (p.AD_Val_Rule_ID=vr.AD_Val_Rule_ID) \"+ \"WHERE p.AD_Process_ID=?\"+ \" AND p.IsActive='Y' \" + ASPFilter + \" ORDER BY SeqNo\";\n else   sql=\"SELECT t.Name, t.Description, t.Help, \" + \"p.AD_Reference_ID, p.AD_Process_Para_ID, \" + \"p.FieldLength, p.IsMandatory, p.IsRange, p.ColumnName, \"+ \"p.DefaultValue, p.DefaultValue2, p.VFormat, p.ValueMin, p.ValueMax, \"+ \"p.SeqNo, p.AD_Reference_Value_ID, vr.Code AS ValidationCode, \"+ \"p.ReadOnlyLogic, p.DisplayLogic \"+ \"FROM AD_Process_Para p\"+ \" INNER JOIN AD_Process_Para_Trl t ON (p.AD_Process_Para_ID=t.AD_Process_Para_ID)\"+ \" LEFT OUTER JOIN AD_Val_Rule vr ON (p.AD_Val_Rule_ID=vr.AD_Val_Rule_ID) \"+ \"WHERE p.AD_Process_ID=?\"+ \" AND t.AD_Language='\" + Env.getAD_Language(Env.getCtx()) + \"'\"+ \" AND p.IsActive='Y' \"+ ASPFilter+ \" ORDER BY SeqNo\";\n  boolean hasFields=false;\n  Rows rows=new Rows();\n  try {\n    PreparedStatement pstmt=DB.prepareStatement(sql,null);\n    pstmt.setInt(1,m_processInfo.getAD_Process_ID());\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      hasFields=true;\n      createField(rs,rows);\n      isPair=!isPair;\n    }\n    rs.close();\n    pstmt.close();\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sql,e);\n  }\n  if (m_mFields.size() != m_mFields2.size() || m_mFields.size() != m_wEditors.size() || m_mFields2.size() != m_wEditors2.size())   log.log(Level.SEVERE,\"View & Model vector size is different\");\n  if (hasFields) {\n    centerPanel.appendChild(rows);\n    dynamicDisplay();\n  }\n else   dispose();\n  return hasFields;\n}", "comment": "read fields to display", "label": "what"}
{"id": "76339", "raw_code": "public void resetSingleton(){\n  root=null;\n  tmpFileCounter.set(0);\n  accessedFiles.clear();\n  shouldAllThrowIOException=false;\n  classesThatShouldThrowIOException.clear();\nsynchronized (leakingResources) {\n    for (    LeakingResource resource : leakingResources) {\n      try {\n        resource.release();\n      }\n catch (      Exception e) {\n        logger.warn(\"Failed to release resource: \" + e.getMessage(),e);\n      }\n    }\n    leakingResources.clear();\n  }\n}", "comment": "reset the internal state of this singleton", "label": "what"}
{"id": "80372", "raw_code": "public static String generateStringOfCharacters(int count){\n  StringBuilder sb=new StringBuilder();\n  for (int i=0; i < count; i++) {\n    sb.append(CHARACTERS.charAt((int)(Math.random() * CHARACTERS.length())));\n  }\n  return sb.toString();\n}", "comment": "creates a random string which only consists of letters", "label": "what"}
{"id": "68667", "raw_code": "private ExchangeRateManager(){\n  if (System.getProperty(\"EXPERIMENTAL\") == null)   throw new UnsupportedOperationException(\"Work in progress\");\n  addKnownRates();\n}", "comment": "constructs a new exchangeratemanager and initialises the most used rates .", "label": "what"}
{"id": "55945", "raw_code": "@Override public void evict(String key){\n  key=safetyKey(key);\n  final File file=new File(cacheDirectory,key);\n  file.delete();\n}", "comment": "delete the object previously saved .", "label": "what"}
{"id": "66433", "raw_code": "public static boolean isUniqueContraintError(Exception e){\n  if (DB.isPostgreSQL())   return isSQLState(e,\"23505\");\n  return isErrorCode(e,1);\n}", "comment": "check if unique constraint exception ( aka ora - 00001 )", "label": "what"}
{"id": "18273", "raw_code": "ConfigurationError(String msg,Exception x){\n  super(msg);\n  this.exception=x;\n}", "comment": "construct a new instance with the specified detail string and exception .", "label": "what"}
{"id": "32177", "raw_code": "public void addPutTimeNanos(long duration){\n  putTimeNanos.addAndGet(duration);\n  if (delegate != null)   delegate.addPutTimeNanos(duration);\n}", "comment": "increments the put time accumulator .", "label": "what"}
{"id": "86888", "raw_code": "@RequestProcessing(value=\"/member/{userName}/following/tags\",method=HTTPRequestMethod.GET) @Before(adviceClass={StopwatchStartAdvice.class,AnonymousViewCheck.class,UserBlockCheck.class}) @After(adviceClass=StopwatchEndAdvice.class) public void showHomeFollowingTags(final HTTPRequestContext context,final HttpServletRequest request,final HttpServletResponse response,final String userName) throws Exception {\n  final JSONObject user=(JSONObject)request.getAttribute(User.USER);\n  request.setAttribute(Keys.TEMAPLTE_DIR_NAME,Symphonys.get(\"skinDirName\"));\n  final AbstractFreeMarkerRenderer renderer=new SkinRenderer();\n  context.setRenderer(renderer);\n  renderer.setTemplateName(\"/home/following-tags.ftl\");\n  final Map<String,Object> dataModel=renderer.getDataModel();\n  filler.fillHeaderAndFooter(request,response,dataModel);\n  String pageNumStr=request.getParameter(\"p\");\n  if (Strings.isEmptyOrNull(pageNumStr) || !Strings.isNumeric(pageNumStr)) {\n    pageNumStr=\"1\";\n  }\n  final int pageNum=Integer.valueOf(pageNumStr);\n  final int pageSize=Symphonys.getInt(\"userHomeFollowingTagsCnt\");\n  final int windowSize=Symphonys.getInt(\"userHomeFollowingTagsWindowSize\");\n  fillHomeUser(dataModel,user);\n  final String followingId=user.optString(Keys.OBJECT_ID);\n  dataModel.put(Follow.FOLLOWING_ID,followingId);\n  avatarQueryService.fillUserAvatarURL(user);\n  final JSONObject followingTagsResult=followQueryService.getFollowingTags(followingId,pageNum,pageSize);\n  final List<JSONObject> followingTags=(List<JSONObject>)followingTagsResult.opt(Keys.RESULTS);\n  dataModel.put(Common.USER_HOME_FOLLOWING_TAGS,followingTags);\n  final boolean isLoggedIn=(Boolean)dataModel.get(Common.IS_LOGGED_IN);\n  if (isLoggedIn) {\n    final JSONObject currentUser=(JSONObject)dataModel.get(Common.CURRENT_USER);\n    final String followerId=currentUser.optString(Keys.OBJECT_ID);\n    final boolean isFollowing=followQueryService.isFollowing(followerId,followingId);\n    dataModel.put(Common.IS_FOLLOWING,isFollowing);\n    for (    final JSONObject followingTag : followingTags) {\n      final String homeUserFollowingTagId=followingTag.optString(Keys.OBJECT_ID);\n      followingTag.put(Common.IS_FOLLOWING,followQueryService.isFollowing(followerId,homeUserFollowingTagId));\n    }\n  }\n  user.put(UserExt.USER_T_CREATE_TIME,new Date(user.getLong(Keys.OBJECT_ID)));\n  final int followingTagCnt=followingTagsResult.optInt(Pagination.PAGINATION_RECORD_COUNT);\n  final int pageCount=(int)Math.ceil(followingTagCnt / (double)pageSize);\n  final List<Integer> pageNums=Paginator.paginate(pageNum,pageSize,pageCount,windowSize);\n  if (!pageNums.isEmpty()) {\n    dataModel.put(Pagination.PAGINATION_FIRST_PAGE_NUM,pageNums.get(0));\n    dataModel.put(Pagination.PAGINATION_LAST_PAGE_NUM,pageNums.get(pageNums.size() - 1));\n  }\n  dataModel.put(Pagination.PAGINATION_CURRENT_PAGE_NUM,pageNum);\n  dataModel.put(Pagination.PAGINATION_PAGE_COUNT,pageCount);\n  dataModel.put(Pagination.PAGINATION_PAGE_NUMS,pageNums);\n}", "comment": "shows user home following tags page .", "label": "what"}
{"id": "10930", "raw_code": "public int elevationAt(float lat,float lon){\n  if (frame_is_valid == true) {\n    if (lat >= dsi.sw_lat && lat <= dsi.ne_lat && lon >= dsi.sw_lon && lon <= dsi.ne_lon) {\n      int lat_index=Math.round((lat - dsi.sw_lat) * 36000 / uhl.lat_post_interval);\n      int lon_index=Math.round((lon - dsi.sw_lon) * 36000 / uhl.lon_post_interval);\n      if (elevations[lon_index] == null)       readDataRecord(lon_index);\n      return (int)elevations[lon_index][lat_index];\n    }\n  }\n  return -32767;\n}", "comment": "the elevation at the closest sw post to the given lat / lon .", "label": "what"}
{"id": "52997", "raw_code": "private void deleteChildren(Element container){\n  while (container.hasChildNodes()) {\n    container.removeChild(container.getLastChild());\n  }\n}", "comment": "delete the children of the element", "label": "what"}
{"id": "34350", "raw_code": "public static final ArrayList readListXml(InputStream in) throws XmlPullParserException, IOException {\n  XmlPullParser parser=Xml.newPullParser();\n  parser.setInput(in,null);\n  return (ArrayList)readValueXml(parser,new String[1]);\n}", "comment": "read an arraylist from an inputstream containing xml .", "label": "what"}
{"id": "1289", "raw_code": "public void clearUnused(ConfigImpl config){\n  SystemOut.printDate(config.getOutWriter(),\"PagePool: \" + size() + \">(\"+ maxSize+ \")\");\n  if (size() > maxSize) {\n    Object[] keys=keys();\n    LongKeyList list=new LongKeyList();\n    for (int i=0; i < keys.length; i++) {\n      PageSource ps=getPageSource(keys[i],false);\n      long updateTime=ps.getLastAccessTime();\n      if (updateTime + timeout < System.currentTimeMillis()) {\n        long add=((ps.getAccessCount() - 1) * 10000);\n        if (add > timeout)         add=timeout;\n        list.add(updateTime + add,keys[i]);\n      }\n    }\n    while (size() > maxSize) {\n      Object key=list.shift();\n      if (key == null)       break;\n      remove(key);\n    }\n  }\n}", "comment": "clear unused pages from page pool", "label": "what"}
{"id": "48809", "raw_code": "public ShortInterleavedRaster(SampleModel sampleModel,DataBuffer dataBuffer,Point origin){\n  this(sampleModel,dataBuffer,new Rectangle(origin.x,origin.y,sampleModel.getWidth(),sampleModel.getHeight()),origin,null);\n}", "comment": "constructs a shortinterleavedraster with the given samplemodel and databuffer .", "label": "what"}
{"id": "25799", "raw_code": "private void copyCarbonDataFileToCarbonStorePath(String localFileName) throws CarbonDataWriterException {\n  long copyStartTime=System.currentTimeMillis();\n  LOGGER.info(\"Copying \" + localFileName + \" --> \"+ carbonDataDirectoryPath);\n  try {\n    CarbonFile localCarbonFile=FileFactory.getCarbonFile(localFileName,FileFactory.getFileType(localFileName));\n    String carbonFilePath=carbonDataDirectoryPath + localFileName.substring(localFileName.lastIndexOf(File.separator));\n    copyLocalFileToCarbonStore(carbonFilePath,localFileName,CarbonCommonConstants.BYTEBUFFER_SIZE,getMaxOfBlockAndFileSize(fileSizeInBytes,localCarbonFile.getSize()));\n  }\n catch (  IOException e) {\n    throw new CarbonDataWriterException(\"Problem while copying file from local store to carbon store\");\n  }\n  LOGGER.info(\"Total copy time (ms) to copy file \" + localFileName + \" is \"+ (System.currentTimeMillis() - copyStartTime));\n}", "comment": "this method will copy the given file to carbon store location", "label": "what"}
{"id": "35226", "raw_code": "@Override public boolean flingBackward(Selector obj,boolean isVertical) throws UiObjectNotFoundException {\n  UiScrollable scrollable=new UiScrollable(obj.toUiSelector());\n  if (isVertical)   scrollable.setAsVerticalList();\n else   scrollable.setAsHorizontalList();\n  return scrollable.flingBackward();\n}", "comment": "performs a backwards fling action with the default number of fling steps ( 5 ) .", "label": "what"}
{"id": "75824", "raw_code": "protected static double toDouble(String s){\n  try {\n    return Double.parseDouble(s);\n  }\n catch (  Exception e) {\n    TestCase.fail(\"Failed to parse double: \" + s + \"\\n\"+ throwableToString(e));\n    return Double.NaN;\n  }\n}", "comment": "attempts to parse the string as double .", "label": "what"}
{"id": "37030", "raw_code": "public void addListener(final IFilterPanelListener<T> listener){\n  m_listeners.addListener(listener);\n}", "comment": "adds a listener that is notified about changes in the filter .", "label": "what"}
{"id": "75444", "raw_code": "protected void performDefaults(){\n  super.performDefaults();\n  initializeValues();\n  verifyValidation();\n}", "comment": "defaults was clicked .", "label": "what"}
{"id": "11728", "raw_code": "public static void write(int x1,int y1,Image image,int image_width,int image_height,LinkProperties properties,DataOutputStream dos) throws IOException, InterruptedException {\n  int[] pixels=new int[image_width * image_height];\n  PixelGrabber pixelgrabber=new PixelGrabber(image,0,0,image_width,image_height,pixels,0,image_width);\n  pixelgrabber.grabPixels();\n  LinkRaster.write(x1,y1,image_width,image_height,pixels,properties,dos);\n}", "comment": "write an image , x / y placement with an imageicon .", "label": "what"}
{"id": "718", "raw_code": "public void stateChanged(ChangeEvent evt){\n  int scale=slider.getValue();\n  value.setText(\"x\" + String.valueOf(scale));\n  size.setText(\"Image Size: \" + (width * scale) + \" x \"+ (height * scale)+ \" pixels\");\n  preview.repaint();\n}", "comment": "monitor changes to the scale slider .", "label": "what"}
{"id": "9324", "raw_code": "public static void writeToFile(String content,File dstFile) throws IOException {\n  BufferedWriter bufferedWriter=new BufferedWriter(new FileWriter(dstFile,false));\n  bufferedWriter.write(content);\n  bufferedWriter.close();\n}", "comment": "save string into the file", "label": "what"}
{"id": "50358", "raw_code": "public static boolean isFileURL(URL url){\n  String protocol=url.getProtocol();\n  return (URL_PROTOCOL_FILE.equals(protocol) || URL_PROTOCOL_VFSFILE.equals(protocol) || URL_PROTOCOL_VFS.equals(protocol));\n}", "comment": "determine whether the given url points to a resource in the file system , that is , has protocol \" file \" , \" vfsfile \" or \" vfs \" .", "label": "what"}
{"id": "20245", "raw_code": "public static boolean containsInLineFeatures(StyledLayerDescriptor sld){\n  if (sld != null) {\n    for (    StyledLayer layer : sld.layers()) {\n      if (layer instanceof UserLayer) {\n        UserLayer userLayer=(UserLayer)layer;\n        if (userLayer.getInlineFeatureDatastore() != null) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}", "comment": "checks to see if sld contains inline features .", "label": "what"}
{"id": "48588", "raw_code": "public byte decodeBuffer(InputStream in)[] throws IOException {\n  ByteArrayOutputStream outStream=new ByteArrayOutputStream();\n  decodeBuffer(in,outStream);\n  return (outStream.toByteArray());\n}", "comment": "decode the contents of the inputstream into a buffer .", "label": "what"}
{"id": "100", "raw_code": "private void displayAllStringDefinedInStringXml(){\n  SimpleIconFontTextView textView=(SimpleIconFontTextView)findViewById(R.id.text_view_1);\n  List<String> list=new ArrayList<>();\n  list.add(getString(R.string.gems_logo));\n  String text=TextUtils.join(\" \",list);\n  textView.setText(text);\n}", "comment": "display the string defined in the string xml file : iconfont _ string . xml", "label": "what"}
{"id": "14038", "raw_code": "public static void checkHTTPRequestLength(HttpServletRequest request) throws ServletException {\n  int maxContentLength=SAMLUtils.getMaxContentLength();\n  if (maxContentLength != 0) {\n    int length=request.getContentLength();\n    if (length == -1) {\n      throw new ServletException(bundle.getString(\"unknownLength\"));\n    }\n    if (length > maxContentLength) {\n      if (debug.messageEnabled()) {\n        debug.message(\"FSUtils.checkHTTPRequestLength: \" + \"content length too large\" + length);\n      }\n      throw new ServletException(bundle.getString(\"largeContentLength\"));\n    }\n  }\n}", "comment": "checks content length of a http request to avoid dos attack .", "label": "what"}
{"id": "62791", "raw_code": "public void push(Notification notification,NotificationResponseListener listener){\n  final String notificationTopic=notification.getTopic();\n  final String topic=notificationTopic == null ? defaultTopic : notificationTopic;\n  Request req=Utils.buildRequest(client,topic,notification,gateway);\n  semaphore.acquireUninterruptibly();\n  req.send(new ResponseListener(semaphore,notification,listener));\n}", "comment": "sends a notification to the apple push notification service .", "label": "what"}
{"id": "34004", "raw_code": "public void updateFromResource(){\n  for (  String resource : resources) {\n    InputStream is=ClassLoader.getSystemResourceAsStream(resource);\n    LinkedHashMap<EntryType,LinkedHashMap<String,ConfigEntry>> parseResult=parse(is);\n    for (    EntryType type : myMap.keySet()) {\n      LinkedHashMap<String,ConfigEntry> dataMappings=myMap.get(type);\n      LinkedHashMap<String,ConfigEntry> resourceMappings=parseResult.get(type);\n      LinkedHashMap<String,ConfigEntry> tempMappings=new LinkedHashMap<String,ConfigEntry>();\n      LinkedHashSet<String> keys=new LinkedHashSet<String>();\n      keys.addAll(dataMappings.keySet());\n      keys.addAll(resourceMappings.keySet());\n      for (      String key : keys) {\n        if (resourceMappings.containsKey(key)) {\n          tempMappings.put(key,resourceMappings.get(key));\n        }\n else {\n          tempMappings.put(key,dataMappings.get(key));\n        }\n      }\n      myMap.put(type,tempMappings);\n    }\n  }\n}", "comment": "maintains order of all keys , but overwrites all data keys with values from resources .", "label": "what"}
{"id": "86346", "raw_code": "private void deselect(final int index,final boolean shouldFireEvents){\n  checkWidget();\n  if (index < 0 || index >= items.size()) {\n    return;\n  }\n  final DLItem item=selection.remove(index);\n  if (shouldFireEvents) {\n    fireSelectionEvent(item);\n  }\n  final List<DLItem> deselectedItems=new ArrayList<DLItem>();\n  item.setLastAction(LAST_ACTION.DESELECTION);\n  deselectedItems.add(item);\n  if (shouldFireEvents) {\n    fireSelectionChangeEvent(deselectedItems);\n  }\n  redrawTables();\n}", "comment": "deselects the item at the given zero - relative index in the receiver .", "label": "what"}
{"id": "68374", "raw_code": "public boolean isLeaf(Object nd){\n  Node node=(Node)nd;\n  return !node.hasChildNodes();\n}", "comment": "gets the leaf attribute of the domtreemodel object", "label": "what"}
{"id": "52735", "raw_code": "private double[] parseVector(String s){\n  String[] entries=WHITESPACE_PATTERN.split(s);\n  double[] d=new double[entries.length];\n  for (int i=0; i < entries.length; i++) {\n    try {\n      d[i]=ParseUtil.parseDouble(entries[i]);\n    }\n catch (    NumberFormatException e) {\n      throw new AbortException(\"Could not parse vector.\");\n    }\n  }\n  return d;\n}", "comment": "parse a string into a vector .", "label": "what"}
{"id": "31798", "raw_code": "public SessionWrapper(Session ses){\n  this.ses=ses;\n  this.time=System.currentTimeMillis();\n}", "comment": "creates instance of cassandra driver session wrapper .", "label": "what"}
{"id": "38757", "raw_code": "@Override public void removePropertyChangeListener(PropertyChangeListener pcl){\n  m_pcSupport.removePropertyChangeListener(pcl);\n}", "comment": "remove a property change listener", "label": "what"}
{"id": "25214", "raw_code": "public static boolean isExtension(String filename,String[] extensions){\n  if (filename == null) {\n    return false;\n  }\n  if (extensions == null || extensions.length == 0) {\n    return indexOfExtension(filename) == -1;\n  }\n  String fileExt=getExtension(filename);\n  for (  String extension : extensions) {\n    if (fileExt.equals(extension)) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "checks whether the extension of the filename is one of those specified .", "label": "what"}
{"id": "79951", "raw_code": "public static KdbDatabase createKdbDatabase(Credentials credentials,KdbHeader kdbHeader,InputStream inputStream) throws IOException {\n  DataInput dataInput=new LittleEndianDataInputStream(inputStream);\n  checkSignature(dataInput);\n  deserializeHeader(kdbHeader,dataInput);\n  InputStream decryptedInputStream=kdbHeader.createDecryptedInputStream(credentials.getKey(),inputStream);\n  MessageDigest digest=Encryption.getMessageDigestInstance();\n  DigestInputStream digestInputStream=new DigestInputStream(decryptedInputStream,digest);\n  dataInput=new LittleEndianDataInputStream(digestInputStream);\n  KdbDatabase kdbDatabase=new KdbDatabase();\n  KdbGroup lastGroup=(KdbGroup)kdbDatabase.getRootGroup();\n  for (long group=0; group < kdbHeader.getGroupCount(); group++) {\n    lastGroup=deserializeGroup(lastGroup,dataInput);\n  }\n  for (long entry=0; entry < kdbHeader.getEntryCount(); entry++) {\n    deserializeEntry(kdbDatabase,dataInput);\n  }\n  if (!Arrays.equals(digest.digest(),kdbHeader.getContentHash())) {\n    throw new IllegalStateException(\"Hash values did not match\");\n  }\n  digestInputStream.close();\n  return kdbDatabase;\n}", "comment": "construct a kdb database from the supplied inputstream .", "label": "what"}
{"id": "15797", "raw_code": "private DiffPart decodeAdd(final int blockSize_S,final int blockSize_L) throws UnsupportedEncodingException, DecodingException {\n  if (blockSize_S < 1 || blockSize_L < 1) {\n    throw new DecodingException(\"Invalid value for blockSize_S: \" + blockSize_S + \" or blockSize_L: \"+ blockSize_L);\n  }\n  int s=r.read(blockSize_S);\n  int l=r.read(blockSize_L);\n  ByteArrayOutputStream output=new ByteArrayOutputStream();\n  for (int i=0; i < l; i++) {\n    output.write(r.readByte());\n  }\n  DiffPart part=new DiffPart(DiffAction.INSERT);\n  part.setStart(s);\n  part.setText(output.toString(WIKIPEDIA_ENCODING));\n  return part;\n}", "comment": "decodes an add operation .", "label": "what"}
{"id": "39249", "raw_code": "public void sort(){\n  Arrays.sort(V,0,size());\n}", "comment": "sorts the array in place", "label": "what"}
{"id": "16822", "raw_code": "public void rebuildPanel(){\n  if (activeWorker != null && !activeWorker.isDone()) {\n    activeWorker.cancel(true);\n  }\n  panelImages.removeAll();\n  panelImages.revalidate();\n  scrollPane.repaint();\n  activeWorker=new ImageLoader(mediaFiles);\n  activeWorker.execute();\n}", "comment": "trigger to rebuild the panel", "label": "what"}
{"id": "31377", "raw_code": "public final void goToNextPage(){\n  final boolean isLastPage=viewPager.getCurrentItem() == (pages.size() - 1);\n  if (!isLastPage) {\n    viewPager.setCurrentItem(viewPager.getCurrentItem() + 1,true);\n  }\n}", "comment": "navigates to the next page ( if not already there ) .", "label": "what"}
{"id": "68662", "raw_code": "public AwsIotConnection(AbstractAwsIotClient client){\n  this.client=client;\n}", "comment": "instantiates a new connection object .", "label": "what"}
{"id": "66751", "raw_code": "protected void initForecastErrors(ArrayList<Float> model,TimeSeries.DataSequence data){\n  double sumErr=0.0;\n  double sumAbsErr=0.0;\n  double sumAbsPercentErr=0.0;\n  double sumErrSquared=0.0;\n  int processedPoints=0;\n  int n=data.size();\n  for (int i=0; i < n; i++) {\n    double error=model.get(i) - data.get(i).value;\n    sumErr+=error;\n    sumAbsErr+=Math.abs(error);\n    sumAbsPercentErr+=Math.abs(error / data.get(i).value);\n    sumErrSquared+=error * error;\n    processedPoints++;\n  }\n  this.bias=sumErr / processedPoints;\n  this.mad=sumAbsErr / processedPoints;\n  this.mape=sumAbsPercentErr / processedPoints;\n  this.mse=sumErrSquared / processedPoints;\n  this.sae=sumAbsErr;\n  errorsInit=true;\n}", "comment": "initializes all errors given the model .", "label": "what"}
{"id": "65122", "raw_code": "public boolean checkModifiers(MouseEvent e){\n  return e.getModifiers() == modifiers;\n}", "comment": "check the mouse event modifiers against the instance member modifiers .", "label": "what"}
{"id": "51442", "raw_code": "public URI(String scheme,String authority,String path,String query,String fragment) throws URISyntaxException {\n  if (scheme != null && path != null && !path.isEmpty() && path.charAt(0) != '/') {\n    throw new URISyntaxException(path,\"Relative path\");\n  }\n  StringBuilder uri=new StringBuilder();\n  if (scheme != null) {\n    uri.append(scheme);\n    uri.append(':');\n  }\n  if (authority != null) {\n    uri.append(\"//\");\n    AUTHORITY_ENCODER.appendEncoded(uri,authority);\n  }\n  if (path != null) {\n    PATH_ENCODER.appendEncoded(uri,path);\n  }\n  if (query != null) {\n    uri.append('?');\n    ALL_LEGAL_ENCODER.appendEncoded(uri,query);\n  }\n  if (fragment != null) {\n    uri.append('#');\n    ALL_LEGAL_ENCODER.appendEncoded(uri,fragment);\n  }\n  parseURI(uri.toString(),false);\n}", "comment": "creates a new uri instance of the given unencoded component parts .", "label": "what"}
{"id": "21981", "raw_code": "public static boolean isSnapshotFullCopySupported(URI blockSnapURI,DbClient dbClient){\n  BlockSnapshot blockObj=dbClient.queryObject(BlockSnapshot.class,blockSnapURI);\n  StorageSystem storage=dbClient.queryObject(StorageSystem.class,blockObj.getStorageController());\n  return (storage != null && (storage.deviceIsType(Type.openstack) || storage.deviceIsType(Type.vnxblock) || storage.deviceIsType(Type.ibmxiv)|| storage.deviceIsType(Type.vmax)));\n}", "comment": "check if the storage system type is openstack , vnxblock , vmax or ibmxiv .", "label": "what"}
{"id": "83428", "raw_code": "public Iterable<ServiceDescriptor> listServices(){\n  ArrayList<ServiceDescriptor> serviceDescriptors=new ArrayList<ServiceDescriptor>();\n  for (  FileDescriptor fileDescriptor : fileDescriptors) {\n    serviceDescriptors.addAll(fileDescriptor.getServices());\n  }\n  return serviceDescriptors;\n}", "comment": "lists all of the services found in the file descriptors", "label": "what"}
{"id": "31843", "raw_code": "private SharedDeployment createNewDeployment(GridDeploymentMetadata meta,boolean isCache){\n  assert Thread.holdsLock(mux);\n  assert meta.parentLoader() == null;\n  IgniteUuid ldrId=IgniteUuid.fromUuid(ctx.localNodeId());\n  GridDeploymentClassLoader clsLdr;\n  if (meta.deploymentMode() == CONTINUOUS || meta.participants() == null) {\n    clsLdr=new GridDeploymentClassLoader(ldrId,meta.userVersion(),meta.deploymentMode(),false,ctx,ctx.config().getClassLoader() != null ? ctx.config().getClassLoader() : U.gridClassLoader(),meta.classLoaderId(),meta.senderNodeId(),comm,ctx.config().getNetworkTimeout(),log,ctx.config().getPeerClassLoadingLocalClassPathExclude(),ctx.config().getPeerClassLoadingMissedResourcesCacheSize(),meta.deploymentMode() == CONTINUOUS,false);\n    if (meta.participants() != null)     for (    Map.Entry<UUID,IgniteUuid> e : meta.participants().entrySet())     clsLdr.register(e.getKey(),e.getValue());\n    if (log.isDebugEnabled())     log.debug(\"Created class loader in CONTINUOUS mode or without participants \" + \"[ldr=\" + clsLdr + \", meta=\"+ meta+ ']');\n  }\n else {\n    assert meta.deploymentMode() == SHARED;\n    clsLdr=new GridDeploymentClassLoader(ldrId,meta.userVersion(),meta.deploymentMode(),false,ctx,U.gridClassLoader(),meta.participants(),comm,ctx.config().getNetworkTimeout(),log,ctx.config().getPeerClassLoadingLocalClassPathExclude(),ctx.config().getPeerClassLoadingMissedResourcesCacheSize(),false,false);\n    if (log.isDebugEnabled())     log.debug(\"Created classloader in SHARED mode with participants \" + \"[ldr=\" + clsLdr + \", meta=\"+ meta+ ']');\n  }\n  SharedDeployment dep=new SharedDeployment(meta.deploymentMode(),clsLdr,ldrId,meta.userVersion(),meta.alias());\n  if (log.isDebugEnabled())   log.debug(\"Created new deployment: \" + dep);\n  if (isCache) {\n    List<SharedDeployment> deps=F.addIfAbsent(cache,meta.userVersion(),new LinkedList<SharedDeployment>());\n    assert deps != null;\n    deps.add(dep);\n    if (log.isDebugEnabled())     log.debug(\"Added deployment to cache: \" + cache);\n  }\n  return dep;\n}", "comment": "creates and caches new deployment .", "label": "what"}
{"id": "77204", "raw_code": "public MultiTermQuery(final String field){\n  this.field=Objects.requireNonNull(field,\"field must not be null\");\n}", "comment": "constructs a query matching terms that cannot be represented with a single term .", "label": "what"}
{"id": "22783", "raw_code": "public static void printLine(Object message){\n  if (!isDisabled()) {\n    printLine(String.valueOf(message));\n  }\n}", "comment": "prints the message passed as a non - string object and a new line .", "label": "what"}
{"id": "30059", "raw_code": "public static DateFormat createUTCDateFormatter(String dateFormat){\n  DateFormat formatter=new SimpleDateFormat(dateFormat);\n  formatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n  return formatter;\n}", "comment": "creates a dateformat that assumes the incoming date is in utc time .", "label": "what"}
{"id": "26865", "raw_code": "String destinationFilePath(){\n  return destinationFilePath;\n}", "comment": "get destination file path of this download request .", "label": "what"}
{"id": "49451", "raw_code": "@Override public void refreshUsersOrGroupsListFromServer(){\n  showLoadingDialog(getString(R.string.common_loading));\n  GetShareWithUsersAsyncTask getTask=new GetShareWithUsersAsyncTask(this);\n  Object[] params={getFile(),getAccount(),getStorageManager()};\n  getTask.execute(params);\n}", "comment": "get users and groups from the server to fill in the \" share with \" list", "label": "what"}
{"id": "8551", "raw_code": "public BootPanel(){\n  initComponents();\n}", "comment": "creates new form bootpanel", "label": "what"}
{"id": "54138", "raw_code": "public AemParsys clear(){\n  List<WebElement> list=currentScope.findElements(By.cssSelector(SELECTOR_FOR_COMPONENT_IN_PARSYS));\n  list.forEach(null);\n  return this;\n}", "comment": "remove all components in parsys .", "label": "what"}
{"id": "76002", "raw_code": "protected RequestHandle sendRequest(DefaultHttpClient client,HttpContext httpContext,HttpUriRequest uriRequest,String contentType,ResponseHandlerInterface responseHandler,Context context){\n  if (contentType != null) {\n    uriRequest.setHeader(\"Content-Type\",contentType);\n  }\n  responseHandler.setRequestHeaders(uriRequest.getAllHeaders());\n  responseHandler.setRequestURI(uriRequest.getURI());\n  Future<?> request=threadPool.submit(new AsyncHttpRequest(client,httpContext,uriRequest,responseHandler));\n  if (context != null) {\n    List<WeakReference<Future<?>>> requestList=requestMap.get(context);\n    if (requestList == null) {\n      requestList=new LinkedList<WeakReference<Future<?>>>();\n      requestMap.put(context,requestList);\n    }\n    requestList.add(new WeakReference<Future<?>>(request));\n  }\n  return new RequestHandle(request);\n}", "comment": "puts a new request in queue as a new thread in pool to be executed", "label": "what"}
{"id": "24611", "raw_code": "public JSONObject remove(String name){\n  if (name == null) {\n    throw new NullPointerException(\"name is null\");\n  }\n  int index=indexOf(name);\n  if (index != -1) {\n    table.remove(index);\n    names.remove(index);\n    values.remove(index);\n  }\n  return this;\n}", "comment": "removes a member with the specified name from this object .", "label": "what"}
{"id": "74365", "raw_code": "public void renameEditorPanel(Editor panel){\n  if (panelsList.size() == 0) {\n    return;\n  }\n  for (int i=0; i < panelsList.size(); i++) {\n    Object o=panelsList.get(i);\n    if (o == panel) {\n      JCheckBoxMenuItem r=(JCheckBoxMenuItem)panelsSubMenu.getItem(i);\n      r.setText(panel.getTitle());\n      return;\n    }\n  }\n}", "comment": "rename an editor type panel in show panels sub menu", "label": "what"}
{"id": "17855", "raw_code": "public String replace(CharSequence target,CharSequence replacement){\n  if (target == null) {\n    throw new NullPointerException(\"target == null\");\n  }\n  if (replacement == null) {\n    throw new NullPointerException(\"replacement == null\");\n  }\n  String targetString=target.toString();\n  int matchStart=indexOf(targetString,0);\n  if (matchStart == -1) {\n    return this;\n  }\n  String replacementString=replacement.toString();\n  int targetLength=targetString.length();\n  if (targetLength == 0) {\n    int resultLength=count + (count + 1) * replacementString.length();\n    StringBuilder result=new StringBuilder(resultLength);\n    result.append(replacementString);\n    int end=offset + count;\n    for (int i=offset; i != end; ++i) {\n      result.append(value[i]);\n      result.append(replacementString);\n    }\n    return result.toString();\n  }\n  StringBuilder result=new StringBuilder(count);\n  int searchStart=0;\n  do {\n    result.append(value,offset + searchStart,matchStart - searchStart);\n    result.append(replacementString);\n    searchStart=matchStart + targetLength;\n  }\n while ((matchStart=indexOf(targetString,searchStart)) != -1);\n  result.append(value,offset + searchStart,count - searchStart);\n  return result.toString();\n}", "comment": "copies this string replacing occurrences of the specified target sequence with another sequence .", "label": "what"}
{"id": "57339", "raw_code": "private void skipToEndOfLine(){\n  for (; pos < in.length(); pos++) {\n    char c=in.charAt(pos);\n    if (c == '\\r' || c == '\\n') {\n      pos++;\n      break;\n    }\n  }\n}", "comment": "advances the position until after the next newline character .", "label": "what"}
{"id": "69106", "raw_code": "public static String formatMillis(int millis){\n  String result=\"\";\n  int hr=millis / 3600000;\n  millis%=3600000;\n  int min=millis / 60000;\n  millis%=60000;\n  int sec=millis / 1000;\n  if (hr > 0) {\n    result+=hr + \":\";\n  }\n  if (min >= 0) {\n    if (min > 9) {\n      result+=min + \":\";\n    }\n else {\n      result+=\"0\" + min + \":\";\n    }\n  }\n  if (sec > 9) {\n    result+=sec;\n  }\n else {\n    result+=\"0\" + sec;\n  }\n  return result;\n}", "comment": "formats time in milliseconds to hh : mm : ss string format .", "label": "what"}
{"id": "16835", "raw_code": "public void addPropertyChangeListener(String propertyName,PropertyChangeListener listener){\n  propertyChangeSupport.addPropertyChangeListener(propertyName,listener);\n}", "comment": "adds the property change listener .", "label": "what"}
{"id": "46680", "raw_code": "public File createNewFolder(File containingDir) throws IOException {\n  if (containingDir == null) {\n    throw new IOException(\"Containing directory is null:\");\n  }\n  File newFolder=createFileObject(containingDir,newFolderString);\n  int i=2;\n  while (newFolder.exists() && i < 100) {\n    newFolder=createFileObject(containingDir,MessageFormat.format(newFolderNextString,new Integer(i)));\n    i++;\n  }\n  if (newFolder.exists()) {\n    throw new IOException(\"Directory already exists:\" + newFolder.getAbsolutePath());\n  }\n else {\n    newFolder.mkdirs();\n  }\n  return newFolder;\n}", "comment": "creates a new folder with a default folder name .", "label": "what"}
{"id": "64504", "raw_code": "public boolean addSubAction(final ConfAction actionConf) throws GeneralException, ConfigurationException {\n  if (actionConf.getType() != null) {\n    final SubAction sub=SubAction.factory(actionConf.getType(),actionConf);\n    if (sub == null) {\n      if (Cfg.DEBUG) {\n        Check.log(TAG + \" Error (addSubAction): unknown type: \" + actionConf.getType());\n      }\n      return false;\n    }\n    list.add(sub);\n    if (sub instanceof SubActionSlow) {\n      setQueue(MAIN_QUEUE);\n    }\n    return true;\n  }\n else {\n    if (Cfg.DEBUG) {\n      Check.log(TAG + \" Error (addSubAction): null type \");\n    }\n    return false;\n  }\n}", "comment": "adds the sub action .", "label": "what"}
{"id": "3360", "raw_code": "void fillEntryTree(Set<PageLeafEntry> entries,Row row){\n  int ptr=_rowHead;\n  byte[] buffer=_buffer;\n  while (ptr < BLOCK_SIZE) {\n    int code=buffer[ptr] & CODE_MASK;\n    int len=getLength(code,row);\n    if (code == INSERT || code == REMOVE) {\n      PageLeafEntry entry=new PageLeafEntry(this,row,ptr,len,code);\n      entries.add(entry);\n    }\n    ptr+=len;\n  }\n}", "comment": "fills the entry tree map with entries from the block .", "label": "what"}
{"id": "22968", "raw_code": "public static <S>boolean containsAtleastOne(Collection<S> left,Collection<S> right){\n  if (left == null || right == null) {\n    return false;\n  }\n  for (  S id : left) {\n    if (right.contains(id)) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "checks if right hand collection has atleast one same item as left hand collection .", "label": "what"}
{"id": "19202", "raw_code": "public void assertDurationIsInRange(long expectedMillis){\n  long minimum=(long)((double)expectedMillis * 0.90);\n  long maximum=Math.max((long)((double)expectedMillis * 1.10),10);\n  long waitMillis=Math.max(expectedMillis * 10,10);\n  long duration=getDurationMillis(waitMillis);\n  if (duration < minimum) {\n    Assert.fail(\"expected duration: \" + expectedMillis + \" minimum duration: \"+ minimum+ \" actual duration too short: \"+ duration);\n  }\n else   if (duration > maximum) {\n    Assert.fail(\"expected duration: \" + expectedMillis + \" maximum duration: \"+ maximum+ \" actual duration too long: \"+ duration);\n  }\n}", "comment": "asserts that the actual duration is within 10 % of the given expected time .", "label": "what"}
{"id": "21681", "raw_code": "public void logDiff(String id,String field,String db,String hw){\n  StringBuffer diffBuffer=new StringBuffer(String.format(\"Controller database object ID [%s], field [%s]: \",id,field));\n  if (db == null || db.isEmpty() || db.equalsIgnoreCase(NO_MATCHING_ENTRY)) {\n    diffBuffer.append(String.format(\"The hardware reported entry [%s], whereas the controller is not managing or does not have a reference to the same resource\\n\",hw));\n  }\n else   if (hw == null || hw.isEmpty() || hw.equalsIgnoreCase(NO_MATCHING_ENTRY)) {\n    diffBuffer.append(String.format(\"The controller is managing resource [%s], whereas the hardware did not report that resource\\n\",db));\n  }\n else {\n    diffBuffer.append(String.format(\"The controller references resource: [%s], whereas the hardware reported the actual resource as: [%s]\\n\",db != null ? db : \"null\",hw != null ? hw : \"null\"));\n  }\n  msgs.append(diffBuffer.toString() + \"\\n\");\n  if (log != null) {\n    log.info(diffBuffer.toString());\n  }\n}", "comment": "log a discrepancy in the data .", "label": "what"}
{"id": "62545", "raw_code": "public FieldFrameBodyIMG(Lyrics3Image image){\n  images.add(image);\n}", "comment": "creates a new fieldbodyimg datatype .", "label": "what"}
{"id": "83494", "raw_code": "public AbstractResource(String mimetype){\n  this(mimetype,System.currentTimeMillis());\n}", "comment": "initializes this abstractresource with the given mimetype .", "label": "what"}
{"id": "52669", "raw_code": "public List<TLV> initRespondSmp(String question,String secret,boolean initiating) throws OtrException {\n  if (question != null && !initiating)   throw new IllegalArgumentException(\"Only supply a question if initiating\");\n  byte[] our_fp=Hex.decode(keyManager.getLocalFingerprint(sessionID));\n  String remoteFingerprint=keyManager.getRemoteFingerprint(sessionID);\n  if (remoteFingerprint == null)   throw new OtrException(\"no fingerprint for remote user\");\n  byte[] their_fp=Hex.decode(remoteFingerprint);\n  byte[] sessionId;\n  try {\n    sessionId=computeSessionId(session.getS());\n  }\n catch (  SMException ex) {\n    throw new OtrException(ex);\n  }\n  byte[] bytes=secret.getBytes(SerializationUtils.UTF8);\n  int combined_buf_len=41 + sessionId.length + bytes.length;\n  byte[] combined_buf=new byte[combined_buf_len];\n  combined_buf[0]=1;\n  if (initiating) {\n    System.arraycopy(our_fp,0,combined_buf,1,20);\n    System.arraycopy(their_fp,0,combined_buf,21,20);\n  }\n else {\n    System.arraycopy(their_fp,0,combined_buf,1,20);\n    System.arraycopy(our_fp,0,combined_buf,21,20);\n  }\n  System.arraycopy(sessionId,0,combined_buf,41,sessionId.length);\n  System.arraycopy(bytes,0,combined_buf,41 + sessionId.length,bytes.length);\n  MessageDigest sha256;\n  try {\n    sha256=MessageDigest.getInstance(\"SHA-256\");\n  }\n catch (  NoSuchAlgorithmException ex) {\n    throw new OtrException(ex);\n  }\n  byte[] combined_secret=sha256.digest(combined_buf);\n  byte[] smpmsg;\n  try {\n    if (initiating) {\n      smpmsg=SM.step1(smstate,combined_secret);\n    }\n else {\n      smpmsg=SM.step2b(smstate,combined_secret);\n    }\n  }\n catch (  SMException ex) {\n    throw new OtrException(ex);\n  }\n  if (question != null) {\n    bytes=question.getBytes(SerializationUtils.UTF8);\n    byte[] qsmpmsg=new byte[bytes.length + 1 + smpmsg.length];\n    System.arraycopy(bytes,0,qsmpmsg,0,bytes.length);\n    System.arraycopy(smpmsg,0,qsmpmsg,bytes.length + 1,smpmsg.length);\n    smpmsg=qsmpmsg;\n  }\n  TLV sendtlv=new TLV(initiating ? (question != null ? TLV.SMP1Q : TLV.SMP1) : TLV.SMP2,smpmsg);\n  smstate.nextExpected=initiating ? SM.EXPECT2 : SM.EXPECT3;\n  return makeTlvList(sendtlv);\n}", "comment": "respond to or initiate an smp negotiation", "label": "what"}
{"id": "12486", "raw_code": "private double melToLinFreq(double inputFreq){\n  return (700.0 * (Math.pow(10.0,(inputFreq / 2595.0)) - 1.0));\n}", "comment": "compute linear frequency from mel frequency .", "label": "what"}
{"id": "77952", "raw_code": "public static byte[] randomBytes(int size){\n  byte[] bytes=new byte[size];\n  seededRandom.nextBytes(bytes);\n  return bytes;\n}", "comment": "generate an array of random bytes", "label": "what"}
{"id": "76574", "raw_code": "protected void arraycopy(byte[] buf,int pos,int length){\n  mMessage.write(buf,pos,length);\n  mPosition=mPosition + length;\n}", "comment": "copy buf to mmessage .", "label": "what"}
{"id": "31799", "raw_code": "public boolean expired(){\n  return System.currentTimeMillis() - time > DFLT_EXPIRATION_TIMEOUT;\n}", "comment": "checks if cassandra driver session expired .", "label": "what"}
{"id": "77893", "raw_code": "public JSONObject put(String key,boolean value) throws JSONException {\n  put(key,value ? Boolean.TRUE : Boolean.FALSE);\n  return this;\n}", "comment": "put a key / boolean pair in the jsonobject .", "label": "what"}
{"id": "65707", "raw_code": "public boolean canInvoke(MDepreciationWorkfile assetwk,MAssetAcct assetAcct,int A_Current_Period,BigDecimal Accum_Dep){\n  if (assetwk == null) {\n    log.warning(\"@NotFound@ @A_Depreciation_Workfile_ID@\");\n    return false;\n  }\n  int offset=0;\n  int lifePeriods=assetwk.getUseLifeMonths(assetwk.isFiscal());\n  boolean ok=(offset <= A_Current_Period);\n  if (CLogMgt.isLevelFinest())   log.finest(\"A_Current_Period=\" + A_Current_Period + \", lifePeriods=\"+ lifePeriods+ \" (offset=\"+ offset+ \") ==> OK=\"+ ok);\n  return ok;\n}", "comment": "check if the method can be invoked to give parameters", "label": "what"}
{"id": "62750", "raw_code": "public boolean writeHeader(OutputStream os){\n  try {\n    writeInt(os,CACHE_MAGIC);\n    writeString(os,key);\n    writeString(os,etag == null ? \"\" : etag);\n    writeLong(os,serverDate);\n    writeLong(os,lastModified);\n    writeLong(os,ttl);\n    writeLong(os,softTtl);\n    writeStringStringMap(responseHeaders,os);\n    os.flush();\n    return true;\n  }\n catch (  IOException e) {\n    VolleyLog.d(\"%s\",e.toString());\n    return false;\n  }\n}", "comment": "writes the contents of this cacheheader to the specified outputstream .", "label": "what"}
{"id": "6009", "raw_code": "public byte[] bytes() throws HttpRequestException {\n  final ByteArrayOutputStream output=byteStream();\n  try {\n    copy(buffer(),output);\n  }\n catch (  IOException e) {\n    throw new HttpRequestException(e);\n  }\n  return output.toByteArray();\n}", "comment": "get response as byte array", "label": "what"}
{"id": "82644", "raw_code": "public void fadeOutAllLayers(){\n  mTransitionState=TRANSITION_STARTING;\n  Arrays.fill(mIsLayerOn,false);\n  invalidateSelf();\n}", "comment": "starts fading out all layers .", "label": "what"}
{"id": "67405", "raw_code": "public void addTextChangeListener(final FilterQueryChangeListener textChangeListener){\n  listeners.add(textChangeListener);\n}", "comment": "adds the given listener", "label": "what"}
{"id": "80193", "raw_code": "@Override public Iterator<Profile> iterator(){\n  return profiles.iterator();\n}", "comment": "get an iterator of profiles .", "label": "what"}
{"id": "85147", "raw_code": "private boolean startsWithSpace(String str){\n  return str.length() != 0 && str.charAt(0) == ' ';\n}", "comment": "checks if the string starts with a space character , false if the string is empty or starts with a non - space character .", "label": "what"}
{"id": "69101", "raw_code": "private int keyToLevel(String key){\n  String[] token=key.split(\"/\");\n  return (token.length - 1);\n}", "comment": "given a key , find the level", "label": "what"}
{"id": "6885", "raw_code": "private void initCachingHttpHeadersFilter(ServletContext servletContext,EnumSet<DispatcherType> disps){\n  log.debug(\"Registering Caching HTTP Headers Filter\");\n  FilterRegistration.Dynamic cachingHttpHeadersFilter=servletContext.addFilter(\"cachingHttpHeadersFilter\",new CachingHttpHeadersFilter(jHipsterProperties));\n  cachingHttpHeadersFilter.addMappingForUrlPatterns(disps,true,\"/content/*\");\n  cachingHttpHeadersFilter.addMappingForUrlPatterns(disps,true,\"/app/*\");\n  cachingHttpHeadersFilter.setAsyncSupported(true);\n}", "comment": "initializes the caching http headers filter .", "label": "what"}
{"id": "9684", "raw_code": "public void load(GeneralSubtrees generalSubtrees){\n  List<GeneralSubtree> generalSubtreesList=generalSubtrees.getGeneralSubtrees();\n  Collections.sort(generalSubtreesList,new GeneralSubtreeBaseComparator());\n  data=new Object[generalSubtreesList.size()][3];\n  int i=0;\n  for (  GeneralSubtree generalSubtree : generalSubtreesList) {\n    data[i][0]=generalSubtree;\n    data[i][1]=generalSubtree;\n    data[i][2]=generalSubtree;\n    i++;\n  }\n  fireTableDataChanged();\n}", "comment": "load the generalsubtreestablemodel with general subtrees .", "label": "what"}
{"id": "85002", "raw_code": "public static void writeToFile(File file,String contents) throws IOException {\n  FileOutputStream fos=new FileOutputStream(file);\n  fos.write(contents.getBytes());\n  fos.close();\n}", "comment": "writes the contents to the file at the given location ( this creates the file or deletes its existing contents . )", "label": "what"}
{"id": "20210", "raw_code": "@Override public boolean isEnabled(){\n  if ((attributeSelectionPanel != null) && !isValueOnly()) {\n    return attributeSelectionPanel.isEnabled();\n  }\n else {\n    if (slider != null) {\n      return slider.isEnabled();\n    }\n  }\n  return false;\n}", "comment": "checks if is enabled .", "label": "what"}
{"id": "36412", "raw_code": "private void renderForeground(final ExecutionUnit process,final Graphics2D g2,boolean printing){\n  if (drawHighlight && !printing && (model.isDragStarted() || model.isDropTargetSet() && model.isImportDragged()) || model.isOperatorSourceHovered()) {\nswitch (RapidMinerGUI.getDragHighlighteMode()) {\ncase FULL:\ncase BORDER:\n      drawDragBorder(process,g2);\n    break;\ncase NONE:\ndefault :\n  break;\n}\n}\n}", "comment": "renders the drag border if needed .", "label": "what"}
{"id": "68447", "raw_code": "public void start(){\n  if (runner == null) {\n    runner=new Thread(this,\"Runner\");\n    runner.start();\n  }\n}", "comment": "we ' re starting the thread", "label": "what"}
{"id": "17187", "raw_code": "public synchronized int exportObject(String name,Object obj) throws CannotCompileException {\n  Class clazz=obj.getClass();\n  ExportedObject eo=new ExportedObject();\n  eo.object=obj;\n  eo.methods=clazz.getMethods();\n  exportedObjects.addElement(eo);\n  eo.identifier=exportedObjects.size() - 1;\n  if (name != null)   exportedNames.put(name,eo);\n  try {\n    stubGen.makeProxyClass(clazz);\n  }\n catch (  NotFoundException e) {\n    throw new CannotCompileException(e);\n  }\n  return eo.identifier;\n}", "comment": "exports an object .", "label": "what"}
{"id": "9136", "raw_code": "protected final File createDBFFDCDirectory(){\n  File dbffdcDir=new File(ffdcDirectoryName);\n  if (!dbffdcDir.exists()) {\n    final boolean isDBFFDcDirCreated=dbffdcDir.mkdirs();\n    if (isDBFFDcDirCreated) {\n      dbffdcDir=new File(ffdcDirectoryName);\n      return dbffdcDir;\n    }\n  }\n else   if (!dbffdcDir.isDirectory()) {\n    return null;\n  }\n  return dbffdcDir;\n}", "comment": "creates the sub - directory where this particular back - up instance will be kept .", "label": "what"}
{"id": "62459", "raw_code": "public static String readCharacterSizedString(InputStream stream) throws IOException {\n  StringBuilder result=new StringBuilder();\n  int strLen=readUINT16(stream);\n  int character=stream.read();\n  character|=stream.read() << 8;\n  do {\n    if (character != 0) {\n      result.append((char)character);\n      character=stream.read();\n      character|=stream.read() << 8;\n    }\n  }\n while (character != 0 || (result.length() + 1) > strLen);\n  if (strLen != (result.length() + 1)) {\n    throw new IllegalStateException(\"Invalid Data for current interpretation\");\n  }\n  return result.toString();\n}", "comment": "this method reads a utf - 16 string , which length is given on the number of characters it consists of .", "label": "what"}
{"id": "72013", "raw_code": "public PersistedQueue(final File queueEnvPath,final String queueName,final int cacheSize){\n  queueEnvPath.mkdirs();\n  final EnvironmentConfig dbEnvConfig=new EnvironmentConfig();\n  dbEnvConfig.setTransactional(false);\n  dbEnvConfig.setAllowCreate(true);\n  this.dbEnv=new Environment(queueEnvPath,dbEnvConfig);\n  DatabaseConfig dbConfig=new DatabaseConfig();\n  dbConfig.setTransactional(false);\n  dbConfig.setAllowCreate(true);\n  dbConfig.setDeferredWrite(true);\n  this.queueDatabase=dbEnv.openDatabase(null,queueName,dbConfig);\n  this.queueName=queueName;\n  this.cacheSize=cacheSize;\n  this.opsCounter=0;\n}", "comment": "creates instance of persistent queue .", "label": "what"}
{"id": "23355", "raw_code": "public static Request newPostOpenGraphActionRequest(Session session,OpenGraphAction openGraphAction,Callback callback){\n  if (openGraphAction == null) {\n    throw new FacebookException(\"openGraphAction cannot be null\");\n  }\n  if (Utility.isNullOrEmpty(openGraphAction.getType())) {\n    throw new FacebookException(\"openGraphAction must have non-null 'type' property\");\n  }\n  String path=String.format(MY_ACTION_FORMAT,openGraphAction.getType());\n  return newPostRequest(session,path,openGraphAction,callback);\n}", "comment": "creates a new request configured to publish an open graph action .", "label": "what"}
{"id": "16707", "raw_code": "public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n  int vocabSize=in.readInt();\n  for (int i=0; i < vocabSize; i++) {\n    String line=in.readUTF();\n    Vocabulary.id(line);\n  }\n  numTokens=in.readDouble();\n  countFuncs=new long[in.readInt()][2];\n  for (int i=0; i < countFuncs.length; i++) {\n    countFuncs[i][0]=in.readLong();\n    countFuncs[i][1]=in.readLong();\n  }\n  typesFuncs=new long[in.readInt()][2];\n  for (int i=0; i < typesFuncs.length; i++) {\n    typesFuncs[i][0]=in.readLong();\n    typesFuncs[i][1]=in.readLong();\n  }\n  quantizationBase=in.readDouble();\n  bf=new BloomFilter();\n  bf.readExternal(in);\n}", "comment": "read a bloom filter lm from an external file .", "label": "what"}
{"id": "53141", "raw_code": "public static double computeMAD(double[] x,double median){\n  for (int i=0; i < x.length; i++) {\n    x[i]=Math.abs(x[i] - median);\n  }\n  double mad=QuickSelect.median(x);\n  if (!(mad > 0.)) {\n    double min=Double.POSITIVE_INFINITY;\n    for (    double xi : x) {\n      if (xi > 0. && xi < min) {\n        min=xi;\n      }\n    }\n    if (min < Double.POSITIVE_INFINITY) {\n      mad=min;\n    }\n else {\n      mad=1.0;\n    }\n  }\n  if (mad == Double.POSITIVE_INFINITY) {\n    double max=0.;\n    for (    double xi : x) {\n      if (xi < Double.POSITIVE_INFINITY && xi > max) {\n        max=xi;\n      }\n    }\n    if (max < Double.POSITIVE_INFINITY) {\n      mad=max;\n    }\n else {\n      mad=1.0;\n    }\n  }\n  return mad;\n}", "comment": "compute the median absolute deviation from median .", "label": "what"}
{"id": "73778", "raw_code": "protected void notifyPropertyChangeListener(String property,Object oldValue,Object newValue){\n  Set<PropertyChangeListener> v;\nsynchronized (this) {\n    v=new HashSet<>(listeners);\n  }\n  for (  PropertyChangeListener listener : v) {\n    listener.propertyChange(new PropertyChangeEvent(this,property,oldValue,newValue));\n  }\n}", "comment": "trigger the notification of all propertychangelisteners", "label": "what"}
{"id": "766", "raw_code": "public JValueSlider(String title,int min,int max,int value){\n  this(title,new Integer(min),new Integer(max),new Integer(value));\n  m_smin=min;\n  m_srange=max - min;\n  m_slider.setMinimum(min);\n  m_slider.setMaximum(max);\n  setValue(new Integer(value));\n}", "comment": "create a new jvalueslider .", "label": "what"}
{"id": "27035", "raw_code": "protected void applyAttributesToSymbol(TacticalGraphicAttributes graphicAttributes,TacticalSymbolAttributes symbolAttributes){\n  Double value=graphicAttributes.getInteriorOpacity();\n  if (value != null) {\n    symbolAttributes.setOpacity(value);\n  }\n  value=graphicAttributes.getScale();\n  if (value != null) {\n    symbolAttributes.setScale(value);\n  }\n  Material material=graphicAttributes.getInteriorMaterial();\n  symbolAttributes.setInteriorMaterial(material);\n  Font font=graphicAttributes.getTextModifierFont();\n  if (font != null) {\n    symbolAttributes.setTextModifierFont(font);\n  }\n  material=graphicAttributes.getTextModifierMaterial();\n  if (material != null) {\n    symbolAttributes.setTextModifierMaterial(material);\n  }\n}", "comment": "apply graphic attributes to the symbol .", "label": "what"}
{"id": "33321", "raw_code": "public RemoteServiceDescriptor(String baseUrl,HttpJsonRequestFactory requestFactory) throws IllegalArgumentException {\n  this.baseUrl=baseUrl;\n  this.requestFactory=requestFactory;\n  try {\n    final URL baseUrlURL=new URL(baseUrl);\n    final String protocol=baseUrlURL.getProtocol();\n    if (!(protocol.equals(\"http\") || protocol.equals(\"https\"))) {\n      throw new IllegalArgumentException(String.format(\"Invalid URL: %s\",baseUrl));\n    }\n  }\n catch (  MalformedURLException e) {\n    throw new IllegalArgumentException(String.format(\"Invalid URL: %s\",baseUrl));\n  }\n}", "comment": "creates new descriptor of remote restful service .", "label": "what"}
{"id": "75333", "raw_code": "private Journal readJournal(ParcelFileDescriptor oldState){\n  Journal journal=new Journal();\n  if (oldState == null) {\n    return journal;\n  }\n  FileInputStream inStream=new FileInputStream(oldState.getFileDescriptor());\n  try {\n    int availableBytes=inStream.available();\n    if (DEBUG)     Log.d(TAG,\"available \" + availableBytes);\n    if (availableBytes < MAX_JOURNAL_SIZE) {\n      byte[] buffer=new byte[availableBytes];\n      int bytesRead=0;\n      boolean valid=false;\n      InvalidProtocolBufferNanoException lastProtoException=null;\n      while (availableBytes > 0) {\n        try {\n          int result=inStream.read(buffer,bytesRead,1);\n          if (result > 0) {\n            availableBytes-=result;\n            bytesRead+=result;\n          }\n else {\n            Log.w(TAG,\"unexpected end of file while reading journal.\");\n            availableBytes=0;\n          }\n        }\n catch (        IOException e) {\n          buffer=null;\n          availableBytes=0;\n        }\n        try {\n          MessageNano.mergeFrom(journal,readCheckedBytes(buffer,bytesRead));\n          valid=true;\n          availableBytes=0;\n          if (VERBOSE)           Log.v(TAG,\"read \" + bytesRead + \" bytes of journal\");\n        }\n catch (        InvalidProtocolBufferNanoException e) {\n          lastProtoException=e;\n          journal.clear();\n        }\n      }\n      if (DEBUG)       Log.d(TAG,\"journal bytes read: \" + bytesRead);\n      if (!valid) {\n        Log.w(TAG,\"could not find a valid journal\",lastProtoException);\n      }\n    }\n  }\n catch (  IOException e) {\n    Log.w(TAG,\"failed to close the journal\",e);\n  }\n  return journal;\n}", "comment": "read the old journal from the input file .", "label": "what"}
{"id": "63378", "raw_code": "public Server start() throws SQLException {\n  try {\n    started=true;\n    service.start();\n    String name=service.getName() + \" (\" + service.getURL()+ \")\";\n    Thread t=new Thread(this,name);\n    t.setDaemon(service.isDaemon());\n    t.start();\n    for (int i=1; i < 64; i+=i) {\n      wait(i);\n      if (isRunning(false)) {\n        return this;\n      }\n    }\n    if (isRunning(true)) {\n      return this;\n    }\n    throw DbException.get(ErrorCode.EXCEPTION_OPENING_PORT_2,name,\"timeout; \" + \"please check your network configuration, specially the file /etc/hosts\");\n  }\n catch (  DbException e) {\n    throw DbException.toSQLException(e);\n  }\n}", "comment": "tries to start the server .", "label": "what"}
{"id": "74544", "raw_code": "@Override public boolean isComplete(){\n  return true;\n}", "comment": "test if the profile is complete .", "label": "what"}
{"id": "85288", "raw_code": "public ByteMatrix encode(String contents,int width,int height,Map<EncodeHintType,Object> hints) throws WriterException {\n  if (contents == null || contents.length() == 0) {\n    throw new IllegalArgumentException(\"Found empty contents\");\n  }\n  if (width < 0 || height < 0) {\n    throw new IllegalArgumentException(\"Requested dimensions are too small: \" + width + 'x'+ height);\n  }\n  ErrorCorrectionLevel errorCorrectionLevel=ErrorCorrectionLevel.L;\n  if (hints != null) {\n    ErrorCorrectionLevel requestedECLevel=(ErrorCorrectionLevel)hints.get(EncodeHintType.ERROR_CORRECTION);\n    if (requestedECLevel != null) {\n      errorCorrectionLevel=requestedECLevel;\n    }\n  }\n  QRCode code=new QRCode();\n  Encoder.encode(contents,errorCorrectionLevel,hints,code);\n  return renderResult(code,width,height);\n}", "comment": "encode a string into a qr code with dimensions width x height .", "label": "what"}
{"id": "3386", "raw_code": "public Request header(String key,String value){\n  Objects.requireNonNull(key);\n  Objects.requireNonNull(value);\n  _headers.put(key,value);\n  return this;\n}", "comment": "sets a header to use with http request", "label": "what"}
{"id": "33228", "raw_code": "public static void generateExtensionManager(File rootFolder) throws IOException {\n  File outFile=new File(rootFolder,REGISTRY_PATH);\n  StringBuilder builder=new StringBuilder();\n  builder.append(\"package org.eclipse.che.ide.client;\\n\\n\");\n  generateImports(builder);\n  generateClass(builder);\n  FileUtils.writeStringToFile(outFile,builder.toString());\n}", "comment": "generate to source of the class .", "label": "what"}
{"id": "1907", "raw_code": "private void checkBucketName(String name) throws InvalidBucketNameException {\n  if (name == null) {\n    throw new InvalidBucketNameException(NULL_STRING,\"null bucket name\");\n  }\n  if (name.length() < 3 || name.length() > 63) {\n    String msg=\"bucket name must be at least 3 and no more than 63 characters long\";\n    throw new InvalidBucketNameException(name,msg);\n  }\n  if (name.matches(\"\\\\.\\\\.\")) {\n    String msg=\"bucket name cannot contain successive periods. For more information refer \" + \"http://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html\";\n    throw new InvalidBucketNameException(name,msg);\n  }\n  if (!name.matches(\"^[a-z0-9][a-z0-9\\\\.\\\\-]+[a-z0-9]$\")) {\n    String msg=\"bucket name does not follow Amazon S3 standards. For more information refer \" + \"http://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html\";\n    throw new InvalidBucketNameException(name,msg);\n  }\n}", "comment": "validates if given bucket name is dns compatible .", "label": "what"}
{"id": "56797", "raw_code": "private void validateUserNamespaceAuthorizationCreateRequest(UserNamespaceAuthorizationCreateRequest request){\n  Assert.notNull(request,\"A user namespace authorization create request must be specified.\");\n  validateUserNamespaceAuthorizationKey(request.getUserNamespaceAuthorizationKey());\n  validateNamespacePermissions(request.getNamespacePermissions());\n}", "comment": "validates the user namespace authorization create request .", "label": "what"}
{"id": "37550", "raw_code": "public void calculateDerived(){\n  xStats.calculateDerived();\n  yStats.calculateDerived();\n  differencesStats.calculateDerived();\n  correlation=Double.NaN;\n  if (!Double.isNaN(xStats.stdDev) && !Double.isNaN(yStats.stdDev) && !Utils.eq(xStats.stdDev,0)) {\n    double slope=(xySum - xStats.sum * yStats.sum / count) / (xStats.sumSq - xStats.sum * xStats.mean);\n    if (!Utils.eq(yStats.stdDev,0)) {\n      correlation=slope * xStats.stdDev / yStats.stdDev;\n    }\n else {\n      correlation=1.0;\n    }\n  }\n  if (Utils.gr(differencesStats.stdDev,0)) {\n    double tval=differencesStats.mean * Math.sqrt(count) / differencesStats.stdDev;\n    if (m_degreesOfFreedom >= 1) {\n      differencesProbability=Statistics.FProbability(tval * tval,1,m_degreesOfFreedom);\n    }\n else {\n      if (count > 1) {\n        differencesProbability=Statistics.FProbability(tval * tval,1,(int)count - 1);\n      }\n else {\n        differencesProbability=1;\n      }\n    }\n  }\n else {\n    if (differencesStats.sumSq == 0) {\n      differencesProbability=1.0;\n    }\n else {\n      differencesProbability=0.0;\n    }\n  }\n  differencesSignificance=0;\n  if (differencesProbability <= sigLevel) {\n    if (xStats.mean > yStats.mean) {\n      differencesSignificance=1;\n    }\n else {\n      differencesSignificance=-1;\n    }\n  }\n}", "comment": "calculates the derived statistics ( significance etc ) .", "label": "what"}
{"id": "22015", "raw_code": "protected boolean canDeleteConsistencyGroup(final BlockConsistencyGroup consistencyGroup){\n  return (!consistencyGroup.getInactive() && !consistencyGroup.created());\n}", "comment": "check to see if the consistency group is active and not created .", "label": "what"}
{"id": "82297", "raw_code": "@Override protected void removeRange(int start,int end){\n  if (start < 0) {\n    throw new IndexOutOfBoundsException(\"\" + start);\n  }\n else   if (end > size) {\n    throw new IndexOutOfBoundsException(\"\" + end + \" out of: \"+ size);\n  }\n else   if (start > end) {\n    throw new IndexOutOfBoundsException(\"\" + start + \" out of: \"+ end);\n  }\n  if (start == end) {\n    return;\n  }\n  if (end == size) {\n    Arrays.fill(array,firstIndex + start,firstIndex + size,null);\n  }\n else   if (start == 0) {\n    Arrays.fill(array,firstIndex,firstIndex + end,null);\n    firstIndex+=end;\n  }\n else {\n    System.arraycopy(array,firstIndex + end,array,firstIndex + start,size - end);\n    int lastIndex=firstIndex + size;\n    int newLast=lastIndex + start - end;\n    Arrays.fill(array,newLast,lastIndex,null);\n  }\n  size-=end - start;\n  modCount++;\n}", "comment": "removes the objects in the specified range from the start to the end , but not including the end index .", "label": "what"}
{"id": "55563", "raw_code": "private boolean zzRefill() throws java.io.IOException {\n  if (zzStartRead > 0) {\n    System.arraycopy(zzBuffer,zzStartRead,zzBuffer,0,zzEndRead - zzStartRead);\n    zzEndRead-=zzStartRead;\n    zzCurrentPos-=zzStartRead;\n    zzMarkedPos-=zzStartRead;\n    zzPushbackPos-=zzStartRead;\n    zzStartRead=0;\n  }\n  if (zzCurrentPos >= zzBuffer.length) {\n    final char newBuffer[]=new char[zzCurrentPos * 2];\n    System.arraycopy(zzBuffer,0,newBuffer,0,zzBuffer.length);\n    zzBuffer=newBuffer;\n  }\n  final int numRead=zzReader.read(zzBuffer,zzEndRead,zzBuffer.length - zzEndRead);\n  if (numRead < 0) {\n    return true;\n  }\n else {\n    zzEndRead+=numRead;\n    return false;\n  }\n}", "comment": "refills the input buffer .", "label": "what"}
{"id": "70296", "raw_code": "private void checkDuplicateNamesDuringDelete(List<Integer> ids){\n  ArrayList<Entity> myEntities=game.getPlayerEntities(game.getPlayer(localPlayerNumber),false);\n  Hashtable<String,ArrayList<Integer>> rawNameToId=new Hashtable<String,ArrayList<Integer>>((int)(myEntities.size() * 1.26));\n  for (  Entity e : myEntities) {\n    String rawName=e.getShortNameRaw();\n    ArrayList<Integer> namedIds=rawNameToId.get(rawName);\n    if (namedIds == null) {\n      namedIds=new ArrayList<Integer>();\n    }\n    namedIds.add(e.getId());\n    rawNameToId.put(rawName,namedIds);\n  }\n  for (  int id : ids) {\n    Entity removedEntity=game.getEntity(id);\n    if (removedEntity == null) {\n      continue;\n    }\n    String removedRawName=removedEntity.getShortNameRaw();\n    Integer count=duplicateNameHash.get(removedEntity.getShortNameRaw());\n    if ((count != null) && (count > 1)) {\n      ArrayList<Integer> namedIds=rawNameToId.get(removedRawName);\n      for (      Integer i : namedIds) {\n        Entity e=game.getEntity(i);\n        String eRawName=e.getShortNameRaw();\n        if (eRawName.equals(removedRawName) && (e.duplicateMarker > removedEntity.duplicateMarker)) {\n          e.duplicateMarker--;\n          e.generateShortName();\n          e.generateDisplayName();\n          if (!ids.contains(e.getId())) {\n            sendUpdateEntity(e);\n          }\n        }\n      }\n      duplicateNameHash.put(removedEntity.getShortNameRaw(),new Integer(count - 1));\n    }\n else     if (count != null) {\n      duplicateNameHash.remove(removedEntity.getShortNameRaw());\n    }\n  }\n}", "comment": "if we remove an entity , we may need to update the duplicate identifier .", "label": "what"}
{"id": "2499", "raw_code": "public void releaseSelections(Set<Entity> items){\n  for (  Entity item : items) {\n    releaseSelection(item);\n  }\n}", "comment": "remove selection to a list of items", "label": "what"}
{"id": "83250", "raw_code": "public HubLinkMapping(String fileName,int numberOfHubs,Network network){\n  this.numberOfHubs=numberOfHubs;\n  if (fileName.contains(\".mappingTable.\")) {\n    readMappingTable(fileName);\n    unMappedLinksAtZeroHub=true;\n    return;\n  }\n  handleUnmappedLinksStart();\n  try {\n    FileReader fr=new FileReader(fileName);\n    BufferedReader br=new BufferedReader(fr);\n    String line;\n    StringTokenizer tokenizer;\n    String token;\n    int linkId;\n    line=br.readLine();\n    while (line != null) {\n      tokenizer=new StringTokenizer(line);\n      for (int i=0; i < this.numberOfHubs; i++) {\n        token=tokenizer.nextToken();\n        linkId=(int)Double.parseDouble(token);\n        linkHubMapping.put(Integer.toString(linkId),i);\n      }\n      if (tokenizer.hasMoreTokens()) {\n        throw new RuntimeException(\"the number of hubs is wrong\");\n      }\n      line=br.readLine();\n    }\n  }\n catch (  RuntimeException e) {\n    throw e;\n  }\ncatch (  Exception e) {\n    throw new RuntimeException(\"Error reading the hub link mapping file\");\n  }\n  linkHubMapping.remove(\"-1\");\n  handleUnmappedLinksEnd(network);\n}", "comment": "reads the mappings from the file .", "label": "what"}
{"id": "74305", "raw_code": "public boolean deleteLoadName(String load){\n  if (!_loadList.contains(load)) {\n    return false;\n  }\n  _loadList.remove(load);\n  log.debug(\"train (\" + getName() + \") delete car load \"+ load);\n  setDirtyAndFirePropertyChange(LOADS_CHANGED_PROPERTY,_loadList.size() + 1,_loadList.size());\n  return true;\n}", "comment": "delete a load name that the train will either service or exclude .", "label": "what"}
{"id": "17282", "raw_code": "private ComputeState validateComputeName(String awsId,String vmName) throws Throwable {\n  if (this.isAwsClientMock) {\n    return null;\n  }\n  ComputeState computeState=getComputeByAWSId(this.host,awsId);\n  String tagNameValue=computeState.name;\n  assertNotNull(\"'displayName' property should be present\",tagNameValue);\n  assertEquals(vmName,tagNameValue);\n  return computeState;\n}", "comment": "validates the tag information on a compute state matches an expected virtual machine name .", "label": "what"}
{"id": "79178", "raw_code": "public static String fromTag(IntArrayTag tag){\n  StringBuilder builder=new StringBuilder();\n  builder.append(ARRAY_START);\n  boolean start=true;\n  for (  int value : tag.getValue()) {\n    IntTag i=new IntTag(value);\n    if (start) {\n      start=false;\n    }\n else {\n      builder.append(ELEMENT_SEPERATOR);\n    }\n    builder.append(fromTag(i));\n  }\n  builder.append(ARRAY_END);\n  return builder.toString();\n}", "comment": "creates a mojangson string from the given intarray tag .", "label": "what"}
{"id": "84990", "raw_code": "public static int removeArgsAndReturnInsertionIndex(List<String> args,int argIndex,boolean tryRemovingArgValue){\n  if (argIndex < 0 || argIndex >= args.size()) {\n    return 0;\n  }\n  if (tryRemovingArgValue) {\n    String argValue=getArgValue(args,argIndex + 1);\n    if (argValue != null) {\n      args.remove(argIndex + 1);\n    }\n  }\n  args.remove(argIndex);\n  return argIndex;\n}", "comment": "removes the argument at the given index .", "label": "what"}
{"id": "14679", "raw_code": "void replacePolicyInResourceTree(ServiceTypeManager svtm,SSOToken token,Policy oldPolicy,Policy newPolicy) throws PolicyException, SSOException {\n  removePolicyFromResourceTree(svtm,token,oldPolicy);\n  addPolicyToResourceTree(svtm,token,newPolicy);\n}", "comment": "replaces a policy ' s relevant content in the resource tree .", "label": "what"}
{"id": "9400", "raw_code": "public AtomicDoubleArray(int length){\n  larray=new AtomicLongArray(length);\n  long ZERO=Double.doubleToRawLongBits(0.0);\n  for (int i=0; i < length; i++)   larray.set(i,ZERO);\n}", "comment": "creates a new atomicdoublearray of the given length , with all values initialized to zero", "label": "what"}
{"id": "52866", "raw_code": "private void recomputeSeperation(double[][] means,double[][] cdist,LongStatistic diststat){\n  final int k=means.length;\n  for (int i=1; i < k; i++) {\n    DoubleVector mi=DoubleVector.wrap(means[i]);\n    for (int j=0; j < i; j++) {\n      cdist[i][j]=cdist[j][i]=distanceFunction.distance(mi,DoubleVector.wrap(means[j]));\n    }\n  }\n  if (diststat != null) {\n    diststat.increment((k * (k - 1)) >> 1);\n  }\n}", "comment": "recompute the separation of cluster means .", "label": "what"}
{"id": "46983", "raw_code": "public void writeStartElement(String localName) throws XMLStreamException {\n  if (localName == null || localName.length() == 0) {\n    throw new XMLStreamException(\"Local Name cannot be null or empty\");\n  }\n  _state=STATE_ELEMENT;\n  if (_currentEle != null && _currentEle.getState() == ELEMENT_STARTTAG_OPEN) {\n    closeStartTag();\n  }\n  _currentEle=new Element(_currentEle,localName,false);\n  openStartTag();\n  _writer.write(localName);\n}", "comment": "writes a start tag to the output .", "label": "what"}
{"id": "26003", "raw_code": "private void traverseInternal(Object root,boolean yieldRoot,IdentityHashMap<Object,Object> seen){\n  if (root == null || seen.containsKey(root)) {\n    return;\n  }\n  if (yieldRoot) {\n    if (!visit(root)) {\n      return;\n    }\n  }\n  seen.put(root,root);\n  if (root instanceof JSONObject) {\n    JSONObject json=(JSONObject)root;\n    Iterator<String> keys=json.keys();\n    while (keys.hasNext()) {\n      String key=keys.next();\n      try {\n        traverseInternal(json.get(key),true,seen);\n      }\n catch (      JSONException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n else   if (root instanceof JSONArray) {\n    JSONArray array=(JSONArray)root;\n    for (int i=0; i < array.length(); ++i) {\n      try {\n        traverseInternal(array.get(i),true,seen);\n      }\n catch (      JSONException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n else   if (root instanceof Map) {\n    Map<?,?> map=(Map<?,?>)root;\n    for (    Object value : map.values()) {\n      traverseInternal(value,true,seen);\n    }\n  }\n else   if (root instanceof List) {\n    List<?> list=(List<?>)root;\n    for (    Object value : list) {\n      traverseInternal(value,true,seen);\n    }\n  }\n else   if (root instanceof ParseObject) {\n    if (traverseParseObjects) {\n      ParseObject object=(ParseObject)root;\n      for (      String key : object.keySet()) {\n        traverseInternal(object.get(key),true,seen);\n      }\n    }\n  }\n else   if (root instanceof ParseACL) {\n    ParseACL acl=(ParseACL)root;\n    ParseUser user=acl.getUnresolvedUser();\n    if (user != null && user.isCurrentUser()) {\n      traverseInternal(user,true,seen);\n    }\n  }\n}", "comment": "internal implementation of traverse .", "label": "what"}
{"id": "84474", "raw_code": "public StrBuilder replaceFirst(final String searchStr,final String replaceStr){\n  final int searchLen=(searchStr == null ? 0 : searchStr.length());\n  if (searchLen > 0) {\n    final int index=indexOf(searchStr,0);\n    if (index >= 0) {\n      final int replaceLen=(replaceStr == null ? 0 : replaceStr.length());\n      replaceImpl(index,index + searchLen,searchLen,replaceStr,replaceLen);\n    }\n  }\n  return this;\n}", "comment": "replaces the first instance of the search string with the replace string .", "label": "what"}
{"id": "76094", "raw_code": "protected void drawDescription(Canvas c){\n  if (!mDescription.equals(\"\")) {\n    if (mDescriptionPosition == null) {\n      c.drawText(mDescription,getWidth() - mViewPortHandler.offsetRight() - 10,getHeight() - mViewPortHandler.offsetBottom() - 10,mDescPaint);\n    }\n else {\n      c.drawText(mDescription,mDescriptionPosition.x,mDescriptionPosition.y,mDescPaint);\n    }\n  }\n}", "comment": "draws the description text in the bottom right corner of the chart", "label": "what"}
{"id": "64156", "raw_code": "long parseBytes(String freeSpace,String path) throws IOException {\n  try {\n    long bytes=Long.parseLong(freeSpace);\n    if (bytes < 0) {\n      throw new IOException(\"Command line '\" + DF + \"' did not find free space in response \"+ \"for path '\"+ path+ \"'- check path is valid\");\n    }\n    return bytes;\n  }\n catch (  NumberFormatException ex) {\n    throw new IOExceptionWithCause(\"Command line '\" + DF + \"' did not return numeric data as expected \"+ \"for path '\"+ path+ \"'- check path is valid\",ex);\n  }\n}", "comment": "parses the bytes from a string .", "label": "what"}
{"id": "28478", "raw_code": "private static void cleanDirectoryOnExit(File directory) throws IOException {\n  if (!directory.exists()) {\n    String message=directory + \" does not exist\";\n    throw new IllegalArgumentException(message);\n  }\n  if (!directory.isDirectory()) {\n    String message=directory + \" is not a directory\";\n    throw new IllegalArgumentException(message);\n  }\n  File[] files=directory.listFiles();\n  if (files == null) {\n    throw new IOException(\"Failed to list contents of \" + directory);\n  }\n  IOException exception=null;\n  for (  File file : files) {\n    try {\n      forceDeleteOnExit(file);\n    }\n catch (    IOException ioe) {\n      exception=ioe;\n    }\n  }\n  if (null != exception) {\n    throw exception;\n  }\n}", "comment": "cleans a directory without deleting it .", "label": "what"}
{"id": "5038", "raw_code": "public PlaPointFloat change_size(double p_new_size){\n  if (v_x == 0 && v_y == 0) {\n    return this;\n  }\n  double length=Math.sqrt(v_x * v_x + v_y * v_y);\n  double new_x=(v_x * p_new_size) / length;\n  double new_y=(v_y * p_new_size) / length;\n  return new PlaPointFloat(new_x,new_y);\n}", "comment": "approximates a floatpoint on the line from zero to this point with distance p _ new _ length from zero .", "label": "what"}
{"id": "3359", "raw_code": "int insert(Row row,byte[] sourceBuffer,int sourceOffset,BlobOutputStream[] blobs){\n  int rowHead=_rowHead;\n  int blobTail=_blobTail;\n  int rowLength=row.length();\n  rowHead-=rowLength;\n  if (rowHead < blobTail) {\n    return -1;\n  }\n  byte[] buffer=_buffer;\n  System.arraycopy(sourceBuffer,sourceOffset,buffer,rowHead,rowLength);\n  buffer[rowHead]=(byte)((buffer[rowHead] & ~CODE_MASK) | INSERT);\n  blobTail=row.insertBlobs(buffer,rowHead,blobTail,blobs);\n  if (blobTail < 0) {\n    return -1;\n  }\n  setBlobTail(blobTail);\n  rowHead(rowHead);\n  validateBlock(row);\n  return rowHead;\n}", "comment": "inserts a new row into the block .", "label": "what"}
{"id": "86825", "raw_code": "protected void transfer(String seqRange) throws IOException {\n  try {\n    final int rangePos=seqRange.indexOf('-');\n    if (rangePos == -1) {\n      transfer(Long.parseLong(seqRange));\n    }\n else {\n      final String start=seqRange.substring(0,rangePos);\n      final String end=seqRange.substring(rangePos + 1);\n      final long startIdx;\n      if (start.length() == 0) {\n        startIdx=0;\n      }\n else {\n        startIdx=Long.parseLong(start);\n      }\n      final long endIdx;\n      if (end.length() == 0) {\n        endIdx=mReader.numberSequences() - 1;\n      }\n else {\n        endIdx=Long.parseLong(end);\n      }\n      if (startIdx > endIdx) {\n        throw new NumberFormatException(\"Invalid range: \" + seqRange);\n      }\n      for (long i=startIdx; i <= endIdx; i++) {\n        transfer(i);\n      }\n    }\n  }\n catch (  final NumberFormatException e) {\n    warnInvalidSequence(seqRange);\n  }\n}", "comment": "transfer an interpreted sequence or set of sequences from the reader to the writer .", "label": "what"}
{"id": "71090", "raw_code": "public static double distancePointLinePerpendicular(Coordinate p,Coordinate A,Coordinate B){\n  double len2=(B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n  double s=((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n  return Math.abs(s) * Math.sqrt(len2);\n}", "comment": "computes the perpendicular distance from a point p to the ( infinite ) line containing the points ab", "label": "what"}
{"id": "82414", "raw_code": "public final void readFully(byte[] b) throws java.io.IOException {\n  readFully(b,0,b.length);\n}", "comment": "see the general contract of the readfully method of datainput .", "label": "what"}
{"id": "37182", "raw_code": "private void createGui(){\n  final JPanel outerNamePanel=new JPanel(new BorderLayout());\n  outerNamePanel.setBorder(new TitledBorder(\"Tag\"));\n  final JPanel namePanel=new JPanel(new BorderLayout());\n  namePanel.setBorder(new EmptyBorder(0,0,5,0));\n  final JLabel nameLabel=new CHelpLabel(\"Name\" + \":\",new CNameHelp());\n  nameLabel.setPreferredSize(new Dimension(110,25));\n  namePanel.add(nameLabel,BorderLayout.WEST);\n  namePanel.add(m_nameTextField,BorderLayout.CENTER);\n  outerNamePanel.add(namePanel,BorderLayout.CENTER);\n  final JPanel outerDescriptionPanel=new JPanel(new BorderLayout());\n  outerDescriptionPanel.setBorder(new EmptyBorder(5,0,0,0));\n  final JPanel descriptionPanel=new JPanel(new BorderLayout());\n  descriptionPanel.setBorder(new TitledBorder(\"Description\"));\n  descriptionPanel.setMinimumSize(new Dimension(0,120));\n  descriptionPanel.add(new JScrollPane(m_descriptionField));\n  outerDescriptionPanel.add(descriptionPanel,BorderLayout.CENTER);\n  final JPanel buttonPanel=new JPanel(new GridLayout(1,2));\n  buttonPanel.add(new JPanel());\n  buttonPanel.setBorder(new EmptyBorder(5,0,5,2));\n  buttonPanel.add(m_saveButton);\n  final JPanel topPanel=new JPanel(new BorderLayout());\n  topPanel.add(outerNamePanel,BorderLayout.NORTH);\n  topPanel.add(outerDescriptionPanel,BorderLayout.CENTER);\n  topPanel.add(buttonPanel,BorderLayout.SOUTH);\n  final JPanel bottomPanel=new JPanel(new BorderLayout());\n  bottomPanel.setBorder(m_tableBorder);\n  final JScrollPane scrollPane=new JScrollPane(m_childrenTagTable);\n  bottomPanel.add(scrollPane,BorderLayout.CENTER);\n  final JSplitPane splitPane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,topPanel,bottomPanel);\n  splitPane.setOneTouchExpandable(true);\n  splitPane.setDividerLocation(splitPane.getMinimumDividerLocation());\n  splitPane.setResizeWeight(0.5);\n  add(splitPane);\n}", "comment": "creates the gui of the component .", "label": "what"}
{"id": "15616", "raw_code": "private static boolean isEnabled(){\n  if (SystemUtils.IS_OS_WINDOWS) {\n    return false;\n  }\n  try {\n    List<String> lines=CommandUtil.executeCommandAndGetLines(Collections.singletonList(\"sestatus\"));\n    for (    String line : lines) {\n      if (line.contains(\"SELinux status\")) {\n        if (line.contains(\"enabled\")) {\n          Logger.info(\"SELinux is enabled on this system\");\n          return true;\n        }\n        return false;\n      }\n    }\n  }\n catch (  Exception ex) {\n  }\n  return false;\n}", "comment": "check whether selinux is enabled or not .", "label": "what"}
{"id": "74774", "raw_code": "public boolean validate(){\n  outputFile=new File(outputPath);\n  if (outputFile.exists() || outputFile.isDirectory()) {\n    invalidMessage=\"Output file already exists.\";\n    return valid=false;\n  }\n  if (!signMode) {\n    keyFile=new File(keyFilePath);\n    if (!keyFile.exists() || keyFile.isDirectory()) {\n      invalidMessage=\"Key file not found.\";\n      return valid=false;\n    }\n  }\n  return valid=true;\n}", "comment": "initialises and checks validity of files .", "label": "what"}
{"id": "81841", "raw_code": "public void addResponseCodeListener(ActionListener a){\n  responseCodeListeners.addElement(a);\n}", "comment": "adds a response listener on the requests", "label": "what"}
{"id": "84572", "raw_code": "public double calculateLogLikelihood(){\n  double logL=0.0;\n  for (  Statistic statistic : dataList) {\n    for (int j=0; j < statistic.getDimension(); j++) {\n      logL-=Math.log(statistic.getStatisticValue(j));\n    }\n  }\n  return logL;\n}", "comment": "calculate the log likelihood of the current state .", "label": "what"}
{"id": "80724", "raw_code": "public Decimal subtract(Decimal decimal){\n  assertDefined();\n  if (null == m_value) {\n    return (decimal);\n  }\n  BigDecimal value=m_value.subtract(decimal.getBigDecimalValue());\n  return new Decimal(value,SCALE);\n}", "comment": "subtracts two decimal objects", "label": "what"}
{"id": "27345", "raw_code": "protected int skipLine(int c) throws IOException {\n  while (c != -1 && c != '\\r' && c != '\\n') {\n    c=reader.read();\n  }\n  if (c == '\\n') {\n    c=reader.read();\n    lineNo++;\n    reportLocation(lineNo,1);\n  }\n else   if (c == '\\r') {\n    c=reader.read();\n    if (c == '\\n') {\n      c=reader.read();\n    }\n    lineNo++;\n    reportLocation(lineNo,1);\n  }\n  return c;\n}", "comment": "reads characters from reader until the first eol has been read .", "label": "what"}
{"id": "51086", "raw_code": "public boolean step(){\n  long current=System.currentTimeMillis();\n  if (mStart == 0 || (current - mStart < 0)) {\n    mProgress=0;\n  }\n else   if (current - mStart > mDuration) {\n    if (mLoop) {\n      mProgress=0;\n      start();\n      return true;\n    }\n    mProgress=1;\n    return false;\n  }\n else {\n    mProgress=(current - mStart) / (double)mDuration;\n  }\n  return true;\n}", "comment": "step in the animation .", "label": "what"}
{"id": "27290", "raw_code": "public ArbitraryLengthPathNode(final TermNode left,final TermNode right,final VarNode tVarLeft,final VarNode tVarRight,final long lowerBound,final long upperBound){\n  this(new BOp[]{new JoinGroupNode()},NV.asMap(new NV(Annotations.LEFT_TERM,left),new NV(Annotations.RIGHT_TERM,right),new NV(Annotations.TRANSITIVITY_VAR_LEFT,tVarLeft),new NV(Annotations.TRANSITIVITY_VAR_RIGHT,tVarRight),new NV(Annotations.DROP_VARS,new ArrayList<VarNode>()),new NV(Annotations.LOWER_BOUND,lowerBound),new NV(Annotations.UPPER_BOUND,upperBound)));\n  final Set<VarNode> dropVars=new LinkedHashSet<>();\n  dropVars.add(tVarLeft);\n  dropVars.add(tVarRight);\n  setProperty(Annotations.DROP_VARS,dropVars);\n}", "comment": "fully construct an arbitrary length path node with all required annotations .", "label": "what"}
{"id": "72629", "raw_code": "public void addChangingListener(OnWheelChangedListener listener){\n  changingListeners.add(listener);\n}", "comment": "adds wheel changing listener", "label": "what"}
{"id": "65433", "raw_code": "private Integer scanYamlDirectiveNumber(Mark startMark){\n  char ch=reader.peek();\n  if (!Character.isDigit(ch)) {\n    throw new ScannerException(\"while scanning a directive\",startMark,\"expected a digit, but found \" + ch + \"(\"+ ((int)ch)+ \")\",reader.getMark());\n  }\n  int length=0;\n  while (Character.isDigit(reader.peek(length))) {\n    length++;\n  }\n  Integer value=Integer.parseInt(reader.prefixForward(length));\n  return value;\n}", "comment": "read a % yaml directive number : this is either the major or the minor part .", "label": "what"}
{"id": "53935", "raw_code": "boolean checkToken(ByteWrapper token,Key nodeId,InetAddress ip,int port,Key lookupKey){\n  updateTokenTimestamps();\n  boolean valid=checkToken(token,nodeId,ip,port,lookupKey,timestampCurrent.get()) || checkToken(token,nodeId,ip,port,lookupKey,timestampPrevious);\n  if (!valid)   DHT.logDebug(\"Received Invalid token from \" + ip.getHostAddress());\n  return valid;\n}", "comment": "check if a received token is ok .", "label": "what"}
{"id": "36400", "raw_code": "public void expandAll(){\n  cancelEditing();\n  final TreeModel tm=getModel();\n  final Object root=tm.getRoot();\n  if (root != null) {\n    expandAllPaths(new TreePath(root),tm);\n  }\n}", "comment": "expands all paths in the tree .", "label": "what"}
{"id": "76089", "raw_code": "public static List<String> generateXVals(int from,int to){\n  List<String> xvals=new ArrayList<String>();\n  for (int i=from; i < to; i++) {\n    xvals.add(\"\" + i);\n  }\n  return xvals;\n}", "comment": "generates an x - values array filled with numbers in range specified by the parameters .", "label": "what"}
{"id": "85889", "raw_code": "public QueryStringDecoderUtil(URI uri){\n  this(uri,Charset.defaultCharset());\n}", "comment": "creates a new decoder that decodes the specified uri .", "label": "what"}
{"id": "82238", "raw_code": "public static void showErrorMessage(String msg){\n  showErrorMessage(msg,3500);\n}", "comment": "simplifies a common use case of showing an error message with an error icon that fades out after a few seconds", "label": "what"}
{"id": "18368", "raw_code": "public final static NameValuePair parseNameValuePair(final String value,HeaderValueParser parser) throws ParseException {\n  if (value == null) {\n    throw new IllegalArgumentException(\"Value to parse may not be null\");\n  }\n  if (parser == null)   parser=BasicHeaderValueParser.DEFAULT;\n  CharArrayBuffer buffer=new CharArrayBuffer(value.length());\n  buffer.append(value);\n  ParserCursor cursor=new ParserCursor(0,value.length());\n  return parser.parseNameValuePair(buffer,cursor);\n}", "comment": "parses a name - value - pair with the given parser .", "label": "what"}
{"id": "26410", "raw_code": "public static String stripCharsInBag(String s,String bag){\n  int i;\n  StringBuilder stringBuilder=new StringBuilder(\"\");\n  for (i=0; i < s.length(); i++) {\n    char c=s.charAt(i);\n    if (bag.indexOf(c) == -1)     stringBuilder.append(c);\n  }\n  return stringBuilder.toString();\n}", "comment": "removes all characters which appear in string bag from string s .", "label": "what"}
{"id": "81615", "raw_code": "@Override protected void onDestroy(){\n  super.onDestroy();\n  doReallyStop(false);\n  mFragments.dispatchDestroy();\n  if (mLoaderManager != null) {\n    mLoaderManager.doDestroy();\n  }\n}", "comment": "destroy all fragments and loaders .", "label": "what"}
{"id": "49287", "raw_code": "static WindowsFileAttributes fromFindData(long address){\n  int fileAttrs=unsafe.getInt(address + OFFSETOF_FIND_DATA_ATTRIBUTES);\n  long creationTime=unsafe.getLong(address + OFFSETOF_FIND_DATA_CREATETIME);\n  long lastAccessTime=unsafe.getLong(address + OFFSETOF_FIND_DATA_LASTACCESSTIME);\n  long lastWriteTime=unsafe.getLong(address + OFFSETOF_FIND_DATA_LASTWRITETIME);\n  long size=((long)(unsafe.getInt(address + OFFSETOF_FIND_DATA_SIZEHIGH)) << 32) + (unsafe.getInt(address + OFFSETOF_FIND_DATA_SIZELOW) & 0xFFFFFFFFL);\n  int reparseTag=isReparsePoint(fileAttrs) ? unsafe.getInt(address + OFFSETOF_FIND_DATA_RESERVED0) : 0;\n  return new WindowsFileAttributes(fileAttrs,creationTime,lastAccessTime,lastWriteTime,size,reparseTag,0,0,0);\n}", "comment": "create a windowsfileattributes from a win32 _ find _ data structure", "label": "what"}
{"id": "54656", "raw_code": "public static final void writeMapXml(Map val,XmlSerializer out,WriteMapCallback callback) throws XmlPullParserException, IOException {\n  if (val == null) {\n    return;\n  }\n  Set s=val.entrySet();\n  Iterator i=s.iterator();\n  while (i.hasNext()) {\n    Map.Entry e=(Map.Entry)i.next();\n    writeValueXml(e.getValue(),(String)e.getKey(),out,callback);\n  }\n}", "comment": "flatten a map into an xmlserializer .", "label": "what"}
{"id": "8601", "raw_code": "public void fireEventProgrammatically(Event event){\n  if (!event.isConsumed())   ripplerPane.fireEvent(event);\n}", "comment": "fire event to the rippler pane manually", "label": "what"}
{"id": "80804", "raw_code": "public static boolean isModule(IResource resource){\n  return (resource != null && TLA_EXTENSION.equals(resource.getFileExtension()));\n}", "comment": "determines if the given member is a tla + module", "label": "what"}
{"id": "78054", "raw_code": "public int writeAnnotation(Annotation annotation){\n  int off=data.position();\n  writeByte(annotation.visibility);\n  writeEncodedArray(annotation.encodedAnnotation);\n  return off;\n}", "comment": "write annotation item into current section .", "label": "what"}
{"id": "15824", "raw_code": "public boolean revisionContainsTemplateName(int revId,String templateName) throws WikiApiException {\n  return revisionContainsTemplateNames(revId,Arrays.asList(new String[]{templateName}));\n}", "comment": "determines whether a given revision contains a given template name", "label": "what"}
{"id": "67789", "raw_code": "public List<GenericEntry> retrieveAllAccountInfoRequests(Date fromDate) throws AppsForYourDomainException, IOException, ServiceException {\n  String url=BASE_URL + \"account/\" + domain;\n  if (fromDate != null) {\n    url+=\"?fromDate=\" + DATE_FORMAT.format(fromDate);\n  }\n  return getAllPages(new URL(url),GenericFeed.class);\n}", "comment": "retrieve all the account info requests from the given start date .", "label": "what"}
{"id": "63018", "raw_code": "public StringList plus(String... args){\n  StringList newList=new StringList();\n  newList.addAll(this);\n  newList.addAll(Arrays.asList(args));\n  return newList;\n}", "comment": "add a list of strings .", "label": "what"}
{"id": "77662", "raw_code": "@Override public final char readChar() throws IOException {\n  dis.readFully(work,0,2);\n  return (char)((work[1] & 0xff) << 8 | (work[0] & 0xff));\n}", "comment": "read on char .", "label": "what"}
{"id": "84522", "raw_code": "public static int truncatedCompareTo(final Date date1,final Date date2,final int field){\n  final Date truncatedDate1=truncate(date1,field);\n  final Date truncatedDate2=truncate(date2,field);\n  return truncatedDate1.compareTo(truncatedDate2);\n}", "comment": "determines how two dates compare up to no more than the specified most significant field .", "label": "what"}
{"id": "43307", "raw_code": "protected List<DecompoundedWord> makeSplit(String aWord){\n  List<DecompoundedWord> result=new ArrayList<DecompoundedWord>();\n  for (int i=0; i < aWord.length(); i++) {\n    String leftWord=aWord.substring(0,i + 1);\n    String rightWord=aWord.substring(i + 1);\n    boolean leftGood=dict.contains(leftWord) && leftWord.length() >= minWordLength;\n    boolean rightGood=rightWord.length() > minRestLength || rightWord.length() == 0;\n    if (leftGood && rightGood) {\n      DecompoundedWord split=DecompoundedWord.createFromString(leftWord + \"+\" + rightWord);\n      split.setSplitPos(i);\n      result.add(split);\n    }\n    for (    String morpheme : morphemes.getAll()) {\n      try {\n        String leftWithoutMorpheme=leftWord.substring(0,leftWord.length() - morpheme.length());\n        if (leftWord.endsWith(morpheme) && dict.contains(leftWithoutMorpheme) && rightGood) {\n          DecompoundedWord split=DecompoundedWord.createFromString(leftWithoutMorpheme + \"(\" + morpheme+ \")+\"+ rightWord);\n          split.setSplitPos(i);\n          result.add(split);\n        }\n      }\n catch (      StringIndexOutOfBoundsException e) {\n        continue;\n      }\n    }\n  }\n  return result;\n}", "comment": "splits a word in two word .", "label": "what"}
{"id": "28275", "raw_code": "public static boolean isBookSearchUrl(String url){\n  return url.startsWith(\"http://google.com/books\") || url.startsWith(\"http://books.google.\");\n}", "comment": "does a given url point to google book search , regardless of domain .", "label": "what"}
{"id": "16875", "raw_code": "public void removeTitlePrefix(String prfx){\n  titlePrefix.remove(prfx);\n  firePropertyChange(TITLE_PREFIX,null,titlePrefix);\n}", "comment": "removes the title prefix .", "label": "what"}
{"id": "31874", "raw_code": "@Override public void close(){\n  closing=true;\n  if (reservations == null || reservations.compareAndSet(0,-1))   doClose();\n}", "comment": "closes tree map and reclaims memory .", "label": "what"}
{"id": "56123", "raw_code": "private void removeOMADownloadFromSharedPrefs(long downloadId){\n  Set<String> omaDownloads=getStoredDownloadInfo(PENDING_OMA_DOWNLOADS);\n  for (  String omaDownload : omaDownloads) {\n    OMAEntry entry=OMAEntry.parseOMAEntry(omaDownload);\n    if (entry.mDownloadId == downloadId) {\n      omaDownloads.remove(omaDownload);\n      storeDownloadInfo(PENDING_OMA_DOWNLOADS,omaDownloads);\n      return;\n    }\n  }\n}", "comment": "remove oma download info from sharedprefs .", "label": "what"}
{"id": "51009", "raw_code": "public static boolean isAndroidSdkDirInLocalPropertiesFile(@NotNull File projectDir){\n  String androidHome=getAndroidHomeFromLocalPropertiesFile(projectDir);\n  if (!Strings.isNullOrEmpty(androidHome)) {\n    String msg=String.format(\"Found Android SDK home at '%1$s' (from local.properties file)\",androidHome);\n    LOG.info(msg);\n    return true;\n  }\n  return false;\n}", "comment": "indicates whether the path of the android sdk home directory is specified in a local . properties file .", "label": "what"}
{"id": "39483", "raw_code": "public static Object invokeStatic(String clazz,String methodName,Class[] types,Object[] values) throws NoSuchMethodException {\n  try {\n    return invokeStatic(Class.forName(clazz),methodName,types,values);\n  }\n catch (  ClassNotFoundException e) {\n    throw new NoSuchMethodException(\"class \" + clazz + \" not found\");\n  }\n}", "comment": "invokes the specified parameterless method if it exists .", "label": "what"}
{"id": "31549", "raw_code": "public Prototype undump(InputStream stream,String chunkname) throws IOException {\n  if (stream.read() != LUA_SIGNATURE[0] || stream.read() != LUA_SIGNATURE[1] || stream.read() != LUA_SIGNATURE[2] || stream.read() != LUA_SIGNATURE[3])   return null;\n  String sname=getSourceName(chunkname);\n  LoadState s=new LoadState(stream,sname);\n  s.loadHeader();\nswitch (s.luacNumberFormat) {\ncase NUMBER_FORMAT_FLOATS_OR_DOUBLES:\ncase NUMBER_FORMAT_INTS_ONLY:\ncase NUMBER_FORMAT_NUM_PATCH_INT32:\n    break;\ndefault :\n  throw new LuaError(\"unsupported int size\");\n}\nreturn s.loadFunction(LuaString.valueOf(sname));\n}", "comment": "load input stream as a lua binary chunk if the first 4 bytes are the lua binary signature .", "label": "what"}
{"id": "85905", "raw_code": "private void mapRequestToResponses(Matcher<Request> requestMatcher,ResponseSource responses){\n  mappings.add(new MatcherResponseSourcePair(requestMatcher,responses));\n}", "comment": "set up a reaction to requests matching certain criteria .", "label": "what"}
{"id": "24939", "raw_code": "@Override protected void commitToInput(){\n  JmxBeanSensorAssignment assignment=getInput();\n  if (null != assignment) {\n    assignment.setDomain(domainText.getText());\n    assignment.setObjectNameParameters(new HashMap<>(parametersMap));\n    if (allAttributesButton.getSelection()) {\n      assignment.setAttributes(Collections.<String>emptySet());\n    }\n else {\n      assignment.setAttributes(new HashSet<>(attributesSet));\n    }\n  }\n}", "comment": "commits changes in page to input .", "label": "what"}
{"id": "82535", "raw_code": "public java.lang.Object newInstance() throws java.lang.InstantiationException, java.lang.IllegalAccessException {\n  Object o=newInstanceImpl();\n  if (o == null) {\n    throw new InstantiationException();\n  }\n  return o;\n}", "comment": "creates a new instance of a class .", "label": "what"}
{"id": "55212", "raw_code": "public boolean isFull(){\n  if (maxSize > 0 && notifications.size() >= maxSize) {\n    return true;\n  }\n  return false;\n}", "comment": "check whether this matcher has reached \" max - size \" or not .", "label": "what"}
{"id": "64939", "raw_code": "private void schedulePlaylistSave(){\n  if (!mPlaylistLoading) {\n    if (mPlaylistSavePending.compareAndSet(false,true)) {\n      mThreadPoolManager.scheduleOnce(new PlaylistSaveTask(),2,TimeUnit.SECONDS);\n    }\n  }\n}", "comment": "schedules a playlist save task .", "label": "what"}
{"id": "74092", "raw_code": "public boolean isToRead(){\n  Iterator<VariableValue> i=variables.iterator();\n  while (i.hasNext()) {\n    VariableValue v=i.next();\n    if (v.isToRead()) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "this variable needs to be read if any of it ' s subsidiary variables needs to be read .", "label": "what"}
{"id": "13476", "raw_code": "public static void v(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_VERBOSE) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.v(tag,msg);\n}", "comment": "send a verbose log message .", "label": "what"}
{"id": "81307", "raw_code": "public void saveIndexes(){\n  ArrayList toSave=new ArrayList();\nsynchronized (this) {\n    Object[] valueTable=this.indexes.valueTable;\n    for (int i=0, l=valueTable.length; i < l; i++) {\n      Index index=(Index)valueTable[i];\n      if (index != null)       toSave.add(index);\n    }\n  }\n  boolean allSaved=true;\n  for (int i=0, length=toSave.size(); i < length; i++) {\n    Index index=(Index)toSave.get(i);\n    ReadWriteMonitor monitor=index.monitor;\n    if (monitor == null)     continue;\n    try {\n      monitor.enterRead();\n      if (index.hasChanged()) {\n        if (monitor.exitReadEnterWrite()) {\n          try {\n            saveIndex(index);\n          }\n catch (          IOException e) {\n            if (VERBOSE) {\n              Util.verbose(\"-> got the following exception while saving:\",System.err);\n              e.printStackTrace();\n            }\n            allSaved=false;\n          }\n finally {\n            monitor.exitWriteEnterRead();\n          }\n        }\n else {\n          allSaved=false;\n        }\n      }\n    }\n  finally {\n      monitor.exitRead();\n    }\n  }\n  if (this.participantsContainers != null && this.participantUpdated) {\n    writeParticipantsIndexNamesFile();\n    this.participantUpdated=false;\n  }\n  this.needToSave=!allSaved;\n}", "comment": "commit all index memory changes to disk", "label": "what"}
{"id": "13482", "raw_code": "private void movePos(float deltaY){\n  if ((deltaY < 0 && mPtrIndicator.isInStartPosition())) {\n    if (DEBUG) {\n      PtrCLog.e(LOG_TAG,String.format(\"has reached the top\"));\n    }\n    return;\n  }\n  int to=mPtrIndicator.getCurrentPosY() + (int)deltaY;\n  if (mPtrIndicator.willOverTop(to)) {\n    if (DEBUG) {\n      PtrCLog.e(LOG_TAG,String.format(\"over top\"));\n    }\n    to=PtrIndicator.POS_START;\n  }\n  mPtrIndicator.setCurrentPos(to);\n  int change=to - mPtrIndicator.getLastPosY();\n  updatePos(change);\n}", "comment": "if deltay > 0 , move the content down", "label": "what"}
{"id": "47244", "raw_code": "public void putAll(Map<? extends K,? extends V> m){\n  tryPresize(m.size());\n  for (  Map.Entry<? extends K,? extends V> e : m.entrySet())   putVal(e.getKey(),e.getValue(),false);\n}", "comment": "copies all of the mappings from the specified map to this one .", "label": "what"}
{"id": "46460", "raw_code": "public UndoableEdit insertString(int where,String str) throws BadLocationException {\n  if (where >= count || where < 0) {\n    throw new BadLocationException(\"Invalid location\",count);\n  }\n  char[] chars=str.toCharArray();\n  replace(where,0,chars,0,chars.length);\n  if (marks != null) {\n    updateMarksForInsert(where,str.length());\n  }\n  return new InsertUndo(where,str.length());\n}", "comment": "inserts a string into the content .", "label": "what"}
{"id": "41574", "raw_code": "boolean writeData() throws IOException {\n  int tosend;\n  int sent;\n  byte[] block=new byte[kBlockSize];\n  do {\n    tosend=Math.min(sendStreamSize - totalSent,block.length);\n    System.arraycopy(sendData,totalSent,block,0,tosend);\n    if (tosend > 0) {\n      sent=localSend(block,tosend);\n      updateLocalClock();\n      if (sent != -1) {\n        totalSent+=sent;\n      }\n else {\n        logger.log(Level.FINE,\"Flow Controlled\");\n      }\n    }\n else {\n      sent=tosend=0;\n    }\n  }\n while (sent > 0);\n  if (logger.isLoggable(Level.FINER)) {\n    logger.log(Level.FINER,\"Sent: \" + totalSent + \" remaining: \"+ (sendStreamSize - totalSent));\n  }\n  return tosend == 0;\n}", "comment": "writes the data until there ' s space available", "label": "what"}
{"id": "44803", "raw_code": "public int checkBookiesUp(int count,int timeout) throws Exception {\n  ZooKeeper zkc=connectZooKeeper(zkHost,zkPort,zkTimeoutSec);\n  try {\n    int mostRecentSize=0;\n    for (int i=0; i < timeout; i++) {\n      try {\n        List<String> children=zkc.getChildren(\"/ledgers/available\",false);\n        children.remove(\"readonly\");\n        mostRecentSize=children.size();\n        if ((mostRecentSize > count) || LOG.isDebugEnabled()) {\n          LOG.info(\"Found \" + mostRecentSize + \" bookies up, \"+ \"waiting for \"+ count);\n          if ((mostRecentSize > count) || LOG.isTraceEnabled()) {\n            for (            String child : children) {\n              LOG.info(\" server: \" + child);\n            }\n          }\n        }\n        if (mostRecentSize == count) {\n          break;\n        }\n      }\n catch (      KeeperException e) {\n      }\n      Thread.sleep(1000);\n    }\n    return mostRecentSize;\n  }\n  finally {\n    zkc.close();\n  }\n}", "comment": "check that a number of bookies are available", "label": "what"}
{"id": "17508", "raw_code": "public int write(byte[] destMac,byte[] packet,int offset,int byteCount){\n  if (destMac == null) {\n    throw new NullPointerException(\"destMac == null\");\n  }\n  if (packet == null) {\n    throw new NullPointerException(\"packet == null\");\n  }\n  Arrays.checkOffsetAndCount(packet.length,offset,byteCount);\n  if (destMac.length != 6) {\n    throw new IllegalArgumentException(\"MAC length must be 6: \" + destMac.length);\n  }\n  return sendPacket(fd,mInterfaceName,mProtocolType,destMac,packet,offset,byteCount);\n}", "comment": "writes a raw packet to the desired interface .", "label": "what"}
{"id": "57997", "raw_code": "private Boolean processYESNO(StylesheetHandler handler,String uri,String name,String rawName,String value) throws org.xml.sax.SAXException {\n  if (!(value.equals(\"yes\") || value.equals(\"no\"))) {\n    handleError(handler,XSLTErrorResources.INVALID_BOOLEAN,new Object[]{name,value},null);\n    return null;\n  }\n  return new Boolean(value.equals(\"yes\") ? true : false);\n}", "comment": "process an attribute string of type t _ yesno into a boolean value .", "label": "what"}
{"id": "65753", "raw_code": "protected ArrayList<KeyNamePair> loadRMAData(int C_BPartner_ID){\n  ArrayList<KeyNamePair> list=new ArrayList<KeyNamePair>();\n  String sqlStmt=\"SELECT r.M_RMA_ID, r.DocumentNo || '-' || r.Amt from M_RMA r \" + \"WHERE ISSOTRX='N' AND r.DocStatus in ('CO', 'CL') \" + \"AND r.C_BPartner_ID=? \"+ \"AND NOT EXISTS (SELECT * FROM C_Invoice inv \"+ \"WHERE inv.M_RMA_ID=r.M_RMA_ID AND inv.DocStatus IN ('CO', 'CL'))\";\n  PreparedStatement pstmt=null;\n  try {\n    pstmt=DB.prepareStatement(sqlStmt,null);\n    pstmt.setInt(1,C_BPartner_ID);\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      list.add(new KeyNamePair(rs.getInt(1),rs.getString(2)));\n    }\n    rs.close();\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sqlStmt.toString(),e);\n  }\n finally {\n    if (pstmt != null) {\n      try {\n        pstmt.close();\n      }\n catch (      Exception ex) {\n        log.severe(\"Could not close prepared statement\");\n      }\n    }\n  }\n  return list;\n}", "comment": "load pbartner dependent order / invoice / shipment field .", "label": "what"}
{"id": "48161", "raw_code": "public void encodeAndSign(X500Name subject,Signature signature) throws CertificateException, IOException, SignatureException {\n  DerOutputStream out, scratch;\n  byte[] certificateRequestInfo;\n  byte[] sig;\n  if (encoded != null)   throw new SignatureException(\"request is already signed\");\n  this.subject=subject;\n  scratch=new DerOutputStream();\n  scratch.putInteger(BigInteger.ZERO);\n  subject.encode(scratch);\n  scratch.write(subjectPublicKeyInfo.getEncoded());\n  attributeSet.encode(scratch);\n  out=new DerOutputStream();\n  out.write(DerValue.tag_Sequence,scratch);\n  certificateRequestInfo=out.toByteArray();\n  scratch=out;\n  signature.update(certificateRequestInfo,0,certificateRequestInfo.length);\n  sig=signature.sign();\n  AlgorithmId algId=null;\n  try {\n    algId=AlgorithmId.get(signature.getAlgorithm());\n  }\n catch (  NoSuchAlgorithmException nsae) {\n    throw new SignatureException(nsae);\n  }\n  algId.encode(scratch);\n  scratch.putBitString(sig);\n  out=new DerOutputStream();\n  out.write(DerValue.tag_Sequence,scratch);\n  encoded=out.toByteArray();\n}", "comment": "create the signed certificate request .", "label": "what"}
{"id": "35913", "raw_code": "public synchronized void schedulePeriodicTask(TimerTask task,long period){\n  try {\n    m_timer.scheduleAtFixedRate(task,0,period);\n  }\n catch (  IllegalStateException ie) {\n    m_timer=new Timer();\n    m_timer.scheduleAtFixedRate(task,0,period);\n  }\n}", "comment": "schedule a task that starts immediately", "label": "what"}
{"id": "72451", "raw_code": "protected void checkRowIndex(final int row) throws MathIllegalArgumentException {\n  if (row < 0 || row >= getRowDimension()) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.ROW_INDEX,row,0,getRowDimension() - 1);\n  }\n}", "comment": "check if a row index is valid .", "label": "what"}
{"id": "69990", "raw_code": "private LocalDateTime parseDate(String dateStr,boolean tryAgain){\n  LocalDateTime date=LocalDateTime.now(ZoneId.of(\"GMT\"));\n  if (mDateTimeFormatter == null) {\n    initFormatter(dateStr);\n  }\n  if (mDateTimeFormatter != null) {\n    try {\n      date=LocalDateTime.parse(dateStr,mDateTimeFormatter);\n    }\n catch (    DateTimeParseException e) {\n      Timber.d(String.format(\"ParseException parsing date: %s\",dateStr));\n      if (tryAgain) {\n        Timber.d(\"ParseException encountered, re-initializing the date parser\");\n        mDateTimeFormatter=null;\n        parseDate(dateStr,false);\n      }\n    }\n  }\n  return date;\n}", "comment": "parses a string date into a java date object", "label": "what"}
{"id": "54153", "raw_code": "public void remove(RequestFilter filter){\n  filters.remove(filter);\n}", "comment": "unregister filter ( it won ' t get anymore events )", "label": "what"}
{"id": "75658", "raw_code": "protected void removeClassifiers(int[] indices){\n  int i;\n  if (indices == null) {\n    m_ModelClassifiers.removeAllElements();\n  }\n else {\n    for (i=indices.length - 1; i >= 0; i--)     m_ModelClassifiers.remove(indices[i]);\n  }\n  setModified(true);\n}", "comment": "removes the specified classifiers .", "label": "what"}
{"id": "38864", "raw_code": "@Override public void addPropertyChangeListener(PropertyChangeListener pcl){\n  m_pcSupport.addPropertyChangeListener(pcl);\n}", "comment": "add a property change listener", "label": "what"}
{"id": "66115", "raw_code": "public void addElement(Object anObject){\n  p_data.add(anObject);\n  fireIntervalAdded(this,p_data.size() - 1,p_data.size() - 1);\n  if (p_data.size() == 1 && m_selectedObject == null && anObject != null)   setSelectedItem(anObject);\n}", "comment": "add element at the end", "label": "what"}
{"id": "20169", "raw_code": "@Override public boolean isCellEditable(int row,int column){\n  EnvVar envVar=dataList.get(row);\n  if (column == COL_VALUE) {\n    return true;\n  }\n  return !envVar.isPredefined();\n}", "comment": "checks if is cell editable .", "label": "what"}
{"id": "45007", "raw_code": "private static char[] zzUnpackCMap(String packed){\n  char[] map=new char[0x10000];\n  int i=0;\n  int j=0;\n  while (i < 150) {\n    int count=packed.charAt(i++);\n    char value=packed.charAt(i++);\n    do     map[j++]=value;\n while (--count > 0);\n  }\n  return map;\n}", "comment": "unpacks the compressed character translation table .", "label": "what"}
{"id": "52173", "raw_code": "public DagIterator(Graph pattern){\n  for (  Edge edge : pattern.getEdges()) {\n    if (Edges.isDirectedEdge(edge) || Edges.isUndirectedEdge(edge)) {\n      continue;\n    }\n    throw new IllegalArgumentException(\"The graph may consist only of \" + \"directed and undirected edges: \" + edge);\n  }\n  decoratedGraphs.add(new DecoratedGraph(pattern));\n}", "comment": "the given pattern must be a pattern .", "label": "what"}
{"id": "64361", "raw_code": "private boolean validateCustomCatalog(String title,String value){\n  return false;\n}", "comment": "check a field that defines a custom catalog", "label": "what"}
{"id": "24037", "raw_code": "public FunctionExecutionPooledExecutor(BlockingQueue<Runnable> q,int poolSize,PoolStatHelper stats,ThreadFactory tf){\n  this(q,poolSize,stats,tf,Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + \"IDLE_THREAD_TIMEOUT\",30000 * 60),false);\n}", "comment": "sets timeout to idle _ thread _ timeout", "label": "what"}
{"id": "31479", "raw_code": "protected boolean isSSDPDiscovery(String body){\n  if (body != null && body.startsWith(\"M-SEARCH * HTTP/1.1\") && body.contains(\"MAN: \\\"ssdp:discover\\\"\")) {\n    return true;\n  }\n  return false;\n}", "comment": "very naive ssdp discovery packet detection", "label": "what"}
{"id": "51642", "raw_code": "@Override public void addChild(WXComponent child,int index){\n  if (child == null || index < -1) {\n    return;\n  }\n  if (child instanceof WXBaseRefresh) {\n    if (!checkRefreshOrLoading(child)) {\n      mRefreshs.add(child);\n    }\n    return;\n  }\n  if (mChildren == null) {\n    mChildren=new ArrayList<>();\n  }\n  int count=mChildren.size();\n  index=index >= count ? -1 : index;\n  if (index == -1) {\n    mChildren.add(child);\n  }\n else {\n    mChildren.add(index,child);\n  }\n}", "comment": "intercept refresh view and loading view", "label": "what"}
{"id": "46343", "raw_code": "private void restoreSortingSelection(int[] selection,int lead,ModelChange change){\n  for (int i=selection.length - 1; i >= 0; i--) {\n    selection[i]=convertRowIndexToView(selection[i],change);\n  }\n  lead=convertRowIndexToView(lead,change);\n  if (selection.length == 0 || (selection.length == 1 && selection[0] == getSelectedRow())) {\n    return;\n  }\n  selectionModel.setValueIsAdjusting(true);\n  selectionModel.clearSelection();\n  for (int i=selection.length - 1; i >= 0; i--) {\n    if (selection[i] != -1) {\n      selectionModel.addSelectionInterval(selection[i],selection[i]);\n    }\n  }\n  SwingUtilities2.setLeadAnchorWithoutSelection(selectionModel,lead,lead);\n  selectionModel.setValueIsAdjusting(false);\n}", "comment": "restores the selection after a model event / sort order changes .", "label": "what"}
{"id": "6313", "raw_code": "public synchronized byte[] toByteArray(){\n  int remaining=count;\n  if (remaining == 0) {\n    return EMPTY_BYTE_ARRAY;\n  }\n  byte newbuf[]=new byte[remaining];\n  int pos=0;\n  for (  byte[] buf : buffers) {\n    int c=Math.min(buf.length,remaining);\n    System.arraycopy(buf,0,newbuf,pos,c);\n    pos+=c;\n    remaining-=c;\n    if (remaining == 0) {\n      break;\n    }\n  }\n  return newbuf;\n}", "comment": "gets the curent contents of this byte stream as a byte array .", "label": "what"}
{"id": "71286", "raw_code": "@After public void clean(){\n  mute(null);\n  mute(null);\n  mute(null);\n}", "comment": "cleanups after each tests .", "label": "what"}
{"id": "78082", "raw_code": "private void updateUiFromCommand(Command command){\n  if (command == null) {\n    return;\n  }\n  actionsComboBox.setText(command.getAction());\n  dataTextField.setText(command.getData());\n  categoryTextField.setText(command.getCategory());\n  mimeTextField.setText(command.getMimeType());\n  componentTextField.setText(command.getComponent());\n  userTextField.setText(command.getUser());\n  flagsList_.removeSelectionInterval(0,flagsList_.getItemsCount());\n  List<IntentFlags> flags=command.getFlags();\n  if (flags != null && flags.size() > 0) {\n    for (    IntentFlags flag : command.getFlags()) {\n      flagsList_.setSelectedValue(flag,false);\n    }\n  }\n else {\n    flagsList_.setSelectedIndex(0);\n  }\n  updateFlagsTextField();\n  tableModel_.removeAllRows();\n  List<ExtraField> extras=command.getExtras();\n  if (extras != null && extras.size() > 0) {\n    for (    ExtraField extra : extras) {\n      tableModel_.addRow(extra);\n    }\n  }\n  updateTableVisibility();\n}", "comment": "fills up vies from given command", "label": "what"}
{"id": "80078", "raw_code": "public static int randGaussian(final int mean,final int sd){\n  return (int)(rand.nextGaussian() * sd + mean);\n}", "comment": "generates a normally distributed random number and rounds it .", "label": "what"}
{"id": "56032", "raw_code": "private float computeOverscrollPercent(){\n  if (mOverScrollOffset >= 0) {\n    return mOverScrollOffset / mMaxOverScroll;\n  }\n else {\n    return mOverScrollOffset / mMaxUnderScroll;\n  }\n}", "comment": "determine the current amount of overscroll .", "label": "what"}
{"id": "4843", "raw_code": "public IVector(int c){\n  vector=new int[Math.max(defaultCapacity,c)];\n}", "comment": "constructs a new vector with the specified capacity .", "label": "what"}
{"id": "87104", "raw_code": "public void processInvite(RequestEvent requestEvent,ServerTransaction serverTransaction){\n  final Request request=requestEvent.getRequest();\n  final SipProvider sipProvider=(SipProvider)requestEvent.getSource();\n  ServerTransaction st=serverTransaction;\n  try {\n    if (st == null) {\n      try {\n        st=sipProvider.getNewServerTransaction(request);\n      }\n catch (      TransactionUnavailableException tae) {\n        tae.printStackTrace();\n        return;\n      }\ncatch (      TransactionAlreadyExistsException taex) {\n        return;\n      }\n    }\n    final String toTag=\"\" + System.nanoTime();\n    Response response=messageFactory.createResponse(Response.RINGING,request);\n    ToHeader toHeader=(ToHeader)response.getHeader(ToHeader.NAME);\n    toHeader.setTag(toTag);\n    st.sendResponse(response);\n    response=messageFactory.createResponse(Response.OK,request);\n    final Address address=addressFactory.createAddress(\"Shootme <sip:\" + myAddress + \":\"+ myPort+ \">\");\n    final ContactHeader contactHeader=headerFactory.createContactHeader(address);\n    response.addHeader(contactHeader);\n    toHeader=(ToHeader)response.getHeader(ToHeader.NAME);\n    toHeader.setTag(toTag);\n    st.sendResponse(response);\n  }\n catch (  Exception ex) {\n    ex.printStackTrace();\n  }\n}", "comment": "process the invite request .", "label": "what"}
{"id": "31952", "raw_code": "public static IgniteLogger logger(GridKernalContext ctx,AtomicReference<IgniteLogger> logRef,Object obj){\n  IgniteLogger log=logRef.get();\n  if (log == null) {\n    logRef.compareAndSet(null,ctx.log(obj.getClass()));\n    log=logRef.get();\n  }\n  return log;\n}", "comment": "initializes logger into / from log reference passed in .", "label": "what"}
{"id": "85099", "raw_code": "private void writeIndent(int times) throws IOException {\n  for (int i=options.getBaseIndent() + times; i > 0; i--) {\n    writer.write(options.getIndent());\n  }\n}", "comment": "writes indents and automatically includes the baseindend from the options .", "label": "what"}
{"id": "33047", "raw_code": "public boolean isInvalidNode(){\n  ASTNode first=fNodes.get(0);\n  ASTNode candidate=first.getParent();\n  if (candidate == null)   return false;\n  if (candidate.getNodeType() == ASTNode.METHOD_DECLARATION)   return true;\n  return false;\n}", "comment": "tests whether the node to be replaced is invalid .", "label": "what"}
{"id": "35965", "raw_code": "public void push(final float value){\n  int bits=Float.floatToIntBits(value);\n  if (bits == 0L || bits == 0x3f800000 || bits == 0x40000000) {\n    mv.visitInsn(Opcodes.FCONST_0 + (int)value);\n  }\n else {\n    mv.visitLdcInsn(value);\n  }\n}", "comment": "generates the instruction to push the given value on the stack .", "label": "what"}
{"id": "38721", "raw_code": "public synchronized void removeBatchClustererListener(BatchClustererListener cl){\n  m_batchClustererListeners.remove(cl);\n}", "comment": "remove a batch clusterer listener", "label": "what"}
{"id": "26011", "raw_code": "void removeKnownObject(ParseObject object){\nsynchronized (mutex) {\n    knownObjects.remove(object);\n  }\n}", "comment": "removes an object that is known to not be in the relation .", "label": "what"}
{"id": "72702", "raw_code": "static HeapBytesStore<byte[]> wrap(@NotNull byte[] bytes){\n  return HeapBytesStore.wrap(bytes);\n}", "comment": "wraps a byte [ ] .", "label": "what"}
{"id": "76478", "raw_code": "private static String parse(JsonValue base){\n  if (!base.isString()) {\n    return null;\n  }\n  return buildString(base.asString());\n}", "comment": "start the string parsing .", "label": "what"}
{"id": "28022", "raw_code": "public void beforeInsert(int index,char element){\n  if (index > size || index < 0)   throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \"+ size);\n  ensureCapacity(size + 1);\n  System.arraycopy(elements,index,elements,index + 1,size - index);\n  elements[index]=element;\n  size++;\n}", "comment": "inserts the specified element before the specified position into the receiver .", "label": "what"}
{"id": "20361", "raw_code": "public static boolean isInputStreamGZIPCompressed(final PushbackInputStream inputStream) throws IOException {\n  if (inputStream == null)   return false;\n  byte[] signature=new byte[2];\n  int readStatus=inputStream.read(signature);\n  inputStream.unread(signature);\n  int streamHeader=((int)signature[0] & 0xff) | ((signature[1] << 8) & 0xff00);\n  return readStatus == 2 && GZIPInputStream.GZIP_MAGIC == streamHeader;\n}", "comment": "checks the inputstream if it contains gzip compressed data", "label": "what"}
{"id": "14789", "raw_code": "private void clear(){\n  valid=false;\n  if ((listenerObjects == null) || listenerObjects.isEmpty()) {\n    deregisterListener();\n  }\n  ssm=null;\n  if (SMSEntry.cacheSMSEntries) {\n    orgConfigs.clear();\n    globalConfigs.clear();\n  }\n}", "comment": "clears instance cache and deregisters listeners", "label": "what"}
{"id": "42524", "raw_code": "public static void registerDecayableObject(Decayable obj){\n  decayObjects.add(obj);\n}", "comment": "registers an object that should be decayed .", "label": "what"}
{"id": "39318", "raw_code": "public boolean remove(String classname){\n  String pkgname;\n  HashSet<String> names;\n  classname=cleanUp(classname);\n  pkgname=extractPackage(classname);\n  names=m_Cache.get(pkgname);\n  if (names != null) {\n    return names.remove(classname);\n  }\n else {\n    return false;\n  }\n}", "comment": "removes the classname from the cache .", "label": "what"}
{"id": "64917", "raw_code": "@Override public void paintComponent(Graphics g){\n  super.paintComponent(g);\n  Graphics2D graphics=(Graphics2D)g;\n  graphics.setBackground(mColorSpectrumBackground);\n  RenderingHints renderHints=new RenderingHints(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);\n  renderHints.put(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);\n  graphics.setRenderingHints(renderHints);\n  drawFrequencies(graphics);\n  drawCursor(graphics);\n}", "comment": "renders the channel configs , lines , labels , and cursor", "label": "what"}
{"id": "3844", "raw_code": "public void classLoaderDestroy(DynamicClassLoader loader){\n  Method destroy=getDestroyMethod(_resource.getClass());\n  if (destroy == null)   return;\n  try {\n    destroy.invoke(_resource);\n  }\n catch (  Throwable e) {\n    log.log(Level.WARNING,e.toString(),e);\n  }\n}", "comment": "handles the case where a class loader is dropped .", "label": "what"}
{"id": "56950", "raw_code": "public boolean deleteAttachmentPoint(DatapathId sw,OFPort port){\n  AttachmentPoint ap=new AttachmentPoint(sw,port,new Date(0));\n  if (this.oldAPs != null) {\n    ArrayList<AttachmentPoint> apList=new ArrayList<AttachmentPoint>();\n    apList.addAll(this.oldAPs);\n    int index=apList.indexOf(ap);\n    if (index > 0) {\n      apList.remove(index);\n      this.oldAPs=apList;\n    }\n  }\n  if (this.attachmentPoints != null) {\n    ArrayList<AttachmentPoint> apList=new ArrayList<AttachmentPoint>();\n    apList.addAll(this.attachmentPoints);\n    int index=apList.indexOf(ap);\n    if (index > 0) {\n      apList.remove(index);\n      this.attachmentPoints=apList;\n      return true;\n    }\n  }\n  return false;\n}", "comment": "delete ( sw , port ) from the list of list of attachment points and oldaps .", "label": "what"}
{"id": "8093", "raw_code": "static boolean isAssignableTo(ClassNode type,ClassNode toBeAssignedTo){\n  if (UNKNOWN_PARAMETER_TYPE == type)   return true;\n  if (type == toBeAssignedTo)   return true;\n  if (toBeAssignedTo.redirect() == STRING_TYPE && type.redirect() == GSTRING_TYPE) {\n    return true;\n  }\n  if (isPrimitiveType(toBeAssignedTo))   toBeAssignedTo=getWrapper(toBeAssignedTo);\n  if (isPrimitiveType(type))   type=getWrapper(type);\n  if (Double_TYPE == toBeAssignedTo) {\n    return type.isDerivedFrom(Number_TYPE);\n  }\n  if (Float_TYPE == toBeAssignedTo) {\n    return type.isDerivedFrom(Number_TYPE) && Double_TYPE != type.redirect();\n  }\n  if (Long_TYPE == toBeAssignedTo) {\n    return type.isDerivedFrom(Number_TYPE) && Double_TYPE != type.redirect() && Float_TYPE != type.redirect();\n  }\n  if (Integer_TYPE == toBeAssignedTo) {\n    return type.isDerivedFrom(Number_TYPE) && Double_TYPE != type.redirect() && Float_TYPE != type.redirect() && Long_TYPE != type.redirect();\n  }\n  if (Short_TYPE == toBeAssignedTo) {\n    return type.isDerivedFrom(Number_TYPE) && Double_TYPE != type.redirect() && Float_TYPE != type.redirect() && Long_TYPE != type.redirect() && Integer_TYPE != type.redirect();\n  }\n  if (Byte_TYPE == toBeAssignedTo) {\n    return type.redirect() == Byte_TYPE;\n  }\n  if (type.isArray() && toBeAssignedTo.isArray()) {\n    return isAssignableTo(type.getComponentType(),toBeAssignedTo.getComponentType());\n  }\n  if (type.isDerivedFrom(GSTRING_TYPE) && STRING_TYPE.equals(toBeAssignedTo)) {\n    return true;\n  }\n  if (toBeAssignedTo.isDerivedFrom(GSTRING_TYPE) && STRING_TYPE.equals(type)) {\n    return true;\n  }\n  if (implementsInterfaceOrIsSubclassOf(type,toBeAssignedTo)) {\n    if (OBJECT_TYPE.equals(toBeAssignedTo))     return true;\n    if (toBeAssignedTo.isUsingGenerics()) {\n      GenericsType gt=GenericsUtils.buildWildcardType(toBeAssignedTo);\n      return gt.isCompatibleWith(type);\n    }\n    return true;\n  }\n  if (type.isDerivedFrom(CLOSURE_TYPE) && isSAMType(toBeAssignedTo)) {\n    return true;\n  }\n  return false;\n}", "comment": "checks if a class node is assignable to another .", "label": "what"}
{"id": "56394", "raw_code": "public synchronized int totalRecoverFiles(){\n  int total=0;\n  for (  File file : fileDetails.values()) {\n    if (file.reused() == false) {\n      total++;\n    }\n  }\n  return total;\n}", "comment": "total number of files to be recovered ( potentially not yet done )", "label": "what"}
{"id": "67199", "raw_code": "@Override @Timed public void deleteAssignment(Experiment experiment,User.ID userID,Context context,Application.Name appName,Assignment currentAssignment){\n  deleteUserFromLookUp(experiment.getID(),userID,context);\n  boolean countUp=false;\n  assignmentsCountExecutor.execute(new AssignmentCountEnvelope(assignmentsRepository,experimentRepository,dbRepository,experiment,currentAssignment,countUp,eventLog,null,assignUserToExport,assignBucketCount));\n  deleteAssignmentOld(experiment.getID(),userID,context,appName,currentAssignment.getBucketLabel());\n  removeIndexUserToExperiment(userID,experiment.getID(),context,appName);\n  removeIndexUserToBucket(userID,experiment.getID(),context,currentAssignment.getBucketLabel());\n  removeIndexExperimentsToUser(userID,experiment.getID(),context,appName);\n}", "comment": "deletes the existing assignment between a user and an experiment .", "label": "what"}
{"id": "81747", "raw_code": "String format(Object obj,StringBuffer toAppendTo) throws IllegalArgumentException {\n  Date source=null;\n  if (obj instanceof Date) {\n    source=(Date)obj;\n  }\n else   if (obj instanceof String) {\n    try {\n      source=parse((String)obj);\n    }\n catch (    ParseException pe) {\n      throw new RuntimeException(pe.toString());\n    }\n  }\n  if (source == null) {\n    throw new IllegalArgumentException((obj == null) ? \"null\" : obj.toString());\n  }\n  return format(source,toAppendTo);\n}", "comment": "format a given object .", "label": "what"}
{"id": "60816", "raw_code": "private static final boolean compareAndSetWaitStatus(Node node,int expect,int update){\n  return unsafe.compareAndSwapInt(node,waitStatusOffset,expect,update);\n}", "comment": "cas waitstatus field of a node .", "label": "what"}
{"id": "75011", "raw_code": "protected boolean matchesFilter(final String input,final String[] filter){\n  for (  final String match : filter) {\n    if (!input.contains(match))     return false;\n  }\n  return true;\n}", "comment": "checks if all keywords in filter array are in input", "label": "what"}
{"id": "66035", "raw_code": "private void createMissingValues(){\n  String sql=\"SELECT ra.A_RegistrationAttribute_ID \" + \"FROM A_RegistrationAttribute ra\" + \" LEFT OUTER JOIN A_RegistrationProduct rp ON (rp.A_RegistrationAttribute_ID=ra.A_RegistrationAttribute_ID)\"+ \" LEFT OUTER JOIN A_Registration r ON (r.M_Product_ID=rp.M_Product_ID) \"+ \"WHERE r.A_Registration_ID=?\"+ \" AND NOT EXISTS (SELECT A_RegistrationAttribute_ID FROM A_RegistrationValue v \"+ \"WHERE ra.A_RegistrationAttribute_ID=v.A_RegistrationAttribute_ID AND r.A_Registration_ID=v.A_Registration_ID)\";\n  PreparedStatement pstmt=null;\n  try {\n    pstmt=DB.prepareStatement(sql,get_TrxName());\n    pstmt.setInt(1,getA_Registration_ID());\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      MRegistrationValue v=new MRegistrationValue(this,rs.getInt(1),\"?\");\n      v.saveEx();\n    }\n    rs.close();\n    pstmt.close();\n    pstmt=null;\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,null,e);\n  }\n  try {\n    if (pstmt != null)     pstmt.close();\n    pstmt=null;\n  }\n catch (  Exception e) {\n    pstmt=null;\n  }\n}", "comment": "create missing attribute values", "label": "what"}
{"id": "34254", "raw_code": "private static String normalisePath(String path){\n  return path.replace('\\\\','/');\n}", "comment": "this method replaces all \\ to / .", "label": "what"}
{"id": "54775", "raw_code": "public void startLaunchNotifier(){\n  if (m_launchNotification == null)   throw new NullPointerException();\n  m_launchNotifierThread.setDaemon(true);\n  m_launchNotifierThread.start();\n}", "comment": "creates a background thread that will call the launch notifier when the process terminates .", "label": "what"}
{"id": "49128", "raw_code": "private static void encode(List<AclEntry> acl,long address){\n  long offset=address;\n  for (  AclEntry ace : acl) {\n    int flags=0;\n    UserPrincipal who=ace.principal();\n    if (!(who instanceof UnixUserPrincipals.User))     throw new ProviderMismatchException();\n    UnixUserPrincipals.User user=(UnixUserPrincipals.User)who;\n    int uid;\n    if (user.isSpecial()) {\n      uid=-1;\n      if (who == UnixUserPrincipals.SPECIAL_OWNER)       flags|=ACE_OWNER;\n else       if (who == UnixUserPrincipals.SPECIAL_GROUP)       flags|=(ACE_GROUP | ACE_IDENTIFIER_GROUP);\n else       if (who == UnixUserPrincipals.SPECIAL_EVERYONE)       flags|=ACE_EVERYONE;\n else       throw new AssertionError(\"Unable to map special identifier\");\n    }\n else {\n      if (user instanceof UnixUserPrincipals.Group) {\n        uid=user.gid();\n        flags|=ACE_IDENTIFIER_GROUP;\n      }\n else {\n        uid=user.uid();\n      }\n    }\n    int type;\nswitch (ace.type()) {\ncase ALLOW:\n      type=ACE_ACCESS_ALLOWED_ACE_TYPE;\n    break;\ncase DENY:\n  type=ACE_ACCESS_DENIED_ACE_TYPE;\nbreak;\ncase AUDIT:\ntype=ACE_SYSTEM_AUDIT_ACE_TYPE;\nbreak;\ncase ALARM:\ntype=ACE_SYSTEM_ALARM_ACE_TYPE;\nbreak;\ndefault :\nthrow new AssertionError(\"Unable to map ACE type\");\n}\nSet<AclEntryPermission> aceMask=ace.permissions();\nint mask=0;\nif (aceMask.contains(AclEntryPermission.READ_DATA)) mask|=ACE_READ_DATA;\nif (aceMask.contains(AclEntryPermission.WRITE_DATA)) mask|=ACE_WRITE_DATA;\nif (aceMask.contains(AclEntryPermission.APPEND_DATA)) mask|=ACE_APPEND_DATA;\nif (aceMask.contains(AclEntryPermission.READ_NAMED_ATTRS)) mask|=ACE_READ_NAMED_ATTRS;\nif (aceMask.contains(AclEntryPermission.WRITE_NAMED_ATTRS)) mask|=ACE_WRITE_NAMED_ATTRS;\nif (aceMask.contains(AclEntryPermission.EXECUTE)) mask|=ACE_EXECUTE;\nif (aceMask.contains(AclEntryPermission.DELETE_CHILD)) mask|=ACE_DELETE_CHILD;\nif (aceMask.contains(AclEntryPermission.READ_ATTRIBUTES)) mask|=ACE_READ_ATTRIBUTES;\nif (aceMask.contains(AclEntryPermission.WRITE_ATTRIBUTES)) mask|=ACE_WRITE_ATTRIBUTES;\nif (aceMask.contains(AclEntryPermission.DELETE)) mask|=ACE_DELETE;\nif (aceMask.contains(AclEntryPermission.READ_ACL)) mask|=ACE_READ_ACL;\nif (aceMask.contains(AclEntryPermission.WRITE_ACL)) mask|=ACE_WRITE_ACL;\nif (aceMask.contains(AclEntryPermission.WRITE_OWNER)) mask|=ACE_WRITE_OWNER;\nif (aceMask.contains(AclEntryPermission.SYNCHRONIZE)) mask|=ACE_SYNCHRONIZE;\nSet<AclEntryFlag> aceFlags=ace.flags();\nif (aceFlags.contains(AclEntryFlag.FILE_INHERIT)) flags|=ACE_FILE_INHERIT_ACE;\nif (aceFlags.contains(AclEntryFlag.DIRECTORY_INHERIT)) flags|=ACE_DIRECTORY_INHERIT_ACE;\nif (aceFlags.contains(AclEntryFlag.NO_PROPAGATE_INHERIT)) flags|=ACE_NO_PROPAGATE_INHERIT_ACE;\nif (aceFlags.contains(AclEntryFlag.INHERIT_ONLY)) flags|=ACE_INHERIT_ONLY_ACE;\nunsafe.putInt(offset + OFFSETOF_UID,uid);\nunsafe.putInt(offset + OFFSETOF_MASK,mask);\nunsafe.putShort(offset + OFFSETOF_FLAGS,(short)flags);\nunsafe.putShort(offset + OFFSETOF_TYPE,(short)type);\noffset+=SIZEOF_ACE_T;\n}\n}", "comment": "encode the acl to the given buffer", "label": "what"}
{"id": "15993", "raw_code": "public CipherParameters decrypt(byte[] in,int inOff,int inLen,int keyLen) throws IllegalArgumentException {\n  if (!key.isPrivate()) {\n    throw new IllegalArgumentException(\"Private key required for decryption\");\n  }\n  BigInteger n=key.getModulus();\n  BigInteger d=key.getExponent();\n  byte[] C=new byte[inLen];\n  System.arraycopy(in,inOff,C,0,C.length);\n  BigInteger c=new BigInteger(1,C);\n  BigInteger r=c.modPow(d,n);\n  return generateKey(n,r,keyLen);\n}", "comment": "decrypt an encapsulated session key .", "label": "what"}
{"id": "78644", "raw_code": "public PrivateKey loadPrivateKey() throws Exception {\n  if (defaultKeys) {\n    return getPrivateKeyFromString(RSAKeyLoader.DEFAULT_PKEY);\n  }\n  if (priKey == null) {\n    FileReader f=new FileReader(path + \"privatekey\" + this.id);\n    BufferedReader r=new BufferedReader(f);\n    String tmp=\"\";\n    String key=\"\";\n    while ((tmp=r.readLine()) != null) {\n      key=key + tmp;\n    }\n    f.close();\n    r.close();\n    priKey=getPrivateKeyFromString(key);\n  }\n  return priKey;\n}", "comment": "loads the private key of this process", "label": "what"}
{"id": "22124", "raw_code": "public void init() throws Exception {\n  loadParameterFromZK();\n  _invalidLoginCleanupExecutor.scheduleWithFixedDelay(new InvalidLoginCleaner(),CLEANUP_THREAD_SCHEDULE_INTERVAL_IN_MINS,CLEANUP_THREAD_SCHEDULE_INTERVAL_IN_MINS,TimeUnit.MINUTES);\n  _log.info(\"Max invalid login attempts from the same client IP: {}\",_maxAuthnLoginAttemtsCount);\n  _log.info(\"Life time in minutes of invalid login records for a client IP: {}\",_maxAuthnLoginAttemtsLifeTimeInMins);\n  _log.info(\"Cleanup thread schedule interval: {} minutes\",CLEANUP_THREAD_SCHEDULE_INTERVAL_IN_MINS);\n}", "comment": "initialize the background task to be run every hour .", "label": "what"}
{"id": "35403", "raw_code": "public void addVertex(Object id) throws IllegalArgumentException {\n  if (initialized) {\n    throw new IllegalArgumentException();\n  }\n  Vertex vertex=new Vertex(id);\n  Object existing=vertexMap.put(id,vertex);\n  if (existing != null) {\n    throw new IllegalArgumentException();\n  }\n  vertexList.add(vertex);\n}", "comment": "defines a new vertex with the given id .", "label": "what"}
{"id": "73824", "raw_code": "public void configureLocalServices(){\n  clientMemo.setLnTrafficController(this);\n  clientMemo.configureCommandStation(LnCommandStationType.COMMAND_STATION_DCS100,false,false);\n  clientMemo.configureManagers();\n}", "comment": "set up all of the other objects to operate with a server connected to this application .", "label": "what"}
{"id": "3974", "raw_code": "public void append(String string){\n  for (int i=0; i < string.length(); i++)   append(string.charAt(i));\n}", "comment": "appends an int ( little endian ) in the buffer", "label": "what"}
{"id": "29334", "raw_code": "public ListenableFuture<String> push(final String name,final Expression func){\n  String let=String.format(\"let %s = %s\",name,func.toHaskell());\n  return pullRaw(let);\n}", "comment": "uploads a new let binding to ghci", "label": "what"}
{"id": "71634", "raw_code": "public MetaDataColumnDescriptor(String columnName,int jdbcType,Object defaultValue){\n  _columnName=columnName.toUpperCase();\n  _jdbcType=jdbcType;\n  _defaultValue=defaultValue;\n}", "comment": "creates a new descriptor instance .", "label": "what"}
{"id": "52768", "raw_code": "private void bulkLoad(double[] lmin,double[] lmax,List<Node> children,ArrayModifiableDBIDs ids,int start,int end,int dim,int level,int code){\n  if (dim == 0) {\n    DBIDArrayIter iter=ids.iter();\n    iter.seek(start);\n    NumberVector first=relation.get(iter);\n    iter.advance();\n    boolean degenerate=true;\n    loop:     for (; iter.getOffset() < end; iter.advance()) {\n      NumberVector other=relation.get(iter);\n      for (int d=0; d < lmin.length; d++) {\n        if (Math.abs(first.doubleValue(d) - other.doubleValue(d)) > 1E-15) {\n          degenerate=false;\n          break loop;\n        }\n      }\n    }\n    if (degenerate) {\n      double[] center=new double[lmin.length];\n      for (int d=0; d < lmin.length; d++) {\n        center[d]=lmin[d] * .5 + lmax[d] * .5 + shift[d];\n        if (center[d] > min[d] + width[d]) {\n          center[d]-=width[d];\n        }\n      }\n      children.add(new Node(code,center,end - start,level,null));\n      return;\n    }\n  }\n  if (dim == lmin.length) {\n    double[] center=new double[lmin.length];\n    for (int d=0; d < lmin.length; d++) {\n      center[d]=lmin[d] * .5 + lmax[d] * .5 + shift[d];\n      if (center[d] > min[d] + width[d]) {\n        center[d]-=width[d];\n      }\n    }\n    if (end - start < nmin) {\n      children.add(new Node(code,center,end - start,level,null));\n      return;\n    }\n else {\n      List<Node> newchildren=new ArrayList<>();\n      bulkLoad(lmin,lmax,newchildren,ids,start,end,0,level + 1,0);\n      children.add(new Node(code,center,end - start,level,newchildren));\n      return;\n    }\n  }\n else {\n    DBIDArrayIter siter=ids.iter(), eiter=ids.iter();\n    siter.seek(start);\n    eiter.seek(end - 1);\n    while (siter.getOffset() < eiter.getOffset()) {\n      if (getShiftedDim(relation.get(siter),dim,level) <= .5) {\n        siter.advance();\n        continue;\n      }\n      if (getShiftedDim(relation.get(eiter),dim,level) > 0.5) {\n        eiter.retract();\n        continue;\n      }\n      ids.swap(siter.getOffset(),eiter.getOffset() - 1);\n      siter.advance();\n      eiter.retract();\n    }\n    final int spos=siter.getOffset();\n    if (start < spos) {\n      final double tmp=lmax[dim];\n      lmax[dim]=lmax[dim] * .5 + lmin[dim] * .5;\n      bulkLoad(lmin,lmax,children,ids,start,spos,dim + 1,level,code);\n      lmax[dim]=tmp;\n    }\n    if (spos < end) {\n      final double tmp=lmin[dim];\n      lmin[dim]=lmax[dim] * .5 + lmin[dim] * .5;\n      bulkLoad(lmin,lmax,children,ids,spos,end,dim + 1,level,code | (1 << dim));\n      lmin[dim]=tmp;\n    }\n  }\n}", "comment": "bulk load the tree", "label": "what"}
{"id": "11445", "raw_code": "protected ArrayList<float[]> _forwardPoly(float[] rawllpts,int ltype,int nsegs,boolean isFilled){\n  boolean DEBUG=Debug.debugging(\"proj\");\n  int len=rawllpts.length >>> 1;\n  if (len < 2)   return new ArrayList<float[]>(0);\n  if (isComplicatedLineType(ltype))   return doPolyDispatch(rawllpts,ltype,nsegs,isFilled);\n  int invalid_count=0;\n  boolean curr_invalid, prev_invalid=false;\n  Point temp=new Point();\n  AzimuthVar az_first=null, az_save=null, azVar=new AzimuthVar();\n  ArrayList<AzimuthVar> sections=new ArrayList<AzimuthVar>(128);\n  float[] x_, xs=new float[len];\n  float[] y_, ys=new float[len];\n  _forward(rawllpts[0],rawllpts[1],temp,azVar);\n  xs[0]=temp.x;\n  ys[0]=temp.y;\n  prev_invalid=azVar.invalid_forward;\n  if (prev_invalid) {\n    ++invalid_count;\n  }\n else {\n    azVar.index=0;\n    azVar.current_azimuth=GreatCircle.sphericalAzimuth((float)centerY,(float)centerX,rawllpts[0],rawllpts[1]);\n    if (!isFilled) {\n      sections.add(azVar);\n    }\n else {\n      az_first=azVar;\n    }\n    azVar=new AzimuthVar();\n  }\n  int i=0, j=0;\n  for (i=1, j=2; i < len; i++, j+=2) {\n    azVar.invalid_forward=false;\n    _forward(rawllpts[j],rawllpts[j + 1],temp,azVar);\n    curr_invalid=azVar.invalid_forward;\n    xs[i]=temp.x;\n    ys[i]=temp.y;\n    if (!curr_invalid && prev_invalid) {\n      azVar.index=i - 1;\n      azVar.current_azimuth=GreatCircle.sphericalAzimuth((float)centerY,(float)centerX,rawllpts[j - 2],rawllpts[j - 1]);\n      sections.add(azVar);\n      azVar=new AzimuthVar();\n    }\n else     if (curr_invalid) {\n      if (!prev_invalid) {\n        azVar.index=i;\n        if (isFilled && (invalid_count == 0)) {\n          az_save=azVar;\n        }\n else {\n          sections.add(azVar);\n        }\n        azVar=new AzimuthVar();\n      }\n      ++invalid_count;\n    }\n    prev_invalid=curr_invalid;\n  }\n  if (invalid_count == 0) {\n    ArrayList<float[]> ret_val=new ArrayList<float[]>(2);\n    ret_val.add(xs);\n    ret_val.add(ys);\n    return ret_val;\n  }\n  if (invalid_count == len) {\n    return new ArrayList<float[]>(0);\n  }\n  if (!prev_invalid) {\n    if (isFilled && (az_save != null)) {\n      int l=az_save.index;\n      x_=new float[len + l];\n      y_=new float[len + l];\n      System.arraycopy(xs,0,x_,0,len);\n      System.arraycopy(ys,0,y_,0,len);\n      System.arraycopy(xs,0,x_,len,l);\n      System.arraycopy(ys,0,y_,len,l);\n      az_save.index=len + l;\n      sections.add(az_save);\n      xs=x_;\n      ys=y_;\n    }\n else {\n      if (DEBUG && isFilled && (az_save == null)) {\n        Debug.output(\"AA, filled, no-wrap!\");\n      }\n      azVar.index=i;\n      j=rawllpts.length;\n      azVar.current_azimuth=GreatCircle.sphericalAzimuth((float)centerY,(float)centerX,rawllpts[j - 2],rawllpts[j - 1]);\n      sections.add(azVar);\n    }\n  }\n else   if (az_save != null) {\n    if (DEBUG)     Debug.output(\"DD, filled!\");\n    sections.add(az_first);\n    sections.add(az_save);\n  }\n  int size=sections.size();\n  ArrayList<float[]> ret_val=new ArrayList<float[]>(size);\n  if (isFilled && (len > 2)) {\n    generateFilledPoly(xs,ys,sections,ret_val);\n    return ret_val;\n  }\n  for (j=0; j < size; j+=2) {\n    AzimuthVar az1=(AzimuthVar)sections.get(j);\n    AzimuthVar az2=(AzimuthVar)sections.get(j + 1);\n    int off1=az1.index;\n    int off2=az2.index;\n    int l=off2 - off1;\n    x_=new float[l];\n    y_=new float[l];\n    System.arraycopy(xs,off1,x_,0,l);\n    System.arraycopy(ys,off1,y_,0,l);\n    ret_val.add(x_);\n    ret_val.add(y_);\n  }\n  return ret_val;\n}", "comment": "forward project a lat / lon poly .", "label": "what"}
{"id": "71987", "raw_code": "public DataProviderEvent(final LocalizableMessage reason,final Set<Type> types){\n  Reject.ifNull(reason,types);\n  Reject.ifTrue(types.isEmpty());\n  this.reason=reason;\n  final EnumSet<Type> tmp=EnumSet.noneOf(Type.class);\n  tmp.addAll(types);\n  this.types=Collections.unmodifiableSet(tmp);\n}", "comment": "creates a new data provider event .", "label": "what"}
{"id": "57296", "raw_code": "public <T>List<String> validateBean(T bean,String errIfBeanNull){\n  List<String> errors=new ArrayList<String>();\n  if (bean == null) {\n    errors.add(errIfBeanNull);\n    return errors;\n  }\n  Set<ConstraintViolation<T>> violations=validator.validate(bean);\n  for (  ConstraintViolation<T> violation : violations) {\n    errors.add(violation.getMessage());\n  }\n  return errors;\n}", "comment": "validate the bean is not null ; then validate its fields", "label": "what"}
{"id": "20254", "raw_code": "@Override protected FieldConfigBase createCopy(FieldConfigBase fieldConfigBase){\n  FieldConfigFontPreview copy=null;\n  if (fieldConfigBase != null) {\n    copy=new FieldConfigFontPreview(fieldConfigBase.getCommonData());\n  }\n  return copy;\n}", "comment": "creates a copy of the field .", "label": "what"}
{"id": "61321", "raw_code": "public Object castToType(int t,XPathContext support) throws javax.xml.transform.TransformerException {\n  Object result;\nswitch (t) {\ncase CLASS_STRING:\n    result=str();\n  break;\ncase CLASS_NUMBER:\nresult=new Double(num());\nbreak;\ncase CLASS_NODESET:\nresult=iter();\nbreak;\ncase CLASS_BOOLEAN:\nresult=new Boolean(bool());\nbreak;\ncase CLASS_UNKNOWN:\nresult=m_obj;\nbreak;\ndefault :\nerror(XPATHErrorResources.ER_CANT_CONVERT_TO_TYPE,new Object[]{getTypeString(),Integer.toString(t)});\nresult=null;\n}\nreturn result;\n}", "comment": "cast object to type t .", "label": "what"}
{"id": "28476", "raw_code": "public static void forceDeleteOnExit(File file) throws IOException {\n  if (file.isDirectory()) {\n    deleteDirectoryOnExit(file);\n  }\n else {\n    file.deleteOnExit();\n  }\n}", "comment": "schedules a file to be deleted when jvm exits .", "label": "what"}
{"id": "36058", "raw_code": "public static void addAnnotationToXML(Element annotationsElement,String name,String value){\n  if (value == null) {\n    deleteAnnotationFromXML(annotationsElement,name);\n  }\n else {\n    final Document doc=annotationsElement.getOwnerDocument();\n    Element elem=doc.createElement(\"annotation\");\n    annotationsElement.appendChild(elem);\n    elem.setAttribute(\"key\",name);\n    elem.setTextContent(value);\n  }\n}", "comment": "updates the xml representation to contain this annotation .", "label": "what"}
{"id": "51515", "raw_code": "public boolean readBoolean() throws IOException {\n  return primitiveTypes.readBoolean();\n}", "comment": "reads a boolean from the source stream .", "label": "what"}
{"id": "45128", "raw_code": "private static char[] zzUnpackCMap(String packed){\n  char[] map=new char[0x10000];\n  int i=0;\n  int j=0;\n  while (i < 188) {\n    int count=packed.charAt(i++);\n    char value=packed.charAt(i++);\n    do     map[j++]=value;\n while (--count > 0);\n  }\n  return map;\n}", "comment": "unpacks the compressed character translation table .", "label": "what"}
{"id": "82039", "raw_code": "public void startTicker(long delay,boolean rightToLeft){\n  if (!tickerEnabled) {\n    return;\n  }\n  if (!isCellRenderer()) {\n    Form parent=getComponentForm();\n    if (parent != null) {\n      parent.registerAnimatedInternal(this);\n    }\n  }\n  tickerStartTime=System.currentTimeMillis();\n  tickerDelay=delay;\n  tickerRunning=true;\n  this.rightToLeft=rightToLeft;\n  if (isRTL()) {\n    this.rightToLeft=!this.rightToLeft;\n  }\n}", "comment": "this method will start the text ticker", "label": "what"}
{"id": "76449", "raw_code": "public static Context createPendingActionContext(Context context,ReconAction action,String mappingName,JsonValue sourceObject,String reconId,Situation situation){\n  Map<String,Object> pendingActionMap=new HashMap<String,Object>();\n  pendingActionMap.put(MAPPING_NAME,mappingName);\n  pendingActionMap.put(SOURCE_OBJECT,sourceObject);\n  pendingActionMap.put(RECON_ID,reconId);\n  pendingActionMap.put(ORIGINAL_SITUATION,situation.toString());\n  PendingActionContext pendingActionContext=new PendingActionContext(context,pendingActionMap,action.toString());\n  return pendingActionContext;\n}", "comment": "creates and populates a pendingactioncontext .", "label": "what"}
{"id": "68411", "raw_code": "private static char[] zzUnpackCMap(String packed){\n  char[] map=new char[0x10000];\n  int i=0;\n  int j=0;\n  while (i < 204) {\n    int count=packed.charAt(i++);\n    char value=packed.charAt(i++);\n    do     map[j++]=value;\n while (--count > 0);\n  }\n  return map;\n}", "comment": "unpacks the compressed character translation table .", "label": "what"}
{"id": "62900", "raw_code": "private static void resolveNewExpression(NewExpression objSubjectExpression,HashSet<String> objTypesSet){\n  ClassReference objClassRef=objSubjectExpression.getClassReference();\n  if (null == objClassRef || null == objClassRef.getFQN()) {\n    objTypesSet.add(Types.strResolvingAbortedOnPsiLevel);\n    return;\n  }\n  objTypesSet.add(objClassRef.getFQN());\n}", "comment": "will resolve type of new expression", "label": "what"}
{"id": "2083", "raw_code": "private static List<Size> pickUpToThree(List<Size> sizes){\n  List<Size> result=new ArrayList<Size>();\n  Size largest=sizes.get(0);\n  result.add(largest);\n  Size lastSize=largest;\n  for (  Size size : sizes) {\n    double targetArea=Math.pow(.5,result.size()) * area(largest);\n    if (area(size) < targetArea) {\n      if (!result.contains(lastSize) && (targetArea - area(lastSize) < area(size) - targetArea)) {\n        result.add(lastSize);\n      }\n else {\n        result.add(size);\n      }\n    }\n    lastSize=size;\n    if (result.size() == 3) {\n      break;\n    }\n  }\n  if (result.size() < 3 && !result.contains(lastSize)) {\n    result.add(lastSize);\n  }\n  return result;\n}", "comment": "given a list of sizes of a similar aspect ratio , it tries to pick evenly spaced out options .", "label": "what"}
{"id": "75751", "raw_code": "public static void copyToClipboard(Transferable t){\n  ClipboardHelper.copyToClipboard(t);\n}", "comment": "copies the given transferable to the system ' s clipboard .", "label": "what"}
{"id": "59710", "raw_code": "public static String formatPercent(int downloadSize,int fileSize){\n  float num=(float)downloadSize / fileSize;\n  float percent=((float)(int)(num * 1000)) / 10;\n  return String.valueOf(percent + \"%\");\n}", "comment": "format the download percent", "label": "what"}
{"id": "6496", "raw_code": "private void updateActions(){\n  String selectedText=getSelectedText();\n  if (selectedText == null)   selectedText=\"\";\n  boolean stuffSelected=!selectedText.equals(\"\");\n  boolean allSelected=selectedText.equals(getText());\n  UNDO_ACTION.setEnabled(isEnabled() && isEditable() && isUndoAvailable());\n  CUT_ACTION.setEnabled(isEnabled() && isEditable() && stuffSelected);\n  COPY_ACTION.setEnabled(isEnabled() && stuffSelected);\n  PASTE_ACTION.setEnabled(isEnabled() && isEditable() && isPasteAvailable());\n  DELETE_ACTION.setEnabled(isEnabled() && stuffSelected);\n  SELECT_ALL_ACTION.setEnabled(isEnabled() && !allSelected);\n}", "comment": "updates the actions in each text just before showing the popup menu .", "label": "what"}
{"id": "50142", "raw_code": "public static Date parseText(String dateStr){\n  try {\n    return mSimpleTextFormat.parse(dateStr);\n  }\n catch (  ParseException e) {\n    e.printStackTrace();\n    throw new RuntimeException(\"date formatDateTime error\");\n  }\n}", "comment": "parse string to datetime", "label": "what"}
{"id": "57", "raw_code": "public boolean isProcessed(Trace trace,Node node,Direction direction){\n  boolean ret=false;\n  if (processor.getNodeType() == node.getType() && processor.getDirection() == direction) {\n    if (uriFilter == null || uriFilter.test(node.getUri())) {\n      ret=true;\n    }\n  }\n  if (log.isLoggable(Level.FINEST)) {\n    log.finest(\"ProcessManager/Processor: isProcessed trace=\" + trace + \" node=\"+ node+ \" direction=\"+ direction+ \"? \"+ ret);\n  }\n  return ret;\n}", "comment": "this method checks that this processor matches the supplied business txn name and node details .", "label": "what"}
{"id": "14018", "raw_code": "public void deleteEntityConfig(String realm,String federationId) throws WSFederationMetaException {\n  if (federationId == null) {\n    return;\n  }\n  if (realm == null) {\n    realm=\"/\";\n  }\n  String[] objs={federationId,realm};\n  try {\n    Map oldAttrs=configInst.getConfiguration(realm,federationId);\n    Set oldValues=(Set)oldAttrs.get(ATTR_ENTITY_CONFIG);\n    if (oldValues == null || oldValues.isEmpty()) {\n      LogUtil.error(Level.INFO,LogUtil.NO_ENTITY_DESCRIPTOR_DELETE_ENTITY_CONFIG,objs,null);\n      throw new WSFederationMetaException(\"entity_config_not_exist\",objs);\n    }\n    IDPSSOConfigElement idpconfig=getIDPSSOConfig(realm,federationId);\n    if (idpconfig != null) {\n      removeFromCircleOfTrust(idpconfig,realm,federationId);\n    }\n    SPSSOConfigElement spconfig=getSPSSOConfig(realm,federationId);\n    if (spconfig != null) {\n      removeFromCircleOfTrust(spconfig,realm,federationId);\n    }\n    Set attr=new HashSet();\n    attr.add(ATTR_ENTITY_CONFIG);\n    configInst.deleteConfiguration(realm,federationId,attr);\n    LogUtil.access(Level.INFO,LogUtil.ENTITY_CONFIG_DELETED,objs,null);\n    WSFederationMetaCache.putEntityConfig(realm,federationId,null);\n  }\n catch (  ConfigurationException e) {\n    debug.error(\"WSFederationMetaManager.deleteEntityConfig:\",e);\n    String[] data={e.getMessage(),federationId,realm};\n    LogUtil.error(Level.INFO,LogUtil.CONFIG_ERROR_DELETE_ENTITY_CONFIG,data,null);\n    throw new WSFederationMetaException(e);\n  }\n}", "comment": "deletes the extended entity configuration under the realm .", "label": "what"}
{"id": "41867", "raw_code": "private Long id(HttpServletRequest request){\n  Long id=null;\n  String pathInfo=request.getPathInfo();\n  if (pathInfo != null && pathInfo.length() > 1) {\n    String idString=pathInfo.substring(1);\n    id=Long.valueOf(idString);\n  }\n  return id;\n}", "comment": "extract id from the http request .", "label": "what"}
{"id": "51502", "raw_code": "@Override public void close() throws IOException {\nsynchronized (lock) {\n    if (!isClosed()) {\n      in.close();\n      buf=null;\n    }\n  }\n}", "comment": "closes this reader .", "label": "what"}
{"id": "51411", "raw_code": "public int compareTo(CharBuffer otherBuffer){\n  int compareRemaining=(remaining() < otherBuffer.remaining()) ? remaining() : otherBuffer.remaining();\n  int thisPos=position;\n  int otherPos=otherBuffer.position;\n  char thisByte, otherByte;\n  while (compareRemaining > 0) {\n    thisByte=get(thisPos);\n    otherByte=otherBuffer.get(otherPos);\n    if (thisByte != otherByte) {\n      return thisByte < otherByte ? -1 : 1;\n    }\n    thisPos++;\n    otherPos++;\n    compareRemaining--;\n  }\n  return remaining() - otherBuffer.remaining();\n}", "comment": "compare the remaining chars of this buffer to another char buffer ' s remaining chars .", "label": "what"}
{"id": "70805", "raw_code": "public synchronized void flush() throws IOException {\n  checkNotClosed();\n  trimToSize();\n  journalWriter.flush();\n}", "comment": "force buffered operations to the filesystem .", "label": "what"}
{"id": "68584", "raw_code": "private static final String decodeFieldName(final String pXmlFieldName){\n  StringBuilder str=new StringBuilder();\n  int fieldNameLength=pXmlFieldName.length();\n  char currentChar;\n  for (int i=0; i < fieldNameLength; i++) {\n    currentChar=pXmlFieldName.charAt(i);\n    if (currentChar == '-') {\n      str.append(Character.toUpperCase(pXmlFieldName.charAt(++i)));\n    }\n else {\n      str.append(currentChar);\n    }\n  }\n  return str.toString();\n}", "comment": "decodes a field name from xml notation ( e . g . my - field - name ) to a valid java field name ( e . g . myfieldname )", "label": "what"}
{"id": "7101", "raw_code": "public void addContentItem(ContentItem contentItem){\n  if (contentItems == null) {\n    contentItems=new ArrayList<ContentItem>();\n  }\n  contentItems.add(contentItem);\n}", "comment": "adds a content item .", "label": "what"}
{"id": "834", "raw_code": "public static String canonicalizeClassName(String name){\n  String classname=name.replace('/','.');\n  classname=classname.replace('\\\\','.');\n  if (classname.startsWith(\"class \"))   classname=classname.substring(6);\n  if (classname.endsWith(\".class\"))   classname=classname.substring(0,classname.length() - 6);\n  return classname;\n}", "comment": "create a proper class name from a messy thing .", "label": "what"}
{"id": "63897", "raw_code": "public boolean isHighlightWithInvisibleEdge(){\n  return highlightWithInvisibleEdge;\n}", "comment": "indicates if neighbor nodes with edges currently not visible still get highlighted .", "label": "what"}
{"id": "31739", "raw_code": "private Configuration prepareJobForCancelling() throws Exception {\n  prepareFile(\"/testFile\",1500);\n  executedTasks.set(0);\n  cancelledTasks.set(0);\n  failMapperId.set(0);\n  splitsCount.set(0);\n  Configuration cfg=new Configuration();\n  setupFileSystems(cfg);\n  Job job=Job.getInstance(cfg);\n  job.setOutputKeyClass(Text.class);\n  job.setOutputValueClass(IntWritable.class);\n  job.setMapperClass(CancellingTestMapper.class);\n  job.setNumReduceTasks(0);\n  job.setInputFormatClass(InFormat.class);\n  FileInputFormat.setInputPaths(job,new Path(\"igfs://:\" + getTestGridName(0) + \"@/\"));\n  FileOutputFormat.setOutputPath(job,new Path(\"igfs://:\" + getTestGridName(0) + \"@/output/\"));\n  job.setJarByClass(getClass());\n  return job.getConfiguration();\n}", "comment": "prepare job with mappers to cancel .", "label": "what"}
{"id": "6246", "raw_code": "public void removeChangingListener(OnWheelChangedListener listener){\n  changingListeners.remove(listener);\n}", "comment": "removes wheel changing listener", "label": "what"}
{"id": "69011", "raw_code": "public boolean isFlying(){\n  return (flyThroughDialog != null);\n}", "comment": "determine if in flight", "label": "what"}
{"id": "24432", "raw_code": "public synchronized void init(){\n  channelFactory=new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),Executors.newCachedThreadPool());\n  datagramChannelFactory=new NioDatagramChannelFactory(Executors.newCachedThreadPool());\n  timer=new HashedWheelTimer();\n}", "comment": "initialize ; cached threadpool is safe as it is releasing resources automatically if idle", "label": "what"}
{"id": "73636", "raw_code": "private void consumeNestedScroll(int dxUnconsumed,int dyUnconsumed,int dxFinalUnconsumed,int dyFinalUnconsumed){\n  if (mOverScrollEffect == OverScrollEffect.BOUNCE && dyFinalUnconsumed != 0) {\n    mUnconsumedOverScrollOffset+=-dyFinalUnconsumed;\n    int maxOffset=mOverScrollOffsetLimit;\n    if (mUnconsumedOverScrollOffset > 0) {\n      mUnconsumedOverScrollOffset=Math.min(maxOffset,mUnconsumedOverScrollOffset);\n    }\n else     if (mUnconsumedOverScrollOffset < 0) {\n      mUnconsumedOverScrollOffset=Math.max(-maxOffset,mUnconsumedOverScrollOffset);\n    }\n    setScrollingOffset(getUnconsumedScrollingOffset());\n  }\n  pullEdgeEffects(dxUnconsumed,dyUnconsumed);\n}", "comment": "consume the final unconsumed nested scroll after all behaviors done .", "label": "what"}
{"id": "69321", "raw_code": "private void retrieveWaypoints(SearchQuery query,ArrayList<Waypoint> waypoints){\n  String queryLikeSelection2=\"%\" + query.textQuery + \"%\";\n  String[] waypointSelectionArgs=new String[]{queryLikeSelection2,queryLikeSelection2,queryLikeSelection2};\n  Cursor cursor=null;\n  try {\n    cursor=providerUtils.getWaypointCursor(WAYPOINT_SELECTION_QUERY,waypointSelectionArgs,WAYPOINT_SELECTION_ORDER,MAX_SCORED_WAYPOINTS);\n    if (cursor != null) {\n      waypoints.ensureCapacity(cursor.getCount());\n      while (cursor.moveToNext()) {\n        Waypoint waypoint=providerUtils.createWaypoint(cursor);\n        if (LocationUtils.isValidLocation(waypoint.getLocation())) {\n          waypoints.add(waypoint);\n        }\n      }\n    }\n  }\n  finally {\n    if (cursor != null) {\n      cursor.close();\n    }\n  }\n}", "comment": "retrieves waypoints matching the given query from the database .", "label": "what"}
{"id": "68935", "raw_code": "void release(){\n  imageLoader.cancelPendingRequests();\n  loading=new boolean[noxItems.size()];\n}", "comment": "cancels all the pending noxitem downloads to the imageloader .", "label": "what"}
{"id": "77314", "raw_code": "public void add(String name,long cnt){\n  if (_values == null) {\n    _values=new ArrayList<>(30);\n  }\n  _values.add(new Count(this,name,cnt));\n}", "comment": "insert at the end of the list", "label": "what"}
{"id": "69701", "raw_code": "DeleteEvent(@NonNull JSONObject json) throws JSONException {\n  super(TYPE_DELETE,json);\n  if (TextUtils.isEmpty(mBlockId)) {\n    throw new JSONException(TYPENAME_DELETE + \" requires \" + JSON_BLOCK_ID);\n  }\n  mOldXml=json.optString(JSON_OLD_VALUE);\n  JSONArray ids=json.getJSONArray(JSON_IDS);\n  int count=ids.length();\n  List<String> temp=new ArrayList<>(count);\n  for (int i=0; i < count; ++i) {\n    temp.add(ids.getString(i));\n  }\n  mIds=Collections.unmodifiableList(temp);\n}", "comment": "constructs a deleteevent from the json serialized representation .", "label": "what"}
{"id": "22042", "raw_code": "public static boolean isFullCopyRestorable(Volume volume,DbClient dbClient){\n  boolean result=false;\n  String replicaState=volume.getReplicaState();\n  if (isVolumeFullCopy(volume,dbClient) && replicaState != null && !replicaState.isEmpty()) {\n    ReplicationState state=ReplicationState.getEnumValue(replicaState);\n    if (state != null && state == ReplicationState.SYNCHRONIZED) {\n      result=true;\n    }\n  }\n  return result;\n}", "comment": "check if the full copy volume could be restored .", "label": "what"}
{"id": "13986", "raw_code": "public boolean verifyXMLSignature(org.w3c.dom.Element element,java.lang.String certAlias) throws XMLSignatureException {\n  return verifyXMLSignature(element,DEF_ID_ATTRIBUTE,certAlias);\n}", "comment": "verify the signature of the xml document", "label": "what"}
{"id": "20340", "raw_code": "private static boolean isInHorizontalTargetZone(float x,float y,float handleXStart,float handleXEnd,float handleY,float targetRadius){\n  if (x > handleXStart && x < handleXEnd && Math.abs(y - handleY) <= targetRadius) {\n    return true;\n  }\n  return false;\n}", "comment": "determines if the specified coordinate is in the target touch zone for a horizontal bar handle .", "label": "what"}
{"id": "83162", "raw_code": "public void readTransportSystems(final int[] columnsIndices,final BufferedReader reader) throws IOException {\n  String line=reader.readLine();\n  while (line != null && line.length() > 0) {\n    line=reader.readLine();\n  }\n}", "comment": "reads the transport systems of the visum file", "label": "what"}
{"id": "61793", "raw_code": "private boolean hasPrefix(byte[] nal){\n  if (nal[0] == 0 && nal[1] == 0 && nal[2] == 0 && nal[3] == 0x01)   return true;\n else   return false;\n}", "comment": "makes sure the nal has a header or not .", "label": "what"}
{"id": "5550", "raw_code": "public static IMultiPoint[] randomPoints(int n,int d,int scale){\n  IMultiPoint points[]=new IMultiPoint[n];\n  for (int i=0; i < n; i++) {\n    StringBuilder sb=new StringBuilder();\n    for (int j=0; j < d; j++) {\n      sb.append(rGen.nextDouble() * scale);\n      if (j < d - 1) {\n        sb.append(\",\");\n      }\n    }\n    points[i]=new Hyperpoint(sb.toString());\n  }\n  return points;\n}", "comment": "generate array of n d - dimensional points whose coordinates are values in the range 0 . .", "label": "what"}
{"id": "9334", "raw_code": "private void parseParameters(String parameters){\n  Log.v(\"HttpHeader\",\"HttpAuthHeader.parseParameters():\" + \" parameters: \" + parameters);\n  if (parameters != null) {\n    int i;\n    do {\n      i=parameters.indexOf(',');\n      if (i < 0) {\n        parseParameter(parameters);\n      }\n else {\n        parseParameter(parameters.substring(0,i));\n        parameters=parameters.substring(i + 1);\n      }\n    }\n while (i >= 0);\n  }\n}", "comment": "parses a comma - separated list of authentification scheme parameters .", "label": "what"}
{"id": "17013", "raw_code": "public GradleDistribution deserializeFromString(String distributionString){\n  Preconditions.checkNotNull(distributionString);\n  String localInstallationPrefix=\"GRADLE_DISTRIBUTION(LOCAL_INSTALLATION(\";\n  if (distributionString.startsWith(localInstallationPrefix) && distributionString.endsWith(\"))\")) {\n    String localInstallationDir=distributionString.substring(localInstallationPrefix.length(),distributionString.length() - 2);\n    return GradleDistribution.forLocalInstallation(new File(localInstallationDir));\n  }\n  String remoteDistributionPrefix=\"GRADLE_DISTRIBUTION(REMOTE_DISTRIBUTION(\";\n  if (distributionString.startsWith(remoteDistributionPrefix) && distributionString.endsWith(\"))\")) {\n    String remoteDistributionUri=distributionString.substring(remoteDistributionPrefix.length(),distributionString.length() - 2);\n    return GradleDistribution.forRemoteDistribution(createURI(remoteDistributionUri));\n  }\n  String versionPrefix=\"GRADLE_DISTRIBUTION(VERSION(\";\n  if (distributionString.startsWith(versionPrefix) && distributionString.endsWith(\"))\")) {\n    String version=distributionString.substring(versionPrefix.length(),distributionString.length() - 2);\n    return GradleDistribution.forVersion(version);\n  }\n  String wrapperString=\"GRADLE_DISTRIBUTION(WRAPPER)\";\n  if (distributionString.equals(wrapperString)) {\n    return GradleDistribution.fromBuild();\n  }\n  String message=String.format(\"Cannot deserialize Gradle distribution string '%s.'\",distributionString);\n  throw new RuntimeException(message);\n}", "comment": "deserializes the gradle distribution from the the given string representation .", "label": "what"}
{"id": "54568", "raw_code": "public boolean sendViaDataSocket(byte[] bytes,int start,int len){\n  if (dataOutputStream == null) {\n    Log.i(TAG,\"Can't send via null dataOutputStream\");\n    return false;\n  }\n  if (len == 0) {\n    return true;\n  }\n  try {\n    dataOutputStream.write(bytes,start,len);\n  }\n catch (  IOException e) {\n    Log.i(TAG,\"Couldn't write output stream for data socket\");\n    Log.i(TAG,e.toString());\n    return false;\n  }\n  localDataSocket.reportTraffic(len);\n  return true;\n}", "comment": "sends a byte array over the already - established data socket", "label": "what"}
{"id": "29714", "raw_code": "private void pushContext(BaseContext c){\n  contextStack.push(c);\n}", "comment": "add a new parsing context onto the parse context stack .", "label": "what"}
{"id": "73009", "raw_code": "@Override public void bookmarksOrHistoryPicker(ComboViews startView){\n  if (mTabControl.getCurrentWebView() == null) {\n    return;\n  }\n  if (isInCustomActionMode()) {\n    endActionMode();\n  }\n  Bundle extras=new Bundle();\n  extras.putBoolean(BrowserBookmarksPage.EXTRA_DISABLE_WINDOW,!mTabControl.canCreateNewTab());\n  mUi.showComboView(startView,extras);\n}", "comment": "open the go page .", "label": "what"}
{"id": "12695", "raw_code": "public FST(String fileName,String encoding,boolean verbose) throws IOException {\n  FileInputStream fis=new FileInputStream(fileName);\n  try {\n    loadHeaderless(fis,encoding,verbose);\n  }\n  finally {\n    fis.close();\n  }\n}", "comment": "initialise the finite state transducer .", "label": "what"}
{"id": "12825", "raw_code": "public static double[] normalizeZscore(double[] x){\n  double mn=mean(x,0);\n  double sd=standardDeviation(x,0);\n  for (int i=0; i < x.length; i++)   if (!Double.isNaN(x[i]))   x[i]=(x[i] - mn) / sd;\n  return x;\n}", "comment": "calcualtes x _ i = ( x _ i - mean ( x ) ) / std ( x ) this function can deal with nans", "label": "what"}
{"id": "33031", "raw_code": "public JavaFormatter(String lineDelimiter,int initialIndentLevel,boolean useCodeFormatter,IJavaProject project){\n  fLineDelimiter=lineDelimiter;\n  fUseCodeFormatter=useCodeFormatter;\n  fInitialIndentLevel=initialIndentLevel;\n  fProject=project;\n}", "comment": "creates a javaformatter with the target line delimiter .", "label": "what"}
{"id": "55596", "raw_code": "private static void checkPathNeed(){\n  if (samplingInterval == -1) {\n    lastPreloadTime=readMorePaths();\n  }\n  if (!Double.isNaN(lastPreloadTime) && SimClock.getTime() >= lastPreloadTime - (samplingInterval * MIN_AHEAD_INTERVALS)) {\n    for (int i=0; i < nrofPreload && !Double.isNaN(lastPreloadTime); i++) {\n      lastPreloadTime=readMorePaths();\n    }\n  }\n}", "comment": "checks if more paths should be preloaded and preloads them if needed .", "label": "what"}
{"id": "22620", "raw_code": "private synchronized void rebuildJournal() throws IOException {\n  if (journalWriter != null) {\n    journalWriter.close();\n  }\n  Writer writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(journalFileTmp),Utils.US_ASCII));\n  try {\n    writer.write(MAGIC);\n    writer.write(\"\\n\");\n    writer.write(VERSION_1);\n    writer.write(\"\\n\");\n    writer.write(Integer.toString(appVersion));\n    writer.write(\"\\n\");\n    writer.write(Integer.toString(valueCount));\n    writer.write(\"\\n\");\n    writer.write(\"\\n\");\n    for (    Entry entry : lruEntries.values()) {\n      if (entry.currentEditor != null) {\n        writer.write(DIRTY + ' ' + entry.key+ '\\n');\n      }\n else {\n        writer.write(CLEAN + ' ' + entry.key+ entry.getLengths()+ '\\n');\n      }\n    }\n  }\n  finally {\n    writer.close();\n  }\n  if (journalFile.exists()) {\n    renameTo(journalFile,journalFileBackup,true);\n  }\n  renameTo(journalFileTmp,journalFile,false);\n  journalFileBackup.delete();\n  journalWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(journalFile,true),Utils.US_ASCII));\n}", "comment": "creates a new journal that omits redundant information .", "label": "what"}
{"id": "65099", "raw_code": "@SuppressWarnings(\"unchecked\") public void restore(String fileName) throws IOException, ClassNotFoundException {\n  ObjectInputStream ois=new ObjectInputStream(new FileInputStream(fileName));\n  locations=(Map<V,Point>)ois.readObject();\n  ois.close();\n  initializeLocations();\n  locked=true;\n  fireStateChanged();\n}", "comment": "restore the graph vertex locations from a file", "label": "what"}
{"id": "23833", "raw_code": "public void waitForData(){\n  if (this.initialized) {\n    return;\n  }\n  waitOnInitialization(this.initializationLatchAfterGetInitialImage);\n}", "comment": "wait until data is ready in this region", "label": "what"}
{"id": "12497", "raw_code": "private void blackmanHarris4sMin(int size){\n  int start=(windowFunction.length - size) / 2;\n  int stop=(windowFunction.length + size) / 2;\n  double scale=1.0 / (double)size / 0.36;\n  for (int i=0; start < stop; start++, i++)   windowFunction[i]=scale * (0.35875 - 0.48829 * Math.cos(twoPI * i / size) + 0.14128 * Math.cos(2 * twoPI * i / size) - 0.01168 * Math.cos(3 * twoPI * i / size));\n}", "comment": "fill an array with the values of a minimum 4 - sample blackman - harris window function", "label": "what"}
{"id": "16000", "raw_code": "private byte[] calculateCMSKeyChecksum(byte[] key){\n  byte[] result=new byte[8];\n  sha1.update(key,0,key.length);\n  sha1.doFinal(digest,0);\n  System.arraycopy(digest,0,result,0,8);\n  return result;\n}", "comment": "some key wrap algorithms make use of the key checksum defined in cms [ cms - algorithms ] .", "label": "what"}
{"id": "54094", "raw_code": "public KafkaCluster usingDirectory(File dataDir){\n  if (running)   throw new IllegalStateException(\"Unable to add a broker when the cluster is already running\");\n  if (dataDir != null && dataDir.exists() && !dataDir.isDirectory() && !dataDir.canWrite() && !dataDir.canRead()) {\n    throw new IllegalArgumentException(\"The directory must be readable and writable\");\n  }\n  this.dataDir=dataDir;\n  return this;\n}", "comment": "set the parent directory where the brokers logs and server ' s logs and snapshots will be kept .", "label": "what"}
{"id": "36292", "raw_code": "public static void registerOperators(String name,InputStream operatorsXML,ClassLoader classLoader){\n  registerOperators(name,operatorsXML,classLoader,null);\n}", "comment": "registers all operators from a given xml input stream .", "label": "what"}
{"id": "15058", "raw_code": "public void deleteSubGroupContainers(Set groupContainers) throws AMException, SSOException {\n  Iterator iter=groupContainers.iterator();\n  while (iter.hasNext()) {\n    String groupContainerDN=(String)iter.next();\n    AMGroupContainer groupContainer=new AMGroupContainerImpl(token,groupContainerDN);\n    groupContainer.delete();\n  }\n}", "comment": "deletes sub group containers in this group container .", "label": "what"}
{"id": "79155", "raw_code": "public GlowTask(Plugin owner,Runnable task,boolean sync,long delay,long period){\n  super(task,null);\n  taskId=nextTaskId.getAndIncrement();\n  description=task.toString();\n  this.owner=owner;\n  this.delay=delay;\n  this.period=period;\n  counter=0;\n  this.sync=sync;\n}", "comment": "creates a new task with the specified number of ticks between consecutive calls to execute ( ) .", "label": "what"}
{"id": "42286", "raw_code": "public static void init(String[] args){\n  try {\n    compiler.initCompiler(args);\n    if (VM.BuildForAdaptiveSystem && VM.BuildWithBaseBootImageCompiler) {\n      optCompiler.initCompiler(args);\n    }\n  }\n catch (  Throwable e) {\n    while (e != null) {\n      e.printStackTrace();\n      e=e.getCause();\n    }\n  }\n}", "comment": "initialize boot image compiler .", "label": "what"}
{"id": "75144", "raw_code": "int sendNextByte(){\n  int result=0;\n  try {\n    long tDiff=interByteTime - ((System.currentTimeMillis() - lastRxTime) * 1000000000);\n    if (tDiff > 0) {\n      log.debug(\"TX: waiting \" + tDiff + \" ns\");\n      Thread.sleep(tDiff / 1000000L,(int)(tDiff % 1000000L));\n    }\n  }\n catch (  InterruptedException ex) {\n    log.error(\"wait: \" + ex.toString());\n  }\n  if (currTxCharPos >= currTxTgm.length) {\n    result=dequeueTelegram();\n  }\n  if (result == 0) {\n    writeChar(currTxTgm[currTxCharPos++],true);\n    if (currTxCharPos >= currTxTgm.length) {\n      setProtStat(ProtStatus.RECEIVING);\n    }\n  }\n  return result;\n}", "comment": "send next available byte", "label": "what"}
{"id": "79709", "raw_code": "public static String encode(Serializable o){\n  ByteArrayOutputStream bos=new ByteArrayOutputStream();\n  try {\n    ObjectOutputStream oos=new ObjectOutputStream(bos);\n    try {\n      oos.writeObject(o);\n      oos.flush();\n    }\n  finally {\n      oos.close();\n    }\n    return Base64.encodeBytes(bos.toByteArray());\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}", "comment": "encode a object to a base64 string", "label": "what"}
{"id": "3192", "raw_code": "private static boolean isIdentifierName(String k){\n  int n=k.length();\n  if (n == 0) {\n    return false;\n  }\n  if (!Character.isJavaIdentifierStart(k.charAt(0))) {\n    return false;\n  }\n  for (int i=1; i < n; ++i) {\n    if (!Character.isJavaIdentifierPart(k.charAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}", "comment": "an ecmascript identifiername is an identifier or reserved word .", "label": "what"}
{"id": "52265", "raw_code": "private void moveSingleNode(Object source,Point newPoint){\n  DisplayNode node=(DisplayNode)source;\n  int deltaX=newPoint.x - clickPoint.x;\n  int deltaY=newPoint.y - clickPoint.y;\n  int newX=node.getLocation().x + deltaX;\n  int newY=node.getLocation().y + deltaY;\n  node.setLocation(newX,newY);\n}", "comment": "move a single , unselected node .", "label": "what"}
{"id": "79404", "raw_code": "public static <T>List<T> toList(T obj1,T obj2,T obj3){\n  List<T> list=new LinkedList<T>();\n  list.add(obj1);\n  list.add(obj2);\n  list.add(obj3);\n  return list;\n}", "comment": "create a list from passed objx parameters", "label": "what"}
{"id": "77796", "raw_code": "public byte[] readRawBytes(final int size) throws IOException {\n  if (size < 0) {\n    throw InvalidProtocolBufferNanoException.negativeSize();\n  }\n  if (bufferPos + size > currentLimit) {\n    skipRawBytes(currentLimit - bufferPos);\n    throw InvalidProtocolBufferNanoException.truncatedMessage();\n  }\n  if (size <= bufferSize - bufferPos) {\n    final byte[] bytes=new byte[size];\n    System.arraycopy(buffer,bufferPos,bytes,0,size);\n    bufferPos+=size;\n    return bytes;\n  }\n else {\n    throw InvalidProtocolBufferNanoException.truncatedMessage();\n  }\n}", "comment": "read a fixed size of bytes from the input .", "label": "what"}
{"id": "55383", "raw_code": "public synchronized void loadFromFile(){\n  entries.clear();\n  Path file=Paths.get(fileName);\n  try (BufferedReader reader=Files.newBufferedReader(file,CHARSET)){\n    String line;\n    do {\n      line=reader.readLine();\n      AddressbookEntry parsedEntry=parseLine(line);\n      if (parsedEntry != null) {\n        entries.put(parsedEntry.getName(),parsedEntry);\n      }\n    }\n while (line != null);\n  }\n catch (  IOException ex) {\n    LOGGER.warning(\"Error reading addressbook: \" + ex.getLocalizedMessage());\n  }\n  LOGGER.info(\"Read \" + entries.size() + \" addressbook entries from \"+ fileName);\n  scanCategories();\n}", "comment": "loads the addressbook from file .", "label": "what"}
{"id": "1928", "raw_code": "public boolean remove(final int position){\n  final AdapterTransaction removeTransaction=new RemoveTransaction<>(this,position);\n  final boolean success=removeTransaction.perform();\n  mTransactions.offer(removeTransaction);\n  return success;\n}", "comment": "removes item from the given position .", "label": "what"}
{"id": "50115", "raw_code": "public static void clearAssertionInformation(){\n  _AssertInfos.clear();\n  _AssertOccured=false;\n}", "comment": "clears internal assertion information storage", "label": "what"}
{"id": "24793", "raw_code": "public long startstack(){\n  return Long.parseLong(fields[27]);\n}", "comment": "the address of the start ( i . e . , bottom ) of the stack .", "label": "what"}
{"id": "1147", "raw_code": "public boolean match(MimeType other){\n  if (this == other)   return true;\n  if (type != null && other.type != null && !type.equals(other.type))   return false;\n  if (subtype != null && other.subtype != null && !subtype.equals(other.subtype))   return false;\n  return true;\n}", "comment": "checks if given mimetype is covered by current mimetype", "label": "what"}
{"id": "36554", "raw_code": "@Override public boolean isArmed(){\n  return other.isArmed();\n}", "comment": "all these methods simply delegate to the \" other \" model that is being decorated .", "label": "what"}
{"id": "70329", "raw_code": "public static boolean validSkinSpecFile(String fileName){\n  File file=new File(Configuration.skinsDir(),fileName);\n  if (!file.exists() || !file.isFile()) {\n    return false;\n  }\n  DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();\n  try {\n    DocumentBuilder builder=dbf.newDocumentBuilder();\n    Document doc=builder.parse(file);\n    NodeList listOfComponents=doc.getElementsByTagName(UI_ELEMENT);\n    if (listOfComponents.getLength() > 0) {\n      return true;\n    }\n else {\n      return false;\n    }\n  }\n catch (  Exception e) {\n    return false;\n  }\n}", "comment": "checks whether the given path points to a file that is a valid skin specification .", "label": "what"}
{"id": "84462", "raw_code": "public StrBuilder insert(final int index,final Object obj){\n  if (obj == null) {\n    return insert(index,nullText);\n  }\n  return insert(index,obj.toString());\n}", "comment": "inserts the string representation of an object into this builder .", "label": "what"}
{"id": "21568", "raw_code": "public boolean disableVMAX3Compression(URI blockObjectURI,StorageSystem storageSystem){\n  VirtualPool virtualPool=null;\n  StoragePool storagePool=null;\n  Volume volume=null;\n  if (URIUtil.isType(blockObjectURI,Volume.class)) {\n    volume=_dbClient.queryObject(Volume.class,blockObjectURI);\n  }\n else   if (URIUtil.isType(blockObjectURI,BlockSnapshot.class)) {\n    BlockSnapshot snapshot=_dbClient.queryObject(BlockSnapshot.class,blockObjectURI);\n    volume=_dbClient.queryObject(Volume.class,snapshot.getParent());\n  }\n else   if (URIUtil.isType(blockObjectURI,BlockMirror.class)) {\n    BlockMirror mirror=_dbClient.queryObject(BlockMirror.class,blockObjectURI);\n    virtualPool=_dbClient.queryObject(VirtualPool.class,mirror.getVirtualPool());\n    storagePool=_dbClient.queryObject(StoragePool.class,mirror.getPool());\n  }\n  if (volume != null) {\n    virtualPool=_dbClient.queryObject(VirtualPool.class,volume.getVirtualPool());\n    storagePool=_dbClient.queryObject(StoragePool.class,volume.getPool());\n  }\n  return (checkIfProviderSupportsCompressionOperations(storageSystem) && !virtualPool.getCompressionEnabled() && storagePool.getCompressionEnabled());\n}", "comment": "this method is will check if the storage pool associated with the volume supports compression .", "label": "what"}
{"id": "74689", "raw_code": "public static LatLon rhumbEndPosition(LatLon p,double rhumbAzimuthRadians,double pathLengthRadians){\n  if (p == null) {\n    throw new IllegalArgumentException(\"LatLon Is Null\");\n  }\n  return rhumbEndPosition(p,Angle.fromRadians(rhumbAzimuthRadians),Angle.fromRadians(pathLengthRadians));\n}", "comment": "computes the location on a rhumb line with the given starting location , rhumb azimuth , and arc distance along the line .", "label": "what"}
{"id": "7360", "raw_code": "public void update(long n){\n  uncounted.addAndGet(n);\n}", "comment": "update the moving average with a new value .", "label": "what"}
{"id": "30955", "raw_code": "private void logExpiration(Entry e){\n  if (e.renewalsDone()) {\n    logger.log(Level.FINE,\"Reached desired expiration for lease {0}\",e.lease);\n  }\n else {\n    logger.log(Levels.FAILED,\"Lease {0} expired before reaching desired expiration\",e.lease);\n  }\n}", "comment": "logs a lease expiration , distinguishing between expected and premature expirations .", "label": "what"}
{"id": "44043", "raw_code": "void removeRipple(Ripple ripple){\n  final Ripple[] ripples=mExitingRipples;\n  final int count=mExitingRipplesCount;\n  final int index=getRippleIndex(ripple);\n  if (index >= 0) {\n    System.arraycopy(ripples,index + 1,ripples,index,count - (index + 1));\n    ripples[count - 1]=null;\n    mExitingRipplesCount--;\n    invalidateSelf();\n  }\n}", "comment": "removes a ripple from the exiting ripple list .", "label": "what"}
{"id": "64265", "raw_code": "protected final void writeS(ByteBuffer buf,String text){\n  if (text == null) {\n    buf.putChar('\\000');\n  }\n else {\n    final int len=text.length();\n    for (int i=0; i < len; i++) {\n      buf.putChar(text.charAt(i));\n    }\n    buf.putChar('\\000');\n  }\n}", "comment": "write string to buffer", "label": "what"}
{"id": "54108", "raw_code": "protected SourceRecords consumeRecordsByTopic(int numRecords) throws InterruptedException {\n  SourceRecords records=new SourceRecords();\n  consumeRecords(numRecords,null);\n  return records;\n}", "comment": "try to consume and capture exactly the specified number of records from the connector .", "label": "what"}
{"id": "16569", "raw_code": "@Override public boolean equals(Object o){\n  if (this == o) {\n    return true;\n  }\n  if (!(o instanceof PrototypeSize)) {\n    return false;\n  }\n  PrototypeSize size=(PrototypeSize)o;\n  return prototype.equals(size.prototype);\n}", "comment": "indicates whether some other constantsize is \" equal to \" this one .", "label": "what"}
{"id": "64231", "raw_code": "public static boolean isValidVector(Vector2f vector){\n  if (vector == null) {\n    return false;\n  }\n  if (Float.isNaN(vector.x) || Float.isNaN(vector.y)) {\n    return false;\n  }\n  if (Float.isInfinite(vector.x) || Float.isInfinite(vector.y)) {\n    return false;\n  }\n  return true;\n}", "comment": "check a vector . . .", "label": "what"}
{"id": "80038", "raw_code": "public boolean isObsessional(){\n  return typeString.contains(SUFFIX_OBSESSIONAL);\n}", "comment": "determine if the expression is a obsessional one .", "label": "what"}
{"id": "47875", "raw_code": "public boolean remove(Object targetChild){\n  return remove(targetChild,true);\n}", "comment": "removes a child from this beancontext .", "label": "what"}
{"id": "28959", "raw_code": "private void notifyClassObservers(ClassDescriptor classDescriptor){\n  for (  IClassObserver observer : classObserverList) {\n    observer.observeClass(classDescriptor);\n  }\n}", "comment": "notify all iclassobservers that we are visiting given class .", "label": "what"}
{"id": "46930", "raw_code": "public void dup2(){\n  mv.visitInsn(Opcodes.DUP2);\n}", "comment": "generates a dup2 instruction .", "label": "what"}
{"id": "64185", "raw_code": "static boolean isAppXml(String mime){\n  return mime != null && (mime.equals(\"application/xml\") || mime.equals(\"application/xml-dtd\") || mime.equals(\"application/xml-external-parsed-entity\")|| mime.startsWith(\"application/\") && mime.endsWith(\"+xml\"));\n}", "comment": "indicates if the mime type belongs to the application xml family .", "label": "what"}
{"id": "38326", "raw_code": "public CustomEditor(){\n  setLayout(new BorderLayout());\n  add(m_Label,BorderLayout.CENTER);\n  m_DeleteBut.addActionListener(m_InnerActionListener);\n  m_EditBut.addActionListener(m_InnerActionListener);\n  m_UpBut.addActionListener(m_InnerActionListener);\n  m_DownBut.addActionListener(m_InnerActionListener);\n  m_AddBut.addActionListener(m_InnerActionListener);\n  m_ElementList.addListSelectionListener(m_InnerSelectionListener);\n  m_ElementList.addMouseListener(m_InnerMouseListener);\n  m_AddBut.setToolTipText(\"Add the current item to the list\");\n  m_DeleteBut.setToolTipText(\"Delete the selected list item\");\n  m_EditBut.setToolTipText(\"Edit the selected list item\");\n  m_UpBut.setToolTipText(\"Move the selected item(s) one up\");\n  m_DownBut.setToolTipText(\"Move the selected item(s) one down\");\n}", "comment": "sets up the array editor .", "label": "what"}
{"id": "7166", "raw_code": "public static EPType singleValue(Class singleValueType){\n  if (singleValueType != null && singleValueType.isArray()) {\n    return new ClassMultiValuedEPType(singleValueType,singleValueType.getComponentType());\n  }\n  return new ClassEPType(singleValueType);\n}", "comment": "indicate that the expression return type is a single ( non - enumerable ) value of the given type .", "label": "what"}
{"id": "15417", "raw_code": "void addXMLElementAfterTokenIndex(int lastTokenIndex,XMLElement element,boolean addAfterNewLine) throws Exception {\n  addXMLElementAfterTokenIndex(lastTokenIndex,element,addAfterNewLine,true);\n}", "comment": "adds the given xmlelement after the token whoes index matches the given lasttokenindex value .", "label": "what"}
{"id": "76780", "raw_code": "public Dictionary(Directory tempDir,String tempFileNamePrefix,InputStream affix,List<InputStream> dictionaries,boolean ignoreCase) throws IOException, ParseException {\n  this.ignoreCase=ignoreCase;\n  this.needsInputCleaning=ignoreCase;\n  this.needsOutputCleaning=false;\n  flagLookup.add(new BytesRef());\n  Path aff=Files.createTempFile(tempPath,\"affix\",\"aff\");\n  OutputStream out=new BufferedOutputStream(Files.newOutputStream(aff));\n  InputStream aff1=null;\n  InputStream aff2=null;\n  boolean success=false;\n  try {\n    final byte[] buffer=new byte[1024 * 8];\n    int len;\n    while ((len=affix.read(buffer)) > 0) {\n      out.write(buffer,0,len);\n    }\n    out.close();\n    aff1=new BufferedInputStream(Files.newInputStream(aff));\n    String encoding=getDictionaryEncoding(aff1);\n    CharsetDecoder decoder=getJavaEncoding(encoding);\n    aff2=new BufferedInputStream(Files.newInputStream(aff));\n    readAffixFile(aff2,decoder);\n    IntSequenceOutputs o=IntSequenceOutputs.getSingleton();\n    Builder<IntsRef> b=new Builder<>(FST.INPUT_TYPE.BYTE4,o);\n    readDictionaryFiles(tempDir,tempFileNamePrefix,dictionaries,decoder,b);\n    words=b.finish();\n    aliases=null;\n    morphAliases=null;\n    success=true;\n  }\n  finally {\n    IOUtils.closeWhileHandlingException(out,aff1,aff2);\n    if (success) {\n      Files.delete(aff);\n    }\n else {\n      IOUtils.deleteFilesIgnoringExceptions(aff);\n    }\n  }\n}", "comment": "creates a new dictionary containing the information read from the provided inputstreams to hunspell affix and dictionary files .", "label": "what"}
{"id": "70127", "raw_code": "public void collapseBuilding(Building bldg){\n  buildings.removeElement(bldg);\n  Enumeration<Coords> bldgCoords=bldg.getCoords();\n  while (bldgCoords.hasMoreElements()) {\n    final Coords coords=bldgCoords.nextElement();\n    collapseBuilding(coords);\n  }\n}", "comment": "the given building has collapsed .", "label": "what"}
{"id": "59999", "raw_code": "private String readNfcErrorMsg(ByteBuffer reply) throws IOException {\n  int errorType=reply.getInt();\n  int errorCode=reply.getInt();\n  int msgLen=reply.getInt();\n  if (msgLen == 0) {\n    return \"\";\n  }\n  ByteBuffer msgBuffer=ByteBuffer.allocate(msgLen);\n  readFully(msgBuffer);\n  String errorMsg=new String(msgBuffer.array(),0,msgLen - 1,Charsets.US_ASCII);\n  return String.format(\"NFC Error %d/%d: %s\",errorType,errorCode,errorMsg);\n}", "comment": "read nfc error from reply message .", "label": "what"}
{"id": "59828", "raw_code": "private void show(boolean show){\n  if (show) {\n    if (mXFade != null) {\n      mXFade.cancel();\n    }\n    mState=STATE_PIE;\n    mCurrentItem=null;\n    PieItem root=getRoot();\n    for (    PieItem openItem : mOpen) {\n      if (openItem.hasItems()) {\n        for (        PieItem item : openItem.getItems()) {\n          item.setSelected(false);\n        }\n      }\n    }\n    mLabel.setText(\"\");\n    mOpen.clear();\n    mOpen.add(root);\n    layoutPie();\n    fadeIn();\n  }\n else {\n    mState=STATE_IDLE;\n    mTapMode=false;\n    if (mXFade != null) {\n      mXFade.cancel();\n    }\n    if (mLabel != null) {\n      mLabel.setText(\"\");\n    }\n  }\n  setVisible(show);\n  mHandler.sendEmptyMessage(show ? MSG_OPEN : MSG_CLOSE);\n}", "comment": "guaranteed has center set", "label": "what"}
{"id": "21927", "raw_code": "private synchronized void persistProfileAndNotifyChange(AuthnProvider modifiedProvider,boolean newObject){\n  modifiedProvider.setLastModified(System.currentTimeMillis());\n  if (newObject) {\n    _dbClient.createObject(modifiedProvider);\n  }\n else {\n    _dbClient.persistObject(modifiedProvider);\n  }\n  notifyChange();\n}", "comment": "update the timestamp and notify", "label": "what"}
{"id": "73316", "raw_code": "public void addUndoableAction(UndoableAction action){\n  undoStack.push(action);\n  redoStack.removeAllElements();\n}", "comment": "add a new undoable action .", "label": "what"}
{"id": "10183", "raw_code": "public IntArrayList(int[] data){\n  array=new int[(int)(data.length * 1.1) + 1];\n  size=data.length;\n  System.arraycopy(data,0,array,0,size);\n}", "comment": "constructs a list containing the elements of the specified array .", "label": "what"}
{"id": "87062", "raw_code": "public StringBuilder encodeBody(StringBuilder buffer){\n  return buffer.append(contentEncoding);\n}", "comment": "canonical encoding of body of the header .", "label": "what"}
{"id": "44936", "raw_code": "public String substring(String subject,int start,int stop){\n  if (stop == -1 || stop >= subject.length()) {\n    return subject.substring(start);\n  }\n  return subject.substring(start,stop);\n}", "comment": "get a substring from a string", "label": "what"}
{"id": "81026", "raw_code": "public void removeCustomSashFormListener(ICustomSashFormListener listener){\n  if (customSashFormListeners != null) {\n    customSashFormListeners.remove(listener);\n  }\n}", "comment": "removes the custom sashform listener .", "label": "what"}
{"id": "70684", "raw_code": "protected void deleteSessionVariables(String sessionId,String... varNames){\n  if (sessionId.equals(\"\")) {\n    return;\n  }\n  Key key=keyFactory.newKey(sessionId);\n  Transaction transaction=datastore.newTransaction();\n  try {\n    Entity stateEntity=transaction.get(key);\n    Entity.Builder builder=Entity.builder(stateEntity);\n    StringBuilder delNames=new StringBuilder();\n    for (    String varName : varNames) {\n      delNames.append(varName + \" \");\n      builder=builder.remove(varName);\n    }\n    datastore.update(builder.build());\n  }\n catch (  NullPointerException e) {\n  }\n finally {\n    if (transaction.active()) {\n      transaction.rollback();\n    }\n  }\n}", "comment": "delete a value stored in the project ' s datastore .", "label": "what"}
{"id": "86743", "raw_code": "@Override public void close() throws IOException {\n  if (mBufferCount > 0) {\n    try {\n      mQueue.write(mBuffer,0,mBufferCount);\n    }\n catch (    InterruptedException e) {\n      throw new IOException(\"GzipAsynchOutputStream interrupted during write/3\");\n    }\n    mBufferCount=0;\n  }\n  mQueue.close();\n  try {\n    mThread.join();\n  }\n catch (  InterruptedException e) {\n    throw new IOException(\"AsynchOutputStream interrupted during close\");\n  }\n finally {\n    super.close();\n  }\n  checkException();\n}", "comment": "this also io errors that happened in the gzip thread .", "label": "what"}
{"id": "64675", "raw_code": "public static int parseStringAsInt(String in) throws IndexParseFieldException {\n  try {\n    return Integer.parseInt(in);\n  }\n catch (  NumberFormatException e) {\n    throw new IndexParseFieldException(in,e);\n  }\n}", "comment": "parses a string as a int .", "label": "what"}
{"id": "25831", "raw_code": "public void writeAll(ResultSet rs,boolean includeColumnNames,boolean trim) throws SQLException, IOException {\n  if (includeColumnNames) {\n    writeColumnNames(rs);\n  }\n  while (rs.next()) {\n    writeNext(resultService.getColumnValues(rs,trim));\n  }\n}", "comment": "writes the entire resultset to a csv file .", "label": "what"}
{"id": "57004", "raw_code": "private static void verifyDevice(IDevice d,long mac,Short vlan,Integer ip,long swId,int port){\n  assertNotNull(d);\n  assertEquals(MacAddress.of(mac),d.getMACAddress());\n  if (vlan == null)   assertArrayEquals(new VlanVid[]{VlanVid.ofVlan(-1)},d.getVlanId());\n else   assertArrayEquals(new VlanVid[]{VlanVid.ofVlan(vlan)},d.getVlanId());\n  if (ip == null)   assertArrayEquals(new IPv4Address[]{IPv4Address.of(0)},d.getIPv4Addresses());\n else   assertArrayEquals(new IPv4Address[]{IPv4Address.of(ip)},d.getIPv4Addresses());\n  SwitchPort expectedAp=new SwitchPort(DatapathId.of(swId),OFPort.of(port));\n  assertArrayEquals(new SwitchPort[]{expectedAp},d.getAttachmentPoints());\n}", "comment": "verify that the given device exactly matches the given fields .", "label": "what"}
{"id": "5477", "raw_code": "public Hashtable<IPoint,List<ILineSegment>> intersections(Iterator<ILineSegment> it){\n  Collection<ILineSegment> c=new ArrayList<ILineSegment>();\n  while (it.hasNext()) {\n    c.add(it.next());\n  }\n  return intersections(c.toArray(new ILineSegment[]{}));\n}", "comment": "compute the intersection of all segments when given an iterator of segments .", "label": "what"}
{"id": "82051", "raw_code": "public boolean isTTFNativeFont(){\n  return ttf;\n}", "comment": "indicates if this is a ttf native font that can be derived and manipulated .", "label": "what"}
{"id": "33273", "raw_code": "private void registerProviders(){\n  final DevMachine devMachine=appContext.getDevMachine();\n  if (devMachine == null) {\n    return;\n  }\n  final Set<Macro> providers=getMacros(devMachine);\n  checkNotNull(providers);\n  if (providers.isEmpty()) {\n    return;\n  }\n  providerRegistry.register(providers);\n}", "comment": "register macro providers which returns the implementation .", "label": "what"}
{"id": "62357", "raw_code": "public LongMap(int initialCapacity,float loadFactor){\n  if (initialCapacity < 0)   throw new IllegalArgumentException(\"initialCapacity must be >= 0: \" + initialCapacity);\n  if (capacity > 1 << 30)   throw new IllegalArgumentException(\"initialCapacity is too large: \" + initialCapacity);\n  capacity=MathUtils.nextPowerOfTwo(initialCapacity);\n  if (loadFactor <= 0)   throw new IllegalArgumentException(\"loadFactor must be > 0: \" + loadFactor);\n  this.loadFactor=loadFactor;\n  threshold=(int)(capacity * loadFactor);\n  mask=capacity - 1;\n  hashShift=31 - Integer.numberOfTrailingZeros(capacity);\n  stashCapacity=Math.max(3,(int)Math.ceil(Math.log(capacity)) + 1);\n  pushIterations=Math.max(Math.min(capacity,32),(int)Math.sqrt(capacity) / 4);\n  keyTable=new long[capacity + stashCapacity];\n  valueTable=(V[])new Object[keyTable.length];\n}", "comment": "creates a new map with the specified initial capacity and load factor .", "label": "what"}
{"id": "23066", "raw_code": "protected ASN1Set(ASN1Encodable obj){\n  set.addElement(obj);\n}", "comment": "create a sequence containing one object", "label": "what"}
{"id": "32228", "raw_code": "public void addNearKey(KeyCacheObject key,GridCacheSharedContext ctx) throws IgniteCheckedException {\n  nearKeys.add(key);\n}", "comment": "adds a near key .", "label": "what"}
{"id": "59672", "raw_code": "private void analyzeClassFields(String className,int action){\n  try {\n    Class<?> dynamicClass=Class.forName(className);\n    Field[] fields=dynamicClass.getDeclaredFields();\n    for (    Field field : fields) {\n      if (isPrivateAndNonPrimitive(field)) {\n        oneToAnyConditions(className,field,action);\n        manyToAnyConditions(className,field,action);\n      }\n    }\n  }\n catch (  ClassNotFoundException ex) {\n    ex.printStackTrace();\n    throw new DatabaseGenerateException(DatabaseGenerateException.CLASS_NOT_FOUND + className);\n  }\n}", "comment": "introspection of the passed in class .", "label": "what"}
{"id": "37228", "raw_code": "public static void loadAll(final JFrame parent,final IDebugger debugger,final IAddress offset,final int size){\n  checkArguments(parent,debugger,offset);\n  final CDumpAllWaiter waiter=new CDumpAllWaiter(debugger,offset,size);\n  CProgressDialog.showEndless(parent,\"Loading memory\" + \" ...\",waiter);\n  if (waiter.getException() != null) {\n    CUtilityFunctions.logException(waiter.getException());\n    final String innerMessage=\"E00078: \" + \"Could not load memory section\";\n    final String innerDescription=CUtilityFunctions.createDescription(String.format(\"The memory section starting at address '%s' could not loaded.\",offset.toHexString()),new String[]{\"There was a problem with the connection to the debug client.\"},new String[]{\"The memory data was not loaded.\"});\n    NaviErrorDialog.show(parent,innerMessage,innerDescription,waiter.getException());\n  }\n}", "comment": "loads all data of a memory section .", "label": "what"}
{"id": "85658", "raw_code": "public static boolean deleteDirectory(String directory,boolean useOSNativeDelete) throws IOException {\n  boolean result=false;\n  if (!useOSNativeDelete) {\n    File dir=new File(directory);\n    for (    File file : dir.listFiles()) {\n      if (file.delete()) {\n        log.debug(\"{} was deleted\",file.getName());\n      }\n else {\n        log.debug(\"{} was not deleted\",file.getName());\n        file.deleteOnExit();\n      }\n      file=null;\n    }\n    if (dir.delete()) {\n      log.debug(\"Directory was deleted\");\n      result=true;\n    }\n else {\n      log.debug(\"Directory was not deleted, it may be deleted on exit\");\n      dir.deleteOnExit();\n    }\n    dir=null;\n  }\n else {\n    Process p=null;\n    Thread std=null;\n    try {\n      Runtime runTime=Runtime.getRuntime();\n      log.debug(\"Execute runtime\");\n      if (File.separatorChar == '\\\\') {\n        p=runTime.exec(\"CMD /D /C \\\"RMDIR /Q /S \" + directory.replace('/','\\\\') + \"\\\"\");\n      }\n else {\n        p=runTime.exec(\"rm -rf \" + directory.replace('\\\\',File.separatorChar));\n      }\n      std=stdOut(p);\n      while (std.isAlive()) {\n        try {\n          Thread.sleep(250);\n        }\n catch (        Exception e) {\n        }\n      }\n      log.debug(\"Process threads wait exited\");\n      result=true;\n    }\n catch (    Exception e) {\n      log.error(\"Error running delete script\",e);\n    }\n finally {\n      if (null != p) {\n        log.debug(\"Destroying process\");\n        p.destroy();\n        p=null;\n      }\n      std=null;\n    }\n  }\n  return result;\n}", "comment": "deletes a directory and its contents .", "label": "what"}
{"id": "6531", "raw_code": "public static String findEditTable(String tables){\n  if (!StringUtils.isEmpty(tables)) {\n    int spacepos=tables.indexOf(' ');\n    int commapos=tables.indexOf(',');\n    if (spacepos > 0 && (spacepos < commapos || commapos < 0)) {\n      return tables.substring(0,spacepos);\n    }\n else     if (commapos > 0 && (commapos < spacepos || spacepos < 0)) {\n      return tables.substring(0,commapos);\n    }\n    return tables;\n  }\n else {\n    throw new IllegalStateException(\"Invalid tables\");\n  }\n}", "comment": "finds the name of the first table , which is editable .", "label": "what"}
{"id": "55237", "raw_code": "private boolean hasNewFollowers(List<Follower> followers){\n  return !followers.isEmpty() && followers.get(0).newFollower;\n}", "comment": "checks if this has new followers .", "label": "what"}
{"id": "16134", "raw_code": "private void onTrackPointElementStart(Attributes attributes) throws SAXException {\n  String latitude=attributes.getValue(ATT_LAT);\n  String longitude=attributes.getValue(ATT_LON);\n  if (latitude == null || longitude == null) {\n    throw new SAXException(createErrorMessage(\"Point with no longitude or latitude.\"));\n  }\n  try {\n    latitudeValue=Double.parseDouble(latitude);\n    longitudeValue=Double.parseDouble(longitude);\n  }\n catch (  NumberFormatException e) {\n    throw new SAXException(createErrorMessage(\"Unable to parse latitude/longitude: \" + latitude + \"/\"+ longitude),e);\n  }\n}", "comment": "on track point element start .", "label": "what"}
{"id": "40461", "raw_code": "static int checkDesc(final String desc,final int start,final boolean canBeVoid){\n  if (desc == null || start >= desc.length()) {\n    throw new IllegalArgumentException(\"Invalid type descriptor (must not be null or empty)\");\n  }\n  int index;\nswitch (desc.charAt(start)) {\ncase 'V':\n    if (canBeVoid) {\n      return start + 1;\n    }\n else {\n      throw new IllegalArgumentException(\"Invalid descriptor: \" + desc);\n    }\ncase 'Z':\ncase 'C':\ncase 'B':\ncase 'S':\ncase 'I':\ncase 'F':\ncase 'J':\ncase 'D':\n  return start + 1;\ncase '[':\nindex=start + 1;\nwhile (index < desc.length() && desc.charAt(index) == '[') {\n++index;\n}\nif (index < desc.length()) {\nreturn checkDesc(desc,index,false);\n}\n else {\nthrow new IllegalArgumentException(\"Invalid descriptor: \" + desc);\n}\ncase 'L':\nindex=desc.indexOf(';',start);\nif (index == -1 || index - start < 2) {\nthrow new IllegalArgumentException(\"Invalid descriptor: \" + desc);\n}\ntry {\ncheckInternalName(desc,start + 1,index,null);\n}\n catch (IllegalArgumentException unused) {\nthrow new IllegalArgumentException(\"Invalid descriptor: \" + desc);\n}\nreturn index + 1;\ndefault :\nthrow new IllegalArgumentException(\"Invalid descriptor: \" + desc);\n}\n}", "comment": "checks that a the given substring is a valid type descriptor .", "label": "what"}
{"id": "37492", "raw_code": "private void drawBackground(final Graphics g){\n  g.setColor(m_bgColorOffset);\n  g.fillRect(-m_firstColumn * m_charWidth,0,m_offsetViewWidth,getHeight());\n}", "comment": "draws the background of the view .", "label": "what"}
{"id": "20556", "raw_code": "public void limitTransAndScale(Matrix matrix,RectF content){\n  float[] vals=new float[9];\n  matrix.getValues(vals);\n  float curTransX=vals[Matrix.MTRANS_X];\n  float curScaleX=vals[Matrix.MSCALE_X];\n  float curTransY=vals[Matrix.MTRANS_Y];\n  float curScaleY=vals[Matrix.MSCALE_Y];\n  mScaleX=Math.max(mMinScaleX,curScaleX);\n  mScaleY=Math.max(mMinScaleY,curScaleY);\n  float width=0f;\n  float height=0f;\n  if (content != null) {\n    width=content.width();\n    height=content.height();\n  }\n  float maxTransX=-width * (mScaleX - 1f);\n  float newTransX=Math.min(Math.max(curTransX,maxTransX - mTransOffsetX),mTransOffsetX);\n  float maxTransY=height * (mScaleY - 1f);\n  float newTransY=Math.max(Math.min(curTransY,maxTransY + mTransOffsetY),-mTransOffsetY);\n  vals[Matrix.MTRANS_X]=newTransX;\n  vals[Matrix.MSCALE_X]=mScaleX;\n  vals[Matrix.MTRANS_Y]=newTransY;\n  vals[Matrix.MSCALE_Y]=mScaleY;\n  matrix.setValues(vals);\n}", "comment": "limits the maximum scale and x translation of the given matrix", "label": "what"}
{"id": "13929", "raw_code": "public StatefulRefreshToken(JsonValue token) throws InvalidGrantException {\n  super(token);\n  if (!OAUTH_REFRESH_TOKEN.equals(getTokenName())) {\n    throw new InvalidGrantException(\"Token is not an refresh token: \" + getTokenId());\n  }\n}", "comment": "constructs a new refreshtoken backed with the data in the specified jsonvalue .", "label": "what"}
{"id": "71734", "raw_code": "public void putStyle(String styleId,StyleSelector styleSelector){\n  try {\n    int id=Integer.parseInt(styleId);\n    mMaxStyleId=Math.max(mMaxStyleId,id);\n  }\n catch (  NumberFormatException e) {\n  }\n  mStyles.put(styleId,styleSelector);\n}", "comment": "put the styleselector ( style or stylemap ) in the list of shared styles , associated to its styleid", "label": "what"}
{"id": "79187", "raw_code": "public static boolean isPlaceAction(InventoryAction action){\nswitch (action) {\ncase SWAP_WITH_CURSOR:\ncase PLACE_ONE:\ncase PLACE_ALL:\ncase PLACE_SOME:\n    return true;\n}\nreturn false;\n}", "comment": "check if a given inventoryaction involves placing items into the slot .", "label": "what"}
{"id": "45115", "raw_code": "private void refreshMarkers(){\n  removeAll();\n  Map markerMap=new HashMap();\n  List notices=textArea.getParserNotices();\n  for (Iterator i=notices.iterator(); i.hasNext(); ) {\n    ParserNotice notice=(ParserNotice)i.next();\n    if (notice.getLevel() <= levelThreshold || (notice instanceof TaskNotice)) {\n      Integer key=new Integer(notice.getLine());\n      Marker m=(Marker)markerMap.get(key);\n      if (m == null) {\n        m=new Marker(notice);\n        m.addMouseListener(listener);\n        markerMap.put(key,m);\n        add(m);\n      }\n else {\n        m.addNotice(notice);\n      }\n    }\n  }\n  if (getShowMarkedOccurrences() && textArea.getMarkOccurrences()) {\n    List occurrences=textArea.getMarkedOccurrences();\n    for (Iterator i=occurrences.iterator(); i.hasNext(); ) {\n      DocumentRange range=(DocumentRange)i.next();\n      int line=0;\n      try {\n        line=textArea.getLineOfOffset(range.getStartOffset());\n      }\n catch (      BadLocationException ble) {\n        continue;\n      }\n      ParserNotice notice=new MarkedOccurrenceNotice(range);\n      Integer key=new Integer(line);\n      Marker m=(Marker)markerMap.get(key);\n      if (m == null) {\n        m=new Marker(notice);\n        m.addMouseListener(listener);\n        markerMap.put(key,m);\n        add(m);\n      }\n else {\n        if (!m.containsMarkedOccurence()) {\n          m.addNotice(notice);\n        }\n      }\n    }\n  }\n  revalidate();\n  repaint();\n}", "comment": "refreshes the markers displayed in this error strip .", "label": "what"}
{"id": "6519", "raw_code": "public void playMedia(boolean showPlayerWindow){\n  String filename=stopAndPrepareFilename();\n  if (filename.length() > 0) {\n    MPlayerMediator mplayerMediator=MPlayerMediator.instance();\n    if (mplayerMediator != null) {\n      mplayerMediator.showPlayerWindow(showPlayerWindow);\n    }\n    mplayer.open(filename,getAdjustedVolume());\n  }\n  notifyState(getState());\n}", "comment": "force showing or not the media player window", "label": "what"}
{"id": "11947", "raw_code": "public static String toUTF8String(String s){\n  return new String(s.getBytes(),Charset.forName(PanboxConstants.STANDARD_CHARSET));\n}", "comment": "string conversion into standard charset", "label": "what"}
{"id": "32276", "raw_code": "public static int encodeCacheFlags(Collection<GridClientCacheFlag> flagSet){\n  int bits=0;\n  if (flagSet.contains(GridClientCacheFlag.SKIP_STORE))   bits|=1;\n  return bits;\n}", "comment": "encodes cache flags to bit map .", "label": "what"}
{"id": "37150", "raw_code": "private JPanel buildRow(final String string,final JCheckBox checkBox){\n  final JPanel panel=new JPanel(new BorderLayout());\n  panel.add(new JLabel(string),BorderLayout.WEST);\n  panel.add(checkBox,BorderLayout.EAST);\n  checkBox.addItemListener(m_checkBoxListener);\n  return panel;\n}", "comment": "builds a checkbox row .", "label": "what"}
{"id": "716", "raw_code": "public static boolean isChildGroup(String group){\n  return group.indexOf(GROUP_DELIMITER) != -1;\n}", "comment": "indicates if a group is a child group , a non - top - level data group in a set of nested data groups ( e . g . , the node or edge table of a graph or tree ) .", "label": "what"}
{"id": "49476", "raw_code": "private LocusInfo createNextUncoveredLocusInfo(final Locus stopBeforeLocus){\n  while (lastReferenceSequence <= stopBeforeLocus.getSequenceIndex() && lastReferenceSequence <= referenceSequenceMask.getMaxSequenceIndex()) {\n    if (lastReferenceSequence == stopBeforeLocus.getSequenceIndex() && lastPosition + 1 >= stopBeforeLocus.getPosition()) {\n      return null;\n    }\n    final int nextbit=referenceSequenceMask.nextPosition(lastReferenceSequence,lastPosition);\n    if (nextbit == -1) {\n      if (lastReferenceSequence == stopBeforeLocus.getSequenceIndex()) {\n        lastPosition=stopBeforeLocus.getPosition();\n        return null;\n      }\n      lastReferenceSequence++;\n      lastPosition=0;\n    }\n else     if (lastReferenceSequence < stopBeforeLocus.getSequenceIndex() || nextbit < stopBeforeLocus.getPosition()) {\n      lastPosition=nextbit;\n      return new LocusInfo(getReferenceSequence(lastReferenceSequence),lastPosition);\n    }\n else     if (nextbit >= stopBeforeLocus.getPosition()) {\n      return null;\n    }\n  }\n  return null;\n}", "comment": "create the next relevant zero - coverage locusinfo", "label": "what"}
{"id": "7046", "raw_code": "public static void launchEmailIntent(final Activity activity,String addr,String text){\n  Log.i(LOG_TAG,\"Launch email intent from \" + activity.getLocalClassName());\n  Intent emailIntent=new Intent(Intent.ACTION_SEND);\n  emailIntent.putExtra(Intent.EXTRA_EMAIL,new String[]{addr});\n  emailIntent.setType(\"text/plain\");\n  PackageManager emailpackageManager=activity.getPackageManager();\n  List<ResolveInfo> emailresolveInfos=emailpackageManager.queryIntentActivities(emailIntent,0);\n  if (emailresolveInfos.size() > 0) {\n    activity.startActivity(emailIntent);\n  }\n}", "comment": "launch an email intent if the device is capable .", "label": "what"}
{"id": "28487", "raw_code": "public void add(int position,T item){\n  mData.add(position,item);\n  notifyItemInserted(position);\n}", "comment": "insert a item associated with the specified position of adapter", "label": "what"}
{"id": "10982", "raw_code": "public void writeLEChars(String s) throws IOException {\n  int length=s.length();\n  for (int i=0; i < length; i++) {\n    int c=s.charAt(i);\n    out.write(c & 0xFF);\n    out.write((c >>> 8) & 0xFF);\n  }\n  written+=length * 2;\n}", "comment": "writes a string in little endian", "label": "what"}
{"id": "44040", "raw_code": "@Deprecated public boolean isValid(String regex){\n  if (regex == null) {\n    return false;\n  }\n  Pattern pattern=Pattern.compile(regex);\n  Matcher matcher=pattern.matcher(getText());\n  return matcher.matches();\n}", "comment": "if the main text matches the regex", "label": "what"}
{"id": "77549", "raw_code": "public void addCloseHook(CloseHook hook){\n  if (closeHooks == null) {\n    closeHooks=new ArrayList<>();\n  }\n  closeHooks.add(hook);\n}", "comment": "add a close callback hook", "label": "what"}
{"id": "16292", "raw_code": "private void updateRange(double x,double y){\n  mMinX=Math.min(mMinX,x);\n  mMaxX=Math.max(mMaxX,x);\n  mMinY=Math.min(mMinY,y);\n  mMaxY=Math.max(mMaxY,y);\n}", "comment": "updates the range on both axes .", "label": "what"}
{"id": "37232", "raw_code": "private static void createCombinedTrace(final TraceList newTrace,final List<TraceList> traces,final Set<BreakpointAddress> addresses){\n  final Set<BreakpointAddress> visitedAddresses=new LinkedHashSet<BreakpointAddress>();\n  for (  final TraceList trace : traces) {\n    for (    final ITraceEvent event : trace) {\n      final BreakpointAddress address=event.getOffset();\n      if (!addresses.contains(address)) {\n        continue;\n      }\n      if (visitedAddresses.contains(address)) {\n        continue;\n      }\n      visitedAddresses.add(address);\n      newTrace.addEvent(event);\n    }\n  }\n}", "comment": "fills a combined trace from the events of multiple input traces .", "label": "what"}
{"id": "27588", "raw_code": "public void interruptAll(){\nsynchronized (knownActorTasks) {\n    for (    Future<Void> ft : knownActorTasks) {\n      ft.cancel(true);\n    }\n    threadGuard.interruptAll();\n  }\n}", "comment": "ensure that any guarded regions are interrupted .", "label": "what"}
{"id": "53898", "raw_code": "@SuppressWarnings(\"unchecked\") public void registerDefaultDeviceTypes(){\n  final HashMap<String,String> devicesList=DefaultPlatform.getDeviceServiceMap();\n  for (  HashMap.Entry<String,String> entry : devicesList.entrySet()) {\n    String key=entry.getKey();\n    String value=entry.getValue();\n    try {\n      registerDeviceService((Class<DeviceService>)Class.forName(key),(Class<DiscoveryProvider>)Class.forName(value));\n    }\n catch (    ClassNotFoundException e) {\n      e.printStackTrace();\n    }\n  }\n}", "comment": "registers a commonly - used set of deviceservices with discoverymanager .", "label": "what"}
{"id": "52616", "raw_code": "private void drawTicks(Canvas canvas,double min,double max,double minAngle,double maxAngle,int centerX,int centerY,double longRadius,double shortRadius,double ticks,Paint paint,boolean labels){\n  for (double i=min; i <= max; i+=ticks) {\n    double angle=getAngleForValue(i,minAngle,maxAngle,min,max);\n    double sinValue=Math.sin(angle);\n    double cosValue=Math.cos(angle);\n    int x1=Math.round(centerX + (float)(shortRadius * sinValue));\n    int y1=Math.round(centerY + (float)(shortRadius * cosValue));\n    int x2=Math.round(centerX + (float)(longRadius * sinValue));\n    int y2=Math.round(centerY + (float)(longRadius * cosValue));\n    canvas.drawLine(x1,y1,x2,y2,paint);\n    if (labels) {\n      paint.setTextAlign(Align.LEFT);\n      if (x1 <= x2) {\n        paint.setTextAlign(Align.RIGHT);\n      }\n      String text=i + \"\";\n      if (Math.round(i) == (long)i) {\n        text=(long)i + \"\";\n      }\n      canvas.drawText(text,x1,y1,paint);\n    }\n  }\n}", "comment": "draws the chart tick lines .", "label": "what"}
{"id": "18229", "raw_code": "private static boolean inEncoding(char ch,String encoding){\n  boolean isInEncoding;\n  try {\n    char cArray[]=new char[1];\n    cArray[0]=ch;\n    String s=new String(cArray);\n    byte[] bArray=s.getBytes(encoding);\n    isInEncoding=inEncoding(ch,bArray);\n  }\n catch (  Exception e) {\n    isInEncoding=false;\n    if (encoding == null)     isInEncoding=true;\n  }\n  return isInEncoding;\n}", "comment": "this is heart of the code that determines if a given character is in the given encoding .", "label": "what"}
{"id": "14783", "raw_code": "public void delete(SSOToken token,String dn) throws SMSException, SSOException {\n  for (  String entry : subEntries(token,dn,\"*\",0,false,false)) {\n    debug.message(\"SMSLdapObject: deleting sub-entry: {}\",entry);\n    delete(token,getNamingAttribute() + \"=\" + entry+ \",\"+ dn);\n  }\n  for (  String subOrg : searchSubOrgNames(token,dn,\"*\",0,false,false,false)) {\n    debug.message(\"SMSLdapObject: deleting suborganization: {}\",subOrg);\n    delete(token,subOrg);\n  }\n  delete(token.getPrincipal(),dn);\n  objectChanged(dn,DELETE);\n}", "comment": "delete the entry in the directory .", "label": "what"}
{"id": "37206", "raw_code": "public CModulesCheckBoxPanel(final CModulesTableModel modulesTableModel){\n  super(new BorderLayout());\n  final JCheckBox checkBox=new JCheckBox(\"Show full module paths\");\n  checkBox.addItemListener(new InternalCheckboxListener());\n  add(checkBox);\n  m_modulesTableModel=modulesTableModel;\n}", "comment": "creates the checkbox panel to control if full paths should be shown in the modules table .", "label": "what"}
{"id": "56358", "raw_code": "protected Tuple<BlobStoreIndexShardSnapshots,Integer> buildBlobStoreIndexShardSnapshots(Map<String,BlobMetaData> blobs){\n  int latest=-1;\n  for (  String name : blobs.keySet()) {\n    if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {\n      try {\n        int gen=Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()));\n        if (gen > latest) {\n          latest=gen;\n        }\n      }\n catch (      NumberFormatException ex) {\n        logger.warn(\"failed to parse index file name [{}]\",name);\n      }\n    }\n  }\n  if (latest >= 0) {\n    try {\n      return new Tuple<>(indexShardSnapshotsFormat.read(blobContainer,Integer.toString(latest)),latest);\n    }\n catch (    IOException e) {\n      logger.warn(\"failed to read index file  [{}]\",e,SNAPSHOT_INDEX_PREFIX + latest);\n    }\n  }\n  List<SnapshotFiles> snapshots=new ArrayList<>();\n  for (  String name : blobs.keySet()) {\n    try {\n      BlobStoreIndexShardSnapshot snapshot=null;\n      if (name.startsWith(SNAPSHOT_PREFIX)) {\n        snapshot=indexShardSnapshotFormat.readBlob(blobContainer,name);\n      }\n else       if (name.startsWith(LEGACY_SNAPSHOT_PREFIX)) {\n        snapshot=indexShardSnapshotLegacyFormat.readBlob(blobContainer,name);\n      }\n      if (snapshot != null) {\n        snapshots.add(new SnapshotFiles(snapshot.snapshot(),snapshot.indexFiles()));\n      }\n    }\n catch (    IOException e) {\n      logger.warn(\"failed to read commit point [{}]\",e,name);\n    }\n  }\n  return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots),-1);\n}", "comment": "loads all available snapshots in the repository", "label": "what"}
{"id": "44667", "raw_code": "protected MapleQuestRequirement(MapleQuest quest,ReadBin data) throws IOException {\n  this.quest=quest;\n  this.dayByDay=data.readByte() > 0;\n  this.normalAutoStart=data.readByte() > 0;\n  this.lvmin=data.readShort();\n  this.lvmax=data.readShort();\n  this.mbmin=data.readShort();\n  this.charismaMin=data.readShort();\n  this.charmMin=data.readShort();\n  this.craftMin=data.readShort();\n  this.insightMin=data.readShort();\n  this.senseMin=data.readShort();\n  this.willMin=data.readShort();\n  this.pop=data.readShort();\n  this.pettamenessmin=data.readShort();\n  this.subJobFlag=data.readShort();\n  this.npc=data.readInt();\n  this.interval=data.readInt();\n  this.end=data.readString();\n  this.startscript=data.readString();\n  this.endscript=data.readString();\n  short size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int field=data.readInt();\n    fieldEnter.add(field);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    short job=data.readShort();\n    jobs.add(job);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int id=data.readInt();\n    boolean acquire=data.readByte() > 0;\n    skills.put(id,acquire);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int id=data.readInt();\n    byte state=data.readByte();\n    byte order=data.readByte();\n    quests.put(id,state);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int id=data.readInt();\n    int count=data.readInt();\n    byte order=data.readByte();\n    items.put(id,count);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int id=data.readInt();\n    int count=data.readInt();\n    mobs.put(id,count);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int id=data.readInt();\n    pets.add(id);\n  }\n}", "comment": "creates a new instance of maplequestrequirement .", "label": "what"}
{"id": "77715", "raw_code": "public ForumPostConfig createReply(ForumPostConfig config){\n  config.addCredentials(this);\n  String xml=POST(this.url + \"/create-reply\",config.toXML());\n  Element root=parse(xml);\n  if (root == null) {\n    return null;\n  }\n  try {\n    ForumPostConfig reply=new ForumPostConfig();\n    reply.parseXML(root);\n    return reply;\n  }\n catch (  Exception exception) {\n    this.exception=SDKException.parseFailure(exception);\n    throw this.exception;\n  }\n}", "comment": "create a reply to a forum post .", "label": "what"}
{"id": "4457", "raw_code": "public boolean isArmed(){\n  return other.isArmed();\n}", "comment": "all these methods simply delegate to the \" other \" model that is being decorated .", "label": "what"}
{"id": "712", "raw_code": "public static Tuple max(TupleSet tuples,String field,Comparator cmp){\n  if (tuples instanceof Table) {\n    Table table=(Table)tuples;\n    ColumnMetadata md=table.getMetadata(field);\n    return table.getTuple(md.getMaximumRow());\n  }\n else {\n    return max(tuples.tuples(),field,cmp);\n  }\n}", "comment": "get the tuple with the maximum data field value .", "label": "what"}
{"id": "38552", "raw_code": "protected void updateRadioLinks(){\n  m_CVBut.setEnabled(true);\n  m_CVText.setEnabled(m_CVBut.isSelected());\n  m_CVLab.setEnabled(m_CVBut.isSelected());\n  m_SeedText.setEnabled(m_CVBut.isSelected());\n  m_SeedLab.setEnabled(m_CVBut.isSelected());\n  if (m_AttributeEvaluatorEditor.getValue() instanceof AttributeTransformer) {\n    m_CVBut.setSelected(false);\n    m_CVBut.setEnabled(false);\n    m_CVText.setEnabled(false);\n    m_CVLab.setEnabled(false);\n    m_SeedText.setEnabled(false);\n    m_SeedLab.setEnabled(false);\n    m_TrainBut.setSelected(true);\n  }\n}", "comment": "updates the enabled status of the input fields and labels .", "label": "what"}
{"id": "69999", "raw_code": "private void showFilterDialog(Filter filter){\n  int sortOrder=mAdapter.getCount() - 1;\n  if (filter == null) {\n    EditFilterActivity.createNewFilter(getActivity(),sortOrder);\n  }\n else {\n    EditFilterActivity.editFilter(getActivity(),filter,sortOrder);\n  }\n}", "comment": "shows the filter dialog", "label": "what"}
{"id": "84308", "raw_code": "public static LocalGitRepo fromCurrentDir(String remoteUrl) throws ValidationException {\n  Git git;\n  File gitDir=new File(\".\");\n  try {\n    git=Git.open(gitDir);\n  }\n catch (  RepositoryNotFoundException rnfe) {\n    String fullPathOfCurrentDir=pathOf(gitDir);\n    File gitRoot=getGitRootIfItExistsInOneOfTheParentDirectories(new File(fullPathOfCurrentDir));\n    String summary;\n    List<String> messages=new ArrayList<String>();\n    if (gitRoot == null) {\n      summary=\"Releases can only be performed from Git repositories.\";\n      messages.add(summary);\n      messages.add(fullPathOfCurrentDir + \" is not a Git repository.\");\n    }\n else {\n      summary=\"The release plugin can only be run from the root folder of your Git repository\";\n      messages.add(summary);\n      messages.add(fullPathOfCurrentDir + \" is not the root of a Gir repository\");\n      messages.add(\"Try running the release plugin from \" + pathOf(gitRoot));\n    }\n    throw new ValidationException(summary,messages);\n  }\ncatch (  Exception e) {\n    throw new ValidationException(\"Could not open git repository. Is \" + pathOf(gitDir) + \" a git repository?\",Arrays.asList(\"Exception returned when accessing the git repo:\",e.toString()));\n  }\n  return new LocalGitRepo(git,remoteUrl);\n}", "comment": "uses the current working dir to open the git repository .", "label": "what"}
{"id": "45334", "raw_code": "public void serialize(KXmlSerializer serializer) throws IOException {\n  mDeviceInfo.serialize(serializer);\n  serializeHostInfo(serializer);\n  serializeTestSummary(serializer);\n  monkeyTag.serialize(serializer);\n  List<TestPackageResult> pkgs=new ArrayList<TestPackageResult>(mPackageMap.values());\n  Collections.sort(pkgs,new PkgComparator());\n  for (  TestPackageResult r : pkgs) {\n    r.serialize(serializer);\n  }\n}", "comment": "serialize the test results to xml .", "label": "what"}
{"id": "22112", "raw_code": "private void verifyBlockMirrorMigration() throws Exception {\n  log.info(\"Verifying BlockMirror migration.\");\n  Iterator<BlockMirror> blockMirrorItr=_dbClient.queryIterativeObjects(BlockMirror.class,blockMirrorURIs);\n  List<BlockObject> blockObjects=new ArrayList<BlockObject>();\n  while (blockMirrorItr.hasNext()) {\n    blockObjects.add(blockMirrorItr.next());\n  }\n  verifyBlockObjects(blockObjects);\n}", "comment": "verify the blockmirror objects have been migrated correctly .", "label": "what"}
{"id": "52362", "raw_code": "public LogFormatter(Logger log){\n  if (log == null)   log=Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);\n  Level lvl=null;\n  while (log != null) {\n    lvl=log.getLevel();\n    if (lvl != null)     break;\n    log=log.getParent();\n  }\n  ;\n  if (lvl == null)   lvl=Level.WARNING;\n  this.level=lvl;\n}", "comment": "create a log formatter around a given logger .", "label": "what"}
{"id": "38725", "raw_code": "public synchronized void removeTextListener(TextListener cl){\n  m_textListeners.remove(cl);\n}", "comment": "remove a text listener", "label": "what"}
{"id": "9908", "raw_code": "private Element createIDPEntityDescriptor(boolean exportPrivateData) throws Exception {\n  Element entEle=doc.createElementNS(null,SAMLNames.ENTDESCRIPTOR);\n  String id=idmClient.getEntityID(tenantName);\n  String alias=idmClient.getLocalIDPAlias(tenantName);\n  if (id == null) {\n    id=tenantName;\n  }\n  entEle.setAttribute(SAMLNames.ENTID,id);\n  Element idpSSO=createIDPSSODescriptor(exportPrivateData);\n  entEle.appendChild(idpSSO);\n  if (exportPrivateData) {\n    if (alias == null || alias.isEmpty()) {\n      alias=id;\n    }\n    Element orgEle=createOrganization(tenantName,tenantName,alias,SAMLNames.ENGLISH);\n    entEle.appendChild(orgEle);\n  }\n  return entEle;\n}", "comment": "create extension element of entitydescriptor in dom .", "label": "what"}
{"id": "53067", "raw_code": "public void applyCamera(GL2 gl){\n  gl.glMatrixMode(GL2.GL_PROJECTION);\n  gl.glLoadIdentity();\n  glu.gluPerspective(45f,width / (float)height,0.f,10.f);\n  eye[0]=(float)Math.sin(theta) * 2.f;\n  eye[1]=.5f;\n  eye[2]=(float)Math.cos(theta) * 2.f;\n  glu.gluLookAt(eye[0],eye[1],eye[2],.0f,.0f,0.f,0.f,1.f,0.f);\n  gl.glMatrixMode(GL2.GL_MODELVIEW);\n  gl.glLoadIdentity();\n  gl.glViewport(0,0,width,height);\n}", "comment": "apply the camera settings .", "label": "what"}
{"id": "3723", "raw_code": "public PathImpl createTempFile(String prefix,String suffix) throws IOException {\n  if (prefix == null || prefix.length() == 0)   prefix=\"t\";\n  if (suffix == null)   suffix=\".tmp\";\nsynchronized (LOCK) {\n    for (int i=0; i < 32768; i++) {\n      int r=Math.abs((int)RandomUtil.getRandomLong());\n      PathImpl file=lookup(prefix + r + suffix);\n      if (file.createNewFile())       return file;\n    }\n  }\n  throw new IOException(\"cannot create temp file\");\n}", "comment": "creates a unique temporary file as a child of this directory .", "label": "what"}
{"id": "78004", "raw_code": "public void load(){\n  try {\n    if (fileChannel == null) {\n      fileChannel=FileChannel.open(path,StandardOpenOption.READ);\n    }\n    fileChannel.position(0L);\n    buffer.clear();\n    tmp.clear();\n    while (fileChannel.read(tmp) > 0) {\n      tmp.flip();\n      if (tmp.remaining() > buffer.capacity() - buffer.position()) {\n        final ByteBuffer next=ByteBuffer.allocateDirect(Math.max(buffer.capacity() * 2,tmp.remaining()));\n        buffer.flip();\n        next.put(buffer);\n        buffer=next;\n      }\n      buffer.put(tmp);\n      tmp.clear();\n    }\n    buffer.flip();\n  }\n catch (  final IOException e) {\n    throw new UncheckedIOException(e);\n  }\n}", "comment": "opens a channel to the specified path if it does not already exist .", "label": "what"}
{"id": "50994", "raw_code": "@NotNull private File resolveName(@NotNull String name) throws IOException {\n  File file;\n  if (name.startsWith(ROOT)) {\n    file=new File(myTemplateRootFolder,name.substring(ROOT.length()));\n  }\n else   if (myLastTemplateFolders != null) {\n    file=new File(myLastTemplateFolders.peek(),name);\n  }\n else {\n    file=new File(myTemplateRootFolder,name);\n  }\n  return file.getCanonicalFile();\n}", "comment": "resolve a freemarker name reference .", "label": "what"}
{"id": "27593", "raw_code": "private void sendResource(final UUID uuid,final Object resource,final long length,final InputStream is) throws IOException {\n  assert uuid != null;\n  assert resource != null;\n  assert length >= 0;\n  assert is != null;\n  assert !sentStatus;\n  long bytesWritten=0L;\n  final long begin=System.nanoTime();\n  final OutputStream os=s.getOutputStream();\n  try {\n{\n      final DataOutputStream dos=new DataOutputStream(os);\n      dos.write(new byte[]{StatusEnum.OK.get()});\n      dos.writeLong(length);\n      dos.flush();\n      bytesWritten+=1 + Bytes.SIZEOF_LONG;\n      sentStatus=true;\n    }\n    final long checksum;\n{\n      final int BUFSIZE=Bytes.kilobyte32 * 2;\n      final CheckedInputStream cis=new CheckedInputStream(new BufferedInputStream(is),new Adler32());\n      final byte[] buff=new byte[BUFSIZE];\n      while (true) {\n        final int read=cis.read(buff,0,BUFSIZE);\n        if (read <= 0)         break;\n        os.write(buff,0,read);\n        bytesWritten+=read;\n      }\n      checksum=cis.getChecksum().getValue();\n    }\n{\n      final DataOutputStream dos=new DataOutputStream(os);\n      dos.writeLong(checksum);\n      bytesWritten+=Bytes.SIZEOF_LONG;\n      dos.flush();\n    }\n    os.flush();\n    if (log.isInfoEnabled())     log.info(\"Sent: uuid=\" + uuid + \", resource=\"+ resource+ \", length=\"+ length+ \", checksum=\"+ checksum+ \", elapsed=\"+ TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - begin)+ \"ms\");\n  }\n  finally {\n    try {\n      os.close();\n    }\n catch (    Throwable t) {\n    }\n    counters.bytesWritten.add(bytesWritten);\n    counters.elapsedWriteNanos.add(System.nanoTime() - begin);\nsynchronized (counters.maxWriteSizeLock) {\n      counters.maxWriteSize=Math.max(counters.maxWriteSize,bytesWritten);\n    }\n  }\n}", "comment": "sends given resource to the socket .", "label": "what"}
{"id": "28666", "raw_code": "public long sigignore(){\n  return Long.parseLong(fields[32]);\n}", "comment": "the bitmap of ignored signals , displayed as a decimal number .", "label": "what"}
{"id": "40104", "raw_code": "private static byte[] generateSeed(){\n  try {\n    final ByteArrayOutputStream seedBuffer=new ByteArrayOutputStream();\n    final DataOutputStream seedBufferOut=new DataOutputStream(seedBuffer);\n    seedBufferOut.writeLong(System.currentTimeMillis());\n    seedBufferOut.writeLong(System.nanoTime());\n    seedBufferOut.writeInt(Process.myPid());\n    seedBufferOut.writeInt(Process.myUid());\n    seedBufferOut.write(BUILD_FINGERPRINT_AND_DEVICE_SERIAL);\n    seedBufferOut.close();\n    return seedBuffer.toByteArray();\n  }\n catch (  final IOException e) {\n    throw new SecurityException(\"Failed to generate seed\",e);\n  }\n}", "comment": "generates a device - and invocation - specific seed to be mixed into the linux prng .", "label": "what"}
{"id": "42121", "raw_code": "public static final void reverseWinding(List<Vector2> points){\n  if (points == null)   throw new NullPointerException(Messages.getString(\"geometry.nullPointList\"));\n  int size=points.size();\n  if (size == 1 || size == 0)   return;\n  Collections.reverse(points);\n}", "comment": "reverses the order of the polygon points within the given list .", "label": "what"}
{"id": "57621", "raw_code": "private int awaitDone(boolean timed,long nanos) throws InterruptedException {\n  final long deadline=timed ? System.nanoTime() + nanos : 0L;\n  WaitNode q=null;\n  boolean queued=false;\n  for (; ; ) {\n    if (Thread.interrupted()) {\n      removeWaiter(q);\n      throw new InterruptedException();\n    }\n    int s=state;\n    if (s > COMPLETING) {\n      if (q != null)       q.thread=null;\n      return s;\n    }\n else     if (s == COMPLETING)     Thread.yield();\n else     if (q == null)     q=new WaitNode();\n else     if (!queued)     queued=UNSAFE.compareAndSwapObject(this,waitersOffset,q.next=waiters,q);\n else     if (timed) {\n      nanos=deadline - System.nanoTime();\n      if (nanos <= 0L) {\n        removeWaiter(q);\n        return state;\n      }\n      LockSupport.parkNanos(this,nanos);\n    }\n else     LockSupport.park(this);\n  }\n}", "comment": "awaits completion or aborts on interrupt or timeout .", "label": "what"}
{"id": "44783", "raw_code": "public static double clamp(double value,double low,double high){\n  return Math.min(Math.max(value,low),high);\n}", "comment": "clamp a value to be within the provided range .", "label": "what"}
{"id": "43196", "raw_code": "public static String parseVolumeHostDirectory(String volume){\n  if (StringUtils.isEmpty(volume)) {\n    return volume;\n  }\n  if (!volume.contains(HOST_CONTAINER_DIR_DELIMITER)) {\n    return volume;\n  }\n  String[] hostContainerDir=volume.split(HOST_CONTAINER_DIR_DELIMITER);\n  if (hostContainerDir.length != 2) {\n    throw new IllegalArgumentException(\"Invalid volume directory.\");\n  }\n  String hostDir=hostContainerDir[0];\n  return hostDir;\n}", "comment": "parses volume host directory only .", "label": "what"}
{"id": "12591", "raw_code": "private String fmtTime(double time){\n  return Utilities.pad(timeFormatter.format(time) + \"s\",10);\n}", "comment": "formats times into a standard format .", "label": "what"}
{"id": "49514", "raw_code": "public static String right(String s,int width,char fillChar){\n  if (s.length() >= width) {\n    return s;\n  }\n  StringBuffer sb=new StringBuffer(width);\n  for (int i=width - s.length(); --i >= 0; ) {\n    sb.append(fillChar);\n  }\n  sb.append(s);\n  return sb.toString();\n}", "comment": "right justify a string .", "label": "what"}
{"id": "30159", "raw_code": "@Override public boolean validateLabel(String label){\n  Objects.requireNonNull(label,\"label cannot be null\");\n  return !labels.contains(label);\n}", "comment": "checks the given label can be added / removed to / from a vertex .", "label": "what"}
{"id": "25418", "raw_code": "public void addMessageObserver(final MessageObserver observer){\n  if (observer == null) {\n    throw new NullPointerException();\n  }\n else   if (messageObservers == null) {\n    initMessageObserverList();\n  }\n  messageObservers.add(observer);\n}", "comment": "adds the specified message observer .", "label": "what"}
{"id": "25579", "raw_code": "public E remove(int index){\n  hashCodeUpToDate=false;\n  modCount++;\n  E oldValue=elementData(index);\n  int numMoved=size - index - 1;\n  if (numMoved > 0)   System.arraycopy(elementData,index + 1,elementData,index,numMoved);\n  elementData[--size]=null;\n  return oldValue;\n}", "comment": "removes the element at the specified position in this list .", "label": "what"}
{"id": "39225", "raw_code": "public static DoubleVector rnorm(int n,double mean,double sd,Random random){\n  if (sd < 0.0)   throw new IllegalArgumentException(\"standard deviation < 0.0\");\n  if (sd == 0.0)   return new DoubleVector(n,mean);\n  DoubleVector v=new DoubleVector(n);\n  for (int i=0; i < n; i++)   v.set(i,(random.nextGaussian() + mean) / sd);\n  return v;\n}", "comment": "generates a sample of a normal distribution .", "label": "what"}
{"id": "74834", "raw_code": "private PdfObject readCompressedStream(PdfObject rootObj,int pointer,final PdfFileReader currentPdfFile,final ObjectReader objectReader,final PdfObject linearObj) throws PdfException {\n  while (pointer != -1) {\n    movePointer(pointer);\n    final byte[] raw=objectReader.readObjectData(-1,null);\n    final StringBuilder objectName=new StringBuilder();\n    char current1, last=' ';\n    int matched=0, i1=0;\n    while (i1 < raw.length) {\n      current1=(char)raw[i1];\n      if (current1 == 10 || current1 == 13) {\n        current1=' ';\n      }\n      if (current1 == ' ' && last == ' ') {\n        matched=0;\n      }\n else       if (current1 == pattern.charAt(matched)) {\n        matched++;\n      }\n else {\n        matched=0;\n        objectName.append(current1);\n      }\n      if (matched == 3) {\n        break;\n      }\n      last=current1;\n      i1++;\n    }\n    objectName.append('R');\n    final PdfObject pdfObject=new CompressedObject(objectName.toString());\n    pdfObject.setCompressedStream(true);\n    final ObjectDecoder objectDecoder=new ObjectDecoder(currentPdfFile);\n    objectDecoder.readDictionaryAsObject(pdfObject,0,raw);\n    final int[] fieldSizes=pdfObject.getIntArray(PdfDictionary.W);\n    byte[] xrefs=pdfObject.getDecodedStream();\n    if (xrefs == null) {\n      xrefs=currentPdfFile.readStream(pdfObject,true,true,false,false,true,null);\n    }\n    final int[] Index=pdfObject.getIntArray(PdfDictionary.Index);\n    if (Index == null) {\n      CompressedObjects.readCompressedOffsets(0,0,pdfObject.getInt(PdfDictionary.Size),fieldSizes,xrefs,offset,pdf_datafile);\n    }\n else {\n      final int count=Index.length;\n      int pntr=0;\n      for (int aa=0; aa < count; aa+=2) {\n        pntr=CompressedObjects.readCompressedOffsets(pntr,Index[aa],Index[aa + 1],fieldSizes,xrefs,offset,pdf_datafile);\n      }\n    }\n    if (rootObj == null) {\n      rootObj=pdfObject.getDictionary(PdfDictionary.Root);\n      encryptObj=pdfObject.getDictionary(PdfDictionary.Encrypt);\n      if (encryptObj != null) {\n        final byte[][] IDs=pdfObject.getStringArray(PdfDictionary.ID);\n        if (IDs != null && this.ID == null) {\n          this.ID=IDs[0];\n        }\n      }\n      infoObject=pdfObject.getDictionary(PdfDictionary.Info);\n    }\n    if (linearObj != null) {\n      pointer=-1;\n    }\n else {\n      pointer=pdfObject.getInt(PdfDictionary.Prev);\n      if (pointer != -1 && !isCompressedStream(pointer,(int)eof)) {\n        return readLegacyReferenceTable(rootObj,pointer,(int)eof,currentPdfFile);\n      }\n    }\n  }\n  return rootObj;\n}", "comment": "read 1 . 5 compression stream ref table", "label": "what"}
{"id": "72706", "raw_code": "public boolean isKnownSub(String subName){\n  return KNOWN_SUBS.contains(subName);\n}", "comment": "checks if sub is indexed .", "label": "what"}
{"id": "36943", "raw_code": "public boolean isStored(){\n  return Integer.signum(id) != -1;\n}", "comment": "determines whether the view was previously stored to the database .", "label": "what"}
{"id": "64146", "raw_code": "public static BigInteger sizeOfDirectoryAsBigInteger(File directory){\n  checkDirectory(directory);\n  final File[] files=directory.listFiles();\n  if (files == null) {\n    return BigInteger.ZERO;\n  }\n  BigInteger size=BigInteger.ZERO;\n  for (  final File file : files) {\n    try {\n      if (!isSymlink(file)) {\n        size=size.add(BigInteger.valueOf(sizeOf(file)));\n      }\n    }\n catch (    IOException ioe) {\n    }\n  }\n  return size;\n}", "comment": "counts the size of a directory recursively ( sum of the length of all files ) .", "label": "what"}
{"id": "84701", "raw_code": "public void calcMajorTick(){\n  majorTick=10;\n  majorTickCount=(int)Math.round(log10(maxTick / minTick)) + 1;\n}", "comment": "calculate the optimum major tick distance .", "label": "what"}
{"id": "79512", "raw_code": "public boolean next() throws GenericDataSourceException {\n  try {\n    return _rs.next();\n  }\n catch (  SQLException sqle) {\n    throw new GenericDataSourceException(\"SQL Exception while executing the following:\" + _sql,sqle);\n  }\n}", "comment": "test if there more records available", "label": "what"}
{"id": "20900", "raw_code": "public void put(String sample,HiddenAttribute attribute,Object value){\n  put(sample,attribute.toString(),value);\n}", "comment": "put a value in the table", "label": "what"}
{"id": "35925", "raw_code": "void postMessage(List<JetstreamMessage> msgs,DispatchQueueStats stats) throws MessageServiceException {\n  m_msgRcvCounter.addAndGet(msgs.size());\n  if ((monitorUpstreamQueueAndPauseTraffic() == UpstreamQueueState.FULL) && (m_paused.get())) {\n    if (!m_msgProcessor.hasAvailableCapacity(m_twentyPercentCapacity)) {\n      m_totalMsgsDropped.increment();\n      return;\n    }\n  }\n  List<Runnable> requests=new ArrayList<Runnable>(msgs.size());\n  for (int i=0, t=msgs.size(); i < t; i++) {\n    JetstreamMessage tm=msgs.get(i);\n    if (tm.getTopic() == null) {\n      m_totalMsgsDropped.increment();\n      if (LOGGER.isDebugEnabled()) {\n        LOGGER.debug(\"Topic is not present in incoming message\");\n      }\n      continue;\n    }\n    MessageServiceRequest msr=new MessageServiceRequest(tm);\n    msr.setPriority(tm.getPriority());\n    msr.setSequenceid(tm.getSequenceId());\n    if (msr.getPriority() == JetstreamMessage.INTERNAL_MSG_PRIORITY) {\n      if (!m_internalMsgProcessor.processRequest(msr)) {\n        m_totalMsgsDropped.increment();\n        throw new MessageServiceException(MessageServiceException.BUFFER_FULL,\"Dispatch Queue Full\");\n      }\n      if (m_msgsRcvdPerSec.addAndGet(1) < 0)       m_msgsRcvdPerSec.set(0);\n      m_totalMsgsRcvd.increment();\n    }\n else {\n      requests.add(msr);\n    }\n  }\n  if (!requests.isEmpty()) {\n    int batchsize=requests.size();\n    if (!m_msgProcessor.processBatch(requests)) {\n      m_totalMsgsDropped.addAndGet(batchsize);\n      throw new MessageServiceException(MessageServiceException.BUFFER_FULL,\"High Priority Dispatch Queue Full - \" + \" Requested capacity = \" + batchsize + \" : available capacity = \"+ m_msgProcessor.getAvailableCapacity());\n    }\n    m_avgMsgsRcvdPerSec.add(batchsize);\n    m_totalMsgsRcvd.addAndGet(batchsize);\n  }\n  if (stats != null) {\n    stats.setHighPriorityQueueDepth((int)m_msgProcessor.getPendingRequests());\n    stats.setLowPriorityQueueDepth((int)m_msgProcessor.getPendingRequests());\n    stats.setMaxQueueDepth((int)m_msgProcessor.getMaxQueueSz());\n  }\n}", "comment": "post a batch of messages .", "label": "what"}
{"id": "46729", "raw_code": "public boolean unsetOrdering(Object first,Object second){\n  DigraphNode firstPONode=(DigraphNode)poNodes.get(first);\n  DigraphNode secondPONode=(DigraphNode)poNodes.get(second);\n  return firstPONode.removeEdge(secondPONode) || secondPONode.removeEdge(firstPONode);\n}", "comment": "removes any ordering between two nodes .", "label": "what"}
{"id": "85356", "raw_code": "public void write(ClassFile classFile,File f) throws IOException {\n  FileOutputStream f_out=new FileOutputStream(f);\n  try {\n    write(classFile,f_out);\n  }\n  finally {\n    f_out.close();\n  }\n}", "comment": "write a classfile data structure to a file .", "label": "what"}
{"id": "25364", "raw_code": "public Connection(final InetSocketAddress peerAddress){\n  this(peerAddress,(Handshaker)null);\n}", "comment": "creates a new connection to a given peer .", "label": "what"}
{"id": "73747", "raw_code": "protected synchronized void notifyVersion(SprogVersion v){\n  ver=v;\n  for (  SprogVersionListener listener : getCopyOfListeners()) {\n    try {\n      listener.notifyVersion(ver);\n      versionListeners.remove(listener);\n    }\n catch (    Exception e) {\n      log.warn(\"notify: During dispatch to \" + listener + \"\\nException \"+ e);\n    }\n  }\n}", "comment": "notify all registered listeners of the sprog version", "label": "what"}
{"id": "35063", "raw_code": "public ControlFlowGraph run(CompilationUnitTree root,ProcessingEnvironment env,MethodTree tree,ClassTree classTree){\n  UnderlyingAST underlyingAST=new CFGMethod(tree,classTree);\n  return run(root,env,underlyingAST);\n}", "comment": "build the control flow graph of a method .", "label": "what"}
{"id": "70147", "raw_code": "private boolean isValidEngine(){\n  if (hasFlag(~(CLAN_ENGINE | TANK_ENGINE | LARGE_ENGINE| SUPERHEAVY_ENGINE| SUPPORT_VEE_ENGINE))) {\n    problem.append(\"Flags:\" + engineFlags);\n    return false;\n  }\n  if (hasFlag(SUPPORT_VEE_ENGINE) && (engineType != STEAM) && (engineType != COMBUSTION_ENGINE)&& (engineType != BATTERY)&& (engineType != FUEL_CELL)&& (engineType != SOLAR)&& (engineType != FISSION)&& (engineType != NORMAL_ENGINE)&& (engineType != NONE)) {\n    problem.append(\"Invalid Engine type for support vehicle engines!\");\n    return false;\n  }\n  if ((((int)Math.ceil(engineRating / 5) > ENGINE_RATINGS.length) || (engineRating < 0)) && !hasFlag(SUPPORT_VEE_ENGINE)) {\n    problem.append(\"Rating:\" + engineRating);\n    return false;\n  }\n  if ((engineRating > 400) && !hasFlag(SUPPORT_VEE_ENGINE)) {\n    engineFlags|=LARGE_ENGINE;\n  }\nswitch (engineType) {\ncase COMBUSTION_ENGINE:\ncase NORMAL_ENGINE:\ncase XL_ENGINE:\ncase XXL_ENGINE:\ncase FUEL_CELL:\ncase NONE:\ncase MAGLEV:\ncase BATTERY:\ncase SOLAR:\n    break;\ncase COMPACT_ENGINE:\n  if (hasFlag(LARGE_ENGINE)) {\n    problem.append(Messages.getString(\"Engine.invalidCompactLarge\"));\n    return false;\n  }\nbreak;\ncase LIGHT_ENGINE:\ncase FISSION:\nif (hasFlag(CLAN_ENGINE)) {\nproblem.append(Messages.getString(\"Engine.invalidSphereOnly\"));\nreturn false;\n}\nbreak;\ndefault :\nproblem.append(\"Type:\" + engineType);\nreturn false;\n}\nreturn true;\n}", "comment": "sanity checks the engine , no negative ratings , and similar checks .", "label": "what"}
{"id": "59367", "raw_code": "static public void assertEquals(String message,float expected,float actual,float delta){\n  if (Float.isInfinite(expected)) {\n    if (!(expected == actual))     failNotEquals(message,new Float(expected),new Float(actual));\n  }\n else   if (!(Math.abs(expected - actual) <= delta))   failNotEquals(message,new Float(expected),new Float(actual));\n}", "comment": "asserts that two floats are equal concerning a delta .", "label": "what"}
{"id": "79837", "raw_code": "public static byte[] base64decode(String coded){\n  if (null == coded)   return null;\n  byte[] src=coded.getBytes();\n  int len=src.length;\n  int dlen=len - (len / 77);\n  dlen=(dlen >>> 2) + (dlen >>> 1);\n  int rem=0;\n  if (61 == src[len - 1])   rem++;\n  if (61 == src[len - 2])   rem++;\n  dlen-=rem;\n  byte[] dst=new byte[dlen];\n  int pos=0;\n  int dpos=0;\n  int col=0;\n  len-=4;\n  while (pos < len) {\n    byte b0=_base64de[src[pos++]];\n    byte b1=_base64de[src[pos++]];\n    byte b2=_base64de[src[pos++]];\n    byte b3=_base64de[src[pos++]];\n    if (B64INV == b0 || B64INV == b1 || B64INV == b2 || B64INV == b3)     throw new RuntimeException(\"Invalid character at or around position \" + pos);\n    dst[dpos++]=(byte)((b0 << 2) | ((b1 >>> 4) & 0x03));\n    dst[dpos++]=(byte)((b1 << 4) | ((b2 >>> 2) & 0x0f));\n    dst[dpos++]=(byte)((b2 << 6) | (b3 & 0x3f));\n    col+=4;\n    if (76 == col) {\n      if (10 != src[pos++])       throw new RuntimeException(\"No linefeed found at position \" + (pos - 1));\n      col=0;\n    }\n  }\n  byte b0=_base64de[src[pos++]];\n  byte b1=_base64de[src[pos++]];\n  byte b2=_base64de[src[pos++]];\n  byte b3=_base64de[src[pos++]];\n  if (B64INV == b0 || B64INV == b1 || B64INV == b2 || B64INV == b3)   throw new RuntimeException(\"Invalid character at or around position \" + pos);\n  dst[dpos++]=(byte)((b0 << 2) | ((b1 >>> 4) & 0x03));\n  if (2 == rem)   return dst;\n  dst[dpos++]=(byte)((b1 << 4) | ((b2 >>> 2) & 0x0f));\n  if (1 == rem)   return dst;\n  dst[dpos++]=(byte)((b2 << 6) | (b3 & 0x3f));\n  return dst;\n}", "comment": "decodes a base64 encoded string .", "label": "what"}
{"id": "70014", "raw_code": "private static Properties loadProperties(String propertiesFile){\n  Properties properties=new Properties();\n  try (InputStream is=new FileInputStream(propertiesFile)){\n    properties.load(is);\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"failed to load properties\",e);\n  }\n  return properties;\n}", "comment": "loads properties from a properties file on the local filesystem .", "label": "what"}
{"id": "5792", "raw_code": "public TextEditor replaceAll(Pattern pattern,Replacement replacement){\n  Matcher m=pattern.matcher(text);\n  int lastIndex=0;\n  StringBuilder sb=new StringBuilder();\n  while (m.find()) {\n    sb.append(text.subSequence(lastIndex,m.start()));\n    sb.append(replacement.replacement(m));\n    lastIndex=m.end();\n  }\n  sb.append(text.subSequence(lastIndex,text.length()));\n  text=sb;\n  return this;\n}", "comment": "replace all occurrences of the pattern .", "label": "what"}
{"id": "22182", "raw_code": "public Map<String,Map<String,String>> list(String serviceName){\n  Map<String,Map<String,String>> results=new HashMap<String,Map<String,String>>();\n  ServiceInfo[] infos=jmdns.list(\"_\" + serviceName + \"._tcp.local.\");\n  for (  ServiceInfo info : infos) {\n    _log.info(\"ServiceInfo:{}\",info);\n    final String[] hostAddrs=info.getHostAddresses();\n    final StringBuffer buf=new StringBuffer();\n    for (    String hostAddr : hostAddrs) {\n      buf.append(hostAddr);\n      buf.append(';');\n    }\n    final String key=buf.toString();\n    _log.info(\"\\tkey:{}\",key);\n    final Map<String,String> values=new HashMap<String,String>();\n    for (Enumeration<String> e=info.getPropertyNames(); e.hasMoreElements(); ) {\n      final String prop=e.nextElement();\n      final String value=new String(info.getPropertyBytes(prop));\n      _log.info(\"\\tprop:{}, value:{}\",prop,value);\n      values.put(prop,value);\n    }\n    if (values.isEmpty()) {\n      _log.warn(\"values are empty for key: {}\",key);\n    }\n    results.put(key,values.isEmpty() ? null : values);\n  }\n  return results;\n}", "comment": "list published node ( s ) configuration in the network via multicast", "label": "what"}
{"id": "56590", "raw_code": "@SuppressWarnings({\"unchecked\"}) @Override default LazyFutureStream<U> concat(final Stream<? extends U> other){\n  return fromStream(Stream.concat(StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator(),Spliterator.ORDERED),false),StreamSupport.stream(Spliterators.spliteratorUnknownSize(other.iterator(),Spliterator.ORDERED),false)));\n}", "comment": "concatenate two streams .", "label": "what"}
{"id": "47802", "raw_code": "private int moveComponents(Container target,int x,int y,int width,int height,int rowStart,int rowEnd,boolean ltr,boolean useBaseline,int[] ascent,int[] descent){\nswitch (newAlign) {\ncase LEFT:\n    x+=ltr ? 0 : width;\n  break;\ncase CENTER:\nx+=width / 2;\nbreak;\ncase RIGHT:\nx+=ltr ? width : 0;\nbreak;\ncase LEADING:\nbreak;\ncase TRAILING:\nx+=width;\nbreak;\n}\nint maxAscent=0;\nint nonbaselineHeight=0;\nint baselineOffset=0;\nif (useBaseline) {\nint maxDescent=0;\nfor (int i=rowStart; i < rowEnd; i++) {\nComponent m=target.getComponent(i);\nif (m.visible) {\nif (ascent[i] >= 0) {\nmaxAscent=Math.max(maxAscent,ascent[i]);\nmaxDescent=Math.max(maxDescent,descent[i]);\n}\n else {\nnonbaselineHeight=Math.max(m.getHeight(),nonbaselineHeight);\n}\n}\n}\nheight=Math.max(maxAscent + maxDescent,nonbaselineHeight);\nbaselineOffset=(height - maxAscent - maxDescent) / 2;\n}\nfor (int i=rowStart; i < rowEnd; i++) {\nComponent m=target.getComponent(i);\nif (m.isVisible()) {\nint cy;\nif (useBaseline && ascent[i] >= 0) {\ncy=y + baselineOffset + maxAscent - ascent[i];\n}\n else {\ncy=y + (height - m.height) / 2;\n}\nif (ltr) {\nm.setLocation(x,cy);\n}\n else {\nm.setLocation(target.width - x - m.width,cy);\n}\nx+=m.width + hgap;\n}\n}\nreturn height;\n}", "comment": "centers the elements in the specified row , if there is any slack .", "label": "what"}
{"id": "32158", "raw_code": "@Override public void readExternal(ObjectInput in) throws IOException {\n  path=IgfsUtils.readPath(in);\n  blockSize=in.readInt();\n  grpBlockSize=in.readLong();\n  len=in.readLong();\n  props=U.readStringMap(in);\n  accessTime=in.readLong();\n  modificationTime=in.readLong();\n  flags=in.readByte();\n}", "comment": "reads object from data input .", "label": "what"}
{"id": "42115", "raw_code": "public Vector2(double direction){\n  this.x=Math.cos(direction);\n  this.y=Math.sin(direction);\n}", "comment": "creates a unit length vector in the given direction .", "label": "what"}
{"id": "26289", "raw_code": "public static Map<String,Object> convertDocumentFileToFile(DispatchContext dctx,Map<String,? extends Object> context){\n  XMultiComponentFactory xmulticomponentfactory=null;\n  String stringUrl=(String)context.get(\"filenameFrom\");\n  String stringConvertedFile=(String)context.get(\"filenameTo\");\n  String inputMimeType=(String)context.get(\"inputMimeType\");\n  String outputMimeType=(String)context.get(\"outputMimeType\");\n  String oooHost=(String)context.get(\"oooHost\");\n  String oooPort=(String)context.get(\"oooPort\");\n  try {\n    xmulticomponentfactory=OpenOfficeWorker.getRemoteServer(oooHost,oooPort);\n    File inputFile=new File(stringUrl);\n    long fileSize=inputFile.length();\n    FileInputStream fis=new FileInputStream(inputFile);\n    ByteArrayOutputStream baos=new ByteArrayOutputStream((int)fileSize);\n    int c;\n    while ((c=fis.read()) != -1) {\n      baos.write(c);\n    }\n    OpenOfficeByteArrayInputStream oobais=new OpenOfficeByteArrayInputStream(baos.toByteArray());\n    OpenOfficeByteArrayOutputStream oobaos=OpenOfficeWorker.convertOODocByteStreamToByteStream(xmulticomponentfactory,oobais,inputMimeType,outputMimeType);\n    FileOutputStream fos=new FileOutputStream(stringConvertedFile);\n    fos.write(oobaos.toByteArray());\n    fos.close();\n    fis.close();\n    oobais.close();\n    oobaos.close();\n    Map results=ServiceUtil.returnSuccess();\n    return results;\n  }\n catch (  IOException e) {\n    Debug.logError(e,\"Error in OpenOffice operation: \",module);\n    return ServiceUtil.returnError(e.toString());\n  }\ncatch (  Exception e) {\n    Debug.logError(e,\"Error in OpenOffice operation: \",module);\n    return ServiceUtil.returnError(e.toString());\n  }\n}", "comment": "use openoffice to convert documents between types", "label": "what"}
{"id": "62611", "raw_code": "@Override public void clear(){\n  columnList.forEach(null);\n}", "comment": "clears all the data from this table", "label": "what"}
{"id": "6004", "raw_code": "public static void proxyPort(final int port){\n  final String portValue=Integer.toString(port);\n  setProperty(\"http.proxyPort\",portValue);\n  setProperty(\"https.proxyPort\",portValue);\n}", "comment": "set the ' http . proxyport ' & ' https . proxyport ' properties to the given port number .", "label": "what"}
{"id": "21018", "raw_code": "public static String fetchClusterName(String clusterCgName){\n  String clusterName=null;\n  if (clusterCgName != null && !clusterCgName.isEmpty()) {\n    String[] tmp=clusterCgName.split(SPLITTER);\n    clusterName=tmp[0];\n  }\n  return clusterName;\n}", "comment": "parses out the cluster name from the combined cluster / cg name .", "label": "what"}
{"id": "9779", "raw_code": "public DViewAsymmetricKeyFields(JDialog parent,String title,RSAPublicKey rsaPublicKey){\n  super(parent,title,Dialog.ModalityType.DOCUMENT_MODAL);\n  key=rsaPublicKey;\n  initFields();\n}", "comment": "creates new dviewasymmetrickeyfields dialog .", "label": "what"}
{"id": "20293", "raw_code": "public static boolean isAttribute(Object objValue){\n  if (objValue instanceof String) {\n    String stringValue=(String)objValue;\n    if (stringValue.startsWith(ATTRIBUTE_START) && stringValue.endsWith(ATTRIBUTE_END)) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "checks if string is actually an attribute .", "label": "what"}
{"id": "27366", "raw_code": "public static String decodeASCII(final byte[] key,final int off,final int len){\n  final byte[] b=new byte[len];\n  System.arraycopy(key,off,b,0,len);\n  for (int i=0; i < len; i++) {\n    b[i]=decodeByte(b[i]);\n  }\n  try {\n    return new String(b,\"US-ASCII\");\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new RuntimeException(e);\n  }\n}", "comment": "decodes an ascii string from a key .", "label": "what"}
{"id": "22677", "raw_code": "public synchronized void removePropertyChangeListener(PropertyChangeListener listener){\n  listeners.remove(listener);\n}", "comment": "removes a property change listener .", "label": "what"}
{"id": "57575", "raw_code": "final boolean transferAfterCancelledWait(Node node){\n  if (compareAndSetWaitStatus(node,Node.CONDITION,0)) {\n    enq(node);\n    return true;\n  }\n  while (!isOnSyncQueue(node))   Thread.yield();\n  return false;\n}", "comment": "transfers node , if necessary , to sync queue after a cancelled wait .", "label": "what"}
{"id": "4494", "raw_code": "private static Intent createShareIntent(Context context,final String shareText){\n  final Intent shareIntent=new Intent(Intent.ACTION_SEND);\n  shareIntent.putExtra(android.content.Intent.EXTRA_SUBJECT,context.getString(R.string.share_subject));\n  shareIntent.putExtra(android.content.Intent.EXTRA_TEXT,shareText);\n  shareIntent.setType(\"text/plain\");\n  return shareIntent;\n}", "comment": "creates a share intent", "label": "what"}
{"id": "7165", "raw_code": "public static RowLimitSpec buildRowLimitSpec(EsperEPL2GrammarParser.RowLimitContext ctx){\n  Object numRows;\n  Object offset;\n  if (ctx.o != null) {\n    numRows=parseNumOrVariableIdent(ctx.n1,ctx.i1);\n    offset=parseNumOrVariableIdent(ctx.n2,ctx.i2);\n  }\n else   if (ctx.c != null) {\n    offset=parseNumOrVariableIdent(ctx.n1,ctx.i1);\n    numRows=parseNumOrVariableIdent(ctx.n2,ctx.i2);\n  }\n else {\n    numRows=parseNumOrVariableIdent(ctx.n1,ctx.i1);\n    offset=null;\n  }\n  Integer numRowsInt=null;\n  String numRowsVariable=null;\n  if (numRows instanceof String) {\n    numRowsVariable=(String)numRows;\n  }\n else {\n    numRowsInt=(Integer)numRows;\n  }\n  Integer offsetInt=null;\n  String offsetVariable=null;\n  if (offset instanceof String) {\n    offsetVariable=(String)offset;\n  }\n else {\n    offsetInt=(Integer)offset;\n  }\n  return new RowLimitSpec(numRowsInt,offsetInt,numRowsVariable,offsetVariable);\n}", "comment": "builds a row limit specification .", "label": "what"}
{"id": "33089", "raw_code": "public void saveIndexes(){\n  ArrayList toSave=new ArrayList();\nsynchronized (this) {\n    Object[] valueTable=this.indexes.valueTable;\n    for (int i=0, l=valueTable.length; i < l; i++) {\n      Index index=(Index)valueTable[i];\n      if (index != null)       toSave.add(index);\n    }\n  }\n  boolean allSaved=true;\n  for (int i=0, length=toSave.size(); i < length; i++) {\n    Index index=(Index)toSave.get(i);\n    ReadWriteMonitor monitor=index.monitor;\n    if (monitor == null)     continue;\n    try {\n      monitor.enterRead();\n      if (index.hasChanged()) {\n        if (monitor.exitReadEnterWrite()) {\n          try {\n            saveIndex(index);\n          }\n catch (          IOException e) {\n            if (JobManager.VERBOSE) {\n              Util.verbose(\"-> got the following exception while saving:\",System.err);\n              e.printStackTrace();\n            }\n            allSaved=false;\n          }\n finally {\n            monitor.exitWriteEnterRead();\n          }\n        }\n else {\n          allSaved=false;\n        }\n      }\n    }\n  finally {\n      monitor.exitRead();\n    }\n  }\n  if (this.participantsContainers != null && this.participantUpdated) {\n    writeParticipantsIndexNamesFile();\n    this.participantUpdated=false;\n  }\n  this.needToSave=!allSaved;\n}", "comment": "commit all index memory changes to disk", "label": "what"}
{"id": "70066", "raw_code": "public void addItem(Artist artist,int position){\n  if (artist == null)   throw new NullPointerException(\"The item cannot be null\");\n  if (position < getItemCount() || position > getItemCount())   throw new IllegalArgumentException(\"The position must be between 0 and lastIndex + 1\");\n  artists.add(position,artist);\n  notifyItemInserted(position);\n}", "comment": "add item in determined index", "label": "what"}
{"id": "36040", "raw_code": "public void expandAndSelectIfExists(RepositoryLocation location){\n  if (location.parent() != null) {\n    expandIfExists(location.parent(),location.getName());\n  }\n else {\n    expandIfExists(location,null);\n  }\n  scrollPathToVisible(getSelectionPath());\n}", "comment": "expands the tree to select the given entry if it exists .", "label": "what"}
{"id": "33770", "raw_code": "public void nextToken(){\n  previousLine=line;\n  previousColumn=column;\n  while (pos < matcher.regionStart()) {\n    if (text.charAt(pos) == '\\n') {\n      ++line;\n      column=0;\n    }\n else {\n      ++column;\n    }\n    ++pos;\n  }\n  if (matcher.regionStart() == matcher.regionEnd()) {\n    currentToken=\"\";\n  }\n else {\n    matcher.usePattern(TOKEN);\n    if (matcher.lookingAt()) {\n      currentToken=matcher.group();\n      matcher.region(matcher.end(),matcher.regionEnd());\n    }\n else {\n      currentToken=String.valueOf(text.charAt(pos));\n      matcher.region(pos + 1,matcher.regionEnd());\n    }\n    skipWhitespace();\n  }\n}", "comment": "advance to the next token .", "label": "what"}
{"id": "23236", "raw_code": "public static void saveProvisioningValidity(Context context,long validity){\n  if (validity <= 0L) {\n    return;\n  }\n  long next=System.currentTimeMillis() + validity;\n  SharedPreferences preferences=context.getSharedPreferences(AndroidRegistryFactory.RCS_PREFS_NAME,Activity.MODE_PRIVATE);\n  SharedPreferences.Editor editor=preferences.edit();\n  editor.putLong(REGISTRY_PROVISIONING_VALIDITY,validity);\n  editor.putLong(REGISTRY_PROVISIONING_EXPIRATION,next);\n  editor.commit();\n}", "comment": "save the provisioning validity in shared preferences", "label": "what"}
{"id": "48200", "raw_code": "public void encode(OutputStream out) throws IOException {\n  DerOutputStream tmp=new DerOutputStream();\n  if (this.extensionValue == null) {\n    this.extensionId=PKIXExtensions.ReasonCode_Id;\n    this.critical=false;\n    encodeThis();\n  }\n  super.encode(tmp);\n  out.write(tmp.toByteArray());\n}", "comment": "write the extension to the deroutputstream .", "label": "what"}
{"id": "22530", "raw_code": "public DriverTask unexportVolumesFromInitiators(List<Initiator> initiators,List<StorageVolume> volumes){\n  LOG.info(\"Unexporting volumes from initiators\");\n  DriverTask task=new DellSCDriverTask(\"unexportVolumes\");\n  ScServer server=null;\n  StringBuilder errBuffer=new StringBuilder();\n  int volumesUnmapped=0;\n  for (  StorageVolume volume : volumes) {\n    String ssn=volume.getStorageSystemId();\n    boolean isSnapshot=StringUtils.countMatches(volume.getNativeId(),\".\") == 2;\n    try {\n      StorageCenterAPI api=connectionManager.getConnection(ssn);\n      ScVolume scVol=null;\n      if (isSnapshot) {\n        scVol=api.findReplayView(volume.getNativeId());\n        if (scVol != null) {\n          api.deleteVolume(scVol.instanceId);\n          volumesUnmapped++;\n          continue;\n        }\n      }\n else {\n        scVol=api.getVolume(volume.getNativeId());\n      }\n      if (scVol == null) {\n        throw new DellSCDriverException(String.format(\"Unable to find volume %s\",volume.getNativeId()));\n      }\n      if (server == null) {\n        server=findScServer(api,ssn,initiators);\n      }\n      if (server == null) {\n        throw new DellSCDriverException(SERVER_CREATE_FAIL_MSG);\n      }\n      ScMappingProfile[] mappingProfiles=api.findMappingProfiles(server.instanceId,scVol.instanceId);\n      for (      ScMappingProfile mappingProfile : mappingProfiles) {\n        api.deleteMappingProfile(mappingProfile.instanceId);\n      }\n      volumesUnmapped++;\n      LOG.info(\"Volume '{}' unexported from server '{}'\",scVol.name,server.name);\n    }\n catch (    StorageCenterAPIException|DellSCDriverException dex) {\n      String error=String.format(\"Error unmapping volume %s: %s\",volume.getDisplayName(),dex);\n      LOG.error(error);\n      errBuffer.append(String.format(\"%s%n\",error));\n      if (SERVER_CREATE_FAIL_MSG.equals(dex.getMessage())) {\n        break;\n      }\n    }\n  }\n  task.setMessage(errBuffer.toString());\n  if (volumesUnmapped == volumes.size()) {\n    task.setStatus(TaskStatus.READY);\n  }\n else   if (volumesUnmapped == 0) {\n    task.setStatus(TaskStatus.FAILED);\n  }\n else {\n    task.setStatus(TaskStatus.PARTIALLY_FAILED);\n  }\n  return task;\n}", "comment": "remove volume exports to initiators .", "label": "what"}
{"id": "59914", "raw_code": "public void createClusterAsync(final String projectId,final ClusterCreateSpec clusterCreateSpec,final FutureCallback<Task> responseCallback) throws IOException {\n  String path=String.format(\"%s/%s/clusters\",getBasePath(),projectId);\n  createObjectAsync(path,serializeObjectAsJson(clusterCreateSpec),responseCallback);\n}", "comment": "create a cluster in the specified project .", "label": "what"}
{"id": "51154", "raw_code": "public static void writeUnsafe(PacketOutputStream out,String value,boolean noBackslashEscapes) throws IOException {\n  byte[] bytes=value.getBytes(\"UTF-8\");\n  out.writeUnsafe(QUOTE);\n  writeBytesEscapedUnsafe(out,bytes,bytes.length,noBackslashEscapes);\n  out.writeUnsafe(QUOTE);\n}", "comment": "write string in text format without checking buffer size .", "label": "what"}
{"id": "43520", "raw_code": "public static void equals(Object object1,Object object2){\n  checkAssertion(object1.equals(object2),null);\n}", "comment": "asserts that given object1 equals object2 .", "label": "what"}
{"id": "74643", "raw_code": "private ODataFeed readFeedLogPerf(String query,Map<String,String> params) throws IOException, ODataException {\n  long delta_time=System.currentTimeMillis();\n  ODataFeed feed=client.readFeed(query,params);\n  log(Level.DEBUG,\"query(\" + query + \") done in \"+ delta_time+ \"ms\");\n  return feed;\n}", "comment": "logs how much time an odata command consumed .", "label": "what"}
{"id": "67000", "raw_code": "public Dependencies resolveFromFile(File file,String className,SootClass sc){\n  DexlibWrapper wrapper=cache.get(file);\n  if (wrapper == null) {\n    wrapper=new DexlibWrapper(file);\n    cache.put(file,wrapper);\n    wrapper.initialize();\n  }\n  Dependencies deps=wrapper.makeSootClass(sc,className);\n  addSourceFileTag(sc,\"dalvik_source_\" + file.getName());\n  return deps;\n}", "comment": "resolve the class contained in file into the passed soot class .", "label": "what"}
{"id": "82013", "raw_code": "public static void assertLabel(int[] path,String text){\n  if (verbose) {\n    log(\"assertLabel(\" + toString(path) + \", \"+ text+ \")\");\n  }\n  Label l=(Label)getComponentByPath(path);\n  assertBool(l != null,\"Null label\" + text);\n  assertBool(text == l.getText() || text.equals(l.getText()),(\"\" + l.getText()) + \" != \" + text);\n}", "comment": "asserts that we have a label with the given text baring the given name", "label": "what"}
{"id": "53963", "raw_code": "private void interpolateResultList(ArrayList<PathParser.PathDataNode> list){\n  if (list == null || list.size() <= 2)   return;\n  float[][] listPenPos=PathNodeUtils.calculatePenPosition(list);\n  ArrayList<PathParser.PathDataNode> subList=new ArrayList<>();\n  int size=list.size();\n  PathParser.PathDataNode currentNode=null;\n  int i=0;\n  while (i < size - 1) {\n    currentNode=list.get(i);\n    if (!isInterpolatableCommand(currentNode.mType)) {\n      i++;\n      continue;\n    }\n    boolean validSequence=true;\n    int k=i;\n    for (int j=i; j < size && validSequence; j++) {\n      if (currentNode.mType == list.get(j).mType) {\n        k=j;\n        if (!Arrays.equals(currentNode.mParams,list.get(j).mParams))         break;\n      }\n else       validSequence=false;\n    }\n    if (k - i > 2) {\n      interpolateSubList(list.subList(i,k + 1));\n    }\n    i++;\n  }\n}", "comment": "apply interpolation on the result list ( where possible )", "label": "what"}
{"id": "39348", "raw_code": "private void initTokenizer(StreamTokenizer tokenizer){\n  tokenizer.resetSyntax();\n  tokenizer.whitespaceChars(0,(' ' - 1));\n  tokenizer.wordChars(' ','\\u00FF');\n  tokenizer.whitespaceChars(',',',');\n  tokenizer.whitespaceChars(':',':');\n  tokenizer.commentChar('|');\n  tokenizer.whitespaceChars('\\t','\\t');\n  tokenizer.quoteChar('\"');\n  tokenizer.quoteChar('\\'');\n  tokenizer.eolIsSignificant(true);\n}", "comment": "initializes the stream tokenizer", "label": "what"}
{"id": "22974", "raw_code": "public void open(int port) throws IOException {\n  connection=new DatagramSocket(port);\n  connection.setSoTimeout(timeout);\n}", "comment": "open the datagram connection", "label": "what"}
{"id": "49923", "raw_code": "public MLResults execute(Script script){\n  ScriptExecutor scriptExecutor=new ScriptExecutor(sparkMonitoringUtil);\n  scriptExecutor.setExplain(explain);\n  scriptExecutor.setExplainLevel(explainLevel);\n  scriptExecutor.setStatistics(statistics);\n  scriptExecutor.setInit(scriptHistoryStrings.isEmpty());\n  return execute(script,scriptExecutor);\n}", "comment": "execute a dml or pydml script .", "label": "what"}
{"id": "85529", "raw_code": "public void disable(RichFormatterFeature feature){\n  features.remove(feature);\n}", "comment": "disable a specific feature on this rich formatter .", "label": "what"}
{"id": "85457", "raw_code": "public static String quoteIfJavaKeyword(String name){\n  return JVMModuleUtil.quoteIfJavaKeyword(name);\n}", "comment": "prefixes the given name with a dollar ( $ ) if it is a java keyword", "label": "what"}
{"id": "5924", "raw_code": "private static <T,ID>void addDropTableStatements(DatabaseType databaseType,TableInfo<T,ID> tableInfo,List<String> statements){\n  List<String> statementsBefore=new ArrayList<String>();\n  List<String> statementsAfter=new ArrayList<String>();\n  for (  FieldType fieldType : tableInfo.getFieldTypes()) {\n    databaseType.dropColumnArg(fieldType,statementsBefore,statementsAfter);\n  }\n  StringBuilder sb=new StringBuilder(64);\n  sb.append(\"DROP TABLE \");\n  databaseType.appendEscapedEntityName(sb,tableInfo.getTableName());\n  sb.append(' ');\n  statements.addAll(statementsBefore);\n  statements.add(sb.toString());\n  statements.addAll(statementsAfter);\n}", "comment": "generate and return the list of statements to drop a database table .", "label": "what"}
{"id": "64443", "raw_code": "public static void write(File file,CharSequence data,Charset encoding,boolean append) throws IOException {\n  String str=data == null ? null : data.toString();\n  writeStringToFile(file,str,encoding,append);\n}", "comment": "writes a charsequence to a file creating the file if it does not exist .", "label": "what"}
{"id": "70520", "raw_code": "private void populateNavDrawer(){\n  mNavDrawerItems.clear();\n  mNavDrawerItems.add(NAVDRAWER_ITEM_HOME);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_SEPARATOR);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_FOLLOWING);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_SHOTS);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_BUCKETS);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_PROJECTS);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_TEAMS);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_LIKES);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_SEPARATOR_SPECIAL);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_SETTINGS);\n  createNavDrawerItems();\n}", "comment": "populates the navigation drawer with the appropriate items .", "label": "what"}
{"id": "12815", "raw_code": "public static float mean(float[] data,int startIndex,int endIndex){\n  float mean=0;\n  int total=0;\n  startIndex=Math.max(startIndex,0);\n  startIndex=Math.min(startIndex,data.length - 1);\n  endIndex=Math.max(endIndex,0);\n  endIndex=Math.min(endIndex,data.length - 1);\n  if (startIndex > endIndex)   startIndex=endIndex;\n  for (int i=startIndex; i <= endIndex; i++) {\n    if (Float.isNaN(data[i]))     throw new IllegalArgumentException(\"NaN not allowed in mean calculation\");\n    mean+=data[i];\n    total++;\n  }\n  mean/=total;\n  return mean;\n}", "comment": "compute the mean of all elements in the array .", "label": "what"}
{"id": "23275", "raw_code": "public static String constructNTPtime(long date){\n  long ntpTime=2208988800L;\n  long startTime=(date / SECONDS_TO_MILLISECONDS_CONVERSION_RATE) + ntpTime;\n  return String.valueOf(startTime);\n}", "comment": "construct an ntp time from a date in milliseconds", "label": "what"}
{"id": "77115", "raw_code": "public void invalidateAndUnmap(ByteBuffer... bufs) throws IOException {\n  if (cleaner != null) {\n    invalidated=true;\n    barrier.lazySet(0);\n    Thread.yield();\n    for (    ByteBuffer b : bufs) {\n      cleaner.freeBuffer(resourceDescription,b);\n    }\n  }\n}", "comment": "invalidates this guard and unmaps ( if supported ) .", "label": "what"}
{"id": "83979", "raw_code": "private boolean isMineshafterPresent(){\n  try {\n    Class.forName(\"mineshafter.MineServer\");\n    return true;\n  }\n catch (  Exception e) {\n    return false;\n  }\n}", "comment": "check if mineshafter is present .", "label": "what"}
{"id": "15270", "raw_code": "public static boolean hasElementChild(Node node){\n  NodeList nl=node.getChildNodes();\n  Node child=null;\n  int length=nl.getLength();\n  for (int i=0; i < length; i++) {\n    child=nl.item(i);\n    if (child.getNodeType() == Node.ELEMENT_NODE) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "checks if a node has a child of element type .", "label": "what"}
{"id": "49208", "raw_code": "public void delItem(int index){\nsynchronized (getMenuTreeLock()) {\n    if (selectedIndex == index) {\n      selectItem(null,false);\n    }\n else     if (selectedIndex > index) {\n      selectedIndex--;\n    }\n    if (index < items.size()) {\n      items.remove(index);\n    }\n else {\n      if (log.isLoggable(PlatformLogger.Level.FINE)) {\n        log.fine(\"WARNING: Attempt to remove non-existing menu item, index : \" + index + \", item count : \"+ items.size());\n      }\n    }\n  }\n  updateSize();\n}", "comment": "removes item at the specified index from items vector .", "label": "what"}
{"id": "84175", "raw_code": "public void printString(String v) throws IOException {\n  printString(v,0,v.length());\n}", "comment": "prints a string to the stream , encoded as utf - 8", "label": "what"}
{"id": "56813", "raw_code": "private void checkPermission(Object object,NamespacePermissionEnum[] permissions,List<AccessDeniedException> accessDeniedExceptions){\n  if (object != null) {\n    if (object instanceof Collection) {\n      Collection<?> collection=(Collection<?>)object;\n      for (      Object element : collection) {\n        checkPermission(element,permissions,accessDeniedExceptions);\n      }\n    }\n else     if (object instanceof String) {\n      try {\n        checkPermission((String)object,permissions);\n      }\n catch (      AccessDeniedException accessDeniedException) {\n        accessDeniedExceptions.add(accessDeniedException);\n      }\n    }\n else {\n      throw new IllegalStateException(String.format(\"Object must be of type %s or %s. Actual object.class = %s\",String.class,Collection.class,object.getClass()));\n    }\n  }\n}", "comment": "checks the current user ' s permissions against the given object which may represent a single or multiple namespaces .", "label": "what"}
{"id": "99", "raw_code": "private void displayAllStringDefinedInStringXml(){\n  SimpleIconFontTextView textView=(SimpleIconFontTextView)findViewById(R.id.text_view_2);\n  List<String> list=new ArrayList<>();\n  list.add(getString(R.string.cubeicon_gems_logo));\n  list.add(getString(R.string.cubeicon_android));\n  list.add(getString(R.string.cubeicon_heart));\n  String text=TextUtils.join(\" \",list);\n  textView.setText(text);\n}", "comment": "display the string defined in the string xml file : iconfont _ string . xml", "label": "what"}
{"id": "57424", "raw_code": "public void removeAttribute(int index){\n  if (index >= 0 && index < length) {\n    if (index < length - 1) {\n      System.arraycopy(data,(index + 1) * 5,data,index * 5,(length - index - 1) * 5);\n    }\n    index=(length - 1) * 5;\n    data[index++]=null;\n    data[index++]=null;\n    data[index++]=null;\n    data[index++]=null;\n    data[index]=null;\n    length--;\n  }\n else {\n    badIndex(index);\n  }\n}", "comment": "remove an attribute from the list .", "label": "what"}
{"id": "71526", "raw_code": "@RequiresPermission(Manifest.permission.CAMERA) public CameraSource start() throws IOException {\nsynchronized (mCameraLock) {\n    if (mCamera != null) {\n      return this;\n    }\n    mCamera=createCamera();\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n      mDummySurfaceTexture=new SurfaceTexture(DUMMY_TEXTURE_NAME);\n      mCamera.setPreviewTexture(mDummySurfaceTexture);\n    }\n else {\n      mDummySurfaceView=new SurfaceView(mContext);\n      mCamera.setPreviewDisplay(mDummySurfaceView.getHolder());\n    }\n    mCamera.startPreview();\n    mProcessingThread=new Thread(mFrameProcessor);\n    mFrameProcessor.setActive(true);\n    mProcessingThread.start();\n  }\n  return this;\n}", "comment": "opens the camera and starts sending preview frames to the underlying detector .", "label": "what"}
{"id": "52581", "raw_code": "public synchronized void clear(){\n  mCategories.clear();\n  mValues.clear();\n}", "comment": "removes all the existing values from the series .", "label": "what"}
{"id": "46263", "raw_code": "private static void updateWindowUI(Window window){\n  SwingUtilities.updateComponentTreeUI(window);\n  Window ownedWins[]=window.getOwnedWindows();\n  for (  Window ownedWin : ownedWins) {\n    updateWindowUI(ownedWin);\n  }\n}", "comment": "updates the ui of the passed in window and all its children .", "label": "what"}
{"id": "28886", "raw_code": "public void clearResults(){\n  if (resultList != null) {\n    resultList.clear();\n    mAdapter.notifyDataSetChanged();\n  }\n  listener.onSearchCleared();\n}", "comment": "clear all the results", "label": "what"}
{"id": "52356", "raw_code": "public final void printSymbol(CharSequence text) throws IOException {\n  if (text == null) {\n    appendAscii(\"null.symbol\");\n  }\n else   if (text.length() == 0) {\n    throw new EmptySymbolException();\n  }\n else   if (symbolNeedsQuoting(text,true)) {\n    appendAscii('\\'');\n    printCodePoints(text,SYMBOL_ESCAPE_CODES);\n    appendAscii('\\'');\n  }\n else {\n    appendAscii(text);\n  }\n}", "comment": "print an ion symbol type .", "label": "what"}
{"id": "37031", "raw_code": "protected final void updateBorderText(final String text){\n  Preconditions.checkNotNull(text,\"IE01842: Text argument can not be null\");\n  m_titledBorder.setTitle(text);\n  updateUI();\n}", "comment": "updates the border text of the component .", "label": "what"}
{"id": "13183", "raw_code": "protected DateTimeData parse(String str) throws SchemaDateTimeException {\n  DateTimeData date=new DateTimeData(str,this);\n  int len=str.length();\n  date.year=YEAR;\n  date.day=DAY;\n  if (str.charAt(0) != '-' || str.charAt(1) != '-') {\n    throw new SchemaDateTimeException(\"Invalid format for gMonth: \" + str);\n  }\n  int stop=4;\n  date.month=parseInt(str,2,stop);\n  if (str.length() >= stop + 2 && str.charAt(stop) == '-' && str.charAt(stop + 1) == '-') {\n    stop+=2;\n  }\n  if (stop < len) {\n    if (!isNextCharUTCSign(str,stop,len)) {\n      throw new SchemaDateTimeException(\"Error in month parsing: \" + str);\n    }\n else {\n      getTimeZone(str,date,stop,len);\n    }\n  }\n  validateDateTime(date);\n  saveUnnormalized(date);\n  if (date.utc != 0 && date.utc != 'Z') {\n    normalize(date);\n  }\n  date.position=1;\n  return date;\n}", "comment": "parses , validates and computes normalized version of gmonth object", "label": "what"}
{"id": "86507", "raw_code": "private void addToQueue(SerialMessage serialMessage){\n  if (serialMessage == null) {\n    return;\n  }\n  if (!msgQueue.contains(serialMessage) && msgQueue.remainingCapacity() > 1) {\n    msgQueue.add(serialMessage);\n  }\n  sendMessage();\n}", "comment": "move the messages to the queue", "label": "what"}
{"id": "52971", "raw_code": "private DBID stringToDBID(String query){\n  return DBIDUtil.importInteger(Integer.valueOf(query));\n}", "comment": "parse a string into a dbid .", "label": "what"}
{"id": "3659", "raw_code": "final public void println(long v){\n  Writer out=this.out;\n  if (out == null)   return;\n  print(v);\n  try {\n    out.write(_newline,0,_newline.length);\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}", "comment": "prints a long followed by a newline .", "label": "what"}
{"id": "29710", "raw_code": "public ThriftServiceMetadata(Class<?> serviceType){\n  requireNonNull(serviceType,\"serviceType\");\n  interfaces=init(null,Collections.singleton(serviceType));\n}", "comment": "creates a new instance from a single thrift service interface .", "label": "what"}
{"id": "48832", "raw_code": "public WritableRaster createCompatibleWritableRaster(int w,int h){\n  if (w <= 0 || h <= 0) {\n    throw new RasterFormatException(\"negative \" + ((w <= 0) ? \"width\" : \"height\"));\n  }\n  SampleModel sm=sampleModel.createCompatibleSampleModel(w,h);\n  return new BytePackedRaster(sm,new Point(0,0));\n}", "comment": "creates a raster with the same layout but using a different width and height , and with new zeroed data arrays .", "label": "what"}
{"id": "67509", "raw_code": "private void parseSwitch(int indent,boolean firstContent,String header,Layout layout,List<Elem> elems){\n  TokenStream tokens=new TokenStream(header);\n  Elem selector=parseExpr(tokens);\n  tokens.checkAtEnd();\n  ImmutableList.Builder<Case> cases=ImmutableList.builder();\n  List<Elem> defaultElems=null;\n  boolean done;\n  String line=getNextLine();\n  Matcher matcher=COMMAND_LINE.matcher(line);\n  String command;\n  String rest;\n  if (matcher.find()) {\n    command=matcher.group(COMMAND_NAME_GROUP);\n    rest=line.substring(matcher.end());\n    done=false;\n  }\n else {\n    error(\"expected '@end', '@case' or '@default' command after 'switch'\");\n    done=true;\n    command=null;\n    rest=null;\n  }\n  while (!done) {\nswitch (command) {\ncase END_COMMAND:\n      checkHeaderEmpty(command,rest);\n    done=true;\n  break;\ncase DEFAULT_COMMAND:\ncheckHeaderEmpty(command,rest);\nif (defaultElems != null) {\nerror(\"duplicate '@default' in @switch\");\n}\ndefaultElems=parseUntil(indent,layout,END_COMMAND);\ncommand=lastTerminator;\nrest=lastTerminatorHeader;\ndone=lastTerminator == null;\nbreak;\ncase CASE_COMMAND:\ntokens=new TokenStream(rest);\nElem value=parseExpr(tokens);\ntokens.checkAtEnd();\nList<Elem> caseElems=parseUntil(indent,layout,END_COMMAND,CASE_COMMAND,DEFAULT_COMMAND);\nif (value != null) {\ncases.add(Case.create(value,caseElems));\n}\ncommand=lastTerminator;\nrest=lastTerminatorHeader;\ndone=lastTerminator == null;\nbreak;\ndefault :\nunexpectedCommandError(command);\ndone=true;\nbreak;\n}\n}\nif (selector != null) {\nelems.add(Block.create(!firstContent,Switch.create(input.location(),selector,cases.build(),defaultElems)));\n}\n}", "comment": "parse a switch command .", "label": "what"}
{"id": "23606", "raw_code": "public static Properties createProperties(final Map<String,String> map){\n  Properties properties=new Properties();\n  if (!(map == null || map.isEmpty())) {\n    for (    Entry<String,String> entry : map.entrySet()) {\n      properties.setProperty(entry.getKey(),entry.getValue());\n    }\n  }\n  return properties;\n}", "comment": "creates an properties object initialized with the value from the given map .", "label": "what"}
{"id": "11167", "raw_code": "public void generate(int x1,int y1,int x2,int y2){\n  Point midPoint=new Point();\n  Point arcCenter=new Point();\n  Point2D peakPoint=new Point2D.Float();\n  double distance=Math.sqrt(Math.pow(Math.abs(y2 - y1),2.0) + Math.pow(Math.abs(x2 - x1),2.0));\n  double straightLineSlope=Math.atan((double)(y2 - y1) / (double)(x2 - x1));\n  double inverseSlope=straightLineSlope - (Math.PI / 2.0);\n  if (Debug.debugging(\"arc\")) {\n    Debug.output(\"ArcCalc.generate: Slope is \" + Math.toDegrees(straightLineSlope) + \" degrees, distance = \"+ distance+ \" pixels.\");\n  }\n  midPoint.setLocation(x1 + ((x2 - x1) / 2),y1 + ((y2 - y1) / 2));\n  if (Debug.debugging(\"arc\")) {\n    Debug.output(\"ArcCalc.generate: Center point for (\" + x1 + \", \"+ y1+ \") to (\"+ x2+ \", \"+ y2+ \") is (\"+ midPoint.x+ \", \"+ midPoint.y+ \")\");\n  }\n  double arccos=Math.cos(arcAngle);\n  double arcRadius;\n  if (arccos != 1.0) {\n    arcRadius=distance / Math.sqrt(2.0 * (1.0 - Math.cos(arcAngle)));\n  }\n else {\n    arcRadius=distance / Math.sqrt(2.0);\n  }\n  if (Debug.debugging(\"arc\")) {\n    Debug.output(\"ArcCalc.generate: radius of arc = \" + arcRadius);\n  }\n  double x=arcRadius - arcRadius * Math.cos(arcAngle);\n  double rPrime=(distance / 2.0) * (Math.sqrt(1.0 - Math.pow(x / distance,2.0))) / Math.sin(arcAngle / 2.0);\n  if (Debug.debugging(\"arc\")) {\n    Debug.output(\"ArcCalc.generate: rPrime = \" + rPrime);\n  }\n  int direction=1;\n  if (arcUp)   direction=-1;\n  arcCenter.x=midPoint.x + (direction * (int)(rPrime * Math.cos(inverseSlope)));\n  arcCenter.y=midPoint.y + (direction * (int)(rPrime * Math.sin(inverseSlope)));\n  if (Debug.debugging(\"arc\")) {\n    Debug.output(\"ArcCalc.generateArc: creating supplimental graphics list\");\n    arcGraphics=new OMGraphicList();\n    double dist1=Math.sqrt(Math.pow((double)(arcCenter.x - x1),2.0) + Math.pow((double)(arcCenter.y - y1),2.0));\n    double dist2=Math.sqrt(Math.pow((double)(arcCenter.x - x2),2.0) + Math.pow((double)(arcCenter.y - y2),2.0));\n    Debug.output(\"ArcCalc.generate: Center focus for arc is (\" + arcCenter.x + \", \"+ arcCenter.y+ \") along slope line of \"+ Math.toDegrees(inverseSlope)+ \" degrees).\");\n    Debug.output(\"ArcCalc.generate: Distance to point 1 from arc focus = \" + dist1 + \"\\n                    Distance to point 2 from arc focus = \"+ dist2);\n    OMRect point1=new OMRect(x1 - 1,y1 - 1,x1 + 1,y1 + 1);\n    OMRect point2=new OMRect(x2 - 1,y2 - 1,x2 + 1,y2 + 1);\n    OMRect arcPoint=new OMRect(arcCenter.x - 1,arcCenter.y - 1,arcCenter.x + 1,arcCenter.y + 1);\n    point1.setLinePaint(OMColor.red);\n    point2.setLinePaint(OMColor.red);\n    arcPoint.setLinePaint(OMColor.blue);\n    arcGraphics.add(point1);\n    arcGraphics.add(point2);\n    arcGraphics.add(arcPoint);\n    OMLine line1=new OMLine(x1,y1,x2,y2);\n    OMLine line2=new OMLine(midPoint.x,midPoint.y,arcCenter.x,arcCenter.y);\n    arcGraphics.add(line1);\n    arcGraphics.add(line2);\n  }\n  int realCount=0;\n  double startSlope=getRealAngle((float)arcCenter.getX(),(float)arcCenter.getY(),x1,y1);\n  double endSlope=getRealAngle((float)arcCenter.getX(),(float)arcCenter.getY(),x2,y2);\n  double smallSlope, largeSlope;\n  double angleIncrement;\n  smallSlope=(startSlope > endSlope) ? endSlope : startSlope;\n  largeSlope=(smallSlope == startSlope) ? endSlope : startSlope;\n  while (Math.abs(smallSlope - largeSlope) > Math.PI) {\n    if (Math.abs(largeSlope - smallSlope - Math.PI) < .001) {\n      break;\n    }\n    Debug.message(\"arc\",\"ArcCalc.generate: Modifying the starting slope.\");\n    double tmpSlope=smallSlope + MoreMath.TWO_PI;\n    smallSlope=largeSlope;\n    largeSlope=tmpSlope;\n  }\n  if (MoreMath.approximately_equal(arcAngle,Math.PI) && arcUp) {\n    Debug.message(\"arc\",\"ArcCalc.generate: Modifying 180 angle points.\");\n    double tmpSlope=smallSlope + MoreMath.TWO_PI;\n    smallSlope=largeSlope;\n    largeSlope=tmpSlope;\n  }\n  if (Math.abs(y2 - y1) < Math.abs(x2 - x1)) {\n    angleIncrement=Math.PI / Math.abs(x2 - x1);\n  }\n else {\n    angleIncrement=Math.PI / Math.abs(y2 - y1);\n  }\n  int numPoints=(int)(Math.abs(smallSlope - largeSlope) / angleIncrement + 2);\n  float[] xPoints=new float[numPoints];\n  float[] yPoints=new float[numPoints];\n  if (Debug.debugging(\"arc\")) {\n    Debug.output(\"ArcCalc.generate: angle to x1, y1 is \" + startSlope + \" (\"+ Math.toDegrees(startSlope)+ \" degrees), angle to x2, y2 is \"+ endSlope+ \" (\"+ Math.toDegrees(endSlope)+ \" degrees)\");\n    Debug.output(\"ArcCalc.generate: Starting angle is \" + smallSlope + \"(\"+ Math.toDegrees(smallSlope)+ \" degrees), end angle is \"+ largeSlope+ \" (\"+ Math.toDegrees(largeSlope)+ \" degrees), incrementing by \"+ angleIncrement+ \" (\"+ Math.toDegrees(angleIncrement)+ \" degrees)\");\n  }\n  reversed=false;\n  while (smallSlope < largeSlope && realCount < numPoints) {\n    xPoints[realCount]=arcCenter.x + (int)(arcRadius * Math.cos(smallSlope));\n    yPoints[realCount]=arcCenter.y + (int)(arcRadius * Math.sin(smallSlope));\n    if (realCount == 0 && xPoints[realCount] == x2) {\n      Debug.message(\"arc\",\"ArcCalc: line reversed\");\n      reversed=true;\n    }\n    if (Debug.debugging(\"arc\") && realCount == 0) {\n      OMLine startLine=new OMLine(arcCenter.x,arcCenter.y,(int)xPoints[0],(int)yPoints[0]);\n      startLine.setLinePaint(OMColor.white);\n      arcGraphics.add(startLine);\n    }\n else     if (Debug.debugging(\"arcdetail\")) {\n      Debug.output(\"  angle \" + smallSlope + \" (\"+ smallSlope * 180 / Math.PI + \" degrees)  = \" + xPoints[realCount] + \", \" + yPoints[realCount]);\n    }\n    if (Math.abs(largeSlope - smallSlope - (arcAngle / 2.0)) < angleIncrement) {\n      peakPoint.setLocation(xPoints[realCount],yPoints[realCount]);\n      Debug.message(\"arc\",\"ArcCalc: Found a midpoint.\");\n    }\n    smallSlope+=angleIncrement;\n    realCount++;\n  }\n  xpoints=new float[realCount];\n  ypoints=new float[realCount];\n  System.arraycopy(xPoints,0,xpoints,0,realCount);\n  System.arraycopy(yPoints,0,ypoints,0,realCount);\n}", "comment": "generate the points that will generate the curved line between two points .", "label": "what"}
{"id": "86420", "raw_code": "private static int compareLocales(Locale primary,Locale other){\n  final String lang=primary.getLanguage();\n  if ((lang == null) || !lang.equals(other.getLanguage())) {\n    return 0;\n  }\n  final String country=primary.getCountry();\n  if ((country == null) || !country.equals(other.getCountry())) {\n    return 1;\n  }\n  final String variant=primary.getVariant();\n  if ((variant == null) || !variant.equals(other.getVariant())) {\n    return 2;\n  }\n  return 3;\n}", "comment": "compares a locale against a primary locale .", "label": "what"}
{"id": "63548", "raw_code": "void queryReadResult(PreparedStatement prep) throws SQLException {\n  ResultSet rs=prep.executeQuery();\n  ResultSetMetaData meta=rs.getMetaData();\n  int columnCount=meta.getColumnCount();\n  while (rs.next()) {\n    for (int i=0; i < columnCount; i++) {\n      rs.getString(i + 1);\n    }\n  }\n}", "comment": "execute a query and read all rows .", "label": "what"}
{"id": "66252", "raw_code": "public boolean equals(Object obj){\n  if (obj instanceof MSort) {\n    MSort ms=(MSort)obj;\n    if (data == ms.data)     return true;\n  }\n  return false;\n}", "comment": "equal ( based on data , ignores index )", "label": "what"}
{"id": "36811", "raw_code": "public static void endTransaction(final CConnection connection) throws SQLException {\n  endTransaction(connection.getConnection());\n}", "comment": "commits and finishes a formerly started transaction .", "label": "what"}
{"id": "37137", "raw_code": "public CCrossReferencesPanel(){\n  super(new BorderLayout());\n  m_table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n  add(new JScrollPane(m_table));\n  m_table.addMouseListener(new InternalMouseListener());\n}", "comment": "creates a new panel object .", "label": "what"}
{"id": "60899", "raw_code": "private void doubleCapacity(){\n  int p=head;\n  int n=elements.length;\n  int r=n - p;\n  int newCapacity=n << 1;\n  if (newCapacity < 0)   throw new IllegalStateException(\"Sorry, deque too big\");\n  Object[] a=new Object[newCapacity];\n  System.arraycopy(elements,p,a,0,r);\n  System.arraycopy(elements,0,a,r,p);\n  elements=a;\n  head=0;\n  tail=n;\n}", "comment": "double the capacity of this deque .", "label": "what"}
{"id": "15372", "raw_code": "private void changeOpenAMDebugFolder(String newOpenAMDebugFolder){\n  SystemPropertiesManager.initializeProperties(DebugConstants.CONFIG_DEBUG_DIRECTORY,newOpenAMDebugFolder);\n}", "comment": "change the debug logs folder", "label": "what"}
{"id": "3848", "raw_code": "private void loadManifest(){\n  if (_isManifestRead)   return;\nsynchronized (this) {\n    if (_isManifestRead)     return;\n    try {\n      _manifest=_jarPath.getManifest();\n      if (_manifest == null)       return;\n      Attributes attr=_manifest.getMainAttributes();\n      if (attr != null)       addManifestPackage(\"\",attr);\n      Map<String,Attributes> entries=_manifest.getEntries();\n      for (      Map.Entry<String,Attributes> entry : entries.entrySet()) {\n        String pkg=entry.getKey();\n        attr=entry.getValue();\n        if (attr == null)         continue;\n        addManifestPackage(pkg,attr);\n      }\n    }\n catch (    IOException e) {\n      log.log(Level.WARNING,e.toString(),e);\n    }\n finally {\n      _isManifestRead=true;\n    }\n  }\n}", "comment": "reads the jar ' s manifest .", "label": "what"}
{"id": "81351", "raw_code": "public ReferenceBinding[] convertToRawTypes(ReferenceBinding[] originalTypes,boolean forceErasure,boolean forceRawEnclosingType){\n  if (originalTypes == null)   return null;\n  ReferenceBinding[] convertedTypes=originalTypes;\n  for (int i=0, length=originalTypes.length; i < length; i++) {\n    ReferenceBinding originalType=originalTypes[i];\n    ReferenceBinding convertedType=(ReferenceBinding)convertToRawType(forceErasure ? originalType.erasure() : originalType,forceRawEnclosingType);\n    if (convertedType != originalType) {\n      if (convertedTypes == originalTypes) {\n        System.arraycopy(originalTypes,0,convertedTypes=new ReferenceBinding[length],0,i);\n      }\n      convertedTypes[i]=convertedType;\n    }\n else     if (convertedTypes != originalTypes) {\n      convertedTypes[i]=originalType;\n    }\n  }\n  return convertedTypes;\n}", "comment": "convert an array of types in raw forms .", "label": "what"}
{"id": "71589", "raw_code": "public void addColumn(int idx,Column column){\n  if (column != null) {\n    columns.add(idx,column);\n  }\n}", "comment": "adds the given column at the specified position .", "label": "what"}
{"id": "83722", "raw_code": "public void readData(DataInput din) throws IOException {\n  reference=din.readUnsignedShort();\n  andMask=din.readUnsignedShort();\n  orMask=din.readUnsignedShort();\n}", "comment": "readdata - - dummy function .", "label": "what"}
{"id": "63936", "raw_code": "boolean removeDisplay(Display display){\n  return m_displays.remove(display);\n}", "comment": "remove a display from this visualization .", "label": "what"}
{"id": "27513", "raw_code": "private void fireEvent(final IRunningQuery q){\n  if (q == null)   throw new IllegalArgumentException();\n  if (listeners.isEmpty()) {\n    return;\n  }\n  final IRunningQueryListener[] a=listeners.toArray(new IRunningQueryListener[0]);\n  for (  IRunningQueryListener l : a) {\n    final IRunningQueryListener listener=l;\n    try {\n      listener.notify(q);\n    }\n catch (    Throwable t) {\n      if (InnerCause.isInnerCause(t,InterruptedException.class)) {\n        throw new RuntimeException(t);\n      }\n      log.error(t,t);\n    }\n  }\n}", "comment": "send an event to all registered listeners .", "label": "what"}
{"id": "23116", "raw_code": "private void updateContactHeaderPort(int localPort,SIPMessage message){\n  if (message != null && message.getContactHeader() != null) {\n    ContactHeader contactHeader=message.getContactHeader();\n    Address contactAddress=contactHeader.getAddress();\n    contactAddress.setPort(localPort);\n  }\n}", "comment": "update port of contact header to reflect local port", "label": "what"}
{"id": "64548", "raw_code": "public static AndroidHttpClient newInstance(String userAgent){\n  return newInstance(userAgent,null);\n}", "comment": "create a new httpclient with reasonable defaults ( which you can update ) .", "label": "what"}
{"id": "69757", "raw_code": "@Override public void visitVertex(StreetRouter.State state){\n  Integer edgeIdx=state.backEdge;\n  if (!(edgeIdx == null || edgeIdx == -1)) {\n    EdgeStore.Edge edge=edgeStore.getCursor(edgeIdx);\n    GeoJsonFeature feature=new GeoJsonFeature(edge.getGeometry());\n    feature.addProperty(\"weight\",state.weight);\n    feature.addProperty(\"mode\",state.streetMode);\n    feature.addProperty(\"backEdge\",state.backEdge);\n    features.add(feature);\n  }\n}", "comment": "saves current state geometry mode and weight as geojson feature properties in list of features .", "label": "what"}
{"id": "9222", "raw_code": "public static void deleteFileOrLog(File file){\n  if (!file.delete()) {\n    logger.warn(FAILED_DELETING_FILE + file.getPath());\n  }\n}", "comment": "delete a file from the file system or log the failure if unable to delete it .", "label": "what"}
{"id": "52595", "raw_code": "public synchronized void remove(int index){\n  super.remove(index);\n  mMaxValues.remove(index);\n}", "comment": "removes existing values from the series .", "label": "what"}
{"id": "13358", "raw_code": "public GitlabGroupMember addGroupMember(GitlabGroup group,GitlabUser user,GitlabAccessLevel accessLevel) throws IOException {\n  return addGroupMember(group.getId(),user.getId(),accessLevel);\n}", "comment": "add a group member .", "label": "what"}
{"id": "52955", "raw_code": "@Override public void increment(double coord,short val){\n  int bin=getBinNr(coord);\n  if (bin < 0) {\n    if (size - bin > data.length) {\n      short[] tmpdata=new short[growSize(data.length,size - bin)];\n      System.arraycopy(data,0,tmpdata,-bin,size);\n      data=tmpdata;\n    }\n else {\n      System.arraycopy(data,0,data,-bin,size);\n      Arrays.fill(data,0,-bin,(short)0);\n    }\n    data[0]=val;\n    assert (data.length >= size - bin);\n    offset-=bin;\n    size-=bin;\n  }\n else   if (bin >= data.length) {\n    short[] tmpdata=new short[growSize(data.length,bin + 1)];\n    System.arraycopy(data,0,tmpdata,0,size);\n    tmpdata[bin]=val;\n    data=tmpdata;\n    size=bin + 1;\n    max=Double.MAX_VALUE;\n  }\n else {\n    if (bin >= size) {\n      size=bin + 1;\n    }\n    data[bin]+=val;\n  }\n}", "comment": "increment the value of a bin .", "label": "what"}
{"id": "85921", "raw_code": "public static void checkArgument(boolean expression,Object errorMessage){\n  if (!expression) {\n    throw new IllegalArgumentException(String.valueOf(errorMessage));\n  }\n}", "comment": "ensures the truth of an expression involving one or more parameters to the calling method .", "label": "what"}
{"id": "54060", "raw_code": "default Document putAll(Map<? extends CharSequence,Object> fields){\n  if (fields != null) {\n    for (    Map.Entry<? extends CharSequence,Object> entry : fields.entrySet()) {\n      set(entry.getKey(),entry.getValue());\n    }\n  }\n  return this;\n}", "comment": "sets on this object all key / value pairs from the supplied map .", "label": "what"}
{"id": "15828", "raw_code": "private boolean containsIgnoreCase(List<String> stringlist,String match){\n  for (  String s : stringlist) {\n    if (s.equalsIgnoreCase(match)) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "checks if a list of string contains a string while ignoring case", "label": "what"}
{"id": "53139", "raw_code": "public static double computeMAD(double[] x,double median){\n  for (int i=0; i < x.length; i++) {\n    x[i]=Math.abs(x[i] - median);\n  }\n  double mad=QuickSelect.median(x);\n  if (!(mad > 0.)) {\n    double min=Double.POSITIVE_INFINITY;\n    for (    double xi : x) {\n      if (xi > 0. && xi < min) {\n        min=xi;\n      }\n    }\n    if (min < Double.POSITIVE_INFINITY) {\n      mad=min;\n    }\n else {\n      mad=1.0;\n    }\n  }\n  return mad;\n}", "comment": "compute the median absolute deviation from median .", "label": "what"}
{"id": "36926", "raw_code": "private static <T>void initializeKnownPlugins(final T pluginInterface,final IPluginRegistry<IPlugin<T>> registry,final List<PluginConfigItem> xmlPluginOrder,final List<Pair<IPlugin<T>,PluginStatus>> validatedPlugins,final List<Pair<IPlugin<T>,Exception>> initializedPlugins,final Set<Long> processedPlugins){\n  for (  final PluginConfigItem pt : xmlPluginOrder) {\n    processedPlugins.add(pt.getGUID());\n    final IPlugin<T> plugin=findPlugin(validatedPlugins,pt.getGUID());\n    if (plugin != null) {\n      if (pt.isLoad()) {\n        initializePlugin(plugin,pluginInterface,registry,initializedPlugins);\n      }\n else {\n        registry.addDisabledPlugin(plugin,DisabledPluginReason.NotLoaded);\n      }\n    }\n  }\n}", "comment": "loads the plugins that are configured in the configuration file .", "label": "what"}
{"id": "37509", "raw_code": "public static void sessionStop(){\n  if (mProcess == null)   return;\n  mProcess.destroy();\n  mProcess=null;\n}", "comment": "stops the superuser session", "label": "what"}
{"id": "6003", "raw_code": "public static void keepAlive(final boolean keepAlive){\n  setProperty(\"http.keepAlive\",Boolean.toString(keepAlive));\n}", "comment": "set the ' http . keepalive ' property to the given value .", "label": "what"}
{"id": "4530", "raw_code": "public static Request newUploadVideoRequest(Session session,File file,Callback callback) throws FileNotFoundException {\n  ParcelFileDescriptor descriptor=ParcelFileDescriptor.open(file,ParcelFileDescriptor.MODE_READ_ONLY);\n  Bundle parameters=new Bundle(1);\n  parameters.putParcelable(file.getName(),descriptor);\n  return new Request(session,MY_VIDEOS,parameters,HttpMethod.POST,callback);\n}", "comment": "creates a new request configured to upload a photo to the user ' s default photo album .", "label": "what"}
{"id": "32416", "raw_code": "private MulticastSocket createSocket() throws IOException {\n  MulticastSocket sock=new MulticastSocket(mcastPort);\n  sock.setLoopbackMode(false);\n  if (sockItf != null)   sock.setInterface(sockItf);\n  if (sock.getLoopbackMode())   U.warn(log,\"Loopback mode is disabled which prevents nodes on the same machine from discovering \" + \"each other.\");\n  sock.joinGroup(mcastGrp);\n  if (ttl != -1)   sock.setTimeToLive(ttl);\n  return sock;\n}", "comment": "creates multicast socket and joins multicast group .", "label": "what"}
{"id": "84725", "raw_code": "void copyNodeStructure(ArrayList<Node> destination){\n  while (destination.size() < nodes.size())   destination.add(new Node());\n  while (destination.size() > nodes.size())   destination.remove(0);\n  int n=nodes.size();\n  for (int i=0; i < n; i++) {\n    Node node0=nodes.get(i);\n    Node node1=destination.get(i);\n    node1.heightParameter=node0.heightParameter;\n    node1.rateParameter=node0.rateParameter;\n    node1.traitParameter=node0.traitParameter;\n    node1.partitioning=node0.partitioning;\n    node1.taxon=node0.taxon;\n    node1.bifurcation=node0.bifurcation;\n    node1.number=node0.number;\n    node1.myHashCode=node0.myHashCode;\n    if (node0.leftParent != null) {\n      node1.leftParent=storedNodes.get(nodes.indexOf(node0.leftParent));\n    }\n else {\n      node1.leftParent=null;\n    }\n    if (node0.rightParent != null) {\n      node1.rightParent=storedNodes.get(nodes.indexOf(node0.rightParent));\n    }\n else {\n      node1.rightParent=null;\n    }\n    if (node0.leftChild != null) {\n      node1.leftChild=storedNodes.get(nodes.indexOf(node0.leftChild));\n    }\n else {\n      node1.leftChild=null;\n    }\n    if (node0.rightChild != null) {\n      node1.rightChild=storedNodes.get(nodes.indexOf(node0.rightChild));\n    }\n else {\n      node1.rightChild=null;\n    }\n  }\n}", "comment": "copies the node connections from this argmodel ' s nodes array to the destination array .", "label": "what"}
{"id": "49590", "raw_code": "private void validateWill(String dest,Object payload){\n  if ((dest == null) || (payload == null)) {\n    throw new IllegalArgumentException();\n  }\n  MqttTopic.validate(dest,false);\n}", "comment": "validates the will fields .", "label": "what"}
{"id": "48546", "raw_code": "protected void encodeLineSuffix(OutputStream aStream) throws IOException {\n  pStream.println();\n}", "comment": "encode the suffix that ends every output line .", "label": "what"}
{"id": "82182", "raw_code": "boolean isSystemFont(){\n  return systemFont;\n}", "comment": "checks if this is a system font", "label": "what"}
{"id": "34238", "raw_code": "public void addToBeLoaded(final String url){\n  if (toBeLoaded == null) {\n    toBeLoaded=new ArrayList<String>();\n  }\n  if (StringUtils.isNotBlank(url)) {\n    toBeLoaded.add(url);\n  }\n}", "comment": "this methods allows to indicate if the resource must be obtained .", "label": "what"}
{"id": "54058", "raw_code": "default Document putAll(Iterator<Field> fields){\n  while (fields.hasNext()) {\n    Field field=fields.next();\n    setValue(field.getName(),field.getValue());\n  }\n  return this;\n}", "comment": "sets on this object all name / value pairs from the supplied object .", "label": "what"}
{"id": "27540", "raw_code": "public RootBlockView(final boolean rootBlock0,final ByteBuffer buf,final ChecksumUtility checker) throws RootBlockException {\n  if (buf == null)   throw new IllegalArgumentException();\n  if (buf.remaining() != SIZEOF_ROOT_BLOCK) {\n    throw new IllegalArgumentException(\"Expecting \" + SIZEOF_ROOT_BLOCK + \" remaining, actual=\"+ buf.remaining());\n  }\n  this.buf=buf.asReadOnlyBuffer();\n  this.rootBlock0=rootBlock0;\nswitch (getStoreType()) {\ncase RW:\n{\n      am=new RWAddressManager(null);\n      break;\n    }\ncase WORM:\n{\n    final int offsetBits=getOffsetBits();\n    am=new WormAddressManager(offsetBits);\n    break;\n  }\ndefault :\nthrow new RootBlockException(\"Unknown storeType=\" + getStoreType());\n}\nif (checker == null) {\nlog.warn(\"Checksum will not be validated\");\n}\nthis.checker=checker;\nvalid();\n}", "comment": "create a new read - only view from the supplied buffer .", "label": "what"}
{"id": "33948", "raw_code": "@SuppressWarnings(\"unchecked\") @Test public void innerEnum(){\n  Class<?> pc=PlayingCard.class;\n  List<Enum<?>> include=new ArrayList<>();\n  List<Enum<?>> exclude=new ArrayList<>();\n  for (  Class<?> c : pc.getDeclaredClasses()) {\n    int mods=c.getModifiers();\n    if (c.isEnum()) {\n      if (Modifier.isPublic(mods)) {\n        include.addAll(asList(c.getEnumConstants()));\n      }\n else {\n        exclude.addAll(asList(c.getEnumConstants()));\n      }\n    }\n  }\n  Set<TypedOperation> actual=getConcreteOperations(pc);\n  assertEquals(\"number of statements\",include.size() + 5,actual.size());\n  for (  Enum<?> e : include) {\n    assertTrue(\"enum constant \" + e.name() + \" should occur\",actual.contains(createEnumOperation(e)));\n  }\n  for (  Enum<?> e : exclude) {\n    assertFalse(\"enum constant \" + e.name() + \" should not occur\",actual.contains(createEnumOperation(e)));\n  }\n}", "comment": "innerenum tests that reflection . getstatements is collecting simple enum constants from a class .", "label": "what"}
{"id": "54087", "raw_code": "public static boolean inTargetDir(File file){\n  return inTargetDir(file.toPath());\n}", "comment": "verify that the supplied file or directory is within the target directory .", "label": "what"}
{"id": "29398", "raw_code": "public final boolean skipAny(char c,CharSequence csq){\n  int i=index;\n  int n=csq.length();\n  for (; (i < n) && (csq.charAt(i) == c); i++) {\n  }\n  if (i == index)   return false;\n  index=i;\n  return true;\n}", "comment": "moves this cursor forward until it points to a character different from the specified character .", "label": "what"}
{"id": "63767", "raw_code": "public synchronized boolean removeAll(Collection c){\n  Object[] elements=getArray();\n  int len=elements.length;\n  if (len != 0) {\n    int newlen=0;\n    Object[] temp=new Object[len];\n    for (int i=0; i < len; ++i) {\n      Object element=elements[i];\n      if (!c.contains(element))       temp[newlen++]=element;\n    }\n    if (newlen != len) {\n      setArray(copyOfRange(temp,0,newlen,Object[].class));\n      return true;\n    }\n  }\n  return false;\n}", "comment": "removes from this list all of its elements that are contained in the specified collection .", "label": "what"}
{"id": "57579", "raw_code": "private final boolean compareAndSetTail(Node expect,Node update){\n  return unsafe.compareAndSwapObject(this,tailOffset,expect,update);\n}", "comment": "cas tail field .", "label": "what"}
{"id": "43047", "raw_code": "public static void UF7(double[] x,double[] f,int nx){\n  int count1=0;\n  int count2=0;\n  double sum1=0.0;\n  double sum2=0.0;\n  double yj;\n  for (int j=2; j <= nx; j++) {\n    yj=x[j - 1] - Math.sin(6.0 * PI * x[0] + j * PI / nx);\n    if (j % 2 == 0) {\n      sum2+=yj * yj;\n      count2++;\n    }\n else {\n      sum1+=yj * yj;\n      count1++;\n    }\n  }\n  yj=Math.pow(x[0],0.2);\n  f[0]=yj + 2.0 * sum1 / (double)count1;\n  f[1]=1.0 - yj + 2.0 * sum2 / (double)count2;\n}", "comment": "evaluates the uf7 problem .", "label": "what"}
{"id": "68165", "raw_code": "private void reloadModelWithNewValue(final Long newValue){\n  final long newValueAsPrimitive=newValue == null ? getModelUpdatePeriod() : newValue;\n  for (  final PropertyChangeListener listener : modelUpdatePeriodListeners) {\n    final PropertyChangeEvent event=new PropertyChangeEvent(this,\"model\",getModelUpdatePeriod(),newValueAsPrimitive);\n    listener.propertyChange(event);\n  }\n}", "comment": "notify all listeners about cacheperiod property changed .", "label": "what"}
{"id": "49325", "raw_code": "public Image createAcceleratedImage(Component target,int width,int height){\n  ColorModel model=getColorModel(Transparency.OPAQUE);\n  WritableRaster wr=model.createCompatibleWritableRaster(width,height);\n  return new OffScreenImage(target,model,wr,model.isAlphaPremultiplied());\n}", "comment": "creates a new managed image of the given width and height that is associated with the target component .", "label": "what"}
{"id": "43492", "raw_code": "public static void writeStringToWriter(String string,Writer writer) throws IOException {\n  BufferedWriter bw=new BufferedWriter(writer);\n  try {\n    bw.write(string);\n  }\n  finally {\n    bw.close();\n  }\n}", "comment": "writes given string to given writer .", "label": "what"}
{"id": "2670", "raw_code": "private void ensureCapacity(int n){\n  if (n <= 0) {\n    return;\n  }\n  int max;\n  if (data == null || data.length == 0) {\n    max=25;\n  }\n else   if (data.length >= n * 5) {\n    return;\n  }\n else {\n    max=data.length;\n  }\n  while (max < n * 5) {\n    max*=2;\n  }\n  String newData[]=new String[max];\n  if (length > 0) {\n    System.arraycopy(data,0,newData,0,length * 5);\n  }\n  data=newData;\n}", "comment": "ensure the internal array ' s capacity .", "label": "what"}
{"id": "66219", "raw_code": "public boolean isFlat(){\n  return TYPE_FLAT.equals(getType());\n}", "comment": "flat background type ( default )", "label": "what"}
{"id": "83623", "raw_code": "@Deprecated private List<CharSequence> buildLimitedNetworksList(){\n  final Context context=getActivity();\n  final ArrayList<CharSequence> limited=Lists.newArrayList();\n  if (hasSubscription(context)) {\n    final String subscriberId=getActiveSubscriberId(context);\n    if (mPolicyEditor.hasLimitedPolicy(buildTemplateMobileAll(subscriberId))) {\n      limited.add(getText(R.string.data_usage_list_mobile));\n    }\n    if (mPolicyEditor.hasLimitedPolicy(buildTemplateMobile3gLower(subscriberId))) {\n      limited.add(getText(R.string.data_usage_tab_3g));\n    }\n    if (mPolicyEditor.hasLimitedPolicy(buildTemplateMobile4g(subscriberId))) {\n      limited.add(getText(R.string.data_usage_tab_4g));\n    }\n  }\n  if (mPolicyEditor.hasLimitedPolicy(buildTemplateWifiWildcard())) {\n    limited.add(getText(R.string.data_usage_tab_wifi));\n  }\n  if (mPolicyEditor.hasLimitedPolicy(buildTemplateEthernet())) {\n    limited.add(getText(R.string.data_usage_tab_ethernet));\n  }\n  return limited;\n}", "comment": "build list of currently limited networks , which defines when background data is restricted .", "label": "what"}
{"id": "32535", "raw_code": "private static void exit(String errMsg,Options options,int exitCode){\n  if (errMsg != null)   echo(\"ERROR: \" + errMsg);\n  String runner=System.getProperty(IGNITE_PROG_NAME,\"randignite.{sh|bat}\");\n  int space=runner.indexOf(' ');\n  runner=runner.substring(0,space == -1 ? runner.length() : space);\n  if (options != null) {\n    HelpFormatter formatter=new HelpFormatter();\n    formatter.printHelp(runner,options);\n  }\n  System.exit(exitCode);\n}", "comment": "exists with optional error message , usage show and exit code .", "label": "what"}
{"id": "78815", "raw_code": "@Override public int compare(NewSplitEmittedTerm term1,NewSplitEmittedTerm term2){\n  return term1.compareTo(term2);\n}", "comment": "compares term key 1 to term key 2 .", "label": "what"}
{"id": "61511", "raw_code": "public ExtendedType(int nodetype,String namespace,String localName){\n  this.nodetype=nodetype;\n  this.namespace=namespace;\n  this.localName=localName;\n  this.hash=nodetype + namespace.hashCode() + localName.hashCode();\n}", "comment": "create an extendedtype object from node type , namespace and local name .", "label": "what"}
{"id": "6629", "raw_code": "public void undo(){\n  try {\n    if (undoManager != null)     undoManager.undoOrRedo();\n  }\n catch (  CannotUndoException ignored) {\n  }\ncatch (  CannotRedoException ignored) {\n  }\n}", "comment": "undoes the last action .", "label": "what"}
{"id": "71592", "raw_code": "public void removeColumn(Column column){\n  if (column != null) {\n    columns.remove(column);\n  }\n}", "comment": "removes the given column .", "label": "what"}
{"id": "66360", "raw_code": "public void balanceSegments(){\n  MAcctSchemaElement[] elements=m_acctSchema.getAcctSchemaElements();\n  for (int i=0; i < elements.length; i++) {\n    MAcctSchemaElement ase=elements[i];\n    if (ase.isBalanced())     balanceSegment(ase.getElementType());\n  }\n}", "comment": "balance all segments .", "label": "what"}
{"id": "80975", "raw_code": "public boolean hasUserPartitions(){\n  return !userOutput.isEmpty();\n}", "comment": "retrieves if user partitions are present", "label": "what"}
{"id": "37480", "raw_code": "@Override public void insertString(final int offs,final String str,final AttributeSet attr){\n  if (offs < 0) {\n    return;\n  }\n  if (str.length() > 1) {\n    int i;\n    for (i=0; i < str.length(); i++) {\n      if (str.charAt(i) == '\\n') {\n        remainingTextString=str.substring(i + 1);\n        remainingTextAttr=attr;\n        inputKeyListener.keyPressed(new KeyEvent(new Container(),KeyEvent.KEY_PRESSED,0,0,KeyEvent.VK_ENTER,'\\n'));\n        break;\n      }\n else {\n        insertChar(offs + i,\"\" + str.charAt(i));\n      }\n    }\n  }\n else   if (str.length() == 1) {\n    insertChar(offs,str);\n  }\n}", "comment": "insert a string of source code to be highlighted to the document .", "label": "what"}
{"id": "43958", "raw_code": "protected int readCodePoint() throws IOException {\n  int next=reader.read();\n  if (Character.isHighSurrogate((char)next)) {\n    next=Character.toCodePoint((char)next,(char)reader.read());\n  }\n  return next;\n}", "comment": "reads the next unicode code point .", "label": "what"}
{"id": "59580", "raw_code": "public static int putInt(byte[] bytes,int offset,int val){\n  if (littleEndian) {\n    val=Integer.reverseBytes(val);\n  }\n  theUnsafe.putInt(bytes,offset + BYTE_ARRAY_BASE_OFFSET,val);\n  return offset + Bytes.SIZEOF_INT;\n}", "comment": "put an int value out to the specified byte array position in big - endian format .", "label": "what"}
{"id": "28384", "raw_code": "public Item(Drawable symbol,String labelText,Font font){\n  double fontSize=font.getSize2D();\n  setLayout(new EdgeLayout(fontSize,0.0));\n  this.symbol=symbol;\n  add(symbol,Location.WEST);\n  label=new Label(labelText);\n  label.setFont(font);\n  label.setAlignmentX(0.0);\n  label.setAlignmentY(0.5);\n  add(label,Location.CENTER);\n}", "comment": "creates a new item object with the specified data source and text .", "label": "what"}
{"id": "80389", "raw_code": "public int consume(){\n  int consumedAmount;\n  if (Math.abs(left) < Math.abs(getRegen())) {\n    consumedAmount=left;\n    left=0;\n  }\n else {\n    consumedAmount=getRegen();\n    left-=getRegen();\n  }\n  return consumedAmount;\n}", "comment": "consumes a part of this item .", "label": "what"}
{"id": "31717", "raw_code": "private Delegate delegate() throws HadoopIgfsCommunicationException {\n  Exception errShmem=null;\n  Exception errTcp=null;\n  Delegate curDelegate=delegateRef.get();\n  if (curDelegate != null)   return curDelegate;\n  boolean skipInProc=parameter(conf,PARAM_IGFS_ENDPOINT_NO_EMBED,authority,false);\n  if (!skipInProc) {\n    IgfsEx igfs=getIgfsEx(endpoint.grid(),endpoint.igfs());\n    if (igfs != null) {\n      HadoopIgfsEx hadoop=null;\n      try {\n        hadoop=new HadoopIgfsInProc(igfs,log,userName);\n        curDelegate=new Delegate(hadoop,hadoop.handshake(logDir));\n      }\n catch (      IOException|IgniteCheckedException e) {\n        if (e instanceof HadoopIgfsCommunicationException)         if (hadoop != null)         hadoop.close(true);\n        if (log.isDebugEnabled())         log.debug(\"Failed to connect to in-process IGFS, fallback to IPC mode.\",e);\n      }\n    }\n  }\n  boolean skipLocShmem=parameter(conf,PARAM_IGFS_ENDPOINT_NO_LOCAL_SHMEM,authority,false);\n  if (curDelegate == null && !skipLocShmem && !U.isWindows()) {\n    HadoopIgfsEx hadoop=null;\n    try {\n      hadoop=new HadoopIgfsOutProc(endpoint.port(),endpoint.grid(),endpoint.igfs(),log,userName);\n      curDelegate=new Delegate(hadoop,hadoop.handshake(logDir));\n    }\n catch (    IOException|IgniteCheckedException e) {\n      if (e instanceof HadoopIgfsCommunicationException)       hadoop.close(true);\n      if (log.isDebugEnabled())       log.debug(\"Failed to connect to IGFS using shared memory [port=\" + endpoint.port() + ']',e);\n      errShmem=e;\n    }\n  }\n  boolean skipLocTcp=parameter(conf,PARAM_IGFS_ENDPOINT_NO_LOCAL_TCP,authority,false);\n  if (curDelegate == null && !skipLocTcp) {\n    HadoopIgfsEx hadoop=null;\n    try {\n      hadoop=new HadoopIgfsOutProc(LOCALHOST,endpoint.port(),endpoint.grid(),endpoint.igfs(),log,userName);\n      curDelegate=new Delegate(hadoop,hadoop.handshake(logDir));\n    }\n catch (    IOException|IgniteCheckedException e) {\n      if (e instanceof HadoopIgfsCommunicationException)       hadoop.close(true);\n      if (log.isDebugEnabled())       log.debug(\"Failed to connect to IGFS using TCP [host=\" + endpoint.host() + \", port=\"+ endpoint.port()+ ']',e);\n      errTcp=e;\n    }\n  }\n  if (curDelegate == null && (skipLocTcp || !F.eq(LOCALHOST,endpoint.host()))) {\n    HadoopIgfsEx hadoop=null;\n    try {\n      hadoop=new HadoopIgfsOutProc(endpoint.host(),endpoint.port(),endpoint.grid(),endpoint.igfs(),log,userName);\n      curDelegate=new Delegate(hadoop,hadoop.handshake(logDir));\n    }\n catch (    IOException|IgniteCheckedException e) {\n      if (e instanceof HadoopIgfsCommunicationException)       hadoop.close(true);\n      if (log.isDebugEnabled())       log.debug(\"Failed to connect to IGFS using TCP [host=\" + endpoint.host() + \", port=\"+ endpoint.port()+ ']',e);\n      errTcp=e;\n    }\n  }\n  if (curDelegate != null) {\n    if (!delegateRef.compareAndSet(null,curDelegate))     curDelegate.doomed=true;\n    return curDelegate;\n  }\n else {\n    SB errMsg=new SB(\"Failed to connect to IGFS [endpoint=igfs://\" + authority + \", attempts=[\");\n    if (errShmem != null)     errMsg.a(\"[type=SHMEM, port=\" + endpoint.port() + \", err=\"+ errShmem+ \"], \");\n    errMsg.a(\"[type=TCP, host=\" + endpoint.host() + \", port=\"+ endpoint.port()+ \", err=\"+ errTcp+ \"]] \");\n    errMsg.a(\"(ensure that IGFS is running and have IPC endpoint enabled; ensure that \" + \"ignite-shmem-1.0.0.jar is in Hadoop classpath if you use shared memory endpoint).\");\n    throw new HadoopIgfsCommunicationException(errMsg.toString());\n  }\n}", "comment": "get delegate creating it if needed .", "label": "what"}
{"id": "6401", "raw_code": "private static final File[] encode(String src){\n  if (src == null || src.length() == 0) {\n    return (new File[0]);\n  }\n  StringTokenizer tokenizer=new StringTokenizer(src,\";\");\n  File[] dirs=new File[tokenizer.countTokens()];\n  for (int i=0; i < dirs.length; i++) {\n    dirs[i]=new File(tokenizer.nextToken());\n  }\n  return dirs;\n}", "comment": "splits the string into an array", "label": "what"}
{"id": "26149", "raw_code": "public int size(){\n  return patterns.size();\n}", "comment": "size of the cluster .", "label": "what"}
{"id": "67973", "raw_code": "public static void writeUint8(OutputStream theOs,int theValue) throws IOException {\n  theOs.write(theValue);\n}", "comment": "writes a \" uint8 \" in wsp format to the given output stream .", "label": "what"}
{"id": "13977", "raw_code": "public void store() throws SAMLException {\n  try {\n    keyProvider.store();\n  }\n catch (  KeyStoreException e) {\n    throw new SAMLException(e.getMessage());\n  }\ncatch (  CertificateException e) {\n    throw new SAMLException(e.getMessage());\n  }\ncatch (  NoSuchAlgorithmException e) {\n    throw new SAMLException(e.getMessage());\n  }\ncatch (  IOException e) {\n    throw new SAMLException(e.getMessage());\n  }\n}", "comment": "store the keystore changes", "label": "what"}
{"id": "51400", "raw_code": "public static void sort(long[] a){\n  doSort(a,0,a.length - 1);\n}", "comment": "sorts the specified array into ascending numerical order .", "label": "what"}
{"id": "83256", "raw_code": "public void write(final String filename){\n  PrintStream stream;\n  try {\n    stream=new PrintStream(new File(filename));\n  }\n catch (  FileNotFoundException e) {\n    e.printStackTrace();\n    return;\n  }\n  write(stream);\n  stream.close();\n}", "comment": "writes the gathered data tab - separated into a text file .", "label": "what"}
{"id": "45510", "raw_code": "@Override public void write(byte[] b,int off,int len) throws IOException {\n  while (len > 0) {\n    int c=Math.min(len,decoderIn.remaining());\n    decoderIn.put(b,off,c);\n    processInput(false);\n    len-=c;\n    off+=c;\n  }\n  if (writeImmediately) {\n    flushOutput();\n  }\n}", "comment": "write bytes from the specified byte array to the stream .", "label": "what"}
{"id": "24818", "raw_code": "public static void log(String message,Object... args){\n  if (loggingEnabled) {\n    Log.d(TAG,args.length == 0 ? message : String.format(message,args));\n  }\n}", "comment": "send a log message if logging is enabled .", "label": "what"}
{"id": "57222", "raw_code": "protected void processUpdates(Queue<DeviceUpdate> updates){\n  if (updates == null)   return;\n  DeviceUpdate update=null;\n  while (null != (update=updates.poll())) {\n    if (logger.isTraceEnabled()) {\n      logger.trace(\"Dispatching device update: {}\",update);\n    }\n    if (update.change == DeviceUpdate.Change.DELETE) {\n      deviceSyncManager.removeDevice(update.device);\n    }\n else {\n      deviceSyncManager.storeDevice(update.device);\n    }\n    List<IDeviceListener> listeners=deviceListeners.getOrderedListeners();\n    notifyListeners(listeners,update);\n  }\n}", "comment": "send update notifications to listeners", "label": "what"}
{"id": "23764", "raw_code": "boolean handleRemoteCanRebalance(long size){\n  return false;\n}", "comment": "checks if this partitionedregiondatastore has the capacity to handle the rebalancing size .", "label": "what"}
{"id": "75020", "raw_code": "public static File toSLDFile(final File file){\n  final String path=file.getAbsolutePath();\n  final String base=path.substring(0,path.length() - 4);\n  String newPath=base + \".sld\";\n  File sld=new File(newPath);\n  if (sld.exists()) {\n    return sld;\n  }\n  newPath=base + \".SLD\";\n  sld=new File(newPath);\n  if (sld.exists()) {\n    return sld;\n  }\n  return null;\n}", "comment": "figure out if a valid sld file is available .", "label": "what"}
{"id": "24878", "raw_code": "private String insertProperties(String template,Map<String,String> properties){\n  for (  Entry<String,String> entry : properties.entrySet()) {\n    template=template.replace(entry.getKey(),entry.getValue());\n  }\n  return template;\n}", "comment": "inserts properties to the template .", "label": "what"}
{"id": "16824", "raw_code": "public static void changeFont(JComponent comp,int style){\n  Font font=comp.getFont();\n  comp.setFont(font.deriveFont(style));\n}", "comment": "change the font style of a component", "label": "what"}
{"id": "73641", "raw_code": "public void clearOnCentralPositionChangedListener(){\n  mOnCentralPositionChangedListeners.clear();\n}", "comment": "clear all listeners that listening the central item of the list changes event .", "label": "what"}
{"id": "39480", "raw_code": "public static Object invokeStatic(Class clazz,String methodName) throws NoSuchMethodException {\n  try {\n    Method method=clazz.getMethod(methodName,new Class[0]);\n    Object result=method.invoke(null,new Object[0]);\n    return result;\n  }\n catch (  IllegalAccessException e) {\n    throw new NoSuchMethodException(methodName + \" is not accessible\");\n  }\ncatch (  InvocationTargetException e) {\n    throw new InternalError(e.getMessage());\n  }\n}", "comment": "invokes the specified accessible parameterless method if it exists .", "label": "what"}
{"id": "13640", "raw_code": "public void onPatchServiceResult(boolean isUpgradePatch){\n  if (!isRetryEnable) {\n    TinkerLog.w(TAG,\"onPatchServiceResult retry disabled, just return\");\n    return;\n  }\n  if (!isUpgradePatch) {\n    TinkerLog.w(TAG,\"onPatchServiceResult is not upgrade patch, just return\");\n    return;\n  }\n  if (retryInfoFile.exists()) {\n    SharePatchFileUtil.safeDeleteFile(retryInfoFile);\n  }\n  if (tempPatchFile.exists()) {\n    SharePatchFileUtil.safeDeleteFile(tempPatchFile);\n  }\n}", "comment": "if we receive any result , we can delete the temp retry info file", "label": "what"}
{"id": "74887", "raw_code": "@Override public int execute(final FormObject form,final int type,final String code,final int eventType,final char keyPressed){\n  int messageCode=ActionHandler.NOMESSAGE;\n  if (code instanceof String) {\n    final String js=code;\n    final String[] args=JSFunction.convertToArray(js);\n    final String command=args[0];\n    if (command.startsWith(\"AF\")) {\n      messageCode=handleAFCommands(form,command,js,args,eventType,keyPressed);\n    }\n  }\n  return messageCode;\n}", "comment": "execute javascript and reset forms values", "label": "what"}
{"id": "15520", "raw_code": "public void clear(FacesContext facesContext,Map<String,Object> viewMap){\n  if (LOGGER.isLoggable(Level.FINEST)) {\n    LOGGER.log(Level.FINEST,\"Clearing @ViewScoped CDI beans for given view map: {0}\");\n  }\n  Map<String,ViewScopeContextObject> contextMap=getContextMap(facesContext,viewMap);\n  if (contextMap != null) {\n    destroyBeans(viewMap,contextMap);\n  }\n}", "comment": "clear the given view map .", "label": "what"}
{"id": "52476", "raw_code": "public void loadLogicalTablesWithGranularities(Map<String,TableGroup> nameGroupMap,Set<? extends Granularity> validGrains,ResourceDictionaries dictionaries){\n  for (  Map.Entry<String,TableGroup> entry : nameGroupMap.entrySet()) {\n    String logicalTableName=entry.getKey();\n    TableGroup group=entry.getValue();\n    loadLogicalTableWithGranularities(logicalTableName,group,validGrains,dictionaries);\n  }\n}", "comment": "load several logical tables into the logicaldictionary .", "label": "what"}
{"id": "1180", "raw_code": "protected int readBlock(){\n  blockSize=read();\n  int n=0;\n  if (blockSize > 0) {\n    try {\n      int count=0;\n      while (n < blockSize) {\n        count=in.read(block,n,blockSize - n);\n        if (count == -1)         break;\n        n+=count;\n      }\n    }\n catch (    IOException e) {\n    }\n    if (n < blockSize) {\n      status=STATUS_FORMAT_ERROR;\n    }\n  }\n  return n;\n}", "comment": "reads next variable length block from input .", "label": "what"}
{"id": "57391", "raw_code": "public X509CertPathImpl(List<? extends java.security.cert.Certificate> certs) throws CertificateException {\n  super(\"X.509\");\n  final int size=certs.size();\n  certificates=new ArrayList<X509Certificate>(size);\n  for (int i=0; i < size; i++) {\n    final java.security.cert.Certificate cert=certs.get(i);\n    if (!(cert instanceof X509Certificate)) {\n      throw new CertificateException(\"Certificate \" + i + \" is not an X.509 certificate\");\n    }\n    certificates.add((X509Certificate)cert);\n  }\n}", "comment": "creates an instance of x . 509 certpath over the specified list of certificates .", "label": "what"}
{"id": "36204", "raw_code": "public Process(final String xmlString) throws IOException, XMLException {\n  initContext();\n  StringReader in=new StringReader(xmlString);\n  readProcess(in);\n  in.close();\n}", "comment": "reads an process configuration from an xml string .", "label": "what"}
{"id": "71614", "raw_code": "public String shortenName(String name,int desiredLength){\n  int originalLength=name.length();\n  if ((desiredLength <= 0) || (originalLength <= desiredLength)) {\n    return name;\n  }\n  int delta=originalLength - desiredLength;\n  int startCut=desiredLength / 2;\n  StringBuffer result=new StringBuffer();\n  result.append(name.substring(0,startCut));\n  if (((startCut == 0) || (name.charAt(startCut - 1) != '_')) && ((startCut + delta + 1 == originalLength) || (name.charAt(startCut + delta + 1) != '_'))) {\n    result.append(\"_\");\n  }\n  result.append(name.substring(startCut + delta + 1,originalLength));\n  return result.toString();\n}", "comment": "generates a version of the name that has at most the specified length .", "label": "what"}
{"id": "28366", "raw_code": "public static Color blend(Color color1,Color color2,double weight){\n  double w2=MathUtils.limit(weight,0.0,1.0);\n  double w1=1.0 - w2;\n  int r=(int)Math.round(w1 * color1.getRed() + w2 * color2.getRed());\n  int g=(int)Math.round(w1 * color1.getGreen() + w2 * color2.getGreen());\n  int b=(int)Math.round(w1 * color1.getBlue() + w2 * color2.getBlue());\n  int a=(int)Math.round(w1 * color1.getAlpha() + w2 * color2.getAlpha());\n  return new Color(r,g,b,a);\n}", "comment": "linearly blends two colors with a defined weight .", "label": "what"}
{"id": "28663", "raw_code": "public long kstkeip(){\n  return Long.parseLong(fields[29]);\n}", "comment": "the current eip ( instruction pointer ) .", "label": "what"}
{"id": "54372", "raw_code": "private JSONArray readArray() throws JSONException {\n  JSONArray result=new JSONArray();\n  boolean hasTrailingSeparator=false;\n  while (true) {\nswitch (nextCleanInternal()) {\ncase -1:\n      throw syntaxError(\"Unterminated array\");\ncase ']':\n    if (hasTrailingSeparator) {\n      result.put(null);\n    }\n  return result;\ncase ',':\ncase ';':\nresult.put(null);\nhasTrailingSeparator=true;\ncontinue;\ndefault :\npos--;\n}\nresult.put(nextValue());\nswitch (nextCleanInternal()) {\ncase ']':\nreturn result;\ncase ',':\ncase ';':\nhasTrailingSeparator=true;\ncontinue;\ndefault :\nthrow syntaxError(\"Unterminated array\");\n}\n}\n}", "comment": "reads a sequence of values and the trailing closing brace ' ] ' of an array .", "label": "what"}
{"id": "73194", "raw_code": "public void removeSensorSelectionListener(SensorSelectionListener listener){\n  listenerList.remove(SensorSelectionListener.class,listener);\n}", "comment": "remove the specified sensor selection listener .", "label": "what"}
{"id": "29428", "raw_code": "public void write(int c) throws IOException {\n  if (_output == null)   throw new IOException(\"Writer closed\");\n  _output.append((char)c);\n}", "comment": "writes the 16 low - order bits of the given integer value ; the 16 high - order bits are ignored .", "label": "what"}
{"id": "14445", "raw_code": "public void initializeKeyStore(){\n  try {\n    Logger logger=(com.sun.identity.log.Logger)Logger.getLogger(logName);\n    resetCurrentFileList(logName);\n    addToCurrentFileList(logName,logName,logName);\n    String logPath=lmanager.getProperty(LogConstants.LOG_LOCATION);\n    if (!logPath.endsWith(\"/\"))     logPath+=\"/\";\n    String fileName=logName;\n    String loggerFileName=logPath + PREFIX + \"log.\"+ fileName;\n    String verifierFileName=logPath + PREFIX + \"ver.\"+ fileName;\n    Debug.message(logName + \":Logger Keystore name = \" + loggerFileName);\n    Debug.message(logName + \":Verifier Keystore name= \" + verifierFileName);\n    helper.initializeSecureLogHelper(loggerFileName,logPassword,verifierFileName,logPassword);\n    Debug.message(logName + \":Initialized SecureLogHelper\");\n    helper.initializeVerifier(verifierFileName,logPassword,verPassword);\n    Debug.message(logName + \":Done init of SecureLogHelper and Verifier\");\n  }\n catch (  Exception e) {\n    Debug.error(logName + \":Logger: exception thrown while initializing secure logger\",e);\n  }\n}", "comment": "initialize logger key store", "label": "what"}
{"id": "16889", "raw_code": "public static String cleanFolderStackingMarkers(String filename){\n  if (!StringUtils.isEmpty(filename)) {\n    Matcher m=folderStackingPattern.matcher(filename);\n    if (m.matches()) {\n      return m.group(1) + m.group(3);\n    }\n  }\n  return filename;\n}", "comment": "clean stacking markers .", "label": "what"}
{"id": "30932", "raw_code": "public void discard(ServiceRegistrar reg){\nsynchronized (registrars) {\n    if (terminated) {\n      throw new IllegalStateException(\"discovery terminated\");\n    }\n    if (reg == null)     return;\n    sendDiscarded(reg,null);\n  }\n}", "comment": "discard a registrar from the set of registrars already discovered .", "label": "what"}
{"id": "13113", "raw_code": "public boolean isFinalState(int state){\n  return (state < 0) ? false : fFinalStateFlags[state];\n}", "comment": "check whether the given state is one of the final states", "label": "what"}
{"id": "54613", "raw_code": "public void writeFigTreeBlock(Map<String,Object> settings) throws IOException {\n  writer.println(\"\\nbegin figtree;\");\n  for (  String key : settings.keySet()) {\n    Object value=settings.get(key);\n    writer.println(\"\\tset \" + key + \"=\"+ createString(value)+ \";\");\n  }\n  writer.println(\"end;\\n\");\n}", "comment": "writes a ' figtree ' block .", "label": "what"}
{"id": "49078", "raw_code": "public int hashCode(){\n  return font.hashCode() ^ glyphs.length;\n}", "comment": "as a concrete subclass of object that implements equality , this must implement hashcode .", "label": "what"}
{"id": "84081", "raw_code": "public boolean equals(Object obj){\n  if (obj == this) {\n    return true;\n  }\n  if (obj instanceof Map == false) {\n    return false;\n  }\n  Map map=(Map)obj;\n  if (map.size() != size()) {\n    return false;\n  }\n  MapIterator it=mapIterator();\n  try {\n    while (it.hasNext()) {\n      Object key=it.next();\n      Object value=it.getValue();\n      if (value == null) {\n        if (map.get(key) != null || map.containsKey(key) == false) {\n          return false;\n        }\n      }\n else {\n        if (value.equals(map.get(key)) == false) {\n          return false;\n        }\n      }\n    }\n  }\n catch (  ClassCastException ignored) {\n    return false;\n  }\ncatch (  NullPointerException ignored) {\n    return false;\n  }\n  return true;\n}", "comment": "compares this map with another .", "label": "what"}
{"id": "13277", "raw_code": "@Override public void doctypeDecl(String rootElement,String publicId,String systemId,Augmentations augs) throws XNIException {\n  fInDTD=true;\n  try {\n    if (fLexicalHandler != null) {\n      fLexicalHandler.startDTD(rootElement,publicId,systemId);\n    }\n  }\n catch (  SAXException e) {\n    throw new XNIException(e);\n  }\n  if (fDeclHandler != null) {\n    fDeclaredAttrs=new SymbolHash();\n  }\n}", "comment": "notifies of the presence of the doctype line in the document .", "label": "what"}
{"id": "66212", "raw_code": "public void cleanStart(){\n  Connection conn=getConnection(true,true);\n  if (conn == null)   throw new IllegalStateException(\"No Database\");\n  dropDatabase(conn);\n  createUser(conn);\n  createDatabase(conn);\n  try {\n    if (conn != null)     conn.close();\n  }\n catch (  SQLException e2) {\n    log.log(Level.SEVERE,\"close connection\",e2);\n  }\n  conn=null;\n}", "comment": "clean start - drop & re - create db", "label": "what"}
{"id": "65300", "raw_code": "static TemplateModelException newMethodArgInvalidValueException(String methodName,int argIdx,Object... details){\n  return new _TemplateModelException(methodName,\"(...) argument #\",Integer.valueOf(argIdx + 1),\" had invalid value: \",details);\n}", "comment": "the type of the argument was good , but it ' s value wasn ' t .", "label": "what"}
{"id": "77756", "raw_code": "public static byte[] compressForZlib(String stringToCompress){\n  byte[] returnValues=null;\n  try {\n    returnValues=compressForZlib(stringToCompress.getBytes(\"UTF-8\"));\n  }\n catch (  UnsupportedEncodingException uee) {\n    uee.printStackTrace();\n  }\n  return returnValues;\n}", "comment": "zlib compress 2 byte", "label": "what"}
{"id": "23215", "raw_code": "private void loadMap(String extension,String mimeType){\n  if (!mimeTypeToExtensionMap.containsKey(mimeType)) {\n    mimeTypeToExtensionMap.put(mimeType,extension);\n  }\n  extensionToMimeTypeMap.put(extension,mimeType);\n  if (isImageType(mimeType)) {\n    imageMimeTypeSet.add(mimeType);\n  }\n}", "comment": "load an entry into the map .", "label": "what"}
{"id": "34391", "raw_code": "private String convertTimestamp(){\n  String result=timestampFormat.replaceAll(VALID_DATEFORMAT_CHAR_PATTERN + \"+\",\"\\\\\\\\S+\");\n  result=result.replaceAll(Pattern.quote(\".\"),\"\\\\\\\\.\");\n  return result;\n}", "comment": "helper method that will convert timestamp format to a pattern", "label": "what"}
{"id": "3653", "raw_code": "final public void print(double v){\n  Writer out=this.out;\n  if (out == null)   return;\n  try {\n    String s=String.valueOf(v);\n    out.write(s,0,s.length());\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}", "comment": "prints a double followed by a newline .", "label": "what"}
{"id": "40610", "raw_code": "private static boolean containsChroot(String zkHost){\n  return zkHost.contains(\"/\");\n}", "comment": "validates if zkhost contains a chroot .", "label": "what"}
{"id": "53975", "raw_code": "public static void onDatabase(MongoClient client,String dbName,Consumer<MongoDatabase> dbOperation){\n  if (contains(client.listDatabaseNames(),dbName)) {\n    dbOperation.accept(client.getDatabase(dbName));\n  }\n}", "comment": "perform the given operation on the database with the given name , only if that database exists .", "label": "what"}
{"id": "67222", "raw_code": "@Override public boolean exclude(String identifier){\n  return blacklist.contains(identifier);\n}", "comment": "checks if the given identifier should be excluded .", "label": "what"}
{"id": "77442", "raw_code": "public static boolean checkCommunicationError(Exception exc){\n  Throwable rootCause=SolrException.getRootCause(exc);\n  boolean wasCommError=(rootCause instanceof ConnectException || rootCause instanceof ConnectTimeoutException || rootCause instanceof NoHttpResponseException|| rootCause instanceof SocketException);\n  return wasCommError;\n}", "comment": "determine if a request to solr failed due to a communication error , which is generally retry - able .", "label": "what"}
{"id": "35962", "raw_code": "private void push(final int type){\n  if (outputStack == null) {\n    outputStack=new int[10];\n  }\n  int n=outputStack.length;\n  if (outputStackTop >= n) {\n    int[] t=new int[Math.max(outputStackTop + 1,2 * n)];\n    System.arraycopy(outputStack,0,t,0,n);\n    outputStack=t;\n  }\n  outputStack[outputStackTop++]=type;\n  int top=owner.inputStackTop + outputStackTop;\n  if (top > owner.outputStackMax) {\n    owner.outputStackMax=top;\n  }\n}", "comment": "pushes a new type onto the output frame stack .", "label": "what"}
{"id": "72786", "raw_code": "public static String encode(String value){\n  value=value.replace(\"&\",\"&amp;\");\n  value=value.replace(\"<\",\"&lt;\");\n  value=value.replace(\">\",\"&gt;\");\n  value=value.replace(\"\\\"\",\"&quot;\");\n  value=value.replace(\"'\",\"&#x27;\");\n  value=value.replace(\"/\",\"&#x2F;\");\n  return value;\n}", "comment": "html encodes value to avoid xss attacks .", "label": "what"}
{"id": "80102", "raw_code": "public void saveBootProp() throws IOException {\n  if (!bootProp.equals(bootPropOrg)) {\n    final String propFile=jarFolder + \"jar.properties\";\n    final OutputStream os=new FileOutputStream(propFile);\n    try {\n      bootProp.store(os,\"Stendhal Boot Configuration\");\n    }\n  finally {\n      os.close();\n    }\n  }\n}", "comment": "saves modified boot properties to disk .", "label": "what"}
{"id": "51144", "raw_code": "public PacketOutputStream writeTimestampLength(final Calendar calendar,Timestamp ts,boolean fractionalSeconds){\n  assureBufferCapacity(fractionalSeconds ? 12 : 8);\n  buffer.put((byte)(fractionalSeconds ? 11 : 7));\n  buffer.putShort((short)calendar.get(Calendar.YEAR));\n  buffer.put((byte)((calendar.get(Calendar.MONTH) + 1) & 0xff));\n  buffer.put((byte)(calendar.get(Calendar.DAY_OF_MONTH) & 0xff));\n  buffer.put((byte)calendar.get(Calendar.HOUR_OF_DAY));\n  buffer.put((byte)calendar.get(Calendar.MINUTE));\n  buffer.put((byte)calendar.get(Calendar.SECOND));\n  if (fractionalSeconds) {\n    buffer.putInt(ts.getNanos() / 1000);\n  }\n  return this;\n}", "comment": "write timestamp in binary format .", "label": "what"}
{"id": "4828", "raw_code": "public static String morpha(String text,boolean tags){\n  if (text.isEmpty()) {\n    return \"\";\n  }\n  String[] textParts=whitespace.split(text);\n  StringBuilder result=new StringBuilder();\n  try {\n    for (    String textPart : textParts) {\n      Morpha morpha=new Morpha(new StringReader(textPart),tags);\n      if (result.length() != 0) {\n        result.append(\" \");\n      }\n      result.append(morpha.next());\n    }\n  }\n catch (  Error e) {\n    return text;\n  }\ncatch (  java.io.IOException e) {\n    return text;\n  }\n  return result.toString();\n}", "comment": "run the morpha algorithm on the specified string .", "label": "what"}
{"id": "9221", "raw_code": "public static void deleteFile(File file) throws AdeUsageException {\n  if (!file.delete()) {\n    throw new AdeUsageException(FAILED_DELETING_FILE + file.getPath());\n  }\n}", "comment": "delete a file from file system .", "label": "what"}
{"id": "27059", "raw_code": "public TCPChannelClient(ExecutorService executor,TCPChannelEvents eventListener,String ip,int port){\n  this.executor=executor;\n  executorThreadCheck=new ThreadUtils.ThreadChecker();\n  executorThreadCheck.detachThread();\n  this.eventListener=eventListener;\n  InetAddress address;\n  try {\n    address=InetAddress.getByName(ip);\n  }\n catch (  UnknownHostException e) {\n    reportError(\"Invalid IP address.\");\n    return;\n  }\n  if (address.isAnyLocalAddress()) {\n    socket=new TCPSocketServer(address,port);\n  }\n else {\n    socket=new TCPSocketClient(address,port);\n  }\n  socket.start();\n}", "comment": "initializes the tcpchannelclient .", "label": "what"}
{"id": "20227", "raw_code": "private void addEntry(){\n  model.addNewEntry();\n  removeButton.setEnabled(false);\n}", "comment": "adds a new colour map entry .", "label": "what"}
{"id": "52804", "raw_code": "private void ensureSize(){\n  if (children == EMPTY_CHILDREN) {\n    children=new FPNode[1];\n    return;\n  }\n  int newsize=children.length == 1 ? INITIAL_SIZE : (children.length << 1);\n  children=Arrays.copyOf(children,newsize);\n}", "comment": "ensure we have enough storage .", "label": "what"}
{"id": "51409", "raw_code": "public UUID(long mostSigBits,long leastSigBits){\n  this.mostSigBits=mostSigBits;\n  this.leastSigBits=leastSigBits;\n  init();\n}", "comment": "constructs an instance with the specified bits .", "label": "what"}
{"id": "111", "raw_code": "public static PrettyPrint indentWithSpaces(int number){\n  if (number < 0) {\n    throw new IllegalArgumentException(\"number is negative\");\n  }\n  char[] chars=new char[number];\n  Arrays.fill(chars,' ');\n  return new PrettyPrint(chars);\n}", "comment": "print every value on a separate line .", "label": "what"}
{"id": "30063", "raw_code": "public static <T>List<T> select(Connection connection,String rawSqlQuery,RowProcessor<T> rowProcessor,Object... parameters) throws IOException, SQLException {\n  PreparedStatement stmt=null;\n  ResultSet rs=null;\n  try {\n    stmt=connection.prepareStatement(rawSqlQuery);\n    for (int index=0; index < parameters.length; index++) {\n      JdbcUtils.bindParameter(stmt,index + 1,parameters[index]);\n    }\n    rs=stmt.executeQuery();\n    List<T> result=Lists.newLinkedList();\n    while (rs.next()) {\n      result.add(rowProcessor.process(rs));\n    }\n    return result;\n  }\n  finally {\n    JdbcUtils.closeResultSet(rs);\n    JdbcUtils.closeStatement(stmt);\n  }\n}", "comment": "retrieve all the rows satisfying the given sql query .", "label": "what"}
{"id": "57097", "raw_code": "private static <T>void assertCollectionEqualsNoOrder(Collection<T> expected,Collection<T> actual){\n  String msg=String.format(\"expected=%s, actual=%s\",expected.toString(),actual.toString());\n  assertEquals(msg,expected.size(),actual.size());\n  for (  T e : expected) {\n    if (!actual.contains(e)) {\n      msg=String.format(\"Expected element %s not found in \" + \"actual. expected=%s, actual=%s\",e,expected,actual);\n      fail(msg);\n    }\n  }\n}", "comment": "test whether two collections contains the same elements , regardless of the order in which the elements appear in the collections", "label": "what"}
{"id": "68456", "raw_code": "private static boolean hasResponseBody(int requestMethod,int responseCode){\n  return requestMethod != Request.Method.HEAD && !(HttpStatus.SC_CONTINUE <= responseCode && responseCode < HttpStatus.SC_OK) && responseCode != HttpStatus.SC_NO_CONTENT && responseCode != HttpStatus.SC_NOT_MODIFIED;\n}", "comment": "checks if a response message contains a body .", "label": "what"}
{"id": "2195", "raw_code": "public void add(double x){\n  Cell[] as;\n  long b, v;\n  int m;\n  Cell a;\n  if ((as=cells) != null || !casBase(b=base,Double.doubleToRawLongBits(Double.longBitsToDouble(b) + x))) {\n    boolean uncontended=true;\n    if (as == null || (m=as.length - 1) < 0 || (a=as[getProbe() & m]) == null || !(uncontended=a.cas(v=a.value,Double.doubleToRawLongBits(Double.longBitsToDouble(v) + x))))     doubleAccumulate(x,null,uncontended);\n  }\n}", "comment": "adds the given value .", "label": "what"}
{"id": "55279", "raw_code": "public boolean shouldExecuteAction(){\n  if (delay <= 0) {\n    return true;\n  }\n  long timePassed=System.currentTimeMillis() - lastActionExecuted;\n  if (timePassed > delay * 100) {\n    lastActionExecuted=System.currentTimeMillis();\n    return true;\n  }\n  return false;\n}", "comment": "checks whether an action should currently be executed , based on the required delay .", "label": "what"}
{"id": "33250", "raw_code": "public static int moveByWord(String text,int column,boolean forward,boolean returnCursorAtEnd){\n  int curColumn=column;\n  int length=text.length();\n  int direction=forward ? 1 : -1;\n  boolean farWordEnd=((direction == 1 && returnCursorAtEnd) || (direction == -1 && !returnCursorAtEnd));\n  boolean foundEarlyMatch=false;\n  if (!UnicodeUtils.isWhitespace(text.charAt(curColumn))) {\n    curColumn=skipNonwhitespaceSimilar(text,curColumn,forward);\n    if (farWordEnd && curColumn - direction != column) {\n      curColumn-=direction;\n      foundEarlyMatch=true;\n    }\n  }\n  if (!foundEarlyMatch && curColumn >= 0 && curColumn < length) {\n    curColumn=skipWhitespace(text,curColumn,forward);\n    if (farWordEnd && curColumn >= 0 && curColumn < length) {\n      curColumn=skipNonwhitespaceSimilar(text,curColumn,forward) - direction;\n    }\n  }\n  if (curColumn < 0 || curColumn >= length) {\n    return -1;\n  }\n  return curColumn;\n}", "comment": "jumps to the previous or next best match given the parameters below .", "label": "what"}
{"id": "24049", "raw_code": "protected void handleOrDeferMessage(DistributionMessage msg){\nsynchronized (startupLock) {\n    if (beingSick || playingDead) {\n      if (msg.containsRegionContentChange() || msg instanceof PartitionMessageWithDirectReply) {\n        startupMessages.add(new StartupEvent(msg));\n        return;\n      }\n    }\n    if (!processingEvents) {\n      startupMessages.add(new StartupEvent(msg));\n      return;\n    }\n  }\n  dispatchMessage(msg);\n}", "comment": "dispatch the distribution message , or place it on the startup queue .", "label": "what"}
{"id": "43594", "raw_code": "private void shutdown(){\n  if (nbestListWriter != null) {\n    logger.info(\"Closing n-best writer\");\n    nbestListWriter.close();\n  }\n  if (alignmentWriter != null) {\n    logger.info(\"Closing alignment writer\");\n    alignmentWriter.close();\n  }\n}", "comment": "free resources and cleanup .", "label": "what"}
{"id": "80709", "raw_code": "public Boolean isHidden(File f){\n  String name=f.getName();\n  if ((name != null) && !name.equals(\"\") && (name.charAt(0) == '.')) {\n    return Boolean.TRUE;\n  }\n else {\n    return Boolean.FALSE;\n  }\n}", "comment": "whether the file is hidden or not .", "label": "what"}
{"id": "70073", "raw_code": "private boolean scrollViewCanScrollVertically(ScrollView scrollView,int direction){\n  final int offset=Math.max(0,scrollView.getScrollY());\n  final int range=computeVerticalScrollRange(scrollView) - scrollView.getHeight();\n  if (range == 0)   return false;\n  if (direction < 0) {\n    return offset > 0;\n  }\n else {\n    return offset < range - 1;\n  }\n}", "comment": "copy from scrollview ( api level > = 14 )", "label": "what"}
{"id": "11340", "raw_code": "public JarInfo loadJar() throws IOException {\n  ZipInputStream zis=null;\n  Manifest mf=null;\n  boolean empty=true;\n  try {\n    zis=new ZipInputStream(jarStream);\n    ZipEntry ent=null;\n    while ((ent=zis.getNextEntry()) != null) {\n      empty=false;\n      String name=ent.getName();\n      if (Manifest.isManifestName(name)) {\n        ByteArrayOutputStream baos=new ByteArrayOutputStream();\n        byte buffer[]=new byte[1024];\n        for (; ; ) {\n          int len=zis.read(buffer);\n          if (len < 0) {\n            break;\n          }\n          baos.write(buffer,0,len);\n        }\n        byte[] buf=baos.toByteArray();\n        mf=new Manifest(buf);\n      }\n    }\n  }\n catch (  IOException ex) {\n    throw ex;\n  }\ncatch (  Throwable th) {\n    th.printStackTrace();\n    throw new IOException(\"loadJar caught: \" + th);\n  }\n finally {\n    if (zis != null) {\n      try {\n        zis.close();\n      }\n catch (      Exception ex) {\n      }\n    }\n  }\n  if (empty) {\n    throw new IOException(\"JAR file is corrupt or empty\");\n  }\n  JarInfo ji=createJarInfo(mf);\n  return ji;\n}", "comment": "load the classes , resources , etc .", "label": "what"}
{"id": "16858", "raw_code": "public void invalidateTitleSortable(){\n  for (  Movie movie : new ArrayList<>(movieList)) {\n    movie.clearTitleSortable();\n  }\n}", "comment": "invalidate the title sortable upon changes to the sortable prefixes", "label": "what"}
{"id": "84263", "raw_code": "private boolean goTo(long day,boolean animate,boolean setSelected,boolean forceScroll){\n  if (setSelected) {\n    mSelectedDay.setTimeInMillis(day);\n  }\n  mTempDay.setTimeInMillis(day);\n  final int position=getPositionFromDay(day);\n  View child;\n  int i=0;\n  int top=0;\n  do {\n    child=getChildAt(i++);\n    if (child == null) {\n      break;\n    }\n    top=child.getTop();\n  }\n while (top < 0);\n  int selectedPosition;\n  if (child != null) {\n    selectedPosition=getPositionForView(child);\n  }\n else {\n    selectedPosition=0;\n  }\n  if (setSelected) {\n    mAdapter.setSelectedDay(mSelectedDay);\n  }\n  if (position != selectedPosition || forceScroll) {\n    setMonthDisplayed(mTempDay);\n    mPreviousScrollState=OnScrollListener.SCROLL_STATE_FLING;\n    if (animate) {\n      smoothScrollToPositionFromTop(position,LIST_TOP_OFFSET,GOTO_SCROLL_DURATION);\n      return true;\n    }\n else {\n      postSetSelection(position);\n    }\n  }\n else   if (setSelected) {\n    setMonthDisplayed(mSelectedDay);\n  }\n  return false;\n}", "comment": "this moves to the specified time in the view .", "label": "what"}
{"id": "5542", "raw_code": "public boolean search(V v){\n  int h=hashMethod.hash(v);\n  LinkedList<V> list=(LinkedList<V>)table[h];\n  if (list == null) {\n    return false;\n  }\n  return list.contains(v);\n}", "comment": "search for the desired value in the hashtable .", "label": "what"}
{"id": "69030", "raw_code": "public void addListener(ColorMapListener listener){\n  listeners.add(listener);\n}", "comment": "add a color map listener", "label": "what"}
{"id": "52771", "raw_code": "protected void computePDists(Relation<O> relation,KNNQuery<O> knn,WritableDoubleDataStore pdists){\n  FiniteProgress prdsProgress=LOG.isVerbose() ? new FiniteProgress(\"pdists\",relation.size(),LOG) : null;\n  for (DBIDIter iditer=relation.iterDBIDs(); iditer.valid(); iditer.advance()) {\n    final KNNList neighbors=knn.getKNNForDBID(iditer,kreach + 1);\n    int ks=0;\n    double ssum=0.;\n    for (DoubleDBIDListIter neighbor=neighbors.iter(); neighbor.valid() && ks < kreach; neighbor.advance()) {\n      if (DBIDUtil.equal(neighbor,iditer)) {\n        continue;\n      }\n      final double d=neighbor.doubleValue();\n      ssum+=d * d;\n      ks++;\n    }\n    double pdist=ks > 0 ? Math.sqrt(ssum / ks) : 0.;\n    pdists.putDouble(iditer,pdist);\n    LOG.incrementProcessed(prdsProgress);\n  }\n  LOG.ensureCompleted(prdsProgress);\n}", "comment": "compute the probabilistic distances used by loop .", "label": "what"}
{"id": "31473", "raw_code": "private JSONArray requestAllFileSystems() throws IOException, JSONException {\n  JSONArray ret=new JSONArray();\n  for (  Filesystem fs : filesystems) {\n    ret.put(fs.getRootEntry());\n  }\n  return ret;\n}", "comment": "requests a filesystem in which to store application data .", "label": "what"}
{"id": "55708", "raw_code": "protected boolean error_recovery(boolean debug) throws java.lang.Exception {\n  if (debug)   debug_message(\"# Attempting error recovery\");\n  if (!find_recovery_config(debug)) {\n    if (debug)     debug_message(\"# Error recovery fails\");\n    return false;\n  }\n  read_lookahead();\n  for (; ; ) {\n    if (debug)     debug_message(\"# Trying to parse ahead\");\n    if (try_parse_ahead(debug)) {\n      break;\n    }\n    if (lookahead[0].sym == EOF_sym()) {\n      if (debug)       debug_message(\"# Error recovery fails at EOF\");\n      return false;\n    }\n    if (debug)     debug_message(\"# Consuming Symbol #\" + lookahead[0].sym);\n    restart_lookahead();\n  }\n  if (debug)   debug_message(\"# Parse-ahead ok, going back to normal parse\");\n  parse_lookahead(debug);\n  return true;\n}", "comment": "attempt to recover from a syntax error .", "label": "what"}
{"id": "70238", "raw_code": "public void addRoll(MMRandom rng){\n  int result=rng.randomInt(this.faces) + this.min;\n  all.addElement(new Integer(result));\n  this.total+=result;\n  if (keep != -1 && all.size() >= keep) {\n    this.total=0;\n    Collections.sort(all,Collections.reverseOrder());\n    for (int i=0; i < keep; i++) {\n      this.total+=all.get(i);\n    }\n  }\n}", "comment": "add the result from the given rng source .", "label": "what"}
{"id": "39207", "raw_code": "public boolean checkCanonicalUserOptions(){\n  boolean result;\n  OptionHandler handler;\n  String[] userOptions;\n  String[] userOptionsCheck;\n  print(\"Canonical user options...\");\n  try {\n    handler=getDefaultHandler();\n    handler.setOptions(getUserOptions());\n    if (getDebug()) {\n      print(\"\\n  Getting canonical user options: \");\n    }\n    userOptions=handler.getOptions();\n    if (getDebug()) {\n      println(printOptions(userOptions));\n    }\n    if (getDebug()) {\n      println(\"  Setting canonical user options\");\n    }\n    handler.setOptions(userOptions.clone());\n    if (getDebug()) {\n      println(\"  Checking canonical user options\");\n    }\n    userOptionsCheck=handler.getOptions();\n    compareOptions(userOptions,userOptionsCheck);\n    println(\"yes\");\n    result=true;\n  }\n catch (  Exception e) {\n    println(\"no\");\n    result=false;\n    if (getDebug()) {\n      println(e);\n    }\n  }\n  return result;\n}", "comment": "checks whether the user - supplied options stay the same after settting , getting and re - setting again", "label": "what"}
{"id": "21910", "raw_code": "private void populateTaskList(Volume source,Map<BlockMirror,Volume> groupMirrorSourceMap,TaskList taskList,String taskId,ResourceOperationTypeEnum operationType){\n  Set<URI> groupSet=new HashSet<URI>();\n  addTask(taskList,source,taskId,operationType);\n  for (  Entry<BlockMirror,Volume> entry : groupMirrorSourceMap.entrySet()) {\n    BlockMirror mirror=entry.getKey();\n    Volume mirrorSource=entry.getValue();\n    if (source.isInCG() && null != taskList.getTaskList()) {\n      groupSet.add(mirrorSource.getConsistencyGroup());\n    }\n  }\n  List<BlockConsistencyGroup> groups=_dbClient.queryObject(BlockConsistencyGroup.class,groupSet);\n  for (  BlockConsistencyGroup group : groups) {\n    addTask(taskList,group,taskId,operationType);\n  }\n}", "comment": "populate the given tasklist with tasks .", "label": "what"}
{"id": "63824", "raw_code": "public static Tuple max(Iterator tuples,String field,Comparator cmp){\n  Tuple t=null, tmp;\n  Object min=null;\n  if (tuples.hasNext()) {\n    t=(Tuple)tuples.next();\n    min=t.get(field);\n  }\n  while (tuples.hasNext()) {\n    tmp=(Tuple)tuples.next();\n    Object obj=tmp.get(field);\n    if (cmp.compare(obj,min) > 0) {\n      t=tmp;\n      min=obj;\n    }\n  }\n  return t;\n}", "comment": "get the tuple with the maximum data field value .", "label": "what"}
{"id": "45150", "raw_code": "private static char[] zzUnpackCMap(String packed){\n  char[] map=new char[0x10000];\n  int i=0;\n  int j=0;\n  while (i < 178) {\n    int count=packed.charAt(i++);\n    char value=packed.charAt(i++);\n    do     map[j++]=value;\n while (--count > 0);\n  }\n  return map;\n}", "comment": "unpacks the compressed character translation table .", "label": "what"}
{"id": "56279", "raw_code": "@Override public int read(char b[],int off,int len) throws IOException {\n  ensureOpen();\n  if ((off < 0) || (off > b.length) || (len < 0)|| ((off + len) > b.length)|| ((off + len) < 0)) {\n    throw new IndexOutOfBoundsException();\n  }\n else   if (len == 0) {\n    return 0;\n  }\n  if (pos >= count) {\n    return -1;\n  }\n  if (pos + len > count) {\n    len=count - pos;\n  }\n  if (len <= 0) {\n    return 0;\n  }\n  System.arraycopy(buf,pos,b,off,len);\n  pos+=len;\n  return len;\n}", "comment": "reads characters into a portion of an array .", "label": "what"}
{"id": "43056", "raw_code": "public static void CF6(double[] x,double[] f,double[] c,int nx){\n  double sum1=0.0;\n  double sum2=0.0;\n  double yj;\n  for (int j=2; j <= nx; j++) {\n    if (j % 2 == 1) {\n      yj=x[j - 1] - 0.8 * x[0] * Math.cos(6.0 * PI * x[0] + j * PI / nx);\n      sum1+=yj * yj;\n    }\n else {\n      yj=x[j - 1] - 0.8 * x[0] * Math.sin(6.0 * PI * x[0] + j * PI / nx);\n      sum2+=yj * yj;\n    }\n  }\n  f[0]=x[0] + sum1;\n  f[1]=(1.0 - x[0]) * (1.0 - x[0]) + sum2;\n  c[0]=x[1] - 0.8 * x[0] * Math.sin(6.0 * x[0] * PI + 2.0 * PI / nx) - MYSIGN((x[0] - 0.5) * (1.0 - x[0])) * Math.sqrt(Math.abs((x[0] - 0.5) * (1.0 - x[0])));\n  c[1]=x[3] - 0.8 * x[0] * Math.sin(6.0 * x[0] * PI + 4.0 * PI / nx) - MYSIGN(0.25 * Math.sqrt(1 - x[0]) - 0.5 * (1.0 - x[0])) * Math.sqrt(Math.abs(0.25 * Math.sqrt(1 - x[0]) - 0.5 * (1.0 - x[0])));\n}", "comment": "evaluates the cf6 problem .", "label": "what"}
{"id": "13454", "raw_code": "public static void f(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_FATAL) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.wtf(tag,msg);\n}", "comment": "send a fatal error log message", "label": "what"}
{"id": "69855", "raw_code": "public static boolean nullEquals(String s1,String s2){\n  return (s1 == null ? s2 == null : s1.equals(s2));\n}", "comment": "equals ( ) with two strings where either could be null", "label": "what"}
{"id": "52966", "raw_code": "@Override public void run(){\n  MultipleObjectsBundle data=generator.loadData();\n  if (LOG.isVerbose()) {\n    LOG.verbose(\"Writing output ...\");\n  }\n  try {\n    if (outputFile.exists() && LOG.isVerbose()) {\n      LOG.verbose(\"The file \" + outputFile + \" already exists, \"+ \"the generator result will be APPENDED.\");\n    }\n    try (OutputStreamWriter outStream=new FileWriter(outputFile,true)){\n      writeClusters(outStream,data);\n    }\n   }\n catch (  IOException e) {\n    throw new AbortException(\"IO Error in data generator.\",e);\n  }\n  if (LOG.isVerbose()) {\n    LOG.verbose(\"Done.\");\n  }\n}", "comment": "runs the wrapper with the specified arguments .", "label": "what"}
{"id": "85054", "raw_code": "public void stop(){\nsynchronized (privateInstanceLock) {\n    if (connectionAcceptThread == null) {\n      return;\n    }\n  }\n  isStopped.set(true);\n  try {\n    connectionAcceptThread.interrupt();\n    connectionAcceptThread.join();\n  }\n catch (  InterruptedException e) {\n  }\n  try {\n    serverSocket.close();\n  }\n catch (  IOException e) {\n  }\n}", "comment": "stops the communicator .", "label": "what"}
{"id": "84480", "raw_code": "public boolean equalsIgnoreCase(final StrBuilder other){\n  if (this == other) {\n    return true;\n  }\n  if (this.size != other.size) {\n    return false;\n  }\n  final char thisBuf[]=this.buffer;\n  final char otherBuf[]=other.buffer;\n  for (int i=size - 1; i >= 0; i--) {\n    final char c1=thisBuf[i];\n    final char c2=otherBuf[i];\n    if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n      return false;\n    }\n  }\n  return true;\n}", "comment": "checks the contents of this builder against another to see if they contain the same character content ignoring case .", "label": "what"}
{"id": "24995", "raw_code": "public void addVMArguments(String vmArgumentName,String vmArgumentValue){\n  VmArgumentData vmArg=new VmArgumentData(vmArgumentName,vmArgumentValue);\n  vmSet.add(vmArg);\n}", "comment": "adds the given vm argument .", "label": "what"}
{"id": "71204", "raw_code": "private List reverse(List seq){\n  LinkedList newSeq=new LinkedList();\n  for (Iterator i=seq.iterator(); i.hasNext(); ) {\n    DirectedEdge de=(DirectedEdge)i.next();\n    newSeq.addFirst(de.getSym());\n  }\n  return newSeq;\n}", "comment": "reverse the sequence .", "label": "what"}
{"id": "18018", "raw_code": "protected LocPathIterator changePartToRef(final QName uniquePseudoVarName,WalkingIterator wi,final int numSteps,final boolean isGlobal){\n  Variable var=new Variable();\n  var.setQName(uniquePseudoVarName);\n  var.setIsGlobal(isGlobal);\n  if (isGlobal) {\n    ElemTemplateElement elem=getElemFromExpression(wi);\n    StylesheetRoot root=elem.getStylesheetRoot();\n    Vector vars=root.getVariablesAndParamsComposed();\n    var.setIndex(vars.size() - 1);\n  }\n  AxesWalker walker=wi.getFirstWalker();\n  for (int i=0; i < numSteps; i++) {\n    assertion(null != walker,\"Walker should not be null!\");\n    walker=walker.getNextWalker();\n  }\n  if (null != walker) {\n    FilterExprWalker few=new FilterExprWalker(wi);\n    few.setInnerExpression(var);\n    few.exprSetParent(wi);\n    few.setNextWalker(walker);\n    walker.setPrevWalker(few);\n    wi.setFirstWalker(few);\n    return wi;\n  }\n else {\n    FilterExprIteratorSimple feis=new FilterExprIteratorSimple(var);\n    feis.exprSetParent(wi.exprGetParent());\n    return feis;\n  }\n}", "comment": "change a given number of steps to a single variable reference .", "label": "what"}
{"id": "25655", "raw_code": "@Deprecated @Override public String readLine() throws IOException {\n  StringBuilder b=new StringBuilder(0);\n  int chr;\n  while ((chr=read()) >= 0) {\n    if (chr != '\\n') {\n      b.append((char)chr);\n    }\n else {\n      return b.toString();\n    }\n  }\n  return b.toString();\n}", "comment": "emulate the deprecated datainputstream . readline ( ) method .", "label": "what"}
{"id": "8326", "raw_code": "public void replace(ClassNode type,int n){\n  remove(n);\n  push(type);\n}", "comment": "replace n top level elements with new element of given type", "label": "what"}
{"id": "13786", "raw_code": "public void handleButton1Request(RequestInvocationEvent event) throws ModelControlException {\n  submitCycle=true;\n  EntitiesModel model=(EntitiesModel)getModel();\n  AMPropertySheet prop=(AMPropertySheet)getChild(PROPERTY_ATTRIBUTE);\n  String universalId=(String)getPageSessionAttribute(UNIVERSAL_ID);\n  try {\n    Map oldValues=model.getAttributeValues(universalId,false);\n    Map values=prop.getAttributeValues(oldValues,true,model);\n    String curRealm=(String)getPageSessionAttribute(AMAdminConstants.CURRENT_REALM);\n    model.modifyEntity(curRealm,universalId,values);\n    setInlineAlertMessage(CCAlert.TYPE_INFO,\"message.information\",\"message.updated\");\n  }\n catch (  AMConsoleException e) {\n    setInlineAlertMessage(CCAlert.TYPE_ERROR,\"message.error\",e.getMessage());\n  }\n  forwardTo();\n}", "comment": "handles create realm request .", "label": "what"}
{"id": "32815", "raw_code": "private Node deleteMax(Node x){\n  if (x.right == null)   return x.left;\n  x.right=deleteMax(x.right);\n  x.size=1 + size(x.left) + size(x.right);\n  x.height=1 + Math.max(height(x.left),height(x.right));\n  return balance(x);\n}", "comment": "removes the largest key and associated value from the given subtree .", "label": "what"}
{"id": "35457", "raw_code": "public void clear(){\n  final ReentrantLock lock=this.lock;\n  lock.lock();\n  try {\n    for (Node<E> f=first; f != null; ) {\n      f.item=null;\n      Node<E> n=f.next;\n      f.prev=null;\n      f.next=null;\n      f=n;\n    }\n    first=last=null;\n    count=0;\n    notFull.signalAll();\n  }\n  finally {\n    lock.unlock();\n  }\n}", "comment": "atomically removes all of the elements from this deque .", "label": "what"}
{"id": "45980", "raw_code": "private TreeNode(long nodeValue,SnmpMibAgent agent,TreeNode sup){\n  this.nodeValue=nodeValue;\n  this.parent=sup;\n  agents.addElement(agent);\n}", "comment": "only the treenode class can create an instance of treenode .", "label": "what"}
{"id": "4073", "raw_code": "public CodeAttribute createCode(){\n  CodeAttribute code=new CodeAttribute();\n  for (int i=0; i < _attributes.size(); i++) {\n    Attribute attr=_attributes.get(i);\n    if (attr instanceof CodeAttribute)     return (CodeAttribute)attr;\n  }\n  return null;\n}", "comment": "create the code attribute .", "label": "what"}
{"id": "32817", "raw_code": "public BinaryOut(String filename){\n  try {\n    OutputStream os=new FileOutputStream(filename);\n    out=new BufferedOutputStream(os);\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}", "comment": "initializes a binary output stream from a file .", "label": "what"}
{"id": "51525", "raw_code": "protected ObjectStreamClass readClassDescriptor() throws IOException, ClassNotFoundException {\n  ObjectStreamClass newClassDesc=new ObjectStreamClass();\n  String name=input.readUTF();\n  if (name.length() == 0) {\n    throw new IOException(\"The stream is corrupted\");\n  }\n  newClassDesc.setName(name);\n  newClassDesc.setSerialVersionUID(input.readLong());\n  newClassDesc.setFlags(input.readByte());\n  if (descriptorHandle == -1) {\n    descriptorHandle=nextHandle();\n  }\n  registerObjectRead(newClassDesc,descriptorHandle,false);\n  readFieldDescriptors(newClassDesc);\n  return newClassDesc;\n}", "comment": "reads a class descriptor from the source stream .", "label": "what"}
{"id": "44578", "raw_code": "public static boolean createNewFile(File targetFile){\n  if (targetFile.exists())   targetFile.delete();\n  try {\n    return targetFile.createNewFile();\n  }\n catch (  IOException e) {\n    return false;\n  }\n}", "comment": "create a new file , if the file exists , delete and create again .", "label": "what"}
{"id": "9890", "raw_code": "public Config(SamlAuthorityConfiguration samlAuthorityConfig,TokenRestrictions tokenRestrictions,Collection<List<Certificate>> validCerts,long clockTolerance,Collection<IDPConfig> inExternalIdps){\n  Validate.notNull(samlAuthorityConfig);\n  Validate.notNull(tokenRestrictions);\n  Validate.notEmpty(validCerts);\n  List<Certificate> authorityCert=samlAuthorityConfig.getSigningCertificateChain();\n  boolean authorityCertInValidCerts=false;\n  for (  List<Certificate> currentChain : validCerts) {\n    Validate.notEmpty(currentChain);\n    Validate.noNullElements(currentChain);\n    if (!authorityCertInValidCerts && currentChain.equals(authorityCert)) {\n      authorityCertInValidCerts=true;\n    }\n  }\n  Validate.isTrue(authorityCertInValidCerts,\"signing certificate chain is not in valid chains.\");\n  Validate.isTrue(clockTolerance >= 0);\n  this.samlAuthorityConfig=samlAuthorityConfig;\n  this.validCerts=validCerts;\n  this.clockTolerance=clockTolerance;\n  this.tokenRestrictions=tokenRestrictions;\n  HashMap<String,IDPConfig> idpsSet=new HashMap<String,IDPConfig>();\n  if (inExternalIdps != null) {\n    for (    IDPConfig conf : inExternalIdps) {\n      if (conf != null) {\n        idpsSet.put(conf.getEntityID(),conf);\n      }\n    }\n  }\n  this.externalIdps=Collections.unmodifiableMap(idpsSet);\n}", "comment": "creates a new configuration", "label": "what"}
{"id": "85725", "raw_code": "public static void checkNotEmpty(String string){\n  if (string.isEmpty()) {\n    throw new NullPointerException();\n  }\n}", "comment": "ensures that an string reference passed as a parameter to the calling method is not empty .", "label": "what"}
{"id": "16911", "raw_code": "public void cancelUnnamedTasks(){\n  if (unnamedTaskExecutor != null) {\n    unnamedTaskExecutor.shutdownNow();\n  }\n}", "comment": "cancel all open and running unnamed tasks", "label": "what"}
{"id": "52623", "raw_code": "public static double[] minmax(List<Double> values){\n  if (values.size() == 0) {\n    return new double[2];\n  }\n  double min=values.get(0);\n  double max=min;\n  int length=values.size();\n  for (int i=1; i < length; i++) {\n    double value=values.get(i);\n    min=Math.min(min,value);\n    max=Math.max(max,value);\n  }\n  return new double[]{min,max};\n}", "comment": "calculate the minimum and maximum values out of a list of doubles .", "label": "what"}
{"id": "45199", "raw_code": "private void removeBookmarkTrackingIcons(){\n  if (trackingIcons != null) {\n    for (Iterator i=trackingIcons.iterator(); i.hasNext(); ) {\n      GutterIconImpl ti=(GutterIconImpl)i.next();\n      if (ti.getIcon() == bookmarkIcon) {\n        i.remove();\n      }\n    }\n  }\n}", "comment": "removes all bookmark tracking icons .", "label": "what"}
{"id": "83911", "raw_code": "public SimpleMetricGroup(GroupName name,Stream<? extends Metric> i){\n  this(name,i.collect(Collectors.<Metric>toList()));\n}", "comment": "create a metric group with the given metrics .", "label": "what"}
{"id": "1686", "raw_code": "private void resolveProtocols(ClassLoader loader){\n  ServiceLoader<ProtocolManagerFactory> serviceLoader=ServiceLoader.load(ProtocolManagerFactory.class,loader);\n  loadProtocolManagerFactories(serviceLoader);\n}", "comment": "finds protocol support from a given classloader .", "label": "what"}
{"id": "73985", "raw_code": "public static List<InetAddress> hostAddresses(){\n  List<InetAddress> addrList=new ArrayList<>();\n  Enumeration<NetworkInterface> IFCs=null;\n  try {\n    IFCs=NetworkInterface.getNetworkInterfaces();\n  }\n catch (  SocketException ex) {\n    log.error(\"Unable to get network interfaces.\",ex);\n  }\n  if (IFCs != null) {\n    while (IFCs.hasMoreElements()) {\n      NetworkInterface IFC=IFCs.nextElement();\n      try {\n        if (IFC.isUp()) {\n          Enumeration<InetAddress> addresses=IFC.getInetAddresses();\n          while (addresses.hasMoreElements()) {\n            InetAddress address=addresses.nextElement();\n            if (!address.isLoopbackAddress() && !address.isLinkLocalAddress()) {\n              addrList.add(address);\n            }\n          }\n        }\n      }\n catch (      SocketException ex) {\n        log.error(\"Unable to read network interface {}.\",IFC.toString(),ex);\n      }\n    }\n  }\n  return addrList;\n}", "comment": "a list of the non - loopback , non - link - local ip addresses of the host , or null if none found .", "label": "what"}
{"id": "13417", "raw_code": "public final static int caculateInSampleSize(BitmapFactory.Options options,int rqsW,int rqsH){\n  final int height=options.outHeight;\n  final int width=options.outWidth;\n  int inSampleSize=1;\n  if (rqsW == 0 || rqsH == 0)   return 1;\n  if (height > rqsH || width > rqsW) {\n    final int heightRatio=Math.round((float)height / (float)rqsH);\n    final int widthRatio=Math.round((float)width / (float)rqsW);\n    inSampleSize=heightRatio < widthRatio ? heightRatio : widthRatio;\n  }\n  return inSampleSize;\n}", "comment": "caculate the bitmap samplesize", "label": "what"}
{"id": "80145", "raw_code": "public boolean hasStatus(final StatusID status){\n  return statuses.contains(status);\n}", "comment": "check if the entity has a certain status .", "label": "what"}
{"id": "17440", "raw_code": "static synchronized void computePRF_SSLv3(byte[] out,byte[] secret,byte[] seed){\n  if (sha == null) {\n    init();\n  }\n  int pos=0;\n  int iteration=1;\n  byte[] digest;\n  while (pos < out.length) {\n    byte[] pref=new byte[iteration];\n    Arrays.fill(pref,(byte)(64 + iteration++));\n    sha.update(pref);\n    sha.update(secret);\n    sha.update(seed);\n    md5.update(secret);\n    md5.update(sha.digest());\n    digest=md5.digest();\n    if (pos + 16 > out.length) {\n      System.arraycopy(digest,0,out,pos,out.length - pos);\n      pos=out.length;\n    }\n else {\n      System.arraycopy(digest,0,out,pos,16);\n      pos+=16;\n    }\n  }\n}", "comment": "computes the value of sslv3 pseudo random function .", "label": "what"}
{"id": "12321", "raw_code": "private void executeClaimedTask(ClaimedTask claimedTask){\n  if (!claimedTask.setStartTime(new Date())) {\n    _log.info(\"Claimed task is overdue; range not scanned: {}\",claimedTask.getTask());\n    return;\n  }\n  ScanRangeTask task=claimedTask.getTask();\n  boolean releaseTask=false;\n  try {\n    _scanWorkflow.renewScanRangeTasks(ImmutableList.of(task),QUEUE_RENEW_TTL);\n    releaseTask=asyncRangeScan(task);\n  }\n  finally {\n    unclaimTask(claimedTask,releaseTask);\n    _backgroundService.submit(_startScansIfAvailableRunnable);\n  }\n}", "comment": "executes a previously claimed scan range task .", "label": "what"}
{"id": "37002", "raw_code": "private static boolean createNaviDirectory(){\n  final File dir=new File(ConfigHelper.getConfigurationDirectory(Constants.COMPANY_NAME,Constants.PROJECT_NAME));\n  return dir.exists() || dir.mkdir();\n}", "comment": "creates the configuration directory if it does not already exist .", "label": "what"}
{"id": "29058", "raw_code": "public Iterator<Target> targetIterator(){\n  return targetList.iterator();\n}", "comment": "iterate over target objects representing control flow targets and their edge types .", "label": "what"}
{"id": "24912", "raw_code": "private void fitSizeOfScrolledContent(){\n  Point p=scrollComposite.getSize();\n  main.setSize(main.computeSize(p.x,SWT.DEFAULT));\n}", "comment": "fits the width of the main composite to the same width scrolled composite was given .", "label": "what"}
{"id": "48899", "raw_code": "private static Map<String,SnmpOid> buildPoolIndexMap(SnmpCachedData cached){\n  if (cached == null)   return Collections.emptyMap();\n  final SnmpOid[] indexes=cached.indexes;\n  final Object[] datas=cached.datas;\n  final int len=indexes.length;\n  final Map<String,SnmpOid> m=new HashMap<>(len);\n  for (int i=0; i < len; i++) {\n    final SnmpOid index=indexes[i];\n    if (index == null)     continue;\n    final MemoryPoolMXBean mpm=(MemoryPoolMXBean)datas[i];\n    if (mpm == null)     continue;\n    final String name=mpm.getName();\n    if (name == null)     continue;\n    m.put(name,index);\n  }\n  return m;\n}", "comment": "builds a map pool - name = > pool - index from the snmptablehandler of the jvmmempooltable .", "label": "what"}
{"id": "9675", "raw_code": "public DCryptoStrength(JFrame parent) throws CryptoException {\n  super(parent,res.getString(\"DCryptoStrength.Title\"),ModalityType.DOCUMENT_MODAL);\n  initComponents();\n}", "comment": "creates a new dcryptostrength dialog where the parent is a frame .", "label": "what"}
{"id": "54547", "raw_code": "public void add(final T object){\nsynchronized (mLock) {\n    mList.add(object);\n  }\n  notifyDataSetChanged();\n}", "comment": "adds the specified object at the end of the array .", "label": "what"}
{"id": "6310", "raw_code": "@Override public void write(byte[] b,int off,int len){\n  if ((off < 0) || (off > b.length) || (len < 0)|| ((off + len) > b.length)|| ((off + len) < 0)) {\n    throw new IndexOutOfBoundsException();\n  }\n else   if (len == 0) {\n    return;\n  }\nsynchronized (this) {\n    int newcount=count + len;\n    int remaining=len;\n    int inBufferPos=count - filledBufferSum;\n    while (remaining > 0) {\n      int part=Math.min(remaining,currentBuffer.length - inBufferPos);\n      System.arraycopy(b,off + len - remaining,currentBuffer,inBufferPos,part);\n      remaining-=part;\n      if (remaining > 0) {\n        needNewBuffer(newcount);\n        inBufferPos=0;\n      }\n    }\n    count=newcount;\n  }\n}", "comment": "write the bytes to byte array .", "label": "what"}
{"id": "5668", "raw_code": "public static PlainText plain(short text){\n  return plain(Integer.toString(text));\n}", "comment": "creates a new plaintext component with the given short", "label": "what"}
{"id": "70069", "raw_code": "public static synchronized void it(String description,UnsafeBlock block){\n  it(description,identity(),block);\n}", "comment": "defines a new example .", "label": "what"}
{"id": "78785", "raw_code": "public static boolean isWritable(final File file,final boolean makeDirs){\n  if (file == null) {\n    Log.e(FileUtils.class,\"isWritable(): Null or Empty parameter given\");\n    return false;\n  }\n  final String fileParentDir=file.getParent();\n  if (!TextUtils.isEmpty(fileParentDir)) {\n    final File fileDir=new File(fileParentDir);\n    if (!fileDir.exists()) {\n      if (makeDirs)       return makeDirsForFile(file);\n else       return false;\n    }\n  }\n  boolean isWritable=true;\n  if (file.exists())   isWritable=file.canWrite();\n else {\n    try {\n      isWritable=file.createNewFile();\n    }\n catch (    IOException e) {\n    }\n    if (isWritable)     isWritable=file.delete();\n  }\n  return isWritable;\n}", "comment": "method checks if file could be written / deleted or created .", "label": "what"}
{"id": "4092", "raw_code": "public void read(ByteCodeParser in) throws IOException {\n  int length=in.readInt();\n  _maxStack=in.readShort();\n  _maxLocals=in.readShort();\n  int codeLength=in.readInt();\n  _code=new byte[codeLength];\n  in.read(_code,0,codeLength);\n  int exnCount=in.readShort();\n  for (int i=0; i < exnCount; i++) {\n    ExceptionItem exn=new ExceptionItem();\n    exn.setStart(in.readShort() & 0xffff);\n    exn.setEnd(in.readShort() & 0xffff);\n    exn.setHandler(in.readShort() & 0xffff);\n    exn.setType(in.readShort() & 0xffff);\n    _exceptions.add(exn);\n  }\n  int attrCount=in.readShort();\n  for (int i=0; i < attrCount; i++) {\n    Attribute attr=in.parseAttribute();\n    _attributes.add(attr);\n  }\n}", "comment": "writes the field to the output .", "label": "what"}
{"id": "64727", "raw_code": "protected void findCandidateCrossings(S2Point a,S2Point b,List<Integer> candidateCrossings){\n  Preconditions.checkState(indexComputed);\n  ArrayList<S2CellId> cover=Lists.newArrayList();\n  getCovering(a,b,false,cover);\n  Set<Integer> uniqueSet=new HashSet<Integer>();\n  getEdgesInParentCells(cover,uniqueSet);\n  getEdgesInChildrenCells(a,b,cover,uniqueSet);\n  candidateCrossings.clear();\n  candidateCrossings.addAll(uniqueSet);\n}", "comment": "appends to \" candidatecrossings \" all edge references which may cross the given edge .", "label": "what"}
{"id": "81275", "raw_code": "protected JavaElementDelta createDeltaTree(IJavaElement element,JavaElementDelta delta){\n  JavaElementDelta childDelta=delta;\n  ArrayList ancestors=getAncestors(element);\n  if (ancestors == null) {\n    if (equalsAndSameParent(delta.getElement(),getElement())) {\n      this.kind=delta.kind;\n      this.changeFlags=delta.changeFlags;\n      this.movedToHandle=delta.movedToHandle;\n      this.movedFromHandle=delta.movedFromHandle;\n    }\n  }\n else {\n    for (int i=0, size=ancestors.size(); i < size; i++) {\n      IJavaElement ancestor=(IJavaElement)ancestors.get(i);\n      JavaElementDelta ancestorDelta=new JavaElementDelta(ancestor);\n      ancestorDelta.addAffectedChild(childDelta);\n      childDelta=ancestorDelta;\n    }\n  }\n  return childDelta;\n}", "comment": "creates the nested delta deltas based on the affected element its delta , and the root of this delta tree .", "label": "what"}
{"id": "56253", "raw_code": "public static String replace(String inString,String oldPattern,String newPattern){\n  if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n    return inString;\n  }\n  StringBuilder sb=new StringBuilder();\n  int pos=0;\n  int index=inString.indexOf(oldPattern);\n  int patLen=oldPattern.length();\n  while (index >= 0) {\n    sb.append(inString.substring(pos,index));\n    sb.append(newPattern);\n    pos=index + patLen;\n    index=inString.indexOf(oldPattern,pos);\n  }\n  sb.append(inString.substring(pos));\n  return sb.toString();\n}", "comment": "replace all occurrences of a substring within a string with another string .", "label": "what"}
{"id": "83381", "raw_code": "public boolean coordinateInZone(Id<ActivityFacility> zoneID,Coord coordinate){\n  Point point=MGC.xy2Point(coordinate.getX(),coordinate.getY());\n  return pointInZone(zoneID,point);\n}", "comment": "determines if a given coordinate lies within a selected zone .", "label": "what"}
{"id": "12725", "raw_code": "public XwavesLabelfileReader(Reader reader) throws IOException {\n  this.reader=new BufferedReader(reader);\n  parseLabels();\n  reader.close();\n}", "comment": "read data from a label file .", "label": "what"}
{"id": "44336", "raw_code": "public void print(char c){\n  writer.print(c);\n}", "comment": "prints the given char .", "label": "what"}
{"id": "13811", "raw_code": "protected void clearAllTrails(SSOTokenID tokenID){\n  boolean removed=false;\n  String key=tokenID.toString();\nsynchronized (mapTokenIDs) {\n    removed=(mapTokenIDs.remove(key) != null);\n  }\n}", "comment": "clears all registered page trails of a given single sign on token id", "label": "what"}
{"id": "9700", "raw_code": "public DNetscapeCaRevocationUrl(JDialog parent,byte[] value) throws IOException {\n  super(parent);\n  setTitle(res.getString(\"DNetscapeCaRevocationUrl.Title\"));\n  initComponents();\n  prepopulateWithValue(value);\n}", "comment": "creates a new dnetscapecarevocationurl dialog .", "label": "what"}
{"id": "42841", "raw_code": "public static int[] parseNumberList(String listStr,int minVal,int maxVal,boolean allowZero){\n  int[] values;\n  if (listStr.indexOf(\",\") < 0) {\n    values=new int[1];\n    values[0]=parseIntRange(listStr,minVal,maxVal,allowZero);\n  }\n else {\n    String[] valueStrs=listStr.split(\",\");\n    int len=valueStrs.length;\n    values=new int[len];\n    for (int i=0; i < len; i++) {\n      values[i]=parseIntRange(valueStrs[i],minVal,maxVal,allowZero);\n    }\n  }\n  return values;\n}", "comment": "parses a comma - separated list of integers , with range - checking .", "label": "what"}
{"id": "22074", "raw_code": "public DirectoryOrFileNotFoundException(String entity,String name){\n  super(String.format(_errorMessage,entity,name));\n}", "comment": "constructs a new exception with detailed error message .", "label": "what"}
{"id": "45805", "raw_code": "void scramble(){\n  initialSize=getSize();\n  int a[]=new int[initialSize.height / 2];\n  double f=initialSize.width / (double)a.length;\n  for (int i=a.length; --i >= 0; ) {\n    a[i]=(int)(i * f);\n  }\n  for (int i=a.length; --i >= 0; ) {\n    int j=(int)(i * Math.random());\n    int t=a[i];\n    a[i]=a[j];\n    a[j]=t;\n  }\n  arr=a;\n}", "comment": "fill the array with random numbers from 0 . . n - 1 .", "label": "what"}
{"id": "86994", "raw_code": "public static SIPHeader parseSIPHeader(String header) throws ParseException {\n  int start=0;\n  int end=header.length() - 1;\n  try {\n    while (header.charAt(start) <= 0x20)     start++;\n    while (header.charAt(end) <= 0x20)     end--;\n  }\n catch (  ArrayIndexOutOfBoundsException e) {\n    throw new ParseException(\"Empty header.\",0);\n  }\n  StringBuilder buffer=new StringBuilder(end + 1);\n  int i=start;\n  int lineStart=start;\n  boolean endOfLine=false;\n  while (i <= end) {\n    char c=header.charAt(i);\n    if (c == '\\r' || c == '\\n') {\n      if (!endOfLine) {\n        buffer.append(header.substring(lineStart,i));\n        endOfLine=true;\n      }\n    }\n else {\n      if (endOfLine) {\n        endOfLine=false;\n        if (c == ' ' || c == '\\t') {\n          buffer.append(' ');\n          lineStart=i + 1;\n        }\n else {\n          lineStart=i;\n        }\n      }\n    }\n    i++;\n  }\n  buffer.append(header.substring(lineStart,i));\n  buffer.append('\\n');\n  HeaderParser hp=ParserFactory.createParser(buffer.toString());\n  if (hp == null)   throw new ParseException(\"could not create parser\",0);\n  return hp.parse();\n}", "comment": "parse an individual sip message header from a string .", "label": "what"}
{"id": "86602", "raw_code": "public void recordBeginning(){\n  final String msg=\"Usage beginning module=\" + mModuleName + \" runId=\"+ mRunId;\n  mUsageMessages.add(msg);\n  Diagnostic.developerLog(msg);\n  mClient.recordBeginning(mModuleName,mRunId);\n}", "comment": "records a start usage logging message to whichever logging endpoint is configured", "label": "what"}
{"id": "31239", "raw_code": "static float rotateY(float pX,float pY,float cX,float cY,float angleInDegrees){\n  double angle=Math.toRadians(angleInDegrees);\n  return (float)(Math.sin(angle) * (pX - cX) + Math.cos(angle) * (pY - cY) + cY);\n}", "comment": "rotate point p around center point c .", "label": "what"}
{"id": "1840", "raw_code": "public MemBasedCache(int maxCacheSizeInBytes){\n  mMaxCacheSizeInBytes=maxCacheSizeInBytes;\n  mDataEntries=new LinkedHashMap<String,CacheHeader>(16,.75f,true);\n}", "comment": "constructs an instance of the membasedcache .", "label": "what"}
{"id": "53054", "raw_code": "public void enableOverview(boolean b){\n  if (overviewItem != null) {\n    overviewItem.setEnabled(b);\n  }\n}", "comment": "enable / disable the overview menu .", "label": "what"}
{"id": "11282", "raw_code": "public void mouseEntered(MouseEvent e){\n  if (Debug.debugging(\"mousemodedetail\")) {\n    Debug.output(getID() + \"|NavMouseMode.mouseEntered()\");\n  }\n  super.mouseEntered(e);\n  autoZoom=true;\n}", "comment": "handle a mouseentered mouselistener event .", "label": "what"}
{"id": "54237", "raw_code": "public void accept(final AnnotationVisitor av){\n  if (av != null) {\n    if (values != null) {\n      for (int i=0; i < values.size(); i+=2) {\n        String name=(String)values.get(i);\n        Object value=values.get(i + 1);\n        accept(av,name,value);\n      }\n    }\n    av.visitEnd();\n  }\n}", "comment": "makes the given visitor visit this annotation .", "label": "what"}
{"id": "81120", "raw_code": "private void stop(HttpServletRequest request,HttpServletResponse response) throws IOException {\n  PrintWriter out=response.getWriter();\n  String label=request.getParameter(\"stop\");\n  Monitor mon=removeMon(label,null,DEFAULT_UNITS);\n  if (mon == null) {\n    out.println(ERROR + \": stop requires that an existing label is passed in.  For example: curl http://localhost:8080/jamon/Mon?stop=mylabel\");\n  }\n else {\n    mon.stop();\n    out.println(OK + \": stop successfully called on - \" + mon);\n  }\n}", "comment": "stop a previously started monitor if it exists .", "label": "what"}
{"id": "67779", "raw_code": "public static String normalizeUrl(String requestUrl) throws OAuthException {\n  if ((requestUrl == null) || (requestUrl.length() == 0)) {\n    throw new OAuthException(\"Request Url cannot be empty\");\n  }\n  URI uri;\n  try {\n    uri=new URI(requestUrl);\n  }\n catch (  URISyntaxException e) {\n    throw new OAuthException(e);\n  }\n  String authority=uri.getAuthority();\n  String scheme=uri.getScheme();\n  if (authority == null || scheme == null) {\n    throw new OAuthException(\"Invalid Request Url\");\n  }\n  authority=authority.toLowerCase();\n  scheme=scheme.toLowerCase();\n  if ((scheme.equals(\"http\") && uri.getPort() == 80) || (scheme.equals(\"https\") && uri.getPort() == 443)) {\n    int index=authority.lastIndexOf(\":\");\n    if (index >= 0) {\n      authority=authority.substring(0,index);\n    }\n  }\n  return scheme + \"://\" + authority+ uri.getRawPath();\n}", "comment": "calculates the normalized request url , as per section 9 . 1 . 2 of the oauth spec .", "label": "what"}
{"id": "84181", "raw_code": "public void invoke(InputStream is,OutputStream os,SerializerFactory serializerFactory) throws Exception {\n  boolean isDebug=false;\n  if (isDebugInvoke()) {\n    isDebug=true;\n    PrintWriter dbg=createDebugPrintWriter();\n    HessianDebugInputStream dIs=new HessianDebugInputStream(is,dbg);\n    dIs.startTop2();\n    is=dIs;\n    HessianDebugOutputStream dOs=new HessianDebugOutputStream(os,dbg);\n    dOs.startTop2();\n    os=dOs;\n  }\n  HessianInputFactory.HeaderType header=_inputFactory.readHeader(is);\n  AbstractHessianInput in;\n  AbstractHessianOutput out;\nswitch (header) {\ncase CALL_1_REPLY_1:\n    in=_hessianFactory.createHessianInput(is);\n  out=_hessianFactory.createHessianOutput(os);\nbreak;\ncase CALL_1_REPLY_2:\nin=_hessianFactory.createHessianInput(is);\nout=_hessianFactory.createHessian2Output(os);\nbreak;\ncase HESSIAN_2:\nin=_hessianFactory.createHessian2Input(is);\nin.readCall();\nout=_hessianFactory.createHessian2Output(os);\nbreak;\ndefault :\nthrow new IllegalStateException(header + \" is an unknown Hessian call\");\n}\nif (serializerFactory != null) {\nin.setSerializerFactory(serializerFactory);\nout.setSerializerFactory(serializerFactory);\n}\ntry {\ninvoke(_service,in,out);\n}\n  finally {\nin.close();\nout.close();\nif (isDebug) os.close();\n}\n}", "comment": "invoke the object with the request from the input stream .", "label": "what"}
{"id": "30438", "raw_code": "private void commitLocalTransaction() throws CommitFailedException {\n  if (_tx == null) {\n    return;\n  }\n  if (_logger.isLoggable(Level.FINEST)) {\n    _logger.log(Level.FINEST,\"Committing local transaction: \" + _tx);\n  }\n  try {\n    _tx.commit();\n  }\n catch (  Exception e) {\n    if (_logger.isLoggable(Level.SEVERE)) {\n      _logger.log(Level.SEVERE,\"Failed to commit local transaction: \" + _tx,e);\n    }\n    throw new CommitFailedException(e);\n  }\n}", "comment": "commits the local transaction .", "label": "what"}
{"id": "14338", "raw_code": "public static Entry addObjectClass(Entry entry){\n  Attribute attribute=entry.getAttribute(CoreTokenConstants.OBJECT_CLASS);\n  if (attribute == null) {\n    entry.addAttribute(CoreTokenConstants.OBJECT_CLASS,CoreTokenConstants.FR_CORE_TOKEN);\n  }\n  return entry;\n}", "comment": "only adds the objectclass if it hasn ' t already been added .", "label": "what"}
{"id": "1725", "raw_code": "public SimpleString concat(final char c){\n  byte[] bytes=new byte[data.length + 2];\n  System.arraycopy(data,0,bytes,0,data.length);\n  bytes[data.length]=(byte)(c & 0xFF);\n  bytes[data.length + 1]=(byte)(c >> 8 & 0xFF);\n  return new SimpleString(bytes);\n}", "comment": "concatenates a simplestring and a char", "label": "what"}
{"id": "47233", "raw_code": "private void signalNotEmpty(){\n  final ReentrantLock takeLock=this.takeLock;\n  takeLock.lock();\n  try {\n    notEmpty.signal();\n  }\n  finally {\n    takeLock.unlock();\n  }\n}", "comment": "signals a waiting take .", "label": "what"}
{"id": "12699", "raw_code": "public void deepFill(MaryNode specTree){\n  tree=specTree;\n  numberOfLeaves=0;\n  sortNode(0,tree);\n}", "comment": "fill a tree which specifies a feature hierarchy but no corresponding units .", "label": "what"}
{"id": "47067", "raw_code": "private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {\n  s.defaultWriteObject();\n  for (Node<K,V> n=findFirst(); n != null; n=n.next) {\n    V v=n.getValidValue();\n    if (v != null) {\n      s.writeObject(n.key);\n      s.writeObject(v);\n    }\n  }\n  s.writeObject(null);\n}", "comment": "saves this map to a stream ( that is , serializes it ) .", "label": "what"}
{"id": "75808", "raw_code": "public static final double sigma(double a){\n  return 1.0 / (1.0 + Math.exp(-a));\n}", "comment": "sigmoid / logistic function", "label": "what"}
{"id": "44135", "raw_code": "public void translate(double x,double y){\n  currentTransform.translate(x,y);\n  try {\n    writeTransform(new AffineTransform(1,0,0,1,x,y));\n  }\n catch (  IOException e) {\n    handleException(e);\n  }\n}", "comment": "translates the current transform .", "label": "what"}
{"id": "21985", "raw_code": "public static boolean isSupportedAddRPProtectionVirtualPoolChange(Volume volume,VirtualPool currentVpool,VirtualPool newVpool,DbClient dbClient,StringBuffer notSuppReasonBuff){\n  s_logger.info(String.format(\"Checking isSupportedAddRPProtectionVirtualPoolChange from [%s] to [%s]...\",currentVpool.getLabel(),newVpool.getLabel()));\n  if (isSameVirtualPool(currentVpool,newVpool,notSuppReasonBuff)) {\n    return false;\n  }\n  if (volume.checkForRp() || VirtualPool.vPoolSpecifiesProtection(currentVpool)) {\n    notSuppReasonBuff.append(\"Can't add RecoverPoint Protection since it already exists.\");\n    return false;\n  }\n  if (!VirtualPool.vPoolSpecifiesHighAvailability(currentVpool) && VirtualPool.vPoolSpecifiesRPVPlex(newVpool)) {\n    notSuppReasonBuff.append(\"Can't add RecoverPoint+VPLEX Protection directly to non-VPLEX volume. Import to VPLEX first.\");\n    return false;\n  }\n  if (VirtualPool.vPoolSpecifiesHighAvailability(currentVpool) && !VirtualPool.vPoolSpecifiesHighAvailabilityDistributed(currentVpool) && VirtualPool.vPoolSpecifiesMetroPoint(newVpool)) {\n    notSuppReasonBuff.append(\"Can't add MetroPoint Protection directly to VPLEX Local volume. \" + \"Upgrade from VPLEX Local to VPLEX Distributed first.\");\n    return false;\n  }\n  String[] include=new String[]{TYPE,VARRAYS,REF_VPOOL,MIRROR_VPOOL,FAST_EXPANSION,ACLS,INACTIVE,PROTOCOLS,PROVISIONING_TYPE,USE_MATCHED_POOLS,ARRAY_INFO,DRIVE_TYPE,AUTO_TIER_POLICY_NAME,HOST_IO_LIMIT_IOPS,HOST_IO_LIMIT_BANDWIDTH,VMAX_COMPRESSION_ENABLED,IS_THIN_VOLUME_PRE_ALLOCATION_ENABLED,ASSIGNED_STORAGE_POOLS};\n  Map<String,Change> changes=analyzeChanges(currentVpool,newVpool,include,null,null);\n  if (!changes.isEmpty()) {\n    notSuppReasonBuff.append(\"These target virtual pool differences are invalid: \");\n    fillInNotSupportedReasons(changes,notSuppReasonBuff);\n    return false;\n  }\n  include=new String[]{PROTECTION_VARRAY_SETTINGS};\n  changes=analyzeChanges(currentVpool,newVpool,include,null,null);\n  if (changes.isEmpty()) {\n    notSuppReasonBuff.append(\"These target virtual pool differences are required: \");\n    fillInNotSupportedReasons(changes,notSuppReasonBuff);\n    return false;\n  }\n  if (VirtualPool.vPoolSpecifiesHighAvailability(currentVpool) && (VirtualPool.vPoolSpecifiesRPVPlex(newVpool) || VirtualPool.vPoolSpecifiesMetroPoint(newVpool))) {\n    VirtualPoolChangeOperationEnum op=vplexCommonChecks(volume,currentVpool,newVpool,dbClient,notSuppReasonBuff,include);\n    if (op == null || !op.equals(VirtualPoolChangeOperationEnum.RP_PROTECTED)) {\n      return false;\n    }\n  }\n  return true;\n}", "comment": "determines if the volume qualifies for rp protection .", "label": "what"}
{"id": "11133", "raw_code": "private void writeObject(ObjectOutputStream oos) throws IOException {\n  oos.defaultWriteObject();\n  boolean writeFont=(f != OMText.DEFAULT_FONT);\n  oos.writeBoolean(writeFont);\n  if (writeFont) {\n    oos.writeObject(f.getName());\n    oos.writeInt(f.getSize());\n    oos.writeInt(f.getStyle());\n  }\n  writeStroke(oos,stroke,OMGraphic.BASIC_STROKE);\n  writeStroke(oos,textMatteStroke,DEFAULT_TEXT_MATTE_STROKE);\n}", "comment": "write this object to a stream .", "label": "what"}
{"id": "42694", "raw_code": "private static void writeSpaces(Writer out,int amt) throws IOException {\n  while (amt > 0) {\n    out.write(' ');\n    amt--;\n  }\n}", "comment": "writes the given number of spaces to the given writer .", "label": "what"}
{"id": "40276", "raw_code": "protected void handleAutoDraw(){\n  if (isToolItemSelected(ToolBarItemKey.AUTO_DRAW)) {\n    onAutoDraw();\n  }\n}", "comment": "if auto draw is enabled , a draw request is sent .", "label": "what"}
{"id": "73761", "raw_code": "public Z21Message(byte[] a,int l){\n  super(String.valueOf(a));\n  setBinary(true);\n}", "comment": "this ctor interprets the byte array as a sequence of characters to send .", "label": "what"}
{"id": "65181", "raw_code": "public boolean packageHasAnnotation(Annotation annotation){\n  try {\n    Package pkg=type.getPackage();\n    if (pkg == null) {\n      return false;\n    }\n    String className=pkg.getName() + \".package-info\";\n    Class<?> packageType=Class.forName(className);\n    AnnotationAccessor accessor=new AnnotationAccessor(supportedAnnotations,packageType,ignoreAnnotationFailure);\n    return accessor.typeHas(annotation);\n  }\n catch (  ClassNotFoundException e) {\n    return false;\n  }\n}", "comment": "determines whether the package in which t resides has a particular annotation .", "label": "what"}
{"id": "37101", "raw_code": "private String buildToolTip(final CTaggedGraphNodesContainerNode node){\n  final StringBuilder tooltip=new StringBuilder(\"<html>\");\n  boolean first=true;\n  for (  final NaviNode graphnode : node.getGraphNodes()) {\n    if (!first) {\n      tooltip.append(\"<br>\");\n    }\n    tooltip.append(CNodesDisplayString.getDisplayString(graphnode));\n    first=false;\n  }\n  return tooltip + \"</html>\";\n}", "comment": "generates the tooltip shown when the cursor hovers over a tag tree node that represents a container of graph nodes .", "label": "what"}
{"id": "39908", "raw_code": "public void makeGraph(File linkGraph) throws Exception {\n  String temp212;\n  int rowNum=0;\n  BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(linkGraph)));\n  while ((temp212=br.readLine()) != null) {\n    String[] strs=temp212.split(\" \");\n    for (int i=0; i < strs.length; i++) {\n      graph[rowNum][i]=Double.parseDouble(strs[i]);\n    }\n    rowNum++;\n  }\n  for (int i=0; i < dataNum; i++) {\n    for (int j=0; j < dimension; j++) {\n      W[i][j]=r.nextDouble();\n      H[j][i]=r.nextDouble();\n    }\n  }\n  for (int i=0; i < dataNum; i++) {\n    double sumW=0;\n    double sumH=0;\n    for (int j=0; j < dimension; j++) {\n      sumW+=W[i][j] * W[i][j];\n      sumH+=H[j][i] * H[j][i];\n    }\n    sumW=Math.sqrt(sumW);\n    sumH=Math.sqrt(sumH);\n    for (int j=0; j < dimension; j++) {\n      W[i][j]/=sumW;\n      H[j][i]/=sumH;\n    }\n  }\n  trainW();\n  init=false;\n}", "comment": "read in the normalized category file .", "label": "what"}
{"id": "8558", "raw_code": "public boolean removeOnItemClickListener(OnItemClickListener itemClickListener){\n  return clickListeners.remove(itemClickListener);\n}", "comment": "remove item click listener from this view", "label": "what"}
{"id": "72900", "raw_code": "@Override protected int lookForSelectablePosition(int position,boolean lookDown){\n  final ListAdapter adapter=mAdapter;\n  if (adapter == null || isInTouchMode()) {\n    return INVALID_POSITION;\n  }\n  final int count=adapter.getCount();\n  if (!mAreAllItemsSelectable) {\n    if (lookDown) {\n      position=Math.max(0,position);\n      while (position < count && !adapter.isEnabled(position)) {\n        position++;\n      }\n    }\n else {\n      position=Math.min(position,count - 1);\n      while (position >= 0 && !adapter.isEnabled(position)) {\n        position--;\n      }\n    }\n    if (position < 0 || position >= count) {\n      return INVALID_POSITION;\n    }\n    return position;\n  }\n else {\n    if (position < 0 || position >= count) {\n      return INVALID_POSITION;\n    }\n    return position;\n  }\n}", "comment": "find a position that can be selected ( i . e . , is not a separator ) .", "label": "what"}
{"id": "86681", "raw_code": "public static String padRight(final String s,final int length){\n  final int pad=length - s.length();\n  return pad > 0 ? s + getSpaceString(pad) : s;\n}", "comment": "pad a string on the right with spaces till it is at least the specified length .", "label": "what"}
{"id": "4782", "raw_code": "public void write(PrintStream out){\n  write(out,table);\n}", "comment": "writes the algorithm ' s internal representation as text .", "label": "what"}
{"id": "41483", "raw_code": "static Part from(String encoded,String decoded){\n  if (encoded == null) {\n    return NULL;\n  }\n  if (encoded.length() == 0) {\n    return EMPTY;\n  }\n  if (decoded == null) {\n    return NULL;\n  }\n  if (decoded.length() == 0) {\n    return EMPTY;\n  }\n  return new Part(encoded,decoded);\n}", "comment": "creates a part from the encoded and decoded strings .", "label": "what"}
{"id": "32525", "raw_code": "void checkAfterUnmarshalled(){\n  assertEquals(shortVal.shortValue(),0x1122);\n  assertEquals(longVal,0x8877665544332211L);\n  assertNull(aArr);\n  assertNull(strVal);\n  assertEquals(doubleVal,123.456);\n}", "comment": "checks correctness of the state after unmarshalling .", "label": "what"}
{"id": "56566", "raw_code": "@Override public <R>CompletableFuture<R> collect(final Supplier<R> supplier,final BiConsumer<R,? super T> accumulator,final BiConsumer<R,R> combiner){\n  return CompletableFuture.supplyAsync(null,exec);\n}", "comment": "asynchronously perform a stream collection", "label": "what"}
{"id": "69434", "raw_code": "private static void applyOverrides(){\n  InputStream stream=getContentTypesPropertiesStream();\n  if (stream == null) {\n    return;\n  }\n  try {\n    try {\n      Properties overrides=new Properties();\n      overrides.load(stream);\n      for (      Map.Entry<Object,Object> entry : overrides.entrySet()) {\n        String extension=(String)entry.getKey();\n        String mimeType=(String)entry.getValue();\n        add(mimeType,extension);\n      }\n    }\n  finally {\n      stream.close();\n    }\n  }\n catch (  IOException ignored) {\n  }\n}", "comment": "this isn ' t what the ri does .", "label": "what"}
{"id": "20728", "raw_code": "private static float computeSimilarity(Lane a,Lane b){\n  int same=0;\n  int diff=0;\n  int firstCoordinate=Math.max(a.getFirstNonGapPosition(),b.getFirstNonGapPosition());\n  int lastCoordinate=Math.min(a.getLastNonGapPosition(),b.getLastNonGapPosition());\n  for (int i=firstCoordinate; i <= lastCoordinate; i++) {\n    char cha=a.charAt(i);\n    char chb=b.charAt(i);\n    if (Character.isLetter(cha) && Character.isLetter(chb)) {\n      if (Character.toLowerCase(cha) == Character.toLowerCase((chb)))       same++;\n else       diff++;\n    }\n  }\n  return Math.max(same > 0 ? 1 : 0,same - 3 * diff);\n}", "comment": "computes the similarity of two sequences", "label": "what"}
{"id": "24325", "raw_code": "private void forceOverflow(){\n  forceOverflow();\n}", "comment": "gratuitous and stupid recursion", "label": "what"}
{"id": "77671", "raw_code": "public int find(String string){\n  if (string == null) {\n    return -1;\n  }\n  for (int i=0; i != m_stringOffsets.length; ++i) {\n    int offset=m_stringOffsets[i];\n    int length=getShort(m_strings,offset);\n    if (length != string.length()) {\n      continue;\n    }\n    int j=0;\n    for (; j != length; ++j) {\n      offset+=2;\n      if (string.charAt(j) != getShort(m_strings,offset)) {\n        break;\n      }\n    }\n    if (j == length) {\n      return i;\n    }\n  }\n  return -1;\n}", "comment": "finds index of the string .", "label": "what"}
{"id": "58377", "raw_code": "private boolean matchStrings(String pattern,String str,boolean caseSensitive){\n  char[] patArr=pattern.toCharArray();\n  char[] strArr=str.toCharArray();\n  int patIdxStart=0;\n  int patIdxEnd=patArr.length - 1;\n  int strIdxStart=0;\n  int strIdxEnd=strArr.length - 1;\n  char ch;\n  boolean containsStar=false;\n  for (  char c : patArr) {\n    if (c == '*') {\n      containsStar=true;\n      break;\n    }\n  }\n  if (!containsStar) {\n    if (patIdxEnd != strIdxEnd) {\n      return false;\n    }\n    for (int i=0; i <= patIdxEnd; i++) {\n      ch=patArr[i];\n      if (ch != '?') {\n        if (different(caseSensitive,ch,strArr[i])) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  if (patIdxEnd == 0) {\n    return true;\n  }\n  while ((ch=patArr[patIdxStart]) != '*' && strIdxStart <= strIdxEnd) {\n    if (ch != '?') {\n      if (different(caseSensitive,ch,strArr[strIdxStart])) {\n        return false;\n      }\n    }\n    patIdxStart++;\n    strIdxStart++;\n  }\n  if (strIdxStart > strIdxEnd) {\n    for (int i=patIdxStart; i <= patIdxEnd; i++) {\n      if (patArr[i] != '*') {\n        return false;\n      }\n    }\n    return true;\n  }\n  while ((ch=patArr[patIdxEnd]) != '*' && strIdxStart <= strIdxEnd) {\n    if (ch != '?') {\n      if (different(caseSensitive,ch,strArr[strIdxEnd])) {\n        return false;\n      }\n    }\n    patIdxEnd--;\n    strIdxEnd--;\n  }\n  if (strIdxStart > strIdxEnd) {\n    for (int i=patIdxStart; i <= patIdxEnd; i++) {\n      if (patArr[i] != '*') {\n        return false;\n      }\n    }\n    return true;\n  }\n  while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd) {\n    int patIdxTmp=-1;\n    for (int i=patIdxStart + 1; i <= patIdxEnd; i++) {\n      if (patArr[i] == '*') {\n        patIdxTmp=i;\n        break;\n      }\n    }\n    if (patIdxTmp == patIdxStart + 1) {\n      patIdxStart++;\n      continue;\n    }\n    int patLength=patIdxTmp - patIdxStart - 1;\n    int strLength=strIdxEnd - strIdxStart + 1;\n    int foundIdx=-1;\n    strLoop:     for (int i=0; i <= strLength - patLength; i++) {\n      for (int j=0; j < patLength; j++) {\n        ch=patArr[patIdxStart + j + 1];\n        if (ch != '?') {\n          if (different(caseSensitive,ch,strArr[strIdxStart + i + j])) {\n            continue strLoop;\n          }\n        }\n      }\n      foundIdx=strIdxStart + i;\n      break;\n    }\n    if (foundIdx == -1) {\n      return false;\n    }\n    patIdxStart=patIdxTmp;\n    strIdxStart=foundIdx + patLength;\n  }\n  for (int i=patIdxStart; i <= patIdxEnd; i++) {\n    if (patArr[i] != '*') {\n      return false;\n    }\n  }\n  return true;\n}", "comment": "tests whether or not a string matches against a pattern .", "label": "what"}
{"id": "62653", "raw_code": "public static List<Double> mergeCoords(List<Double> x,List<Double> y){\n  if (x.size() != y.size())   throw new IllegalArgumentException(\"Sample sizes must be the same for each data applyTransformToDestination.\");\n  List<Double> ret=new ArrayList<>();\n  for (int i=0; i < x.size(); i++) {\n    ret.add(x.get(i));\n    ret.add(y.get(i));\n  }\n  return ret;\n}", "comment": "this will merge the coordinates of the given coordinate system .", "label": "what"}
{"id": "32854", "raw_code": "public static void print(int x){\n  out.print(x);\n  out.flush();\n}", "comment": "prints an integer to standard output and flushes standard output .", "label": "what"}
{"id": "13717", "raw_code": "public void handleButton1Request(RequestInvocationEvent event) throws ModelControlException {\n  try {\n    AuthPropertiesModel model=(AuthPropertiesModel)getModel();\n    Map original=model.getValues();\n    AMPropertySheet ps=(AMPropertySheet)getChild(PROPERTY_ATTRIBUTE);\n    model.setValues(ps.getAttributeValues(original,true,model));\n    setInlineAlertMessage(CCAlert.TYPE_INFO,\"message.information\",\"authentication.profile.updated\");\n  }\n catch (  AMConsoleException a) {\n    setInlineAlertMessage(CCAlert.TYPE_ERROR,\"message.error\",a.getMessage());\n  }\n  forwardTo();\n}", "comment": "handles save button request .", "label": "what"}
{"id": "86328", "raw_code": "private void buildDescriptionPanel(final Composite parent){\n  descriptionLabel=new StyledText(parent,SWT.READ_ONLY);\n  descriptionLabel.setText(\"\");\n  descriptionLabel.setLayoutData(new GridData(GridData.FILL,GridData.FILL,true,true,1,1));\n}", "comment": "build the description panel", "label": "what"}
{"id": "10769", "raw_code": "public HttpMethodClient(){\n  this(5000,10000,3 * 60000);\n}", "comment": "creates a new http method client with default timeouts .", "label": "what"}
{"id": "62310", "raw_code": "String decodeTextValue(byte[] data) throws IOException {\n  boolean isCompressed=((data.length > 1) && (data[0] == TEXT_COMPRESSION_HEADER[0]) && (data[1] == TEXT_COMPRESSION_HEADER[1]));\n  if (isCompressed) {\n    StringBuilder textBuf=new StringBuilder(data.length);\n    int dataStart=TEXT_COMPRESSION_HEADER.length;\n    int dataEnd=dataStart;\n    boolean inCompressedMode=true;\n    while (dataEnd < data.length) {\n      if (data[dataEnd] == (byte)0x00) {\n        decodeTextSegment(data,dataStart,dataEnd,inCompressedMode,textBuf);\n        inCompressedMode=!inCompressedMode;\n        ++dataEnd;\n        dataStart=dataEnd;\n      }\n else {\n        ++dataEnd;\n      }\n    }\n    decodeTextSegment(data,dataStart,dataEnd,inCompressedMode,textBuf);\n    return textBuf.toString();\n  }\n  return decodeUncompressedText(data,getCharset());\n}", "comment": "decodes a compressed or uncompressed text value .", "label": "what"}
{"id": "78093", "raw_code": "public static boolean isZTE(){\n  return sBuildModel.startsWith(\"zte\");\n}", "comment": "whether the stack is running on a zte device", "label": "what"}
{"id": "4832", "raw_code": "static public String normalizeToEncoding(String origString_,Charset encoding_){\n  String normString=origString_;\n  CharsetEncoder encoder=encoding_.newEncoder();\n  if (!encoder.canEncode(origString_)) {\n    final int length=origString_.length();\n    char[] normSeq=new char[(origString_.length())];\n    int charNum=0;\n    for (int offset=0; offset < length; ) {\n      Pair<Character,Integer> replacement=normalizeCodepoint(origString_,encoding_,offset);\n      Character replacedChar=replacement.getFirst();\n      int codepoint=replacement.getSecond();\n      if (null != replacedChar) {\n        normSeq[charNum]=replacedChar;\n        charNum++;\n      }\n      offset+=Character.charCount(codepoint);\n    }\n    normString=new String(normSeq);\n  }\n  return normString;\n}", "comment": "tries to normalize string to specified encoding .", "label": "what"}
{"id": "38154", "raw_code": "public int size(){\n  return m_sets.size();\n}", "comment": "get the number of item sets .", "label": "what"}
{"id": "78383", "raw_code": "public static float approximateLength(float controlPoints[][]){\n  float length=0;\n  for (int i=0; i < controlPoints.length - 1; i++) {\n    float xDif=controlPoints[i + 1][0] - controlPoints[i][0];\n    float yDif=controlPoints[i + 1][1] - controlPoints[i][1];\n    float zDif=controlPoints[i + 1][2] - controlPoints[i][2];\n    length+=Math.sqrt(xDif * xDif + yDif * yDif + zDif * zDif);\n  }\n  return length;\n}", "comment": "compute an approximate length of a bezier curve given the control points .", "label": "what"}
{"id": "49193", "raw_code": "protected int mapDragOperationFromModifiers(MouseEvent e){\n  int mods=e.getModifiersEx();\n  int btns=mods & ButtonMask;\n  if (!(btns == InputEvent.BUTTON1_DOWN_MASK || btns == InputEvent.BUTTON2_DOWN_MASK)) {\n    return DnDConstants.ACTION_NONE;\n  }\n  return SunDragSourceContextPeer.convertModifiersToDropAction(mods,getSourceActions());\n}", "comment": "determine the drop action from the event", "label": "what"}
{"id": "69828", "raw_code": "public void assignThreadForSubscriber(@NonNull Object subscriber){\n  Looper looper=Looper.myLooper();\n  if (looper != null) {\n    mSubscribersDefaultThreads.put(new IdentityWeakReferenceKey<>(subscriber),looper != Looper.getMainLooper() ? new Handler(looper) : mUiThreadHandler);\n  }\n else {\n    mSubscribersDefaultThreads.remove(new IdentityWeakReferenceKey<>(subscriber));\n  }\n}", "comment": "assign current thread to the subscriber object .", "label": "what"}
{"id": "532", "raw_code": "public boolean connect(final String address){\n  if (mBluetoothAdapter == null || address == null) {\n    Log.w(TAG,\"BluetoothAdapter not initialized or unspecified address.\");\n    return false;\n  }\n  if (mBluetoothDeviceAddress != null && address.equals(mBluetoothDeviceAddress) && mBluetoothGatt != null) {\n    Log.d(TAG,\"Trying to use an existing mBluetoothGatt for connection.\");\n    if (mBluetoothGatt.connect()) {\n      mConnectionState=STATE_CONNECTING;\n      return true;\n    }\n else {\n      return false;\n    }\n  }\n  final BluetoothDevice device=mBluetoothAdapter.getRemoteDevice(address);\n  if (device == null) {\n    Log.w(TAG,\"Device not found.  Unable to connect.\");\n    return false;\n  }\n  mBluetoothGatt=device.connectGatt(this,false,mGattCallback);\n  Log.d(TAG,\"Trying to create a new connection.\");\n  mBluetoothDeviceAddress=address;\n  mConnectionState=STATE_CONNECTING;\n  return true;\n}", "comment": "connects to the gatt server hosted on the bluetooth le device .", "label": "what"}
{"id": "38470", "raw_code": "private double normalDens(double x,double mean,double stdDev){\n  double diff=x - mean;\n  return (1 / (m_normConst * stdDev)) * Math.exp(-(diff * diff / (2 * stdDev * stdDev)));\n}", "comment": "density function of normal distribution .", "label": "what"}
{"id": "17348", "raw_code": "private static void drawShape(GL2 gl,Shape s){\n  PathIterator it=s.getPathIterator(new AffineTransform(),shapeFlatness);\n  float[] lastMoveTo=new float[6];\n  float[] f=new float[6];\n  while (!it.isDone()) {\n    int res=it.currentSegment(f);\nswitch (res) {\ncase PathIterator.SEG_CLOSE:\n      GLPanel.V(gl,lastMoveTo[0],lastMoveTo[1]);\n    break;\ncase PathIterator.SEG_MOVETO:\n  GLPanel.V(gl,f[0],f[1]);\nSystem.arraycopy(f,0,lastMoveTo,0,6);\nbreak;\ncase PathIterator.SEG_LINETO:\nGLPanel.V(gl,f[0],f[1]);\nbreak;\ncase PathIterator.SEG_CUBICTO:\nCubicCurve2D c=new CubicCurve2D.Float(lastMoveTo[0],lastMoveTo[1],f[0],f[1],f[2],f[3],f[4],f[5]);\ndrawShape(gl,c);\nbreak;\ndefault :\nthrow new Error(\"Error while drawing AWT shape. \" + \"Path iterator setment not handled:\" + res);\n}\nit.next();\n}\n}", "comment": "draw the given shape on the given opengl object .", "label": "what"}
{"id": "1809", "raw_code": "@Override protected void tearDown() throws NamingException, JMSException {\n  NamingEnumeration<Binding> iter=context.listBindings(\"\");\n  while (iter.hasMore()) {\n    Binding binding=iter.next();\n    Object connFactory=binding.getObject();\n    if (connFactory instanceof ActiveMQConnectionFactory) {\n    }\n  }\n}", "comment": "stops all existing activemqconnectionfactory in context .", "label": "what"}
{"id": "42180", "raw_code": "public final void lazySet(long newValue){\n  unsafe.putOrderedLong(this,valueOffset,newValue);\n}", "comment": "eventually sets to the given value .", "label": "what"}
{"id": "67706", "raw_code": "@Deprecated public static String Collection2String(Collection<?> in,String separator){\n  if (in == null) {\n    return null;\n  }\n  return Iterator2String(in.iterator(),separator);\n}", "comment": "this concatenates the elements of a collection in a string", "label": "what"}
{"id": "29654", "raw_code": "public static byte[] decodeBase64(String base64Str){\n  return DatatypeConverter.parseBase64Binary(base64Str);\n}", "comment": "decodes a base 64 encoded string into byte array .", "label": "what"}
{"id": "40275", "raw_code": "protected void removeAllPremoveDrops(){\n  for (  PremoveInfo info : premoves.toArray(new PremoveInfo[0])) {\n    if (info.isPremoveDrop) {\n      premoves.remove(info);\n    }\n  }\n}", "comment": "removes all of the premove drops from premoves .", "label": "what"}
{"id": "66246", "raw_code": "public static String sayNumber(StringBuffer appendTo,double number) throws IllegalArgumentException {\n  if (number == Double.MIN_VALUE) {\n    throw new IllegalArgumentException(\"Out of range\");\n  }\n  if (number < 0) {\n    appendTo.append(\"Minus \");\n  }\n  double abs=Math.abs(number);\n  if (abs < POWER_THREE) {\n    saySimpleNumber(appendTo,(int)abs);\n  }\n else   if (abs < 2000) {\n    int thousand=(int)(abs % POWER_THREE);\n    appendTo.append(\"Seribu \");\n    saySimpleNumber(appendTo,thousand);\n  }\n else   if (abs < POWER_SIX) {\n    int thousand=(int)(abs % POWER_SIX / POWER_THREE);\n    saySimpleNumber(appendTo,thousand);\n    appendTo.append(\" Ribu\");\n    double remainder=abs - thousand * POWER_THREE;\n    if (remainder > 0) {\n      appendTo.append(' ');\n      sayNumber(appendTo,remainder);\n    }\n  }\n else   if (abs < POWER_NINE) {\n    int million=(int)(abs % POWER_NINE / POWER_SIX);\n    saySimpleNumber(appendTo,million);\n    appendTo.append(\" Juta\");\n    double remainder=abs - million * POWER_SIX;\n    if (remainder > 0) {\n      appendTo.append(' ');\n      sayNumber(appendTo,remainder);\n    }\n  }\n else   if (abs < POWER_TWELVE) {\n    int billion=(int)(abs % POWER_TWELVE / POWER_NINE);\n    saySimpleNumber(appendTo,billion);\n    appendTo.append(\" Milyar\");\n    double remainder=abs - billion * POWER_NINE;\n    if (remainder > 0) {\n      appendTo.append(' ');\n      sayNumber(appendTo,remainder);\n    }\n  }\n else   if (abs < POWER_FIFTEEN) {\n    int trillion=(int)(abs % POWER_FIFTEEN / POWER_TWELVE);\n    saySimpleNumber(appendTo,trillion);\n    appendTo.append(\" Trilyun\");\n    double remainder=abs - trillion * POWER_TWELVE;\n    if (remainder > 0) {\n      appendTo.append(' ');\n      sayNumber(appendTo,remainder);\n    }\n  }\n else {\n    appendTo.append(\"Lebih Dari Seribu Triliun\");\n  }\n  return appendTo.toString();\n}", "comment": "say a number .", "label": "what"}
{"id": "74159", "raw_code": "public void stop(){\n  _throttle.setSpeedSetting(-0.5F);\n  _throttle.setSpeedSetting(0.0F);\n  stopLabel.setIcon(stopIcon);\n  stopLabel.setIconTextGap(_gap);\n  pack();\n}", "comment": "perform an emergency stop", "label": "what"}
{"id": "48227", "raw_code": "public void encode(OutputStream out) throws IOException {\n  DerOutputStream tmp=new DerOutputStream();\n  dnName.encode(tmp);\n  out.write(tmp.toByteArray());\n}", "comment": "encode the name in der form to the stream .", "label": "what"}
{"id": "47252", "raw_code": "private ArrayList<E> toArrayList(){\n  ArrayList<E> list=new ArrayList<E>();\n  for (Node<E> p=first(); p != null; p=succ(p)) {\n    E item=p.item;\n    if (item != null)     list.add(item);\n  }\n  return list;\n}", "comment": "creates an array list and fills it with elements of this list .", "label": "what"}
{"id": "18383", "raw_code": "public boolean remove(HttpConnection connection){\n  TimeValues times=connectionToTimes.remove(connection);\n  if (times == null) {\n    log.warn(\"Removing a connection that never existed!\");\n    return true;\n  }\n else {\n    return System.currentTimeMillis() <= times.timeExpires;\n  }\n}", "comment": "removes the given connection from the list of connections to be closed when idle .", "label": "what"}
{"id": "82831", "raw_code": "private List<String> split(String prefix){\n  List<String> parts=new ArrayList<String>();\n  int bracketCount=0;\n  boolean inquotes=false;\n  int lastIndex=0;\n  for (int i=0; i < prefix.length(); i++) {\n    char c=prefix.charAt(i);\n    if (c == '[') {\n      bracketCount++;\n      continue;\n    }\n else     if (c == '\"') {\n      inquotes=!inquotes;\n      continue;\n    }\n else     if (c == ']') {\n      bracketCount--;\n      if (bracketCount < 0) {\n        throw new RuntimeException(\"Malformed prefix: \" + prefix);\n      }\n      continue;\n    }\n    if (c == ':' && !inquotes && bracketCount == 0) {\n      parts.add(prefix.substring(lastIndex,i));\n      lastIndex=i + 1;\n    }\n  }\n  if (lastIndex < prefix.length() - 1 && !inquotes && bracketCount == 0) {\n    parts.add(prefix.substring(lastIndex));\n  }\n  return parts;\n}", "comment": "given some dot separated prefix , split on the colons that are not within quotes , and not within brackets .", "label": "what"}
{"id": "9670", "raw_code": "public void load(List<PolicyQualifierInfo> policyQualifierInfo){\n  PolicyQualifierInfo[] policyQualifierInfoArray=policyQualifierInfo.toArray(new PolicyQualifierInfo[policyQualifierInfo.size()]);\n  Arrays.sort(policyQualifierInfoArray,new PolicyQualifierInfoComparator());\n  data=new Object[policyQualifierInfoArray.length][1];\n  int i=0;\n  for (  PolicyQualifierInfo policyQualInfo : policyQualifierInfoArray) {\n    data[i][0]=policyQualInfo;\n    i++;\n  }\n  fireTableDataChanged();\n}", "comment": "load the policyqualifierinfotablemodel with policy qualifier info .", "label": "what"}
{"id": "84738", "raw_code": "public double doOperation() throws OperatorFailedException {\n  double logq;\n  final NodeRef root=tree.getRoot();\n  final double oldTreeHeight=tree.getNodeHeight(root);\n  NodeRef i;\n  do {\n    i=tree.getNode(MathUtils.nextInt(tree.getNodeCount()));\n  }\n while (root == i);\n  final NodeRef iP=tree.getParent(i);\n  final NodeRef CiP=getOtherChild(tree,iP,i);\n  final NodeRef PiP=tree.getParent(iP);\n  final double delta=getDelta();\n  final double oldHeight=tree.getNodeHeight(iP);\n  final double newHeight=oldHeight + delta;\n  if (delta > 0) {\n    if (PiP != null && tree.getNodeHeight(PiP) < newHeight) {\n      NodeRef newParent=PiP;\n      NodeRef newChild=iP;\n      while (tree.getNodeHeight(newParent) < newHeight) {\n        newChild=newParent;\n        newParent=tree.getParent(newParent);\n        if (newParent == null)         break;\n      }\n      tree.beginTreeEdit();\n      if (tree.isRoot(newChild)) {\n        tree.removeChild(iP,CiP);\n        tree.removeChild(PiP,iP);\n        tree.addChild(iP,newChild);\n        tree.addChild(PiP,CiP);\n        tree.setRoot(iP);\n        if (tree.hasNodeTraits()) {\n          tree.swapAllTraits(newChild,iP);\n        }\n        if (tree.hasRates()) {\n          final double rootNodeRate=tree.getNodeRate(newChild);\n          tree.setNodeRate(newChild,tree.getNodeRate(iP));\n          tree.setNodeRate(iP,rootNodeRate);\n        }\n      }\n else {\n        tree.removeChild(iP,CiP);\n        tree.removeChild(PiP,iP);\n        tree.removeChild(newParent,newChild);\n        tree.addChild(iP,newChild);\n        tree.addChild(PiP,CiP);\n        tree.addChild(newParent,iP);\n      }\n      tree.setNodeHeight(iP,newHeight);\n      tree.endTreeEdit();\n      final int possibleSources=intersectingEdges(tree,newChild,oldHeight,null);\n      logq=-Math.log(possibleSources);\n    }\n else {\n      tree.setNodeHeight(iP,newHeight);\n      logq=0.0;\n    }\n  }\n else {\n    if (tree.getNodeHeight(i) > newHeight) {\n      return Double.NEGATIVE_INFINITY;\n    }\n    if (tree.getNodeHeight(CiP) > newHeight) {\n      List<NodeRef> newChildren=new ArrayList<NodeRef>();\n      final int possibleDestinations=intersectingEdges(tree,CiP,newHeight,newChildren);\n      if (newChildren.size() == 0) {\n        return Double.NEGATIVE_INFINITY;\n      }\n      final int childIndex=MathUtils.nextInt(newChildren.size());\n      NodeRef newChild=newChildren.get(childIndex);\n      NodeRef newParent=tree.getParent(newChild);\n      tree.beginTreeEdit();\n      if (tree.isRoot(iP)) {\n        tree.removeChild(iP,CiP);\n        tree.removeChild(newParent,newChild);\n        tree.addChild(iP,newChild);\n        tree.addChild(newParent,iP);\n        tree.setRoot(CiP);\n        if (tree.hasNodeTraits()) {\n          tree.swapAllTraits(iP,CiP);\n        }\n        if (tree.hasRates()) {\n          final double rootNodeRate=tree.getNodeRate(iP);\n          tree.setNodeRate(iP,tree.getNodeRate(CiP));\n          tree.setNodeRate(CiP,rootNodeRate);\n        }\n      }\n else {\n        tree.removeChild(iP,CiP);\n        tree.removeChild(PiP,iP);\n        tree.removeChild(newParent,newChild);\n        tree.addChild(iP,newChild);\n        tree.addChild(PiP,CiP);\n        tree.addChild(newParent,iP);\n      }\n      tree.setNodeHeight(iP,newHeight);\n      tree.endTreeEdit();\n      logq=Math.log(possibleDestinations);\n    }\n else {\n      tree.setNodeHeight(iP,newHeight);\n      logq=0.0;\n    }\n  }\n  if (swapInRandomRate) {\n    final NodeRef j=tree.getNode(MathUtils.nextInt(tree.getNodeCount()));\n    if (j != i) {\n      final double tmp=tree.getNodeRate(i);\n      tree.setNodeRate(i,tree.getNodeRate(j));\n      tree.setNodeRate(j,tmp);\n    }\n  }\n  if (swapInRandomTrait) {\n    final NodeRef j=tree.getNode(MathUtils.nextInt(tree.getNodeCount()));\n    if (j != i) {\n      tree.swapAllTraits(i,j);\n    }\n  }\n  if (logq == Double.NEGATIVE_INFINITY)   throw new OperatorFailedException(\"invalid slide\");\n  if (scaledDirichletBranches) {\n    if (oldTreeHeight != tree.getNodeHeight(tree.getRoot()))     throw new OperatorFailedException(\"Temporarily disabled.\");\n  }\n  return logq;\n}", "comment": "do a probablistic subtree slide move .", "label": "what"}
{"id": "56609", "raw_code": "default Filterable<T> removeAll(final T... values){\n  return removeAll(Stream.of(values));\n}", "comment": "remove all supplied elements from this filterable", "label": "what"}
{"id": "26282", "raw_code": "public static Map<String,Object> createContentAssocMethod(DispatchContext dctx,Map<String,? extends Object> rcontext) throws GenericServiceException, GenericEntityException {\n  Map<String,Object> context=UtilMisc.makeMapWritable(rcontext);\n  List<String> targetOperationList=ContentWorker.prepTargetOperationList(context,\"_CREATE\");\n  List<String> contentPurposeList=ContentWorker.prepContentPurposeList(context);\n  context.put(\"targetOperationList\",targetOperationList);\n  context.put(\"contentPurposeList\",contentPurposeList);\n  Locale locale=(Locale)context.get(\"locale\");\n  Delegator delegator=dctx.getDelegator();\n  LocalDispatcher dispatcher=dctx.getDispatcher();\n  Map<String,Object> result=FastMap.newInstance();\n  String contentIdFrom=(String)context.get(\"contentIdFrom\");\n  String contentIdTo=(String)context.get(\"contentIdTo\");\n  String contentId=(String)context.get(\"contentId\");\n  int contentIdCount=0;\n  if (UtilValidate.isNotEmpty(contentIdFrom))   contentIdCount++;\n  if (UtilValidate.isNotEmpty(contentIdTo))   contentIdCount++;\n  if (UtilValidate.isNotEmpty(contentId))   contentIdCount++;\n  if (contentIdCount < 2) {\n    Debug.logError(\"Not 2 out of ContentId/To/From.\",\"ContentServices\");\n    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"ContentCreateContentAssocMethodError\",locale));\n  }\n  if (UtilValidate.isNotEmpty(contentIdFrom)) {\n    if (UtilValidate.isEmpty(contentIdTo))     contentIdTo=contentId;\n  }\n  if (UtilValidate.isNotEmpty(contentIdTo)) {\n    if (UtilValidate.isEmpty(contentIdFrom))     contentIdFrom=contentId;\n  }\n  GenericValue contentAssoc=delegator.makeValue(\"ContentAssoc\",FastMap.newInstance());\n  contentAssoc.put(\"contentId\",contentIdFrom);\n  contentAssoc.put(\"contentIdTo\",contentIdTo);\n  contentAssoc.put(\"contentAssocTypeId\",context.get(\"contentAssocTypeId\"));\n  contentAssoc.put(\"contentAssocPredicateId\",context.get(\"contentAssocPredicateIdFrom\"));\n  contentAssoc.put(\"dataSourceId\",context.get(\"dataSourceId\"));\n  Timestamp fromDate=(Timestamp)context.get(\"fromDate\");\n  if (fromDate == null) {\n    contentAssoc.put(\"fromDate\",UtilDateTime.nowTimestamp());\n  }\n else {\n    contentAssoc.put(\"fromDate\",fromDate);\n  }\n  Timestamp thruDate=(Timestamp)context.get(\"thruDate\");\n  if (thruDate == null) {\n    contentAssoc.put(\"thruDate\",null);\n  }\n else {\n    contentAssoc.put(\"thruDate\",thruDate);\n  }\n  contentAssoc.put(\"sequenceNum\",context.get(\"sequenceNum\"));\n  contentAssoc.put(\"mapKey\",context.get(\"mapKey\"));\n  String upperCoordinateStr=(String)context.get(\"upperCoordinate\");\n  if (UtilValidate.isEmpty(upperCoordinateStr)) {\n    contentAssoc.put(\"upperCoordinate\",null);\n  }\n else {\n    contentAssoc.put(\"upperCoordinate\",upperCoordinateStr);\n  }\n  String leftCoordinateStr=(String)context.get(\"leftCoordinate\");\n  if (UtilValidate.isEmpty(leftCoordinateStr)) {\n    contentAssoc.put(\"leftCoordinate\",null);\n  }\n else {\n    contentAssoc.put(\"leftCoordinate\",leftCoordinateStr);\n  }\n  GenericValue userLogin=(GenericValue)context.get(\"userLogin\");\n  String userLoginId=(String)userLogin.get(\"userLoginId\");\n  String createdByUserLogin=userLoginId;\n  String lastModifiedByUserLogin=userLoginId;\n  Timestamp createdDate=UtilDateTime.nowTimestamp();\n  Timestamp lastModifiedDate=UtilDateTime.nowTimestamp();\n  contentAssoc.put(\"createdByUserLogin\",createdByUserLogin);\n  contentAssoc.put(\"lastModifiedByUserLogin\",lastModifiedByUserLogin);\n  contentAssoc.put(\"createdDate\",createdDate);\n  contentAssoc.put(\"lastModifiedDate\",lastModifiedDate);\n  Map<String,Object> serviceInMap=FastMap.newInstance();\n  String permissionStatus=null;\n  serviceInMap.put(\"userLogin\",context.get(\"userLogin\"));\n  serviceInMap.put(\"targetOperationList\",targetOperationList);\n  serviceInMap.put(\"contentPurposeList\",contentPurposeList);\n  serviceInMap.put(\"entityOperation\",context.get(\"entityOperation\"));\n  serviceInMap.put(\"contentAssocPredicateId\",context.get(\"contentAssocPredicateId\"));\n  serviceInMap.put(\"contentIdTo\",contentIdTo);\n  serviceInMap.put(\"contentIdFrom\",contentIdFrom);\n  serviceInMap.put(\"statusId\",context.get(\"statusId\"));\n  serviceInMap.put(\"privilegeEnumId\",context.get(\"privilegeEnumId\"));\n  serviceInMap.put(\"roleTypeList\",context.get(\"roleTypeList\"));\n  serviceInMap.put(\"displayFailCond\",context.get(\"displayFailCond\"));\n  Map<String,Object> permResults=null;\n  permResults=dispatcher.runSync(\"checkAssocPermission\",serviceInMap);\n  permissionStatus=(String)permResults.get(\"permissionStatus\");\n  if (permissionStatus != null && permissionStatus.equals(\"granted\")) {\n    contentAssoc.create();\n  }\n else {\n    String errorMsg=(String)permResults.get(ModelService.ERROR_MESSAGE);\n    result.put(ModelService.ERROR_MESSAGE,errorMsg);\n    return ServiceUtil.returnFailure(errorMsg);\n  }\n  result.put(\"contentIdTo\",contentIdTo);\n  result.put(\"contentIdFrom\",contentIdFrom);\n  result.put(\"fromDate\",contentAssoc.get(\"fromDate\"));\n  result.put(\"contentAssocTypeId\",contentAssoc.get(\"contentAssocTypeId\"));\n  return result;\n}", "comment": "create a contentassoc method .", "label": "what"}
{"id": "60768", "raw_code": "void removeAt(final int removeIndex){\n  final Object[] items=this.items;\n  if (removeIndex == takeIndex) {\n    items[takeIndex]=null;\n    takeIndex=inc(takeIndex);\n    count--;\n    if (itrs != null)     itrs.elementDequeued();\n  }\n else {\n    final int putIndex=this.putIndex;\n    for (int i=removeIndex; ; ) {\n      int next=inc(i);\n      if (next != putIndex) {\n        items[i]=items[next];\n        i=next;\n      }\n else {\n        items[i]=null;\n        this.putIndex=i;\n        break;\n      }\n    }\n    count--;\n    if (itrs != null)     itrs.removedAt(removeIndex);\n  }\n  notFull.signal();\n}", "comment": "deletes item at array index removeindex .", "label": "what"}
{"id": "70064", "raw_code": "private void saveAndClose(boolean save){\n  content.setEnabled(false);\n  if (timer != null) {\n    timer.cancel();\n    timer=null;\n  }\n  if (timerNextSync != null) {\n    timerNextSync.cancel();\n    timerNextSync=null;\n  }\n  if (save) {\n    Log.d(LOG_TAG,\"saveAndClose with SAVE\");\n    saveData(null);\n  }\n else {\n    Log.d(LOG_TAG,\"saveAndClose WITHOUT save\");\n  }\n  Intent data=new Intent();\n  data.setAction(Intent.ACTION_VIEW);\n  data.putExtra(PARAM_NOTE,note);\n  data.putExtra(PARAM_NOTE_POSITION,notePosition);\n  setResult(RESULT_OK,data);\n  finish();\n}", "comment": "saves all changes and closes the activity", "label": "what"}
{"id": "28496", "raw_code": "public static <T>void blockingSubscribePrint(Observable<T> observable,String name){\n  CountDownLatch latch=new CountDownLatch(1);\n  subscribePrint(observable.finallyDo(null),name);\n  try {\n    latch.await();\n  }\n catch (  InterruptedException e) {\n  }\n}", "comment": "subscribes to an observable , printing all its emissions .", "label": "what"}
{"id": "23101", "raw_code": "private static final boolean copyHeader(String name,String fromReq,StringBuffer buf){\n  int start=fromReq.indexOf(name);\n  if (start != -1) {\n    int end=fromReq.indexOf(\"\\r\\n\",start);\n    if (end != -1) {\n      buf.append(fromReq.subSequence(start - 2,end));\n      return true;\n    }\n  }\n  return false;\n}", "comment": "copies a header from a request", "label": "what"}
{"id": "23582", "raw_code": "public StatArchiveReader(String archiveName) throws IOException {\n  this(new File[]{new File(archiveName)},null,false);\n}", "comment": "creates a statarchivereader that will read the named archive file .", "label": "what"}
{"id": "68272", "raw_code": "private static void initAdbSocketAddr(){\n  try {\n    sAdbServerPort=getAdbServerPort();\n    InetAddress hostAddr=InetAddress.getByName(DEFAULT_ADB_HOST);\n    sSocketAddr=new InetSocketAddress(hostAddr,sAdbServerPort);\n  }\n catch (  UnknownHostException e) {\n  }\n}", "comment": "instantiates ssocketaddr with the address of the host ' s adb process .", "label": "what"}
{"id": "3670", "raw_code": "public int read(long fileOffset,byte[] buffer,int offset,int length) throws IOException {\n  _file.seek(fileOffset);\n  return _file.read(buffer,offset,length);\n}", "comment": "reads a block from a given location .", "label": "what"}
{"id": "55127", "raw_code": "private boolean matchesAnyTag(String tagName){\n  return tagNames.contains(tagName);\n}", "comment": "tries to match tagname to known tag names .", "label": "what"}
{"id": "24580", "raw_code": "private static int labelEnd(String s){\n  int colonIndex=s.indexOf(\":\");\n  int semicolonIndex=s.indexOf(\";\");\n  if ((semicolonIndex == -1) || (colonIndex < semicolonIndex)) {\n    return colonIndex;\n  }\n else {\n    return -1;\n  }\n}", "comment": "determines the position in the string where a label that might be contained ends", "label": "what"}
{"id": "77788", "raw_code": "public static boolean equals(byte[][] field1,byte[][] field2){\n  int index1=0;\n  int length1=field1 == null ? 0 : field1.length;\n  int index2=0;\n  int length2=field2 == null ? 0 : field2.length;\n  while (true) {\n    while (index1 < length1 && field1[index1] == null) {\n      index1++;\n    }\n    while (index2 < length2 && field2[index2] == null) {\n      index2++;\n    }\n    boolean atEndOf1=index1 >= length1;\n    boolean atEndOf2=index2 >= length2;\n    if (atEndOf1 && atEndOf2) {\n      return true;\n    }\n else     if (atEndOf1 != atEndOf2) {\n      return false;\n    }\n else     if (!Arrays.equals(field1[index1],field2[index2])) {\n      return false;\n    }\n    index1++;\n    index2++;\n  }\n}", "comment": "checks repeated bytes field equality .", "label": "what"}
{"id": "55490", "raw_code": "public void update(List<Race> races){\n  if (currentRace == null) {\n    return;\n  }\n  if (races.contains(currentRace)) {\n    setRace(races.get(races.indexOf(currentRace)));\n  }\n}", "comment": "give this list of races , whereas the dialog picks out the one it currently has open ( if present ) .", "label": "what"}
{"id": "65226", "raw_code": "public boolean required(){\n  return _parameterMetadata.contains(Metadata.REQUIRED);\n}", "comment": "indicates whether the parameter is required .", "label": "what"}
{"id": "73105", "raw_code": "protected void sendDataToReceiver(ResultReceiver receiver,Intent originalIntent,Serializable data){\n  if (receiver != null && data != null) {\n    Bundle bundle=new Bundle();\n    bundle.putParcelable(ServiceReceiver.EXTRA_ORIGINAL_INTENT,originalIntent);\n    bundle.putSerializable(ServiceReceiver.EXTRA_DATA,data);\n    receiver.send(ServiceReceiver.STATUS_DATA,bundle);\n  }\n}", "comment": "sends data to the receiver , usually the creator of the service intent .", "label": "what"}
{"id": "20925", "raw_code": "private static Object matchOrReplace(Context cx,Scriptable scope,Scriptable thisObj,Object[] args,RegExpImpl reImpl,GlobData data,boolean forceFlat){\n  NativeRegExp re;\n  String str=ScriptRuntime.toString(thisObj);\n  data.str=str;\n  Scriptable topScope=ScriptableObject.getTopLevelScope(scope);\n  if (args.length == 0) {\n    Object compiled=NativeRegExp.compileRE(cx,\"\",\"\",false);\n    re=new NativeRegExp(topScope,compiled);\n  }\n else   if (args[0] instanceof NativeRegExp) {\n    re=(NativeRegExp)args[0];\n  }\n else {\n    String src=ScriptRuntime.toString(args[0]);\n    String opt;\n    if (data.optarg < args.length) {\n      args[0]=src;\n      opt=ScriptRuntime.toString(args[data.optarg]);\n    }\n else {\n      opt=null;\n    }\n    Object compiled=NativeRegExp.compileRE(cx,src,opt,forceFlat);\n    re=new NativeRegExp(topScope,compiled);\n  }\n  data.global=(re.getFlags() & NativeRegExp.JSREG_GLOB) != 0;\n  int[] indexp={0};\n  Object result=null;\n  if (data.mode == RA_SEARCH) {\n    result=re.executeRegExp(cx,scope,reImpl,str,indexp,NativeRegExp.TEST);\n    if (result != null && result.equals(Boolean.TRUE))     result=Integer.valueOf(reImpl.leftContext.length);\n else     result=Integer.valueOf(-1);\n  }\n else   if (data.global) {\n    re.lastIndex=0;\n    for (int count=0; indexp[0] <= str.length(); count++) {\n      result=re.executeRegExp(cx,scope,reImpl,str,indexp,NativeRegExp.TEST);\n      if (result == null || !result.equals(Boolean.TRUE))       break;\n      if (data.mode == RA_MATCH) {\n        match_glob(data,cx,scope,count,reImpl);\n      }\n else {\n        if (data.mode != RA_REPLACE)         Kit.codeBug();\n        SubString lastMatch=reImpl.lastMatch;\n        int leftIndex=data.leftIndex;\n        int leftlen=lastMatch.index - leftIndex;\n        data.leftIndex=lastMatch.index + lastMatch.length;\n        replace_glob(data,cx,scope,reImpl,leftIndex,leftlen);\n      }\n      if (reImpl.lastMatch.length == 0) {\n        if (indexp[0] == str.length())         break;\n        indexp[0]++;\n      }\n    }\n  }\n else {\n    result=re.executeRegExp(cx,scope,reImpl,str,indexp,((data.mode == RA_REPLACE) ? NativeRegExp.TEST : NativeRegExp.MATCH));\n  }\n  return result;\n}", "comment": "analog of c match _ or _ replace .", "label": "what"}
{"id": "12507", "raw_code": "public void print(PrintWriter output,int w,int d){\n  DecimalFormat format=new DecimalFormat();\n  format.setDecimalFormatSymbols(new DecimalFormatSymbols(Locale.US));\n  format.setMinimumIntegerDigits(1);\n  format.setMaximumFractionDigits(d);\n  format.setMinimumFractionDigits(d);\n  format.setGroupingUsed(false);\n  print(output,format,w + 2);\n}", "comment": "print the matrix to the output stream .", "label": "what"}
{"id": "81726", "raw_code": "public static <E>Set<E> newSetFromMap(Map<E,Boolean> map){\n  if (map.isEmpty()) {\n    return new SetFromMap<E>(map);\n  }\n  throw new IllegalArgumentException();\n}", "comment": "answers a set backed by a map .", "label": "what"}
{"id": "43475", "raw_code": "public void removeBiomeType(BiomeDictionary.Type type){\n  ArrayList<BiomeGenBase> entryList=new ArrayList<BiomeGenBase>();\n  entryList.addAll(Arrays.asList(BiomeDictionary.getBiomesForType(type)));\n  for (  BiomeGenBase biome : entryList) {\n    Iterator<BiomeEntry> iterator=allowedBiomes.iterator();\n    while (iterator.hasNext()) {\n      if (BiomeDictionary.areBiomesEquivalent(iterator.next().biome,biome))       iterator.remove();\n    }\n  }\n}", "comment": "removes all biomes of this type from the list of biomes allowed to generate", "label": "what"}
{"id": "70987", "raw_code": "protected void defineLabels(){\n  labelsValues=calcLabels();\n  if (handleValues)   labels=getLabelsFromValues();\n else   labels=getLabelsFromData();\n  nLabels=labels.size();\n}", "comment": "defines what will be the axis labels", "label": "what"}
{"id": "52491", "raw_code": "public static Set<Interval> mergeIntervalToSet(Set<Interval> intervals,Interval intervalToMerge){\n  LinkedHashSet<Interval> copyOfOriginalSet=new LinkedHashSet<>(intervals);\n  copyOfOriginalSet.add(intervalToMerge);\n  return mergeIntervalSet(copyOfOriginalSet);\n}", "comment": "merge an interval into the given interval set .", "label": "what"}
{"id": "8128", "raw_code": "public static String dropWhile(GString self,@ClosureParams(value=FromString.class,conflictResolutionStrategy=PickFirstResolver.class,options={\"String\",\"Character\"}) Closure condition){\n  return dropWhile(self.toString(),condition);\n}", "comment": "a gstring variant of the equivalent charsequence method .", "label": "what"}
{"id": "32967", "raw_code": "public void printText(String text){\n  view.print(text,text.endsWith(\"\\r\"));\n  for (  ActionDelegate actionDelegate : actionDelegates) {\n    actionDelegate.onConsoleOutput(this);\n  }\n}", "comment": "print text in the console .", "label": "what"}
{"id": "36256", "raw_code": "@Override public void trim(){\n  if (counter < x.length) {\n    int[] y=new int[counter];\n    System.arraycopy(x,0,y,0,counter);\n    x=y;\n    resizeValues(counter);\n  }\n}", "comment": "trims the data row to the number of actually used elements .", "label": "what"}
{"id": "2275", "raw_code": "void assertThreadsStayAlive(long millis,Thread... threads){\n  try {\n    delay(millis);\n    for (    Thread thread : threads)     assertTrue(thread.isAlive());\n  }\n catch (  InterruptedException fail) {\n    threadFail(\"Unexpected InterruptedException\");\n  }\n}", "comment": "checks that the threads do not terminate within the given millisecond delay .", "label": "what"}
{"id": "29757", "raw_code": "public AbstractWorkerManager(String id){\n  _id=id;\n  _status=new WorkerManagerStatus();\n  setExecutionMode(EXECUTION_MODE.NON_SERIAL);\n  setupExecutor();\n}", "comment": "set the identifier of the process", "label": "what"}
{"id": "50334", "raw_code": "@OnMessage public void onMessage(String message,Session session){\n  callInternal(\"onMessage\",session,message);\n}", "comment": "on message received handler", "label": "what"}
{"id": "61364", "raw_code": "public void write(final char chars[],final int start,final int length) throws java.io.IOException {\n  if (m_writer != null)   m_writer.write(chars,start,length);\n  int lengthx3=(length << 1) + length;\n  if (lengthx3 >= buf_length) {\n    flushBuffer();\n    setBufferSize(2 * lengthx3);\n  }\n  if (lengthx3 > buf_length - count) {\n    flushBuffer();\n  }\n  final int n=length + start;\n  for (int i=start; i < n; i++) {\n    final char c=chars[i];\n    if (c < 0x80)     buf[count++]=(byte)(c);\n else     if (c < 0x800) {\n      buf[count++]=(byte)(0xc0 + (c >> 6));\n      buf[count++]=(byte)(0x80 + (c & 0x3f));\n    }\n else {\n      buf[count++]=(byte)(0xe0 + (c >> 12));\n      buf[count++]=(byte)(0x80 + ((c >> 6) & 0x3f));\n      buf[count++]=(byte)(0x80 + (c & 0x3f));\n    }\n  }\n}", "comment": "write a portion of an array of characters .", "label": "what"}
{"id": "85587", "raw_code": "public boolean isRunning(){\n  return mThread != null && mThread.isAlive();\n}", "comment": "indicates whether the server is currently running .", "label": "what"}
{"id": "11967", "raw_code": "public static byte[] unwrapVCF(File sourceFile,File tmpFile) throws FileNotFoundException, IOException {\n  ZipArchiveInputStream in=null;\n  FileOutputStream fos=null;\n  String hmacString=null;\n  try {\n    in=new ZipArchiveInputStream(new FileInputStream(sourceFile));\n    ArchiveEntry entry;\n    in.getNextEntry();\n    fos=new FileOutputStream(tmpFile);\n    IOUtils.copy(in,fos);\n    entry=in.getNextEntry();\n    hmacString=entry.getName();\n    return Utils.hexToBytes(hmacString);\n  }\n catch (  StringIndexOutOfBoundsException e) {\n    logger.error(\"Error parsing hmac: \" + hmacString + \" is no valid hex String\",e);\n    throw e;\n  }\ncatch (  Exception e) {\n    logger.error(\"Error unwrapping VCF file\",e);\n    throw e;\n  }\n finally {\n    if (fos != null) {\n      fos.flush();\n      fos.close();\n    }\n    if (in != null) {\n      in.close();\n    }\n  }\n}", "comment": "method extracts the vcf file stored within the zipped import file to the given destination file .", "label": "what"}
{"id": "50487", "raw_code": "public boolean registerUser(String username,String password,String uri) throws DataAccessException {\n  if (checkUsernameExists(username)) {\n    return false;\n  }\n  storeUser(username,password,uri);\n  return true;\n}", "comment": "attempts to register the username , password combination .", "label": "what"}
{"id": "68215", "raw_code": "public SELECT(@NonNull String... columns){\n  if (columns == null) {\n    throw new NullPointerException(\"SELECT: Columns are null\");\n  }\n  if (columns.length == 0)   throw new IllegalArgumentException(\"At least on column is required\");\n  StringBuilder builder=new StringBuilder(\"SELECT \");\n  for (int i=0; i < columns.length; i++) {\n    builder.append(columns[i]);\n    if (i != (columns.length - 1))     builder.append(\", \");\n  }\n  sql=builder.toString();\n}", "comment": "create a select column1 , column2 , . . .", "label": "what"}
{"id": "26348", "raw_code": "public static Set<String> toStringSet(TemplateSequenceModel seqModel) throws TemplateModelException {\n  Set<String> set=new HashSet<String>();\n  for (int i=0; i < seqModel.size(); i++) {\n    set.add(getAsStringNonEscaping((TemplateScalarModel)seqModel.get(i)));\n  }\n  return set;\n}", "comment": "to string set .", "label": "what"}
{"id": "34199", "raw_code": "public JKSSignatureToken(InputStream ksStream,String ksPassword){\n  try {\n    keyStore=KeyStore.getInstance(KeyStore.getDefaultType());\n    password=(ksPassword == null) ? null : ksPassword.toCharArray();\n    keyStore.load(ksStream,password);\n  }\n catch (  Exception e) {\n    throw new DSSException(e);\n  }\n finally {\n    if (ksStream != null) {\n      try {\n        ksStream.close();\n      }\n catch (      IOException e) {\n        logger.error(e.getMessage(),e);\n      }\n    }\n  }\n}", "comment": "creates a signaturetokenconnection with the provided inputstream to java keystore file and password .", "label": "what"}
{"id": "47850", "raw_code": "protected void writeLocation(String loc) throws IOException {\n  hadAnnotations|=(loc != null);\n  locOut.writeObject(loc);\n}", "comment": "overrides marshaloutputstream . writelocation implementation to write annotations to the location stream .", "label": "what"}
{"id": "431", "raw_code": "protected int __offset(int vtable_offset){\n  int vtable=bb_pos - bb.getInt(bb_pos);\n  return vtable_offset < bb.getShort(vtable) ? bb.getShort(vtable + vtable_offset) : 0;\n}", "comment": "look up a field in the vtable .", "label": "what"}
{"id": "21284", "raw_code": "public static String selectText(XPathExpression expr,Node context){\n  try {\n    return (String)expr.evaluate(context,XPathConstants.STRING);\n  }\n catch (  XPathExpressionException e) {\n    throw new XmlException(e);\n  }\n}", "comment": "evaluates the xpath expression as text .", "label": "what"}
{"id": "25324", "raw_code": "public static int calculateRMSLevel(short[] audioData,int numframes){\n  long lSum=0;\n  int numread=0;\n  for (  short s : audioData) {\n    lSum=lSum + s;\n    numread++;\n    if (numread == numframes)     break;\n  }\n  double dAvg=lSum / numframes;\n  double sumMeanSquare=0d;\n  numread=0;\n  for (  short anAudioData : audioData) {\n    sumMeanSquare=sumMeanSquare + Math.pow(anAudioData - dAvg,2d);\n    numread++;\n    if (numread == numframes)     break;\n  }\n  double averageMeanSquare=sumMeanSquare / numframes;\n  return (int)(Math.pow(averageMeanSquare,0.5d) + 0.5);\n}", "comment": "calculates the rms audio level from the provided short sample extract", "label": "what"}
{"id": "39994", "raw_code": "private void initProgram(){\n  glUseProgram(this.program);\n  vec3ArrayUniform=glGetUniformLocation(this.program,\"cols\");\n  chosenUniform=glGetUniformLocation(this.program,\"chosen\");\n  glUseProgram(0);\n}", "comment": "initialize the shader program .", "label": "what"}
{"id": "48376", "raw_code": "public boolean engineContainsAlias(String alias){\n  return entries.containsKey(alias.toLowerCase(Locale.ENGLISH));\n}", "comment": "checks if the given alias exists in this keystore .", "label": "what"}
{"id": "17395", "raw_code": "public void invertSelectedRelations(){\n  ISelection selection=viewer.getSelection();\n  if (!(selection instanceof IStructuredSelection)) {\n    return;\n  }\n  IStructuredSelection structuredSelection=(IStructuredSelection)selection;\n  Collection<Relation> inverse=computeInverseRelations(getTableRelations(),structuredSelection);\n  StructuredSelection nextSelection=new StructuredSelection(inverse.toArray());\n  viewer.setSelection(nextSelection,true);\n}", "comment": "invert the set of relations selected in the table .", "label": "what"}
{"id": "76386", "raw_code": "public void bindKeyStore(final KeyStoreService keyStoreService){\n  this.keyStore=keyStoreService;\n}", "comment": "binds the keystore to the truststore service .", "label": "what"}
{"id": "29056", "raw_code": "private static boolean isMerge(InstructionHandle handle){\n  if (handle.hasTargeters()) {\n    InstructionTargeter[] targeterList=handle.getTargeters();\n    for (    InstructionTargeter targeter : targeterList) {\n      if (targeter instanceof BranchInstruction) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "comment": "determine whether or not the given instruction is a control flow merge .", "label": "what"}
{"id": "45259", "raw_code": "private boolean isOutsideDocElem(){\n  return (null == m_docFrag) && m_elemStack.size() == 0 && (null == m_currentNode || m_currentNode.getNodeType() == Node.DOCUMENT_NODE);\n}", "comment": "tell if the current node is outside the document element .", "label": "what"}
{"id": "14484", "raw_code": "public ThreadPool(String name,int poolSize){\n  this.poolSize=poolSize;\n  this.poolName=name;\n  taskList=new LinkedList<Runnable>();\n  threads=new WorkerThread[poolSize];\n  createThreads();\n}", "comment": "constructs a thread pool with given parameters .", "label": "what"}
{"id": "43728", "raw_code": "public void clear(){\n  this.normal=null;\n  this.depth=0;\n}", "comment": "clears the penetration information .", "label": "what"}
{"id": "77519", "raw_code": "ListBasedTokenStream(AttributeSource attributeSource,List<AttributeSource> tokens){\n  super(attributeSource.getAttributeFactory());\n  this.tokens=tokens;\n  addAttributes(attributeSource);\n}", "comment": "creates a new listbasedtokenstream which uses the given tokens as its token source .", "label": "what"}
{"id": "47866", "raw_code": "@SuppressWarnings(\"rawtypes\") protected Class resolveClass(ObjectStreamClass classDesc) throws IOException, ClassNotFoundException {\n  String cname=classDesc.getName();\n  return ClassFinder.resolveClass(cname,this.loader);\n}", "comment": "use the given classloader rather than using the system class", "label": "what"}
{"id": "26541", "raw_code": "public Map<String,Object> makeValid(Map<String,? extends Object> source,String mode){\n  return makeValid(source,mode,true,null);\n}", "comment": "creates a new map based from an existing map with just valid parameters .", "label": "what"}
{"id": "43891", "raw_code": "public static int find(byte[] a,int fromIndex,int toIndex,byte[] key){\n  int result=-1;\n  int sublen=key.length;\n  int maxpos, first, sp=0;\n  maxpos=Math.min(toIndex,a.length) - sublen;\n  for (first=fromIndex; sp != sublen && first <= maxpos; first++) {\n    first=find(a,first,maxpos,key[0]);\n    if ((first < 0) || (first > maxpos)) {\n      break;\n    }\n    for (sp=1; sp < sublen; sp++) {\n      if (a[first + sp] != key[sp]) {\n        sp=sublen;\n      }\n    }\n  }\n  if (sublen == 0) {\n    result=0;\n  }\n else   if (sp == sublen) {\n    result=(first - 1);\n  }\n  return result;\n}", "comment": "look for a sequence of bytes in a byte array .", "label": "what"}
{"id": "138", "raw_code": "public Tasker addTask(Task task){\n  tasks.add(task);\n  lastAddedTask=task;\n  return this;\n}", "comment": "add a new task", "label": "what"}
{"id": "40017", "raw_code": "private void initComputeProgram(){\n  glUseProgram(computeProgram);\n  IntBuffer workGroupSize=BufferUtils.createIntBuffer(3);\n  glGetProgramiv(computeProgram,GL_COMPUTE_WORK_GROUP_SIZE,workGroupSize);\n  workGroupSizeX=workGroupSize.get(0);\n  workGroupSizeY=workGroupSize.get(1);\n  timeUniform=glGetUniformLocation(computeProgram,\"time\");\n  blendFactorUniform=glGetUniformLocation(computeProgram,\"blendFactor\");\n  bounceCountUniform=glGetUniformLocation(computeProgram,\"bounceCount\");\n  IntBuffer params=BufferUtils.createIntBuffer(1);\n  int loc=glGetUniformLocation(computeProgram,\"framebufferImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  framebufferImageBinding=params.get(0);\n  loc=glGetUniformLocation(computeProgram,\"worldPositionImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  worldPositionImageBinding=params.get(0);\n  loc=glGetUniformLocation(computeProgram,\"worldNormalImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  worldNormalImageBinding=params.get(0);\n  glUseProgram(0);\n}", "comment": "initialize the compute shader .", "label": "what"}
{"id": "41051", "raw_code": "public void sort(){\n  throwIfImmutable();\n  if (!sorted) {\n    Arrays.sort(values,0,size);\n    sorted=true;\n  }\n}", "comment": "sorts the elements in the list in - place .", "label": "what"}
{"id": "30457", "raw_code": "public static Object objectFromByteBuffer(byte[] buffer) throws Exception {\n  if (buffer == null)   return null;\n  ByteArrayInputStream inStream=new ByteArrayInputStream(buffer);\n  ObjectInputStream in=new ObjectInputStreamExt(inStream);\n  Object retval=in.readObject();\n  in.close();\n  return retval;\n}", "comment": "creates an object from a byte buffer .", "label": "what"}
{"id": "60395", "raw_code": "public DefaultActionGroup(@NotNull AnAction... actions){\n  this(Arrays.asList(actions));\n}", "comment": "creates an action group containing the specified actions .", "label": "what"}
{"id": "63666", "raw_code": "public NumericLiteral(Object x){\n  if (x instanceof Number) {\n    m_number=(Number)x;\n    m_type=TypeLib.getPrimitiveType(m_number.getClass());\n  }\n else {\n    throw new IllegalArgumentException(\"Invalid type!\");\n  }\n}", "comment": "create a new numericliteral .", "label": "what"}
{"id": "469", "raw_code": "@SuppressLint(\"DrawAllocation\") @Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){\n  int widthMode=MeasureSpec.getMode(widthMeasureSpec);\n  int heightMode=MeasureSpec.getMode(heightMeasureSpec);\n  int maxWidth=MeasureSpec.getSize(widthMeasureSpec);\n  int maxHeight=MeasureSpec.getSize(heightMeasureSpec);\n  if (widthMode == MeasureSpec.UNSPECIFIED)   maxWidth=Integer.MAX_VALUE;\n  if (heightMode == MeasureSpec.UNSPECIFIED)   maxHeight=Integer.MAX_VALUE;\n  int paddingLeft=getPaddingLeft();\n  int paddingTop=getPaddingTop();\n  int paddingRight=getPaddingRight();\n  int paddingBottom=getPaddingBottom();\n  int maxRightBound=maxWidth - paddingRight;\n  int maxBottomBound=maxHeight - paddingBottom;\n  int left;\n  int top;\n  int right;\n  int bottom;\n  int rightBound=paddingLeft;\n  int maxRightNoPadding=rightBound;\n  int bottomBound;\n  int lastMaxBottom=paddingTop;\n  int maxBottom=lastMaxBottom;\n  int childWidth;\n  int childHeight;\n  int lineStartIndex=0;\n  int lineEndIndex;\n  rectList.clear();\n  int childCount=getChildCount();\n  for (int index=0; index < childCount; index++) {\n    final View child=getChildAt(index);\n    child.measure(MeasureSpec.UNSPECIFIED,MeasureSpec.UNSPECIFIED);\n    if (child.getVisibility() == View.GONE)     continue;\n    final LayoutParams lp=(LayoutParams)child.getLayoutParams();\n    childWidth=child.getMeasuredWidth();\n    childHeight=child.getMeasuredHeight();\n    left=rightBound + lp.leftMargin;\n    right=left + childWidth;\n    rightBound=right + lp.rightMargin;\n    if (rightBound > maxRightBound) {\n      lineEndIndex=index;\n      adjustBaseLine(maxBottom - lastMaxBottom,lineStartIndex,lineEndIndex);\n      if (maxBottom >= maxBottomBound)       break;\n      if (lineEndIndex == lineStartIndex) {\n        child.measure(MeasureSpec.makeMeasureSpec(maxWidth - paddingLeft - paddingRight- lp.leftMargin- lp.rightMargin,MeasureSpec.AT_MOST),MeasureSpec.UNSPECIFIED);\n        childWidth=child.getMeasuredWidth();\n        childHeight=child.getMeasuredHeight();\n      }\n      left=paddingLeft + lp.leftMargin;\n      right=left + childWidth;\n      rightBound=right + lp.rightMargin;\n      lastMaxBottom=maxBottom;\n      top=lastMaxBottom + lp.topMargin;\n      bottom=top + childHeight;\n      bottomBound=bottom + lp.bottomMargin;\n      lineStartIndex=index;\n    }\n else {\n      top=lastMaxBottom + lp.topMargin;\n      bottom=top + childHeight;\n      bottomBound=bottom + lp.bottomMargin;\n    }\n    if (rightBound > maxRightNoPadding)     maxRightNoPadding=rightBound;\n    if (bottomBound > maxBottom)     maxBottom=bottomBound;\n    Rect rect=new Rect();\n    rect.left=left;\n    rect.top=top;\n    rect.right=right;\n    rect.bottom=bottom;\n    rectList.add(rect);\n  }\n  adjustBaseLine(maxBottom - lastMaxBottom,lineStartIndex,rectList.size());\n  int measuredWidth;\n  int measuredHeight;\n  if (widthMode == MeasureSpec.EXACTLY)   measuredWidth=maxWidth;\n else   measuredWidth=maxRightNoPadding + paddingRight;\n  if (heightMode == MeasureSpec.EXACTLY)   measuredHeight=maxHeight;\n else {\n    measuredHeight=maxBottom + paddingBottom;\n    if (heightMode == MeasureSpec.AT_MOST)     measuredHeight=measuredHeight > maxHeight ? maxHeight : measuredHeight;\n  }\n  setMeasuredDimension(measuredWidth,measuredHeight);\n}", "comment": "each row or line at least show one child horizontal only show child can show or partly show in parent", "label": "what"}
{"id": "57578", "raw_code": "private final boolean compareAndSetHead(Node update){\n  return unsafe.compareAndSwapObject(this,headOffset,null,update);\n}", "comment": "cas head field .", "label": "what"}
{"id": "971", "raw_code": "private void ensureBufferCapacity(int desiredCapacity){\n  int capacity=pixelBuffer.length;\n  while (capacity < desiredCapacity) {\n    capacity*=2;\n  }\n  if (capacity > pixelBuffer.length) {\n    pixelBuffer=new byte[capacity];\n  }\n}", "comment": "grow the pixel buffer if necessary .", "label": "what"}
{"id": "84416", "raw_code": "protected Set<DependencyKind> removeDependency(Node n){\n  Set<DependencyKind> removedKinds=new HashSet<>();\n  for (  DependencyKind dk : DependencyKind.values()) {\n    Set<Node> depsByKind=deps.get(dk);\n    if (depsByKind == null)     continue;\n    if (depsByKind.remove(n)) {\n      removedKinds.add(dk);\n    }\n  }\n  return removedKinds;\n}", "comment": "remove a dependency , regardless of its kind .", "label": "what"}
{"id": "56214", "raw_code": "public static <K,V>ConcurrentMap<K,V> newConcurrentMapWithAggressiveConcurrency(){\n  return new ConcurrentHashMap<>(16,0.75f,aggressiveConcurrencyLevel);\n}", "comment": "creates a new chm with an aggressive concurrency level , aimed at high concurrent update rate long living maps .", "label": "what"}
{"id": "55632", "raw_code": "protected char skipAllWhitespace(Reader r) throws IOException {\n  char c;\n  do {\n    c=(char)r.read();\n  }\n while (Character.isWhitespace(c) && c != (char)-1);\n  return c;\n}", "comment": "skips all consecutive whitespace characters from reader", "label": "what"}
{"id": "85904", "raw_code": "public Map<String,String> parse(final String str,char separator){\n  if (str == null) {\n    return new HashMap<>();\n  }\n  return parse(str.toCharArray(),separator);\n}", "comment": "extracts a map of name / value pairs from the given string .", "label": "what"}
{"id": "81631", "raw_code": "public PriorityQueue(Collection<? extends E> c){\n  if (c instanceof PriorityQueue) {\n    getFromPriorityQueue((PriorityQueue<? extends E>)c);\n  }\n else   if (c instanceof SortedSet) {\n    getFromSortedSet((SortedSet<? extends E>)c);\n  }\n else {\n    initSize(c);\n    addAll(c);\n  }\n}", "comment": "constructs a priority queue that contains the elements of a collection .", "label": "what"}
{"id": "15391", "raw_code": "private String resourceId(){\n  return subSchemaPath.isEmpty() ? null : lastSchemaNodeName();\n}", "comment": "gets the resource id .", "label": "what"}
{"id": "30547", "raw_code": "public static void performSaveAs(String schemaPrefixFileName,String selFilePath,ContainerConfig containerConfig){\n  try {\n    File fileWithDefaultConfiguration=createContainerSchemaFile(schemaPrefixFileName,selFilePath);\n    updateFile(containerConfig,fileWithDefaultConfiguration.getPath(),schemaPrefixFileName);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}", "comment": "save content of containerconfig instance into xml file ( schema or configuration ) .", "label": "what"}
{"id": "32850", "raw_code": "public static void print(boolean x){\n  out.print(x);\n  out.flush();\n}", "comment": "prints a boolean to standard output and flushes standard output .", "label": "what"}
{"id": "70652", "raw_code": "@Override public void close(){\n  try {\n    if (connection != null) {\n      connection.close();\n    }\n  }\n catch (  SQLException e) {\n    e.printStackTrace();\n  }\n}", "comment": "close the jdbc connection", "label": "what"}
{"id": "71282", "raw_code": "public Version addQualifier(String qualifier){\n  List<String> newQualifiers=new ArrayList<>(this.qualifiers);\n  newQualifiers.add(qualifier);\n  return new Version(major,minor,patch,newQualifiers.toArray(new String[newQualifiers.size()]));\n}", "comment": "creates a new version object from the current one , but append a new qualifier to it .", "label": "what"}
{"id": "62984", "raw_code": "public int loadSigned16(int addr){\n  return loadSigned16(addr,AccessSource.CODE);\n}", "comment": "perform a 16bit load where the sign extended result fills the return value", "label": "what"}
{"id": "67956", "raw_code": "public static void unregisterBaggageHandler(BaggageHandler handler){\n  handlers.remove(handler);\n}", "comment": "remove an existing baggage handler that was previously registered .", "label": "what"}
{"id": "7936", "raw_code": "public DefaultHeatMapDataset(int xSamples,int ySamples,double minX,double maxX,double minY,double maxY){\n  if (xSamples < 1) {\n    throw new IllegalArgumentException(\"Requires 'xSamples' > 0\");\n  }\n  if (ySamples < 1) {\n    throw new IllegalArgumentException(\"Requires 'ySamples' > 0\");\n  }\n  if (Double.isInfinite(minX) || Double.isNaN(minX)) {\n    throw new IllegalArgumentException(\"'minX' cannot be INF or NaN.\");\n  }\n  if (Double.isInfinite(maxX) || Double.isNaN(maxX)) {\n    throw new IllegalArgumentException(\"'maxX' cannot be INF or NaN.\");\n  }\n  if (Double.isInfinite(minY) || Double.isNaN(minY)) {\n    throw new IllegalArgumentException(\"'minY' cannot be INF or NaN.\");\n  }\n  if (Double.isInfinite(maxY) || Double.isNaN(maxY)) {\n    throw new IllegalArgumentException(\"'maxY' cannot be INF or NaN.\");\n  }\n  this.xSamples=xSamples;\n  this.ySamples=ySamples;\n  this.minX=minX;\n  this.maxX=maxX;\n  this.minY=minY;\n  this.maxY=maxY;\n  this.zValues=new double[xSamples][];\n  for (int x=0; x < xSamples; x++) {\n    this.zValues[x]=new double[ySamples];\n  }\n}", "comment": "creates a new dataset where all the z - values are initially 0 .", "label": "what"}
{"id": "7207", "raw_code": "public static void assertEqualsAnyOrder(EventBean[][] expected,EventBean[][] actual){\n  if (compareArraySize(expected,actual)) {\n    return;\n  }\n  int numMatches=0;\n  boolean[] foundReceived=new boolean[actual.length];\n  for (  EventBean[] expectedObject : expected) {\n    boolean found=false;\n    for (int i=0; i < actual.length; i++) {\n      if (foundReceived[i]) {\n        continue;\n      }\n      boolean match=compareEqualsExactOrder(actual[i],expectedObject);\n      if (match) {\n        found=true;\n        numMatches++;\n        foundReceived[i]=true;\n        break;\n      }\n    }\n    if (!found) {\n      log.error(\".assertEqualsAnyOrder Not found in received results is expected=\" + Arrays.toString(expectedObject));\n      log.error(\".assertEqualsAnyOrder received=\" + Arrays.toString(actual));\n    }\n    ScopeTestHelper.assertTrue(found);\n  }\n  ScopeTestHelper.assertEquals(numMatches,expected.length);\n}", "comment": "compare two 2 - dimensional event arrays .", "label": "what"}
{"id": "44318", "raw_code": "private void collectText(){\n  if (textNodeCount > 1) {\n    firstTextNode.setText(textBuffer.toString());\n  }\n  textNodeCount=0;\n}", "comment": "this method breaks concatenation mode .", "label": "what"}
{"id": "52961", "raw_code": "protected static double calcQ_i(double f,double lambda){\n  return lambda * Math.exp(-lambda * f);\n}", "comment": "compute q _ i ( exponential distribution , inliers )", "label": "what"}
{"id": "5921", "raw_code": "void flush(){\n  printStream.flush();\n}", "comment": "flush any io to disk .", "label": "what"}
{"id": "3481", "raw_code": "public CharBuffer delete(int start,int end){\n  int length=length();\n  if (start < 0 || end < start || length < start)   throw new StringIndexOutOfBoundsException();\n  end=Math.min(length,end);\n  int tail=length - end;\n  char[] buffer=buffer();\n  for (int i=0; i < tail; i++) {\n    buffer[start + i]=buffer[end + i];\n  }\n  length(length - (end - start));\n  return this;\n}", "comment": "deletes characters from the buffer .", "label": "what"}
{"id": "55316", "raw_code": "public void addListener(SpeedrunsLiveListener listener){\n  listeners.add(listener);\n}", "comment": "adds a listener that receives the data and error messages .", "label": "what"}
{"id": "56248", "raw_code": "public static boolean containsWhitespace(CharSequence str){\n  if (!hasLength(str)) {\n    return false;\n  }\n  int strLen=str.length();\n  for (int i=0; i < strLen; i++) {\n    if (Character.isWhitespace(str.charAt(i))) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "check whether the given charsequence contains any whitespace characters .", "label": "what"}
{"id": "15247", "raw_code": "public void validate(Set setData) throws ValidationException {\n  for (Iterator iter=setData.iterator(); iter.hasNext(); ) {\n    performValidation((String)iter.next());\n  }\n}", "comment": "performs validation on a set of string .", "label": "what"}
{"id": "44942", "raw_code": "public String add(Object... values){\n  double result=0;\n  for (int i=0; i < values.length; i++) {\n    result+=FunctionHandler.getDouble(values[i]);\n  }\n  return Double.toString(result);\n}", "comment": "adds all values together", "label": "what"}
{"id": "75869", "raw_code": "public List<String> listMyDBs(String owner,boolean restricted){\n  Connection conn=null;\n  try {\n    conn=getConnection();\n    return listMyDBs(conn,owner,restricted);\n  }\n catch (  Exception ex) {\n    logger.log(Level.SEVERE,\"Exception\",ex);\n  }\n finally {\n    DBUtils.close(conn);\n  }\n  return null;\n}", "comment": "list database groups the specific user has provided passwords", "label": "what"}
{"id": "81141", "raw_code": "public int compare(Object o1,Object o2){\n  return comparator.compare(o1,o2);\n}", "comment": "call the comparator on the column", "label": "what"}
{"id": "42611", "raw_code": "public static void w(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_WARNING) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.w(tag,msg);\n}", "comment": "send a warning log message", "label": "what"}
{"id": "17762", "raw_code": "private int processPollFds() throws IOException {\n  if (pollFds.get(0).revents == POLLIN) {\n    byte[] buffer=new byte[8];\n    while (IoBridge.read(wakeupIn,buffer,0,1) > 0) {\n    }\n  }\n  int readyKeyCount=0;\n  for (int i=1; i < pollFds.size(); ++i) {\n    StructPollfd pollFd=pollFds.get(i);\n    if (pollFd.revents == 0) {\n      continue;\n    }\n    if (pollFd.fd == null) {\n      break;\n    }\n    SelectionKeyImpl key=(SelectionKeyImpl)pollFd.userData;\n    pollFd.fd=null;\n    pollFd.userData=null;\n    int ops=key.interestOpsNoCheck();\n    int selectedOps=0;\n    if ((pollFd.revents & POLLHUP) != 0) {\n      selectedOps|=ops;\n    }\n    if ((pollFd.revents & POLLIN) != 0) {\n      selectedOps|=ops & (OP_ACCEPT | OP_READ);\n    }\n    if ((pollFd.revents & POLLOUT) != 0) {\n      if (key.isConnected()) {\n        selectedOps|=ops & OP_WRITE;\n      }\n else {\n        selectedOps|=ops & OP_CONNECT;\n      }\n    }\n    if (selectedOps != 0) {\n      boolean wasSelected=mutableSelectedKeys.contains(key);\n      if (wasSelected && key.readyOps() != selectedOps) {\n        key.setReadyOps(key.readyOps() | selectedOps);\n        ++readyKeyCount;\n      }\n else       if (!wasSelected) {\n        key.setReadyOps(selectedOps);\n        mutableSelectedKeys.add(key);\n        ++readyKeyCount;\n      }\n    }\n  }\n  return readyKeyCount;\n}", "comment": "updates the key ready ops and selected key set .", "label": "what"}
{"id": "7401", "raw_code": "@Override public void actionPerformed(ActionEvent event){\n  String command=event.getActionCommand();\n  if (command.equals(\"SelectLabelFont\")) {\n    attemptLabelFontSelection();\n  }\n else   if (command.equals(\"SelectLabelPaint\")) {\n    attemptModifyLabelPaint();\n  }\n else   if (command.equals(\"SelectTickLabelFont\")) {\n    attemptTickLabelFontSelection();\n  }\n}", "comment": "handles user interaction with the property panel .", "label": "what"}
{"id": "14402", "raw_code": "public static void upgradeServerInstance(SSOToken ssoToken,String instanceName,String instanceId,Map<String,String> upgradedValues) throws SMSException, SSOException, ConfigurationException, IOException {\n  ServiceConfig sc=getServerConfig(ssoToken,instanceName);\n  if (sc != null) {\n    Map map=sc.getAttributes();\n    map.remove(ATTR_PARENT_SITE_ID);\n    Set newSet=getPropertiesSet(upgradedValues);\n    map.put(ATTR_SERVER_CONFIG,newSet);\n    sc.setAttributes(map);\n  }\n else {\n    throw new ConfigurationException(\"Unable to upgrade server \" + \"default properties: no properties found!\");\n  }\n}", "comment": "upgrades a server instance .", "label": "what"}
{"id": "15493", "raw_code": "public static <T>T instance(Class<T> clazz){\n  try {\n    return clazz.newInstance();\n  }\n catch (  InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e);\n  }\n}", "comment": "creates a new instance of the class represented by the given class object", "label": "what"}
{"id": "24598", "raw_code": "private void pop(final String desc){\n  char c=desc.charAt(0);\n  if (c == '(') {\n    pop((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);\n  }\n else   if (c == 'J' || c == 'D') {\n    pop(2);\n  }\n else {\n    pop(1);\n  }\n}", "comment": "pops a type from the output frame stack .", "label": "what"}
{"id": "23288", "raw_code": "public GenericSipMsrpSession createMsrpSession(ContactId contact,String featureTag,String[] acceptTypes,String[] acceptWrappedTypes){\n  if (sLogger.isActivated()) {\n    sLogger.info(\"Initiate a MSRP session with contact \" + contact);\n  }\n  return new OriginatingSipMsrpSession(this,contact,featureTag,mRcsSettings,System.currentTimeMillis(),mContactManager,acceptTypes,acceptWrappedTypes);\n}", "comment": "initiate a msrp session", "label": "what"}
{"id": "77712", "raw_code": "public ForumPostConfig create(ForumPostConfig config){\n  config.addCredentials(this);\n  String xml=POST(this.url + \"/create-forum-post\",config.toXML());\n  Element root=parse(xml);\n  if (root == null) {\n    return null;\n  }\n  try {\n    ForumPostConfig post=new ForumPostConfig();\n    post.parseXML(root);\n    return post;\n  }\n catch (  Exception exception) {\n    this.exception=SDKException.parseFailure(exception);\n    throw this.exception;\n  }\n}", "comment": "create a new forum post .", "label": "what"}
{"id": "84705", "raw_code": "protected void drawMark(Graphics2D g2,float x,float y,Color color){\n  Rectangle2D bounds=mark.getBounds2D();\n  float w=(float)bounds.getWidth();\n  float h=(float)bounds.getHeight();\n  x=x - (w / 2);\n  y=y - (h / 2);\n  g2.translate(x,y);\n  if (color == null) {\n    if (markFillPaint != null) {\n      g2.setPaint(markFillPaint);\n      g2.fill(mark);\n    }\n  }\n else {\n    g2.setPaint(color);\n    g2.fill(mark);\n  }\n  g2.setPaint(markPaint);\n  g2.setStroke(markStroke);\n  g2.draw(mark);\n  g2.translate(-x,-y);\n  Rectangle2D rect=new Rectangle2D.Float(x,y,w,h);\n  markBounds.add(rect);\n}", "comment": "draw a mark transforming co - ordinates to each axis", "label": "what"}
{"id": "11471", "raw_code": "public void componentResized(ComponentEvent e){\n  if (logger.isLoggable(Level.FINE)) {\n    logger.fine(\"Size changed: \" + getWidth() + \" x \"+ getHeight());\n  }\n  projection.setWidth(getWidth());\n  projection.setHeight(getHeight());\n  fireProjectionChanged();\n}", "comment": "componentlistener interface method .", "label": "what"}
{"id": "55041", "raw_code": "public void write(byte[] b,int offset,int length) throws IOException {\n  if (entry.getMethod() == DEFLATED) {\n    if (length > 0) {\n      if (!def.finished()) {\n        def.setInput(b,offset,length);\n        while (!def.needsInput()) {\n          deflate();\n        }\n      }\n    }\n  }\n else {\n    writeOut(b,offset,length);\n    written+=length;\n  }\n  crc.update(b,offset,length);\n}", "comment": "writes bytes to zip entry .", "label": "what"}
{"id": "40851", "raw_code": "public void updatePoint(float x,float y){\n  if (Math.sqrt(x * x + y * y) > 1.5)   if (listener != null) {\n    listener.onAngleChangedListener(getAngle(x,-y));\n  }\n}", "comment": "update the gravity point only if a the gravity vector is longer than the threshold", "label": "what"}
{"id": "62215", "raw_code": "HttpRequestWrapper(HttpServletRequest request){\n  super(request);\n}", "comment": "constructs a request object wrapping the given request .", "label": "what"}
{"id": "31771", "raw_code": "private Set<String> primaryKeys(PreparedStatement stmt,String owner,String tbl) throws SQLException {\n  Set<String> pkCols=new HashSet<>();\n  stmt.setString(1,owner);\n  stmt.setString(2,tbl);\n  try (ResultSet pkRs=stmt.executeQuery()){\n    while (pkRs.next())     pkCols.add(pkRs.getString(1));\n  }\n   return pkCols;\n}", "comment": "retrieve primary key columns .", "label": "what"}
{"id": "20500", "raw_code": "private void scheduledEnqueueSend(){\n  schedulerQueueSize.decrementAndGet();\n  scheduled.set(false);\n  enqueueSendWithErrorLogging();\n}", "comment": "decrements the scheduled queue counter and enqueues the request .", "label": "what"}
{"id": "8184", "raw_code": "public static String join(char[] self,String separator){\n  StringBuilder buffer=new StringBuilder();\n  boolean first=true;\n  if (separator == null)   separator=\"\";\n  for (  char next : self) {\n    if (first) {\n      first=false;\n    }\n else {\n      buffer.append(separator);\n    }\n    buffer.append(next);\n  }\n  return buffer.toString();\n}", "comment": "concatenates the string representation of each items in this array , with the given string as a separator between each item .", "label": "what"}
{"id": "40031", "raw_code": "private void initComputeProgram(){\n  glUseProgram(computeProgram);\n  IntBuffer workGroupSize=BufferUtils.createIntBuffer(3);\n  glGetProgramiv(computeProgram,GL_COMPUTE_WORK_GROUP_SIZE,workGroupSize);\n  workGroupSizeX=workGroupSize.get(0);\n  workGroupSizeY=workGroupSize.get(1);\n  timeUniform=glGetUniformLocation(computeProgram,\"time\");\n  blendFactorUniform=glGetUniformLocation(computeProgram,\"blendFactor\");\n  lightRadiusUniform=glGetUniformLocation(computeProgram,\"lightRadius\");\n  IntBuffer props=BufferUtils.createIntBuffer(1);\n  IntBuffer params=BufferUtils.createIntBuffer(1);\n  props.put(0,GL_BUFFER_BINDING);\n  int objectsResourceIndex=glGetProgramResourceIndex(computeProgram,GL_SHADER_STORAGE_BLOCK,\"Objects\");\n  glGetProgramResourceiv(computeProgram,GL_SHADER_STORAGE_BLOCK,objectsResourceIndex,props,null,params);\n  objectsSsboBinding=params.get(0);\n  int trianglesResourceIndex=glGetProgramResourceIndex(computeProgram,GL_SHADER_STORAGE_BLOCK,\"Triangles\");\n  glGetProgramResourceiv(computeProgram,GL_SHADER_STORAGE_BLOCK,trianglesResourceIndex,props,null,params);\n  trianglesSsboBinding=params.get(0);\n  int loc=glGetUniformLocation(computeProgram,\"framebufferImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  framebufferImageBinding=params.get(0);\n  loc=glGetUniformLocation(computeProgram,\"worldPositionImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  worldPositionImageBinding=params.get(0);\n  loc=glGetUniformLocation(computeProgram,\"worldNormalImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  worldNormalImageBinding=params.get(0);\n  glUseProgram(0);\n}", "comment": "initialize the compute shader .", "label": "what"}
{"id": "24438", "raw_code": "public boolean ifTaskCompletedSuccessOrFailureFromResponse(ResponseOnSingeRequest myResponse){\n  boolean isCompleted=false;\n  try {\n    if (myResponse == null || myResponse.isFailObtainResponse()) {\n      return isCompleted;\n    }\n    String responseBody=myResponse.getResponseBody();\n    if (responseBody.matches(successRegex) || responseBody.matches(failureRegex)) {\n      isCompleted=true;\n    }\n  }\n catch (  Exception t) {\n    logger.error(\"fail\" + t);\n  }\n  return isCompleted;\n}", "comment": "if task completed success or failure from response .", "label": "what"}
{"id": "37670", "raw_code": "public void centerHorizontal(ArrayList<Integer> nodes){\n  if (m_bNeedsUndoAction) {\n    addUndoAction(new centerHorizontalAction(nodes));\n  }\n  int nMinY=-1;\n  int nMaxY=-1;\n  for (int iNode=0; iNode < nodes.size(); iNode++) {\n    int nY=getPositionY(nodes.get(iNode));\n    if (nY < nMinY || iNode == 0) {\n      nMinY=nY;\n    }\n    if (nY > nMaxY || iNode == 0) {\n      nMaxY=nY;\n    }\n  }\n  for (int iNode=0; iNode < nodes.size(); iNode++) {\n    int nNode=nodes.get(iNode);\n    m_nPositionY.set(nNode,(nMinY + nMaxY) / 2);\n  }\n}", "comment": "center set of nodes half way between left and right most node in the list", "label": "what"}
{"id": "30037", "raw_code": "public void onRestoreInstanceState(Bundle savedInstanceState){\n  mSelectedPositions.addAll(savedInstanceState.getIntegerArrayList(TAG));\n  Log.d(TAG,\"Restore selection \" + mSelectedPositions);\n}", "comment": "restores the previous state of the selection on the items .", "label": "what"}
{"id": "7863", "raw_code": "public Hour(int hour,Day day){\n  ParamChecks.nullNotPermitted(day,\"day\");\n  this.hour=(byte)hour;\n  this.day=day;\n  peg(Calendar.getInstance());\n}", "comment": "constructs a new hour .", "label": "what"}
{"id": "38551", "raw_code": "public void undo(){\n  if (--m_tempUndoIndex < 0) {\n    m_tempUndoIndex=m_tempUndoFiles.length - 1;\n  }\n  if (m_tempUndoFiles[m_tempUndoIndex] != null) {\n    AbstractFileLoader loader=ConverterUtils.getLoaderForFile(m_tempUndoFiles[m_tempUndoIndex]);\n    try {\n      loader.setFile(m_tempUndoFiles[m_tempUndoIndex]);\n      setInstancesFromFile(loader);\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n      m_Log.logMessage(e.toString());\n      JOptionPane.showMessageDialog(PreprocessPanel.this,\"Cannot perform undo operation!\\n\" + e.toString(),\"Undo\",JOptionPane.ERROR_MESSAGE);\n    }\n    m_tempUndoFiles[m_tempUndoIndex]=null;\n  }\n  int temp=m_tempUndoIndex - 1;\n  if (temp < 0) {\n    temp=m_tempUndoFiles.length - 1;\n  }\n  m_UndoBut.setEnabled(m_tempUndoFiles[temp] != null);\n}", "comment": "reverts to the last backed up version of the dataset .", "label": "what"}
{"id": "54565", "raw_code": "public static boolean isConnectedUsingWifi(){\n  Context context=FeApp.getAppContext();\n  ConnectivityManager cm=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);\n  NetworkInfo ni=cm.getActiveNetworkInfo();\n  return ni != null && ni.isConnected() == true && ni.getType() == ConnectivityManager.TYPE_WIFI;\n}", "comment": "checks to see if we are connected using wifi", "label": "what"}
{"id": "77481", "raw_code": "public void close() throws IOException {\n  if (writer != null)   writer.flushBuffer();\n}", "comment": "done with this responsewriter . . .", "label": "what"}
{"id": "36203", "raw_code": "public Process(final File file,final ProgressListener progressListener) throws IOException, XMLException {\n  this.processLocation=new FileProcessLocation(file);\n  initContext();\n  Reader in=null;\n  try {\n    in=new InputStreamReader(new FileInputStream(file),\"UTF-8\");\n    readProcess(in,progressListener);\n  }\n catch (  IOException e) {\n    throw e;\n  }\n finally {\n    if (in != null) {\n      in.close();\n    }\n  }\n}", "comment": "creates a new process from the given process file .", "label": "what"}
{"id": "70959", "raw_code": "public static String extractMusicIDFromMediaID(@NonNull String mediaID){\n  int pos=mediaID.indexOf(LEAF_SEPARATOR);\n  if (pos >= 0) {\n    return mediaID.substring(pos + 1);\n  }\n  return null;\n}", "comment": "extracts unique musicid from the mediaid .", "label": "what"}
{"id": "45730", "raw_code": "public Object[] buildParameters(Object[] firstParameters,Method method,Class<? extends Annotation> annotationType){\n  int parametersLength=method.getParameterTypes().length;\n  if (firstParameters.length > 0 && parametersLength < 1) {\n    throw new RepositoryMethodException(String.format(\"Method with %s annotation should have at least one parameter.\",annotationType));\n  }\n  int parametersToResolve=parametersLength - firstParameters.length;\n  Object[] additionalParameters=new Object[parametersToResolve];\n  for (int i=firstParameters.length; i < parametersLength; i++) {\n    additionalParameters[i - firstParameters.length]=parameterProvider.provide(method,i);\n  }\n  return concatenate(firstParameters,additionalParameters);\n}", "comment": "build a list of parameters that can be provided to a method .", "label": "what"}
{"id": "64717", "raw_code": "@Override public boolean contains(S2Cell cell){\n  return contains(cell.id());\n}", "comment": "this is a fast operation ( logarithmic in the size of the cell union ) .", "label": "what"}
{"id": "9276", "raw_code": "public SimplexNoiseGenerator(Random rand){\n  super(rand);\n  offsetW=rand.nextDouble() * 256;\n}", "comment": "creates a seeded simplex noise generator with the given random", "label": "what"}
{"id": "83743", "raw_code": "public void readData(DataInput din) throws IOException {\n  din.readShort();\n  count=din.readUnsignedShort();\n  registers=new InputRegister[count];\n  for (int i=0; i < count; i++) {\n    registers[i]=new SimpleInputRegister(din.readShort());\n  }\n}", "comment": "readdata - - input the modbus message from din .", "label": "what"}
{"id": "24490", "raw_code": "public void adjustIndentation(int delta){\n  if (delta < 0) {\n    indentationLevel=Math.max(0,indentationLevel + delta);\n  }\n else {\n    indentationLevel+=delta;\n  }\n}", "comment": "adjusts the current indentation level of this log stream .", "label": "what"}
{"id": "53747", "raw_code": "public int capacity(){\n  return capacity.get();\n}", "comment": "retrieves the maximum capacity of the map .", "label": "what"}
{"id": "69506", "raw_code": "protected static token do_code_string() throws java.io.IOException {\n  StringBuffer result=new StringBuffer();\n  advance();\n  advance();\n  while (!(next_char == ':' && next_char2 == '}')) {\n    if (next_char == EOF_CHAR) {\n      emit_error(\"Specification file ends inside a code string\");\n      break;\n    }\n    result.append(new Character((char)next_char));\n    advance();\n  }\n  advance();\n  advance();\n  return new str_token(sym.CODE_STRING,result.toString());\n}", "comment": "swallow up a code string .", "label": "what"}
{"id": "25030", "raw_code": "private void loadConfigurationFromJvmParameters(){\n  String repositoryProperty=System.getProperty(REPOSITORY_PROPERTY);\n  if (null != repositoryProperty) {\n    String[] repositoryIpHost=repositoryProperty.split(\":\");\n    if (repositoryIpHost.length == 2) {\n      String repositoryIp=repositoryIpHost[0];\n      String repositoryPort=repositoryIpHost[1];\n      if (StringUtils.isNotBlank(repositoryIp) && StringUtils.isNotBlank(repositoryPort)) {\n        log.info(\"Repository information found in the JVM parameters: IP=\" + repositoryIp + \" Port=\"+ repositoryPort);\n        try {\n          int port=Integer.parseInt(repositoryPort);\n          setRepository(repositoryIp,port);\n        }\n catch (        Exception e) {\n          log.warn(\"Repository could not be defined from the data in the JVM parameters\",e);\n        }\n      }\n    }\n  }\n  String agentName=System.getProperty(AGENT_NAME_PROPERTY);\n  if (StringUtils.isNotBlank(agentName)) {\n    try {\n      log.info(\"Agent name found in the JVM parameters: AgentName=\" + agentName);\n      setAgentName(agentName);\n    }\n catch (    Exception e) {\n      log.warn(\"Agent name could not be defined from the data in the JVM parameters\",e);\n    }\n  }\n else {\n    try {\n      setAgentName(DEFAULT_AGENT_NAME);\n    }\n catch (    StorageException e) {\n      log.warn(\"Agent name could not be defined from default agent name\",e);\n    }\n  }\n}", "comment": "checks if the jvm parameters have the repository and agent information .", "label": "what"}
{"id": "45872", "raw_code": "public static Element createElement(Document doc,String tag,String nsURI,String prefix){\n  String qName=(prefix == null || prefix.length() == 0) ? tag : prefix + \":\" + tag;\n  return doc.createElementNS(nsURI,qName);\n}", "comment": "creates an element in the specified namespace , with the specified tag and namespace prefix .", "label": "what"}
{"id": "350", "raw_code": "public static void modifyFile(File file,Function<String,String> modifier) throws IOException {\n  String content=new String(Files.toByteArray(file),StandardCharsets.UTF_8);\n  String result=modifier.apply(content);\n  Files.write(result.getBytes(StandardCharsets.UTF_8),file);\n}", "comment": "modifies the given file in place .", "label": "what"}
{"id": "43018", "raw_code": "private void state2() throws IOException {\n  int[] selectionIds=readList(new File(filePrefix + \"sel\"));\n  int[] archivedIds=readList(new File(filePrefix + \"arc\"));\n  int[] variationIds=new int[lambda];\n  if (selectionIds.length != mu) {\n    throw new IOException(\"invalid selection length\");\n  }\n  updatePopulation(archivedIds);\n  clearFile(new File(filePrefix + \"sel\"));\n  clearFile(new File(filePrefix + \"arc\"));\n  List<Solution> offspring=new ArrayList<Solution>();\n  for (int i=0; i < mu; i+=variation.getArity()) {\n    Solution[] parents=new Solution[variation.getArity()];\n    for (int j=0; j < variation.getArity(); j++) {\n      parents[j]=solutions.get(selectionIds[i + j]);\n    }\n    offspring.addAll(Arrays.asList(variation.evolve(parents)));\n  }\n  if (offspring.size() != lambda) {\n    throw new IOException(\"invalid variation length\");\n  }\n  evaluateAll(offspring);\n  for (int i=0; i < lambda; i++) {\n    variationIds[i]=addToPopulation(offspring.get(i));\n  }\n  writePopulation(new File(filePrefix + \"var\"),variationIds);\n}", "comment": "the commands to execute when in state 2 .", "label": "what"}
{"id": "74405", "raw_code": "protected boolean removeTurntable(LayoutTurntable o){\n  if (!noWarnTurntable) {\n    int selectedValue=JOptionPane.showOptionDialog(this,rb.getString(\"Question4r\"),Bundle.getMessage(\"WarningTitle\"),JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,new Object[]{Bundle.getMessage(\"ButtonYes\"),Bundle.getMessage(\"ButtonNo\"),rb.getString(\"ButtonYesPlus\")},Bundle.getMessage(\"ButtonNo\"));\n    if (selectedValue == 1) {\n      return (false);\n    }\n    if (selectedValue == 2) {\n      noWarnTurntable=true;\n    }\n  }\n  if (selectedObject == o) {\n    selectedObject=null;\n  }\n  if (prevSelectedObject == o) {\n    prevSelectedObject=null;\n  }\n  for (int j=0; j < o.getNumberRays(); j++) {\n    TrackSegment t=o.getRayConnectOrdered(j);\n    if (t != null) {\n      substituteAnchor(o.getRayCoordsIndexed(j),o,t);\n    }\n  }\n  for (int i=0; i < turntableList.size(); i++) {\n    LayoutTurntable lx=turntableList.get(i);\n    if (lx == o) {\n      turntableList.remove(i);\n      o.remove();\n      setDirty(true);\n      repaint();\n      return (true);\n    }\n  }\n  return (false);\n}", "comment": "remove a layout turntable", "label": "what"}
{"id": "54256", "raw_code": "@Override public final void endElement(final String ns,final String lName,final String qName) throws SAXException {\n  String name=lName == null || lName.length() == 0 ? qName : lName;\n  Rule r=(Rule)RULES.match(match);\n  if (r != null) {\n    r.end(name);\n  }\n  int slash=match.lastIndexOf('/');\n  if (slash >= 0) {\n    match=match.substring(0,slash);\n  }\n else {\n    match=\"\";\n  }\n}", "comment": "process notification of the end of an xml element being reached .", "label": "what"}
{"id": "20496", "raw_code": "public int scheduledQueueSize(){\n  return schedulerQueueSize.get();\n}", "comment": "get the total number of scheduled requests .", "label": "what"}
{"id": "9678", "raw_code": "public DGeneralNameChooser(JFrame parent,String title,GeneralName generalName){\n  super(parent,title,ModalityType.DOCUMENT_MODAL);\n  initComponents(generalName);\n}", "comment": "constructs a new dgeneralnamechooser dialog .", "label": "what"}
{"id": "26039", "raw_code": "private static Platform findPlatform(){\n  try {\n    try {\n      Class.forName(\"com.android.org.conscrypt.OpenSSLSocketImpl\");\n    }\n catch (    ClassNotFoundException e) {\n      Class.forName(\"org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl\");\n    }\n    OptionalMethod<Socket> setUseSessionTickets=new OptionalMethod<>(null,\"setUseSessionTickets\",boolean.class);\n    OptionalMethod<Socket> setHostname=new OptionalMethod<>(null,\"setHostname\",String.class);\n    Method trafficStatsTagSocket=null;\n    Method trafficStatsUntagSocket=null;\n    OptionalMethod<Socket> getAlpnSelectedProtocol=null;\n    OptionalMethod<Socket> setAlpnProtocols=null;\n    try {\n      Class<?> trafficStats=Class.forName(\"android.net.TrafficStats\");\n      trafficStatsTagSocket=trafficStats.getMethod(\"tagSocket\",Socket.class);\n      trafficStatsUntagSocket=trafficStats.getMethod(\"untagSocket\",Socket.class);\n      try {\n        Class.forName(\"android.net.Network\");\n        getAlpnSelectedProtocol=new OptionalMethod<>(byte[].class,\"getAlpnSelectedProtocol\");\n        setAlpnProtocols=new OptionalMethod<>(null,\"setAlpnProtocols\",byte[].class);\n      }\n catch (      ClassNotFoundException ignored) {\n      }\n    }\n catch (    ClassNotFoundException|NoSuchMethodException ignored) {\n    }\n    return new Android(setUseSessionTickets,setHostname,trafficStatsTagSocket,trafficStatsUntagSocket,getAlpnSelectedProtocol,setAlpnProtocols);\n  }\n catch (  ClassNotFoundException ignored) {\n  }\n  try {\n    String negoClassName=\"org.eclipse.jetty.alpn.ALPN\";\n    Class<?> negoClass=Class.forName(negoClassName);\n    Class<?> providerClass=Class.forName(negoClassName + \"$Provider\");\n    Class<?> clientProviderClass=Class.forName(negoClassName + \"$ClientProvider\");\n    Class<?> serverProviderClass=Class.forName(negoClassName + \"$ServerProvider\");\n    Method putMethod=negoClass.getMethod(\"put\",SSLSocket.class,providerClass);\n    Method getMethod=negoClass.getMethod(\"get\",SSLSocket.class);\n    Method removeMethod=negoClass.getMethod(\"remove\",SSLSocket.class);\n    return new JdkWithJettyBootPlatform(putMethod,getMethod,removeMethod,clientProviderClass,serverProviderClass);\n  }\n catch (  ClassNotFoundException|NoSuchMethodException ignored) {\n  }\n  return new Platform();\n}", "comment": "attempt to match the host runtime to a capable platform implementation .", "label": "what"}
{"id": "71217", "raw_code": "private void addLimitedMitreJoin(LineSegment offset0,LineSegment offset1,double distance,double mitreLimit){\n  Coordinate basePt=seg0.p1;\n  double ang0=Angle.angle(basePt,seg0.p0);\n  double ang1=Angle.angle(basePt,seg1.p1);\n  double angDiff=Angle.angleBetweenOriented(seg0.p0,basePt,seg1.p1);\n  double angDiffHalf=angDiff / 2;\n  double midAng=Angle.normalize(ang0 + angDiffHalf);\n  double mitreMidAng=Angle.normalize(midAng + Math.PI);\n  double mitreDist=mitreLimit * distance;\n  double bevelDelta=mitreDist * Math.abs(Math.sin(angDiffHalf));\n  double bevelHalfLen=distance - bevelDelta;\n  double bevelMidX=basePt.x + mitreDist * Math.cos(mitreMidAng);\n  double bevelMidY=basePt.y + mitreDist * Math.sin(mitreMidAng);\n  Coordinate bevelMidPt=new Coordinate(bevelMidX,bevelMidY);\n  LineSegment mitreMidLine=new LineSegment(basePt,bevelMidPt);\n  Coordinate bevelEndLeft=mitreMidLine.pointAlongOffset(1.0,bevelHalfLen);\n  Coordinate bevelEndRight=mitreMidLine.pointAlongOffset(1.0,-bevelHalfLen);\n  if (side == Position.LEFT) {\n    segList.addPt(bevelEndLeft);\n    segList.addPt(bevelEndRight);\n  }\n else {\n    segList.addPt(bevelEndRight);\n    segList.addPt(bevelEndLeft);\n  }\n}", "comment": "adds a limited mitre join connecting the two reflex offset segments .", "label": "what"}
{"id": "7541", "raw_code": "protected AbstractCategoryItemLabelGenerator(String labelFormat,DateFormat formatter){\n  ParamChecks.nullNotPermitted(labelFormat,\"labelFormat\");\n  ParamChecks.nullNotPermitted(formatter,\"formatter\");\n  this.labelFormat=labelFormat;\n  this.numberFormat=null;\n  this.percentFormat=NumberFormat.getPercentInstance();\n  this.dateFormat=formatter;\n  this.nullValueString=\"-\";\n}", "comment": "creates a label generator with the specified date formatter .", "label": "what"}
{"id": "38597", "raw_code": "private void loadFile(String filename,AbstractFileLoader... loaders){\n  ArffSortedTableModel model;\n  this.m_Filename=filename;\n  createTitle();\n  if (filename.equals(\"\")) {\n    model=null;\n  }\n else {\n    model=new ArffSortedTableModel(filename,loaders);\n    model.setShowAttributeIndex(getShowAttributeIndex());\n  }\n  m_TableArff.setModel(model);\n  setChanged(false);\n  createName();\n}", "comment": "loads the specified file into the table", "label": "what"}
{"id": "38312", "raw_code": "private void destinationTypeChanged(){\n  if (m_Exp == null)   return;\n  String str=\"\";\n  if (m_ResultsDestinationCBox.getSelectedItem() == DEST_DATABASE_TEXT) {\n    m_ResultsDestinationPathLabel.setText(\"URL:\");\n    str=m_destinationDatabaseURL;\n    m_BrowseDestinationButton.setEnabled(true);\n    m_BrowseDestinationButton.setText(\"User...\");\n  }\n else {\n    m_ResultsDestinationPathLabel.setText(\"Filename:\");\n    if (m_ResultsDestinationCBox.getSelectedItem() == DEST_ARFF_TEXT) {\n      int ind=m_destinationFilename.lastIndexOf(\".csv\");\n      if (ind > -1) {\n        m_destinationFilename=m_destinationFilename.substring(0,ind) + \".arff\";\n      }\n    }\n    if (m_ResultsDestinationCBox.getSelectedItem() == DEST_CSV_TEXT) {\n      int ind=m_destinationFilename.lastIndexOf(\".arff\");\n      if (ind > -1) {\n        m_destinationFilename=m_destinationFilename.substring(0,ind) + \".csv\";\n      }\n    }\n    str=m_destinationFilename;\n    if (m_ResultsDestinationCBox.getSelectedItem() == DEST_ARFF_TEXT) {\n      int ind=str.lastIndexOf(\".csv\");\n      if (ind > -1) {\n        str=str.substring(0,ind) + \".arff\";\n      }\n    }\n    if (m_ResultsDestinationCBox.getSelectedItem() == DEST_CSV_TEXT) {\n      int ind=str.lastIndexOf(\".arff\");\n      if (ind > -1) {\n        str=str.substring(0,ind) + \".csv\";\n      }\n    }\n    m_BrowseDestinationButton.setEnabled(true);\n    m_BrowseDestinationButton.setText(\"Browse...\");\n  }\n  if (m_ResultsDestinationCBox.getSelectedItem() == DEST_DATABASE_TEXT) {\n    DatabaseResultListener drl=null;\n    try {\n      drl=new DatabaseResultListener();\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n    }\n    drl.setDatabaseURL(m_destinationDatabaseURL);\n    m_Exp.setResultListener(drl);\n  }\n else {\n    if (m_ResultsDestinationCBox.getSelectedItem() == DEST_ARFF_TEXT) {\n      InstancesResultListener irl=new InstancesResultListener();\n      if (!m_destinationFilename.equals(\"\")) {\n        irl.setOutputFile(new File(m_destinationFilename));\n      }\n      m_Exp.setResultListener(irl);\n    }\n else     if (m_ResultsDestinationCBox.getSelectedItem() == DEST_CSV_TEXT) {\n      CSVResultListener crl=new CSVResultListener();\n      if (!m_destinationFilename.equals(\"\")) {\n        crl.setOutputFile(new File(m_destinationFilename));\n      }\n      m_Exp.setResultListener(crl);\n    }\n  }\n  m_ResultsDestinationPathTField.setText(str);\n  m_Support.firePropertyChange(\"\",null,null);\n}", "comment": "responds to a change in the destination type .", "label": "what"}
{"id": "53384", "raw_code": "public static InputStream tryGzipInput(InputStream in) throws IOException {\n  if (!in.markSupported()) {\n    PushbackInputStream pb=new PushbackInputStream(in,16);\n    in=pb;\n    byte[] magic={0,0};\n    pb.read(magic);\n    pb.unread(magic);\n    if (magic[0] == 31 && magic[1] == -117) {\n      return new GZIPInputStream(pb);\n    }\n    return in;\n  }\n  in.mark(16);\n  boolean isgzip=(in.read() == 31 && in.read() == -117);\n  in.reset();\n  if (isgzip) {\n    in=new GZIPInputStream(in);\n  }\n  return in;\n}", "comment": "try to open a stream as gzip , if it starts with the gzip magic .", "label": "what"}
{"id": "4856", "raw_code": "protected void expandFor(int index,double d){\n  if (index < size)   return;\n  int oldSize=size, capacity=vector.length;\n  size=index + 1;\n  if (capacity >= size)   return;\n  while (capacity < size)   capacity*=2;\n  double[] t=new double[capacity];\n  System.arraycopy(vector,0,t,0,oldSize);\n  if (d != 0)   Arrays.fill(t,oldSize,size,d);\n  vector=t;\n}", "comment": "makes sure the capacity and size of the vector can accomodate the given index .", "label": "what"}
{"id": "40351", "raw_code": "public void triangulate(PointSet ps){\n  _triangulations.clear();\n  _triangulations.add(ps);\n  start();\n}", "comment": "triangulate a pointset with eventual constraints", "label": "what"}
{"id": "2307", "raw_code": "@SafeVarargs public final void insert(int rowIndex,T... newItems){\n  insert(rowIndex,Arrays.asList(newItems));\n}", "comment": "insert new records at a specified index .", "label": "what"}
{"id": "53257", "raw_code": "@Deprecated public void put(Collection<Integer> data){\n  for (  Integer value : data) {\n    final int val=value.intValue();\n    min=val < min ? val : min;\n    max=val > max ? val : max;\n  }\n}", "comment": "process a whole collection of integer values .", "label": "what"}
{"id": "56339", "raw_code": "public CreateIndexRequest source(XContentBuilder source){\n  return source(source.bytes());\n}", "comment": "sets the settings and mappings as a single source .", "label": "what"}
{"id": "29627", "raw_code": "public static byte[] createDataToSign(byte[] digest){\n  byte[] prefix=getDigestInfoPrefix(digest);\n  byte[] digestInfo=new byte[prefix.length + digest.length];\n  System.arraycopy(prefix,0,digestInfo,0,prefix.length);\n  System.arraycopy(digest,0,digestInfo,prefix.length,digest.length);\n  return digestInfo;\n}", "comment": "creates data to be signed from the digest .", "label": "what"}
{"id": "6021", "raw_code": "public HttpRequest ifModifiedSince(final long value){\n  connection.setIfModifiedSince(value);\n  return this;\n}", "comment": "set the ' if - modified - since ' request header to the given value", "label": "what"}
{"id": "25654", "raw_code": "public static Object newInstance(Class<?> cl,int[] dims){\n  if (dims.length == 0) {\n    dims=new int[]{1};\n  }\n  return Array.newInstance(cl,dims);\n}", "comment": "allocate an array dynamically .", "label": "what"}
{"id": "54572", "raw_code": "public void playTogether(Collection<Animator> items){\n  if (items != null && items.size() > 0) {\n    mNeedsSort=true;\n    Builder builder=null;\n    for (    Animator anim : items) {\n      if (builder == null) {\n        builder=play(anim);\n      }\n else {\n        builder.with(anim);\n      }\n    }\n  }\n}", "comment": "sets up this animatorset to play all of the supplied animations at the same time .", "label": "what"}
{"id": "9354", "raw_code": "private void applyL1Reg(final double eta_t,Vec x){\n  if (lambda1 > 0) {\n    l1U+=eta_t * lambda1;\n    for (int k=0; k < ws.length; k++) {\n      final Vec w_k=ws[k];\n      final double[] l1Q_k=l1Q[k];\n      for (      IndexValue iv : x) {\n        final int i=iv.getIndex();\n        final double z=w_k.get(i);\n        double newW_i=0;\n        if (z > 0)         newW_i=Math.max(0,z - (l1U + l1Q_k[i]));\n else         if (z < 0)         newW_i=Math.min(0,z + (l1U - l1Q_k[i]));\n        l1Q_k[i]+=(newW_i - z);\n        w_k.set(i,newW_i);\n      }\n    }\n  }\n}", "comment": "applies l1 regularization to the model", "label": "what"}
{"id": "82761", "raw_code": "private void paintForegroundDisabled(Graphics2D g,int width,int height){\n  Shape s=decodeArrowPath(width,height);\n  g.setPaint(disabledColor);\n  g.fill(s);\n}", "comment": "paint the arrow in disabled state .", "label": "what"}
{"id": "68033", "raw_code": "@Override public boolean hasNext(){\n  log.log(Level.FINE,\"hasNext()\");\n  boolean result=(nextEvent != null);\n  log.log(Level.FINE,\"hasNext(): {0}\",result);\n  return result;\n}", "comment": "check if there are more events .", "label": "what"}
{"id": "2051", "raw_code": "public static XMPMeta extractXMPMeta(InputStream is){\n  List<Section> sections=parse(is,true);\n  if (sections == null) {\n    return null;\n  }\n  for (  Section section : sections) {\n    if (hasXMPHeader(section.data)) {\n      int end=getXMPContentEnd(section.data);\n      byte[] buffer=new byte[end - XMP_HEADER_SIZE];\n      System.arraycopy(section.data,XMP_HEADER_SIZE,buffer,0,buffer.length);\n      try {\n        XMPMeta result=XMPMetaFactory.parseFromBuffer(buffer);\n        return result;\n      }\n catch (      XMPException e) {\n        Log.d(TAG,\"XMP parse error\",e);\n        return null;\n      }\n    }\n  }\n  return null;\n}", "comment": "extracts xmpmeta from a jpeg image file stream .", "label": "what"}
{"id": "66007", "raw_code": "private void initialize(ModelValidator validator,MClient client){\n  if (client == null)   m_globalValidators.add(validator);\n  m_validators.add(validator);\n  validator.initialize(this,client);\n}", "comment": "initialize and add validator", "label": "what"}
{"id": "36602", "raw_code": "public Perspective createUserPerspective(final String name,final boolean show){\n  Perspective perspective=model.addPerspective(name,true);\n  perspective.store(context);\n  if (show) {\n    showPerspective(name);\n  }\n  return perspective;\n}", "comment": "creates a user - defined perspectives , and possibly switches to this new perspective immediately .", "label": "what"}
{"id": "86640", "raw_code": "public static double phred(double error){\n  return -10 * Math.log10(error);\n}", "comment": "get a phred - scaled quality value corresponding to the supplied error rate .", "label": "what"}
{"id": "35395", "raw_code": "@SafeVarargs public final Token<TokenType> expect(TokenType... expected) throws SimpleParserException {\n  if (hasType(expected))   return this;\n  throw new SimpleParserException(line,column,\"Expected \" + Arrays.toString(expected) + \", but got \"+ toString());\n}", "comment": "ensures that this token has one of the given expected types .", "label": "what"}
{"id": "28572", "raw_code": "@Deprecated public boolean isAssignableFrom(Type from){\n  if (from == null) {\n    return false;\n  }\n  if (type.equals(from)) {\n    return true;\n  }\n  if (type instanceof Class<?>) {\n    return rawType.isAssignableFrom($Gson$Types.getRawType(from));\n  }\n else   if (type instanceof ParameterizedType) {\n    return isAssignableFrom(from,(ParameterizedType)type,new HashMap<String,Type>());\n  }\n else   if (type instanceof GenericArrayType) {\n    return rawType.isAssignableFrom($Gson$Types.getRawType(from)) && isAssignableFrom(from,(GenericArrayType)type);\n  }\n else {\n    throw buildUnexpectedTypeError(type,Class.class,ParameterizedType.class,GenericArrayType.class);\n  }\n}", "comment": "check if this type is assignable from the given type .", "label": "what"}
{"id": "12557", "raw_code": "public SampleInfo(ByteBuffer bb) throws IOException {\n  numberOfChannels=bb.getInt();\n  sampleRate=bb.getInt();\n  coeffMin=bb.getFloat();\n  coeffRange=bb.getFloat();\n  postEmphasis=bb.getFloat();\n  residualFold=bb.getInt();\n}", "comment": "constructs a sample info from the given byte buffer .", "label": "what"}
{"id": "7370", "raw_code": "public <T>T time(Callable<T> event) throws Exception {\n  final long startTime=clock.tick();\n  try {\n    return event.call();\n  }\n  finally {\n    update(clock.tick() - startTime);\n  }\n}", "comment": "times and records the duration of event .", "label": "what"}
{"id": "8104", "raw_code": "public static boolean isPostJDK7(String bytecodeVersion){\n  return JDK7.equals(bytecodeVersion) || JDK8.equals(bytecodeVersion);\n}", "comment": "checks if the specified bytecode version string represents a jdk 1 . 7 + compatible bytecode version .", "label": "what"}
{"id": "45032", "raw_code": "private static char[] zzUnpackCMap(String packed){\n  char[] map=new char[0x10000];\n  int i=0;\n  int j=0;\n  while (i < 160) {\n    int count=packed.charAt(i++);\n    char value=packed.charAt(i++);\n    do     map[j++]=value;\n while (--count > 0);\n  }\n  return map;\n}", "comment": "unpacks the compressed character translation table .", "label": "what"}
{"id": "54936", "raw_code": "private InputStream findTemplate(String path,String template){\n  try {\n    File file=new File(path,template);\n    if (file.canRead()) {\n      return new BufferedInputStream(new FileInputStream(file.getAbsolutePath()));\n    }\n else {\n      return null;\n    }\n  }\n catch (  FileNotFoundException fnfe) {\n    return null;\n  }\n}", "comment": "try to find a template given a normalized path .", "label": "what"}
{"id": "83535", "raw_code": "public void addListener(CircularProgressViewListener listener){\n  if (listener != null)   listeners.add(listener);\n}", "comment": "register a circularprogressviewlistener with this view", "label": "what"}
{"id": "74716", "raw_code": "@Override public void render(final int type,final Graphics2D g2,final float scaling,final boolean isFormGlyph){\n  glyphDisplay.setScalingValues(0,0,scaling);\n  final float OLDglyphScale=glyphScale;\n  if (isFormGlyph) {\n    glyphScale=scaling * glyphScale;\n  }\n  AffineTransform aff=null;\n  if (glyphScale != 1f) {\n    aff=g2.getTransform();\n    g2.scale(glyphScale,glyphScale);\n  }\n  glyphDisplay.setG2(g2);\n  glyphDisplay.paint(null,null,null);\n  if (aff != null) {\n    g2.setTransform(aff);\n  }\n  glyphScale=OLDglyphScale;\n}", "comment": "draw the t3 glyph", "label": "what"}
{"id": "48883", "raw_code": "protected void release(){\n  AppContext tempAppContext=null;\nsynchronized (grabReleaseSynchronizer) {\n    if (usageCount > 1) {\n      --usageCount;\n    }\n else {\nsynchronized (threadGroupSynchronizer) {\n        tempAppContext=resetAppContext();\n      }\n    }\n  }\n  if (tempAppContext != null) {\n    try {\n      tempAppContext.dispose();\n    }\n catch (    IllegalThreadStateException e) {\n    }\n  }\n}", "comment": "release this appletclassloader and its threadgroup / appcontext .", "label": "what"}
{"id": "53706", "raw_code": "public synchronized void deleteAllTables(){\n  List<String> tableNames=new ArrayList<String>(tableLookup.keySet());\n  for (  String s : tableNames) {\n    deleteTable(s);\n  }\n}", "comment": "delete all tables from this database .", "label": "what"}
{"id": "25381", "raw_code": "public Exchange(final Request request,final Origin origin){\n  this.currentRequest=request;\n  this.origin=origin;\n  this.timestamp=System.currentTimeMillis();\n}", "comment": "creates a new exchange with the specified request and origin .", "label": "what"}
{"id": "40915", "raw_code": "public void removeAddress(AddressEntity address){\n  addresses.remove(address);\n}", "comment": "removes the given address from this user", "label": "what"}
{"id": "15426", "raw_code": "private boolean verifyMigrateFromProductHome(String migrateFromProductHome) throws InstallException {\n  if (migrateFromProductHome == null || migrateFromProductHome.length() == 0) {\n    Debug.log(\"MultipleMigrateDriver.verifyMigrateFromProductHome() :\" + \"empty product home by the user\");\n    Console.println(LocalizedMessage.get(LOC_HR_MSG_MIGRATE_NONE_FOUND));\n    return false;\n  }\n  if (!migrateFromProductHome.equals(ConfigUtil.getHomePath())) {\n    Debug.log(\"MultipleMigrateDriver.verifyMigrateFromProductHome() : \" + \"Migrate from product home: \" + migrateFromProductHome + \", New product home: \"+ ConfigUtil.getHomePath());\n    String translateFile=migrateFromProductHome + MigrateFromInstFinderStore.getRelativeTranslateFile();\n    if (!FileUtils.isFileValid(translateFile)) {\n      Console.println(LocalizedMessage.get(LOC_HR_MSG_MIGRATE_NONE_FOUND));\n      return false;\n    }\n  }\n else {\n    Debug.log(\"MultipleMigrateDriver - Error:\" + \"This product has been already migrated!\");\n    throw new InstallException(LocalizedMessage.get(LOC_DR_ERR_PRODUCT_ALREADY_MIGRATED));\n  }\n  return true;\n}", "comment": "check if the product home input by the user has the locator file of the product to be migrated from .", "label": "what"}
{"id": "33478", "raw_code": "public Spanned[] history(){\n  int i=0;\n  Spanned[] array=new Spanned[history.size()];\n  for (  String s : history) {\n    if (s != null) {\n      array[i]=Html.fromHtml(s);\n      i++;\n    }\n  }\n  return array;\n}", "comment": "generate an array of spanned items representing the history of this connection .", "label": "what"}
{"id": "33134", "raw_code": "public static String format(String message,Object[] arguments){\n  return MessageFormat.format(message,arguments);\n}", "comment": "formats the given string with the given argument .", "label": "what"}
{"id": "33695", "raw_code": "public static boolean createFolder(@SuppressWarnings(\"UnusedParameters\") Context mContext,String path,String folderName){\n  File SDCardRoot=new File(path,folderName);\n  if (!SDCardRoot.exists()) {\n    return SDCardRoot.mkdir();\n  }\n  return false;\n}", "comment": "use to create folder in your directory", "label": "what"}
{"id": "4129", "raw_code": "private void translateMatrixAfterRotate(int axis,float trans,float prevImageSize,float imageSize,int prevViewSize,int viewSize,int drawableSize){\n  if (imageSize < viewSize) {\n    m[axis]=(viewSize - (drawableSize * m[Matrix.MSCALE_X])) * 0.5f;\n  }\n else   if (trans > 0) {\n    m[axis]=-((imageSize - viewSize) * 0.5f);\n  }\n else {\n    float percentage=(Math.abs(trans) + (0.5f * prevViewSize)) / prevImageSize;\n    m[axis]=-((percentage * imageSize) - (viewSize * 0.5f));\n  }\n}", "comment": "after rotating , the matrix needs to be translated .", "label": "what"}
{"id": "21515", "raw_code": "private void addProtocolIfNotExists(Set<String> protocols,String protocolType){\n  if (!protocols.contains(protocolType)) {\n    protocols.add(protocolType);\n  }\n}", "comment": "verify whether protocoltype already exists or not .", "label": "what"}
{"id": "52576", "raw_code": "public Configuration loadConfigFromResource(Resource resource){\n  PropertiesConfiguration result=new PropertiesConfiguration();\n  try {\n    result.load(resource.getInputStream());\n    return result;\n  }\n catch (  ConfigurationException|IOException e) {\n    LOG.error(CONFIGURATION_LOAD_ERROR.format(resource.getFilename()),e);\n    throw new SystemConfigException(CONFIGURATION_LOAD_ERROR.format(resource.getFilename()),e);\n  }\n}", "comment": "build a configuration object from a resource , processing it as a properties file .", "label": "what"}
{"id": "55835", "raw_code": "public final void log(String filename,int lineNumber,String method,String tag,int level,String message){\n  final LogMessage lm=new LogMessage(LogMessage.LOGMSG_TYPE_LOG,nextSequenceNumber.getAndIncrement());\n  lm.addInt16(level,LogMessage.PART_KEY_LEVEL);\n  if (filename != null) {\n    lm.addString(filename,LogMessage.PART_KEY_FILENAME);\n    if (lineNumber != 0)     lm.addInt32(lineNumber,LogMessage.PART_KEY_LINENUMBER);\n  }\n  if (method != null)   lm.addString(method,LogMessage.PART_KEY_FUNCTIONNAME);\n  if (tag != null && !tag.isEmpty())   lm.addString(tag,LogMessage.PART_KEY_TAG);\n  lm.addString(message,LogMessage.PART_KEY_MESSAGE);\n  log(lm);\n}", "comment": "log a message with full information ( if provided )", "label": "what"}
{"id": "7411", "raw_code": "protected Size2D drawVertical(Graphics2D g2,Rectangle2D chartArea){\n  double startX;\n  double topSpace=0.0;\n  double bottomSpace=0.0;\n  double leftSpace=0.0;\n  double rightSpace=0.0;\n  double w=getWidth();\n  double h=getHeight();\n  RectangleInsets padding=getPadding();\n  if (padding != null) {\n    topSpace=padding.calculateTopOutset(h);\n    bottomSpace=padding.calculateBottomOutset(h);\n    leftSpace=padding.calculateLeftOutset(w);\n    rightSpace=padding.calculateRightOutset(w);\n  }\n  if (getPosition() == RectangleEdge.LEFT) {\n    startX=chartArea.getX() + leftSpace;\n  }\n else {\n    startX=chartArea.getMaxX() - rightSpace - w;\n  }\n  VerticalAlignment alignment=getVerticalAlignment();\n  double startY=0.0;\n  if (alignment == VerticalAlignment.CENTER) {\n    startY=chartArea.getMinY() + topSpace + chartArea.getHeight() / 2.0 - h / 2.0;\n  }\n else   if (alignment == VerticalAlignment.TOP) {\n    startY=chartArea.getMinY() + topSpace;\n  }\n else   if (alignment == VerticalAlignment.BOTTOM) {\n    startY=chartArea.getMaxY() - bottomSpace - h;\n  }\n  g2.drawImage(this.image,(int)startX,(int)startY,(int)w,(int)h,null);\n  return new Size2D(chartArea.getWidth() + leftSpace + rightSpace,h + topSpace + bottomSpace);\n}", "comment": "draws the title on a java 2d graphics device ( such as the screen or a printer ) .", "label": "what"}
{"id": "46127", "raw_code": "private static final PublicKey constructPublicKey(byte[] encodedKey,String encodedKeyAlgorithm) throws InvalidKeyException, NoSuchAlgorithmException {\n  PublicKey key=null;\n  try {\n    KeyFactory keyFactory=KeyFactory.getInstance(encodedKeyAlgorithm,SunJCE.getInstance());\n    X509EncodedKeySpec keySpec=new X509EncodedKeySpec(encodedKey);\n    key=keyFactory.generatePublic(keySpec);\n  }\n catch (  NoSuchAlgorithmException nsae) {\n    try {\n      KeyFactory keyFactory=KeyFactory.getInstance(encodedKeyAlgorithm);\n      X509EncodedKeySpec keySpec=new X509EncodedKeySpec(encodedKey);\n      key=keyFactory.generatePublic(keySpec);\n    }\n catch (    NoSuchAlgorithmException nsae2) {\n      throw new NoSuchAlgorithmException(\"No installed providers \" + \"can create keys for the \" + encodedKeyAlgorithm + \"algorithm\");\n    }\ncatch (    InvalidKeySpecException ikse2) {\n      InvalidKeyException ike=new InvalidKeyException(\"Cannot construct public key\");\n      ike.initCause(ikse2);\n      throw ike;\n    }\n  }\ncatch (  InvalidKeySpecException ikse) {\n    InvalidKeyException ike=new InvalidKeyException(\"Cannot construct public key\");\n    ike.initCause(ikse);\n    throw ike;\n  }\n  return key;\n}", "comment": "construct a public key from its encoding .", "label": "what"}
{"id": "4287", "raw_code": "public static boolean expressionIsTrue(double leftSide,Operator operator,double rightSide){\n  final String expression=leftSide + operator.getMathematicalOperator() + rightSide;\n  return expressionIsTrue(expression);\n}", "comment": "evaluates whether an expression is true or false .", "label": "what"}
{"id": "19425", "raw_code": "public MockResponse addHeader(String name,Object value){\n  return addHeader(name + \": \" + String.valueOf(value));\n}", "comment": "adds a new header with the name and value .", "label": "what"}
{"id": "56565", "raw_code": "@Override public CompletableFuture<Optional<T>> max(final Comparator<? super T> comparator){\n  return CompletableFuture.supplyAsync(null,exec);\n}", "comment": "perform an asyncrhonous min operation", "label": "what"}
{"id": "64420", "raw_code": "private static String doGetFullPath(String filename,boolean includeSeparator){\n  if (filename == null) {\n    return null;\n  }\n  int prefix=getPrefixLength(filename);\n  if (prefix < 0) {\n    return null;\n  }\n  if (prefix >= filename.length()) {\n    if (includeSeparator) {\n      return getPrefix(filename);\n    }\n else {\n      return filename;\n    }\n  }\n  int index=indexOfLastSeparator(filename);\n  if (index < 0) {\n    return filename.substring(0,prefix);\n  }\n  int end=index + (includeSeparator ? 1 : 0);\n  if (end == 0) {\n    end++;\n  }\n  return filename.substring(0,end);\n}", "comment": "does the work of getting the path .", "label": "what"}
{"id": "52921", "raw_code": "private void preInsert(MkMaxEntry q,MkMaxEntry nodeEntry,KNNHeap knns_q){\n  if (LOG.isDebugging()) {\n    LOG.debugFine(\"preInsert \" + q + \" - \"+ nodeEntry+ \"\\n\");\n  }\n  double knnDist_q=knns_q.getKNNDistance();\n  MkMaxTreeNode<O> node=getNode(nodeEntry);\n  double knnDist_node=0.;\n  if (node.isLeaf()) {\n    for (int i=0; i < node.getNumEntries(); i++) {\n      MkMaxEntry p=node.getEntry(i);\n      double dist_pq=distance(p.getRoutingObjectID(),q.getRoutingObjectID());\n      if (dist_pq <= knnDist_q) {\n        knns_q.insert(dist_pq,p.getRoutingObjectID());\n        if (knns_q.size() >= getKmax()) {\n          knnDist_q=knns_q.getKNNDistance();\n          q.setKnnDistance(knnDist_q);\n        }\n      }\n      if (dist_pq <= p.getKnnDistance()) {\n        KNNList knns_p=knnq.getKNNForDBID(p.getRoutingObjectID(),getKmax() - 1);\n        if (knns_p.size() + 1 < getKmax()) {\n          p.setKnnDistance(Double.NaN);\n        }\n else {\n          double knnDist_p=Math.max(dist_pq,knns_p.getKNNDistance());\n          p.setKnnDistance(knnDist_p);\n        }\n      }\n      knnDist_node=Math.max(knnDist_node,p.getKnnDistance());\n    }\n  }\n else {\n    List<DoubleIntPair> entries=getSortedEntries(node,q.getRoutingObjectID());\n    for (    DoubleIntPair distEntry : entries) {\n      MkMaxEntry dirEntry=node.getEntry(distEntry.second);\n      double entry_knnDist=dirEntry.getKnnDistance();\n      if (distEntry.second < entry_knnDist || distEntry.second < knnDist_q) {\n        preInsert(q,dirEntry,knns_q);\n        knnDist_q=knns_q.getKNNDistance();\n      }\n      knnDist_node=Math.max(knnDist_node,dirEntry.getKnnDistance());\n    }\n  }\n  if (LOG.isDebugging()) {\n    LOG.debugFine(nodeEntry + \"set knn dist \" + knnDist_node);\n  }\n  nodeEntry.setKnnDistance(knnDist_node);\n}", "comment": "adapts the knn distances before insertion of entry q .", "label": "what"}
{"id": "1191", "raw_code": "public static String encodeFromString(String plain,String charset) throws CoderException, UnsupportedEncodingException {\n  return encode(plain.getBytes(charset));\n}", "comment": "encodes a string to base64 string", "label": "what"}
{"id": "86931", "raw_code": "public void slide(SLIDE slide){\n  if (slide == SLIDE.UP) {\n    if (!isPanelShown()) {\n      int position=0;\n      if (items != null) {\n        position=items.size() / 2;\n      }\n      slideUp(position);\n    }\n  }\n else {\n    hidePanelPickerUI();\n  }\n}", "comment": "slide the panel to the desired direction .", "label": "what"}
{"id": "53112", "raw_code": "public boolean isDebuggingFinest(){\n  return logger.isLoggable(Level.FINEST);\n}", "comment": "test whether to log ' debug ' at ' finest ' level", "label": "what"}
{"id": "33870", "raw_code": "private static void sort1(int[] x,int off,int len){\n  if (len < 7) {\n    for (int i=off; i < len + off; i++)     for (int j=i; j > off && x[j - 1] > x[j]; j--)     swap(x,j,j - 1);\n    return;\n  }\n  int m=off + (len >> 1);\n  if (len > 7) {\n    int l=off;\n    int n=off + len - 1;\n    if (len > 40) {\n      int s=len / 8;\n      l=med3(x,l,l + s,l + 2 * s);\n      m=med3(x,m - s,m,m + s);\n      n=med3(x,n - 2 * s,n - s,n);\n    }\n    m=med3(x,l,m,n);\n  }\n  int v=x[m];\n  int a=off, b=a, c=off + len - 1, d=c;\n  while (true) {\n    while (b <= c && x[b] <= v) {\n      if (x[b] == v)       swap(x,a++,b);\n      b++;\n    }\n    while (c >= b && x[c] >= v) {\n      if (x[c] == v)       swap(x,c,d--);\n      c--;\n    }\n    if (b > c)     break;\n    swap(x,b++,c--);\n  }\n  int s, n=off + len;\n  s=Math.min(a - off,b - a);\n  vecswap(x,off,b - s,s);\n  s=Math.min(d - c,n - d - 1);\n  vecswap(x,b,n - s,s);\n  if ((s=b - a) > 1)   sort1(x,off,s);\n  if ((s=d - c) > 1)   sort1(x,n - s,s);\n}", "comment": "sorts the specified sub - array of integers into ascending order .", "label": "what"}
{"id": "85198", "raw_code": "public void reset(){\n  ns.removeAllElements();\n  ks.setLength(0);\n  cur=tt.root;\n  run();\n}", "comment": "resets the iterator to its initial state .", "label": "what"}
{"id": "692", "raw_code": "public static GeneralPath cardinalSpline(float pts[],int start,int npoints,float slack,boolean closed){\n  GeneralPath path=new GeneralPath();\n  path.moveTo(pts[start],pts[start + 1]);\n  return cardinalSpline(path,pts,start,npoints,slack,closed,0f,0f);\n}", "comment": "compute a cardinal spline , a series of cubic bezier splines smoothly connecting a set of points .", "label": "what"}
{"id": "77072", "raw_code": "public static Automaton determinize(Automaton a,int maxDeterminizedStates){\n  if (a.isDeterministic()) {\n    return a;\n  }\n  if (a.getNumStates() <= 1) {\n    return a;\n  }\n  Automaton.Builder b=new Automaton.Builder();\n  SortedIntSet.FrozenIntSet initialset=new SortedIntSet.FrozenIntSet(0,0);\n  b.createState();\n  LinkedList<SortedIntSet.FrozenIntSet> worklist=new LinkedList<>();\n  Map<SortedIntSet.FrozenIntSet,Integer> newstate=new HashMap<>();\n  worklist.add(initialset);\n  b.setAccept(0,a.isAccept(0));\n  newstate.put(initialset,0);\n  final PointTransitionSet points=new PointTransitionSet();\n  final SortedIntSet statesSet=new SortedIntSet(5);\n  Transition t=new Transition();\n  while (worklist.size() > 0) {\n    SortedIntSet.FrozenIntSet s=worklist.removeFirst();\n    for (int i=0; i < s.values.length; i++) {\n      final int s0=s.values[i];\n      int numTransitions=a.getNumTransitions(s0);\n      a.initTransition(s0,t);\n      for (int j=0; j < numTransitions; j++) {\n        a.getNextTransition(t);\n        points.add(t);\n      }\n    }\n    if (points.count == 0) {\n      continue;\n    }\n    points.sort();\n    int lastPoint=-1;\n    int accCount=0;\n    final int r=s.state;\n    for (int i=0; i < points.count; i++) {\n      final int point=points.points[i].point;\n      if (statesSet.upto > 0) {\n        assert lastPoint != -1;\n        statesSet.computeHash();\n        Integer q=newstate.get(statesSet);\n        if (q == null) {\n          q=b.createState();\n          if (q >= maxDeterminizedStates) {\n            throw new TooComplexToDeterminizeException(a,maxDeterminizedStates);\n          }\n          final SortedIntSet.FrozenIntSet p=statesSet.freeze(q);\n          worklist.add(p);\n          b.setAccept(q,accCount > 0);\n          newstate.put(p,q);\n        }\n else {\n          assert (accCount > 0 ? true : false) == b.isAccept(q) : \"accCount=\" + accCount + \" vs existing accept=\"+ b.isAccept(q)+ \" states=\"+ statesSet;\n        }\n        b.addTransition(r,q,lastPoint,point - 1);\n      }\n      int[] transitions=points.points[i].ends.transitions;\n      int limit=points.points[i].ends.next;\n      for (int j=0; j < limit; j+=3) {\n        int dest=transitions[j];\n        statesSet.decr(dest);\n        accCount-=a.isAccept(dest) ? 1 : 0;\n      }\n      points.points[i].ends.next=0;\n      transitions=points.points[i].starts.transitions;\n      limit=points.points[i].starts.next;\n      for (int j=0; j < limit; j+=3) {\n        int dest=transitions[j];\n        statesSet.incr(dest);\n        accCount+=a.isAccept(dest) ? 1 : 0;\n      }\n      lastPoint=point;\n      points.points[i].starts.next=0;\n    }\n    points.reset();\n    assert statesSet.upto == 0 : \"upto=\" + statesSet.upto;\n  }\n  Automaton result=b.finish();\n  assert result.isDeterministic();\n  return result;\n}", "comment": "determinizes the given automaton .", "label": "what"}
{"id": "60037", "raw_code": "public boolean matches(String seq){\n  return queue.regionMatches(true,pos,seq,0,seq.length());\n}", "comment": "tests if the next characters on the queue match the sequence .", "label": "what"}
{"id": "72522", "raw_code": "private boolean findRoot(final ODEStateInterpolator interpolator,final double ta,final double ga,final double tb,final double gb){\n  check(ga == 0.0 || gb == 0.0 || (ga > 0.0 && gb < 0.0) || (ga < 0.0 && gb > 0.0));\n  final UnivariateFunction f=null;\n  double beforeRootT=Double.NaN, beforeRootG=Double.NaN;\n  double afterRootT=ta, afterRootG=0.0;\n  if (ta == tb) {\n    beforeRootT=ta;\n    beforeRootG=ga;\n    afterRootT=shiftedBy(beforeRootT,convergence);\n    afterRootG=f.value(afterRootT);\n  }\n else   if (ga != 0.0 && gb == 0.0) {\n    beforeRootT=tb;\n    beforeRootG=gb;\n    afterRootT=shiftedBy(beforeRootT,convergence);\n    afterRootG=f.value(afterRootT);\n  }\n else   if (ga != 0.0) {\n    final double newGa=f.value(ta);\n    if (ga > 0 != newGa > 0) {\n      beforeRootT=ta;\n      beforeRootG=newGa;\n      afterRootT=minTime(shiftedBy(beforeRootT,convergence),tb);\n      afterRootG=f.value(afterRootT);\n    }\n  }\n  double loopT=ta, loopG=ga;\n  while ((afterRootG == 0.0 || afterRootG > 0.0 == g0Positive) && strictlyAfter(afterRootT,tb)) {\n    if (loopG == 0.0) {\n      beforeRootT=loopT;\n      beforeRootG=loopG;\n      afterRootT=minTime(shiftedBy(beforeRootT,convergence),tb);\n      afterRootG=f.value(afterRootT);\n    }\n else {\n      if (forward) {\n        final Interval interval=solver.solveInterval(maxIterationCount,f,loopT,tb);\n        beforeRootT=interval.getLeftAbscissa();\n        beforeRootG=interval.getLeftValue();\n        afterRootT=interval.getRightAbscissa();\n        afterRootG=interval.getRightValue();\n      }\n else {\n        final Interval interval=solver.solveInterval(maxIterationCount,f,tb,loopT);\n        beforeRootT=interval.getRightAbscissa();\n        beforeRootG=interval.getRightValue();\n        afterRootT=interval.getLeftAbscissa();\n        afterRootG=interval.getLeftValue();\n      }\n    }\n    if (beforeRootT == afterRootT) {\n      afterRootT=nextAfter(afterRootT);\n      afterRootG=f.value(afterRootT);\n    }\n    check((forward && afterRootT > beforeRootT) || (!forward && afterRootT < beforeRootT));\n    loopT=afterRootT;\n    loopG=afterRootG;\n  }\n  if (afterRootG == 0.0 || afterRootG > 0.0 == g0Positive) {\n    return false;\n  }\n else {\n    check(!Double.isNaN(beforeRootT) && !Double.isNaN(beforeRootG));\n    increasing=!g0Positive;\n    pendingEventTime=beforeRootT;\n    stopTime=beforeRootG == 0.0 ? beforeRootT : afterRootT;\n    pendingEvent=true;\n    afterEvent=afterRootT;\n    afterG=afterRootG;\n    check(afterG > 0 == increasing);\n    check(increasing == gb >= ga);\n    return true;\n  }\n}", "comment": "find a root in a bracketing interval .", "label": "what"}
{"id": "84127", "raw_code": "public static int compare(Comparable c1,Comparable c2,boolean nullGreater){\n  if (c1 == c2) {\n    return 0;\n  }\n else   if (c1 == null) {\n    return (nullGreater ? 1 : -1);\n  }\n else   if (c2 == null) {\n    return (nullGreater ? -1 : 1);\n  }\n  return c1.compareTo(c2);\n}", "comment": "null safe comparison of comparables .", "label": "what"}
{"id": "6045", "raw_code": "boolean trackMotionScroll(int deltaY,int incrementalDeltaY){\n  final int childCount=getChildCount();\n  if (childCount == 0) {\n    return true;\n  }\n  final int firstTop=getScrollChildTop();\n  final int lastBottom=getScrollChildBottom();\n  final Rect listPadding=mListPadding;\n  final int end=getHeight() - listPadding.bottom;\n  final int spaceAbove=listPadding.top - getFillChildTop();\n  final int spaceBelow=getFillChildBottom() - end;\n  final int height=getHeight() - getPaddingBottom() - getPaddingTop();\n  if (deltaY < 0) {\n    deltaY=Math.max(-(height - 1),deltaY);\n  }\n else {\n    deltaY=Math.min(height - 1,deltaY);\n  }\n  if (incrementalDeltaY < 0) {\n    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);\n  }\n else {\n    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);\n  }\n  final int firstPosition=mFirstPosition;\n  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY >= 0) {\n    return true;\n  }\n  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY <= 0) {\n    return true;\n  }\n  final boolean down=incrementalDeltaY < 0;\n  final int headerViewsCount=getHeaderViewsCount();\n  final int footerViewsStart=mItemCount - getFooterViewsCount();\n  int start=0;\n  int count=0;\n  if (down) {\n    final int top=listPadding.top - incrementalDeltaY;\n    for (int i=0; i < childCount; i++) {\n      final View child=getChildAt(i);\n      if (child.getBottom() >= top) {\n        break;\n      }\n else {\n        count++;\n        int position=firstPosition + i;\n        if (position >= headerViewsCount && position < footerViewsStart) {\n          mRecycler.addScrapView(child);\n          if (ViewDebug.TRACE_RECYCLER) {\n            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);\n          }\n        }\n      }\n    }\n  }\n else {\n    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;\n    for (int i=childCount - 1; i >= 0; i--) {\n      final View child=getChildAt(i);\n      if (child.getTop() <= bottom) {\n        break;\n      }\n else {\n        start=i;\n        count++;\n        int position=firstPosition + i;\n        if (position >= headerViewsCount && position < footerViewsStart) {\n          mRecycler.addScrapView(child);\n          if (ViewDebug.TRACE_RECYCLER) {\n            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);\n          }\n        }\n      }\n    }\n  }\n  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;\n  mBlockLayoutRequests=true;\n  if (count > 0) {\n    detachViewsFromParent(start,count);\n  }\n  tryOffsetChildrenTopAndBottom(incrementalDeltaY);\n  if (down) {\n    mFirstPosition+=count;\n  }\n  invalidate();\n  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);\n  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {\n    fillGap(down);\n  }\n  mBlockLayoutRequests=false;\n  invokeOnItemScrollListener();\n  awakenScrollBars();\n  return false;\n}", "comment": "track a motion scroll", "label": "what"}
{"id": "63640", "raw_code": "public boolean isFingerprint(ClassTemplate classTemplate){\n  return fingerprintClass.equals(classTemplate.getImplementingClass());\n}", "comment": "tests if a template contains methods with signatures that are required by the filter object .", "label": "what"}
{"id": "32588", "raw_code": "public void writeField(final String name,final float value) throws java.io.IOException {\n  writeField(name,Float.toString(value));\n}", "comment": "writes an float field value .", "label": "what"}
{"id": "7933", "raw_code": "private List extractColumnKeys(String line){\n  List keys=new java.util.ArrayList();\n  int fieldIndex=0;\n  int start=0;\n  for (int i=0; i < line.length(); i++) {\n    if (line.charAt(i) == this.fieldDelimiter) {\n      if (fieldIndex > 0) {\n        String key=line.substring(start,i);\n        keys.add(removeStringDelimiters(key));\n      }\n      start=i + 1;\n      fieldIndex++;\n    }\n  }\n  String key=line.substring(start,line.length());\n  keys.add(removeStringDelimiters(key));\n  return keys;\n}", "comment": "extracts the column keys from a string .", "label": "what"}
{"id": "36710", "raw_code": "protected void drawRhombus(int x,int y,int w,int h,Color fillColor,Paint fillPaint,Color penColor,boolean shadow){\n  int halfWidth=w / 2;\n  int halfHeight=h / 2;\n  Polygon rhombus=new Polygon();\n  rhombus.addPoint(x + halfWidth,y);\n  rhombus.addPoint(x + w,y + halfHeight);\n  rhombus.addPoint(x + halfWidth,y + h);\n  rhombus.addPoint(x,y + halfHeight);\n  drawPolygon(rhombus,fillColor,fillPaint,penColor,shadow);\n}", "comment": "draws a rhombus ( aka .", "label": "what"}
{"id": "47884", "raw_code": "static Object instantiate(Class<?> sibling,String className) throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n  ClassLoader cl=sibling.getClassLoader();\n  Class<?> cls=ClassFinder.findClass(className,cl);\n  return cls.newInstance();\n}", "comment": "try to create an instance of a named class .", "label": "what"}
{"id": "8848", "raw_code": "public synchronized void show(Bundle options){\n  if (DEBUG)   Log.d(TAG,\"show(); mKeyguardView==\" + mKeyguardView);\n  boolean enableScreenRotation=shouldEnableScreenRotation();\n  maybeCreateKeyguardLocked(enableScreenRotation,false,options);\n  maybeEnableScreenRotation(enableScreenRotation);\n  final int visFlags=View.STATUS_BAR_DISABLE_HOME;\n  if (DEBUG)   Log.v(TAG,\"show:setSystemUiVisibility(\" + Integer.toHexString(visFlags) + \")\");\n  mKeyguardHost.setSystemUiVisibility(visFlags);\n  mViewManager.updateViewLayout(mKeyguardHost,mWindowLayoutParams);\n  mKeyguardHost.setVisibility(View.VISIBLE);\n  mKeyguardView.show();\n  mKeyguardView.requestFocus();\n}", "comment": "show the keyguard .", "label": "what"}
{"id": "66442", "raw_code": "public AddressLookup(String serverUrl,String serialNo,String password){\n  this.serverUrl=serverUrl.trim();\n  this.clientID=serialNo.trim();\n  this.accessCode=password.trim();\n}", "comment": "creates a new instance of addresslookup .", "label": "what"}
{"id": "72243", "raw_code": "public Node(String permission,boolean value,boolean override,long expireAt,String server,String world,ContextSet contexts){\n  if (permission == null || permission.equals(\"\")) {\n    throw new IllegalArgumentException(\"Empty permission\");\n  }\n  if (server != null && (server.equalsIgnoreCase(\"global\") || server.equals(\"\"))) {\n    server=null;\n  }\n  if (world != null && world.equals(\"\")) {\n    world=null;\n  }\n  if (world != null && server == null) {\n    server=\"global\";\n  }\n  this.permission=permission;\n  this.value=value;\n  this.override=override;\n  this.expireAt=expireAt;\n  this.server=server;\n  this.world=world;\n  this.contexts=contexts == null ? ContextSet.empty() : contexts.makeImmutable();\n}", "comment": "make an immutable node instance", "label": "what"}
{"id": "85209", "raw_code": "public Cell(int rowspan,int colspan){\n  this.rowspan=Math.max(rowspan,1);\n  this.colspan=Math.max(colspan,1);\n}", "comment": "creates a cell which takes a custom amount of cell spaces in the table .", "label": "what"}
{"id": "21141", "raw_code": "private void initializeLocalAndTargetInfo() throws Exception {\n  targetSiteInfo=coordinator.getTargetInfo(SiteInfo.class);\n  if (targetSiteInfo == null) {\n    targetSiteInfo=new SiteInfo();\n    try {\n      coordinator.setTargetInfo(targetSiteInfo,false);\n      log.info(\"Step1b: Target site info set to: {}\",targetSiteInfo);\n    }\n catch (    CoordinatorClientException e) {\n      log.info(\"Step1b: Wait another control node to set target\");\n      retrySleep();\n      throw e;\n    }\n  }\n  localVdcPropInfo=localRepository.getVdcPropertyInfo();\n  String localConfigVersion=localVdcPropInfo.getProperty(VdcConfigUtil.VDC_CONFIG_VERSION);\n  coordinator.setNodeSessionScopeInfo(new VdcConfigVersion(localConfigVersion));\n  targetVdcPropInfo=loadVdcConfig();\n  if (isGeoUpgradeFromPreYoda()) {\n    log.info(\"Detect vdc properties from preyoda. Keep local vdc config properties unchanged until all vdc configs are migrated to zk\");\n    localVdcPropInfo.addProperty(VdcConfigUtil.VDC_CONFIG_VERSION,String.valueOf(targetSiteInfo.getVdcConfigVersion()));\n    localRepository.setVdcPropertyInfo(localVdcPropInfo);\n  }\n else {\n    if (localVdcPropInfo.getProperty(VdcConfigUtil.VDC_CONFIG_VERSION) == null) {\n      localVdcPropInfo=new PropertyInfoExt(targetVdcPropInfo.getAllProperties());\n      localVdcPropInfo.addProperty(VdcConfigUtil.VDC_CONFIG_VERSION,String.valueOf(targetSiteInfo.getVdcConfigVersion()));\n      localRepository.setVdcPropertyInfo(localVdcPropInfo);\n      String vdc_ids=targetVdcPropInfo.getProperty(VdcConfigUtil.VDC_IDS);\n      String[] vdcIds=vdc_ids.split(\",\");\n      if (vdcIds.length > 1) {\n        log.info(\"More than one Vdc, rebooting\");\n        reboot();\n      }\n    }\n  }\n  targetPowerOffState=coordinator.getTargetInfo(PowerOffState.class);\n  if (targetPowerOffState == null) {\n    try {\n      coordinator.setTargetInfo(new PowerOffState(PowerOffState.State.NONE));\n      targetPowerOffState=coordinator.getTargetInfo(PowerOffState.class);\n      log.info(\"Step1b: Target poweroff state set to: {}\",PowerOffState.State.NONE);\n    }\n catch (    CoordinatorClientException e) {\n      log.info(\"Step1b: Wait another control node to set target\");\n      retrySleep();\n      throw e;\n    }\n  }\n}", "comment": "initialize local and target info", "label": "what"}
{"id": "39556", "raw_code": "@Override public void openElement(String tagName){\n  XMLElement newElement=new XMLElement();\n  newElement.setName(tagName);\n  current.addChild(newElement);\n  stack.push(current);\n  current=newElement;\n}", "comment": "puts a new element into the dom document .", "label": "what"}
{"id": "53910", "raw_code": "public Format(String pFormatString){\n  String formatVars[]=pFormatString.split(\"/\");\n  mId=Integer.parseInt(formatVars[0]);\n}", "comment": "construct this object from one of the strings in the \" fmt _ list \" parameter", "label": "what"}
{"id": "5535", "raw_code": "public boolean equals(Object interval){\n  if (intervals == null) {\n    return false;\n  }\n  return intervals.contains(interval);\n}", "comment": "determine the matching test .", "label": "what"}
{"id": "27586", "raw_code": "public JournalIndex(final IRawStore store,final Checkpoint checkpoint,final IndexMetadata metadata,final boolean readOnly){\n  super(store,checkpoint,metadata,readOnly);\n}", "comment": "load from the store .", "label": "what"}
{"id": "50108", "raw_code": "private void accesBreakpointInstruction(ArrayList<Instruction> instructions,int lineNumber,int op,BPINSTRUCTION_STATUS status){\n  for (int i=0; i < instructions.size(); i++) {\n    Instruction currInst=instructions.get(i);\n    if (op == 0) {\n      if (currInst instanceof MRJobInstruction) {\n        MRJobInstruction currMRInst=(MRJobInstruction)currInst;\n        if (currMRInst.findMRInstructions(lineNumber)) {\n          BreakPointInstruction breakpoint=new BreakPointInstruction();\n          breakpoint.setLocation(currInst);\n          breakpoint.setInstID(instID++);\n          breakpoint.setBPInstructionLocation(location);\n          instructions.add(i,breakpoint);\n          DMLBreakpointManager.insertBreakpoint(breakpoint,lineNumber);\n          return;\n        }\n      }\n else       if (currInst instanceof CPInstruction || currInst instanceof SPInstruction) {\n        if (currInst.getLineNum() == lineNumber) {\n          BreakPointInstruction breakpoint=new BreakPointInstruction();\n          breakpoint.setLocation(currInst);\n          breakpoint.setInstID(instID++);\n          breakpoint.setBPInstructionLocation(location);\n          instructions.add(i,breakpoint);\n          DMLBreakpointManager.insertBreakpoint(breakpoint,lineNumber);\n          return;\n        }\n      }\n else       if (currInst instanceof BreakPointInstruction && currInst.getLineNum() == lineNumber) {\n        BreakPointInstruction breakpoint=(BreakPointInstruction)currInst;\n        breakpoint.setBPInstructionStatus(BPINSTRUCTION_STATUS.ENABLED);\n        breakpoint.setBPInstructionLocation(location);\n        instructions.set(i,breakpoint);\n        DMLBreakpointManager.updateBreakpoint(lineNumber,status);\n        return;\n      }\n    }\n else {\n      if (currInst instanceof BreakPointInstruction && currInst.getLineNum() == lineNumber) {\n        if (op == 1) {\n          BreakPointInstruction breakpoint=(BreakPointInstruction)currInst;\n          breakpoint.setLocation(currInst);\n          breakpoint.setInstID(currInst.getInstID());\n          breakpoint.setBPInstructionStatus(status);\n          breakpoint.setBPInstructionLocation(location);\n          instructions.set(i,breakpoint);\n          DMLBreakpointManager.updateBreakpoint(lineNumber,status);\n        }\n else {\n          instructions.remove(i);\n          DMLBreakpointManager.removeBreakpoint(lineNumber,status);\n        }\n        return;\n      }\n    }\n  }\n}", "comment": "access breakpoint instruction at specified line number in set of instructions ( if valid )", "label": "what"}
{"id": "19718", "raw_code": "private void closeFile(){\n  if (plogStream != null) {\n    try {\n      plogStream.close();\n      logger.info(\"File \" + plogFilename + \" closed.\");\n    }\n catch (    IOException e) {\n      logger.warn(\"Unable to close file cleanly: \" + plogFilename);\n    }\n finally {\n      plogStream=null;\n    }\n  }\n}", "comment": "close plog file .", "label": "what"}
{"id": "41410", "raw_code": "private void parseFirstConsonant(){\n  Iterator iter=alFirstConsonants.iterator();\n  while (iter.hasNext()) {\n    String strFirstCon=(String)iter.next();\n    if (strSyllable.startsWith(strFirstCon,iCurPos)) {\n      strFirstConsonant=strFirstCon;\n      iCurPos+=strFirstCon.length();\n      return;\n    }\n  }\n  strFirstConsonant=ZERO;\n}", "comment": "parses the first consonant .", "label": "what"}
{"id": "80158", "raw_code": "private BuddyPanelController(){\n  buddyPanel=new JPanel();\n  buddyPanel.setLayout(new SBoxLayout(SBoxLayout.VERTICAL));\n  model=new BuddyListModel();\n  JList<Buddy> list=new BuddyPanel(model);\n  buddyPanel.add(list,SLayout.EXPAND_X);\n}", "comment": "creates a new buddypanelcontroller .", "label": "what"}
{"id": "38403", "raw_code": "private void removeGapsWithEdgeConcentration(int nodesLevel[]){\n  final int temp=m_nodes.size(), temp2=graphMatrix[0].length;\n  int tempCnt=1;\n  for (int n=0; n < temp; n++) {\n    for (int i=0; i < temp2; i++) {\n      if (graphMatrix[n][i] > 0) {\n        if (nodesLevel[i] > nodesLevel[n] + 1) {\n          int tempLevel=nodesLevel[n];\n          boolean tempNodePresent=false;\n          int k=temp;\n          int tempnode=n;\n          while (tempLevel < nodesLevel[i] - 1) {\n            tempNodePresent=false;\n            for (; k < graphMatrix.length; k++) {\n              if (graphMatrix[tempnode][k] > 0) {\n                tempNodePresent=true;\n                break;\n              }\n            }\n            if (tempNodePresent) {\n              tempnode=k;\n              k=k + 1;\n              tempLevel++;\n            }\n else {\n              if (tempnode != n) {\n                tempnode=k - 1;\n              }\n              break;\n            }\n          }\n          if (m_nodes.get(tempnode).nodeType == SINGULAR_DUMMY) {\n            m_nodes.get(tempnode).nodeType=PLURAL_DUMMY;\n          }\n          if (tempNodePresent) {\n            graphMatrix[tempnode][i]=graphMatrix[n][i];\n            graphMatrix[i][tempnode]=-graphMatrix[n][i];\n            graphMatrix[n][i]=0;\n            graphMatrix[i][n]=0;\n            continue;\n          }\n          int len=graphMatrix.length;\n          int tempMatrix[][]=new int[graphMatrix.length + (nodesLevel[i] - nodesLevel[tempnode] - 1)][graphMatrix.length + (nodesLevel[i] - nodesLevel[tempnode] - 1)];\n          int level=nodesLevel[tempnode] + 1;\n          copyMatrix(graphMatrix,tempMatrix);\n          String s1=new String(\"S\" + tempCnt++);\n          m_nodes.add(new GraphNode(s1,s1,SINGULAR_DUMMY));\n          int temp3[]=new int[nodeLevels[level].length + 1];\n          System.arraycopy(nodeLevels[level],0,temp3,0,nodeLevels[level].length);\n          temp3[temp3.length - 1]=m_nodes.size() - 1;\n          nodeLevels[level]=temp3;\n          temp3=new int[m_nodes.size() + 1];\n          System.arraycopy(nodesLevel,0,temp3,0,nodesLevel.length);\n          temp3[m_nodes.size() - 1]=level;\n          nodesLevel=temp3;\n          level++;\n          int m;\n          for (m=len; m < len + nodesLevel[i] - nodesLevel[tempnode] - 1 - 1; m++) {\n            String s2=new String(\"S\" + tempCnt++);\n            m_nodes.add(new GraphNode(s2,s2,SINGULAR_DUMMY));\n            temp3=new int[nodeLevels[level].length + 1];\n            System.arraycopy(nodeLevels[level],0,temp3,0,nodeLevels[level].length);\n            temp3[temp3.length - 1]=m_nodes.size() - 1;\n            nodeLevels[level]=temp3;\n            temp3=new int[m_nodes.size() + 1];\n            System.arraycopy(nodesLevel,0,temp3,0,nodesLevel.length);\n            temp3[m_nodes.size() - 1]=level;\n            nodesLevel=temp3;\n            level++;\n            tempMatrix[m][m + 1]=tempMatrix[n][i];\n            if (m > len) {\n              tempMatrix[m][m - 1]=-1 * tempMatrix[n][i];\n            }\n          }\n          tempMatrix[m][i]=tempMatrix[n][i];\n          tempMatrix[tempnode][len]=tempMatrix[n][i];\n          tempMatrix[len][tempnode]=-1 * tempMatrix[n][i];\n          tempMatrix[i][m]=-1 * tempMatrix[n][i];\n          if (m > len) {\n            tempMatrix[m][m - 1]=-1 * tempMatrix[n][i];\n          }\n          tempMatrix[n][i]=0;\n          tempMatrix[i][n]=0;\n          graphMatrix=tempMatrix;\n        }\n else {\n          graphMatrix[i][n]=-1 * graphMatrix[n][i];\n        }\n      }\n    }\n  }\n}", "comment": "this method removes gaps from the graph .", "label": "what"}
{"id": "8592", "raw_code": "public static CLPlatform[] listGPUPoweredPlatforms(){\n  CLPlatform[] platforms=listPlatforms();\n  List<CLPlatform> out=new ArrayList<CLPlatform>(platforms.length);\n  for (  CLPlatform platform : platforms) {\n    if (platform.listGPUDevices(true).length > 0)     out.add(platform);\n  }\n  return out.toArray(new CLPlatform[out.size()]);\n}", "comment": "list the opencl implementations that contain at least one gpu device .", "label": "what"}
{"id": "63276", "raw_code": "static boolean isDate(Object obj){\n  return obj instanceof Date && obj.getClass() == Date.class;\n}", "comment": "check whether this object is a date .", "label": "what"}
{"id": "72557", "raw_code": "private static List<Vector2D> buildQuadrilateral(final Vector2D... points){\n  List<Vector2D> quadrilateral=new ArrayList<Vector2D>();\n  for (  Vector2D p : points) {\n    if (!quadrilateral.contains(p)) {\n      quadrilateral.add(p);\n    }\n  }\n  return quadrilateral;\n}", "comment": "build the convex quadrilateral with the found corner points ( with min / max x / y coordinates ) .", "label": "what"}
{"id": "53920", "raw_code": "private static boolean isSubFormat(String filename){\n  for (  String ext : SUB_EXTENSIONS) {\n    if (filename.contains(\".\" + ext)) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "test if file is subtitle format", "label": "what"}
{"id": "48646", "raw_code": "void write(Environment env,DataOutputStream out,ConstantPool tab) throws IOException {\n  out.writeByte(CONSTANT_NAMEANDTYPE);\n  out.writeShort(tab.index(name));\n  out.writeShort(tab.index(type));\n}", "comment": "write the constant to the output stream", "label": "what"}
{"id": "14974", "raw_code": "public static void initializeProperties(Properties properties,boolean reset,boolean withDefaults){\n  Properties defaultProp=null;\n  if (withDefaults) {\n    SSOToken appToken=AccessController.doPrivileged(AdminTokenAction.getInstance());\n    defaultProp=ServerConfiguration.getDefaults(appToken);\n  }\n  PropertiesHolder oldProps;\n  PropertiesHolder newProps;\n  do {\n    oldProps=propertiesHolderRef.get();\n    final Properties combined=new Properties();\n    if (defaultProp != null) {\n      combined.putAll(defaultProp);\n    }\n    if (!reset) {\n      combined.putAll(oldProps.properties);\n    }\n    combined.putAll(properties);\n    newProps=new PropertiesHolder(Maps.fromProperties(combined));\n  }\n while (!propertiesHolderRef.compareAndSet(oldProps,newProps));\n}", "comment": "initializes the properties to be used by openam .", "label": "what"}
{"id": "73423", "raw_code": "public void addNetworkListener(final NetworkListener listener){\n  networkListeners.add(listener);\n}", "comment": "register a network listener .", "label": "what"}
{"id": "73271", "raw_code": "public void addErrorListener(final ErrorListener errorListener){\n  if (errorListeners == null) {\n    errorListeners=new ArrayList<ErrorListener>();\n  }\n  errorListeners.add(errorListener);\n}", "comment": "add an error listener .", "label": "what"}
{"id": "36816", "raw_code": "public static void importBaseTypes(final CConnection connection,final int rawModuleId,final int moduleId) throws SQLException {\n  final String query=\"INSERT INTO \" + CTableNames.BASE_TYPES_TABLE + \" SELECT \"+ moduleId+ \", id, name, size, pointer, signed \"+ \"FROM \"+ String.format(CTableNames.RAW_BASE_TYPES,rawModuleId);\n  connection.executeUpdate(query,true);\n  final String updateSequence=String.format(\"SELECT setval('bn_base_types_id_seq', \" + \"COALESCE((SELECT MAX(id) + 1 FROM %s), 1), false) from %s\",CTableNames.BASE_TYPES_TABLE,CTableNames.BASE_TYPES_TABLE);\n  connection.executeQuery(updateSequence,true);\n}", "comment": "imports the base types .", "label": "what"}
{"id": "39386", "raw_code": "@SuppressWarnings(\"deprecation\") public Object readMatrixOld(Element node) throws Exception {\n  weka.core.Matrix matrix;\n  weka.core.matrix.Matrix matrixNew;\n  if (DEBUG) {\n    trace(new Throwable(),node.getAttribute(ATT_NAME));\n  }\n  m_CurrentNode=node;\n  matrixNew=(weka.core.matrix.Matrix)readMatrix(node);\n  matrix=new weka.core.Matrix(matrixNew.getArrayCopy());\n  return matrix;\n}", "comment": "builds the matrix ( old ) from the given dom node .", "label": "what"}
{"id": "21908", "raw_code": "public void recordFileSystemOperation(DbClient dbClient,OperationTypeEnum opType,Operation.Status status,Object... extParam){\n  try {\n    boolean opStatus=(Operation.Status.ready == status) ? true : false;\n    String evType;\n    evType=opType.getEvType(opStatus);\n    String evDesc=opType.getDescription();\n    String opStage=AuditLogManager.AUDITOP_END;\n    _logger.info(\"opType: {} detail: {}\",opType.toString(),evType.toString() + ':' + evDesc);\n    URI uri=(URI)extParam[0];\n    recordBourneFileSystemEvent(dbClient,evType,status,evDesc,uri);\n    auditFile(dbClient,opType,opStatus,opStage,uri.toString());\n  }\n catch (  Exception e) {\n    _logger.error(\"Failed to record filesystem operation {}, err:\",opType.toString(),e);\n  }\n}", "comment": "record filesystem related event and audit", "label": "what"}
{"id": "15439", "raw_code": "public CoreTokenException(int errorCode){\n  this.errorCode=errorCode;\n  this.message=getLocalizedMessage(Locale.getDefault());\n}", "comment": "creates a core token service exception .", "label": "what"}
{"id": "9781", "raw_code": "public DExamineSsl(JFrame parent,KseFrame kseFrame){\n  super(parent,res.getString(\"DExamineSsl.Title\"),Dialog.ModalityType.DOCUMENT_MODAL);\n  this.kseFrame=kseFrame;\n  initComponents();\n}", "comment": "creates new dexaminessl dialog .", "label": "what"}
{"id": "84940", "raw_code": "private static List<String> computeDynamicVMArgs(IJavaProject javaProject){\n  ArrayList<String> out=new ArrayList<String>();\n  String devJarPath=maybeGetDevJarPath(javaProject);\n  if (devJarPath.length() > 0) {\n    out.add(\"-Dgwt.devjar=\\\"\" + devJarPath + '\"');\n  }\n  return out;\n}", "comment": "dynamic vm args common to both computejunitdynamicvmargsaslist and computecompiledynamicvmargsaslist .", "label": "what"}
{"id": "10002", "raw_code": "static void normalize(StringBuilder number){\n  String normalizedNumber=normalize(number.toString());\n  number.replace(0,number.length(),normalizedNumber);\n}", "comment": "normalizes a string of characters representing a phone number .", "label": "what"}
{"id": "72433", "raw_code": "public double[] skipTo(final int index) throws MathIllegalArgumentException {\n  if (index == 0) {\n    Arrays.fill(x,0);\n  }\n else {\n    final int i=index - 1;\n    final long grayCode=i ^ (i >> 1);\n    for (int j=0; j < dimension; j++) {\n      long result=0;\n      for (int k=1; k <= BITS; k++) {\n        final long shift=grayCode >> (k - 1);\n        if (shift == 0) {\n          break;\n        }\n        final long ik=shift & 1;\n        result^=ik * direction[j][k];\n      }\n      x[j]=result;\n    }\n  }\n  count=index;\n  return nextVector();\n}", "comment": "skip to the i - th point in the sobol sequence .", "label": "what"}
{"id": "14765", "raw_code": "public void removeOrganizationConfiguration(String orgName,String groupName,boolean checkLegacyMode) throws SMSException, SSOException {\n  if ((groupName == null) || groupName.length() == 0) {\n    groupName=SMSUtils.DEFAULT;\n  }\n  String orgdn=DNMapper.orgNameToDN(orgName);\n  validateSCM();\n  String odn=scm.constructServiceConfigDN(groupName,CreateServiceConfig.ORG_CONFIG_NODE,orgdn);\n  CachedSMSEntry cEntry=CachedSMSEntry.getInstance(token,odn);\n  if (cEntry.isNewEntry()) {\n    return;\n  }\n  if (checkLegacyMode && ServiceManager.isCoexistenceMode() && groupName.equalsIgnoreCase(SMSUtils.DEFAULT)) {\n    OrgConfigViaAMSDK amsdk=new OrgConfigViaAMSDK(token,DNMapper.realmNameToAMSDKName(orgdn),orgdn);\n    amsdk.unassignService(serviceName);\n  }\n  if (!cEntry.isNewEntry()) {\n    SMSEntry entry=cEntry.getClonedSMSEntry();\n    entry.delete(token);\n    cEntry.refresh(entry);\n  }\n}", "comment": "deletes the organization ' s group configuration data .", "label": "what"}
{"id": "73430", "raw_code": "public void removeGroupListener(final GroupListener listener){\n  groupListeners.remove(listener);\n}", "comment": "remove a group listener .", "label": "what"}
{"id": "49174", "raw_code": "public boolean grabInput(){\n  if (grabLog.isLoggable(PlatformLogger.Level.FINE)) {\n    grabLog.fine(\"Grab input on {0}\",this);\n  }\n  XToolkit.awtLock();\n  try {\n    if (XAwtState.getGrabWindow() == this && XAwtState.isManualGrab()) {\n      grabLog.fine(\"    Already Grabbed\");\n      return true;\n    }\n    XBaseWindow prevGrabWindow=XAwtState.getGrabWindow();\n    final int eventMask=(int)(XConstants.ButtonPressMask | XConstants.ButtonReleaseMask | XConstants.EnterWindowMask| XConstants.LeaveWindowMask| XConstants.PointerMotionMask| XConstants.ButtonMotionMask);\n    final int ownerEvents=1;\n    if (!XToolkit.getSunAwtDisableGrab()) {\n      int ptrGrab=XlibWrapper.XGrabPointer(XToolkit.getDisplay(),getContentWindow(),ownerEvents,eventMask,XConstants.GrabModeAsync,XConstants.GrabModeAsync,XConstants.None,(XWM.isMotif() ? XToolkit.arrowCursor : XConstants.None),XConstants.CurrentTime);\n      if (ptrGrab != XConstants.GrabSuccess) {\n        XlibWrapper.XUngrabPointer(XToolkit.getDisplay(),XConstants.CurrentTime);\n        XAwtState.setGrabWindow(null);\n        grabLog.fine(\"    Grab Failure - mouse\");\n        return false;\n      }\n      int keyGrab=XlibWrapper.XGrabKeyboard(XToolkit.getDisplay(),getContentWindow(),ownerEvents,XConstants.GrabModeAsync,XConstants.GrabModeAsync,XConstants.CurrentTime);\n      if (keyGrab != XConstants.GrabSuccess) {\n        XlibWrapper.XUngrabPointer(XToolkit.getDisplay(),XConstants.CurrentTime);\n        XlibWrapper.XUngrabKeyboard(XToolkit.getDisplay(),XConstants.CurrentTime);\n        XAwtState.setGrabWindow(null);\n        grabLog.fine(\"    Grab Failure - keyboard\");\n        return false;\n      }\n    }\n    if (prevGrabWindow != null) {\n      prevGrabWindow.ungrabInputImpl();\n    }\n    XAwtState.setGrabWindow(this);\n    grabLog.fine(\"    Grab - success\");\n    return true;\n  }\n  finally {\n    XToolkit.awtUnlock();\n  }\n}", "comment": "we should always grab both keyboard and pointer to control event flow on popups .", "label": "what"}
{"id": "33926", "raw_code": "public ComponentManager(Collection<Sequence> generalSeeds){\n  Set<Sequence> seedSet=new LinkedHashSet<>(generalSeeds.size());\n  seedSet.addAll(generalSeeds);\n  this.gralSeeds=Collections.unmodifiableSet(seedSet);\n  gralComponents=new SequenceCollection(seedSet);\n}", "comment": "create a component manager , initially populated with the given sequences , which are considered seed sequences .", "label": "what"}
{"id": "82316", "raw_code": "public synchronized void deleteObservers(){\n  observers.clear();\n}", "comment": "removes all observers from the list of observers .", "label": "what"}
{"id": "68796", "raw_code": "private byte[] calculateGeneralEncryptionKey(byte[] userPassword,byte[] firstDocIdValue,int keyBitLength,int revision,byte[] oValue,int pValue,boolean encryptMetadata) throws GeneralSecurityException {\n  final byte[] paddedPassword=padPassword(userPassword);\n  MessageDigest md5=createMD5Digest();\n  md5.reset();\n  md5.update(paddedPassword);\n  md5.update(oValue);\n  md5.update((byte)(pValue & 0xFF));\n  md5.update((byte)((pValue >> 8) & 0xFF));\n  md5.update((byte)((pValue >> 16) & 0xFF));\n  md5.update((byte)(pValue >> 24));\n  if (firstDocIdValue != null) {\n    md5.update(firstDocIdValue);\n  }\n  if (revision >= 4 && !encryptMetadata) {\n    for (int i=0; i < 4; ++i) {\n      md5.update((byte)0xFF);\n    }\n  }\n  byte[] hash=md5.digest();\n  final int keyLen=revision == 2 ? 5 : (keyBitLength / 8);\n  final byte[] key=new byte[keyLen];\n  if (revision >= 3) {\n    for (int i=0; i < 50; ++i) {\n      md5.update(hash,0,key.length);\n      digestTo(md5,hash);\n    }\n  }\n  System.arraycopy(hash,0,key,0,key.length);\n  return key;\n}", "comment": "determine what the general encryption key is , given a configuration .", "label": "what"}
{"id": "44697", "raw_code": "public MessageCapture(final Logger logger,final boolean captureEntity){\n  this(logger,captureEntity,false);\n}", "comment": "builds a new messagecapture .", "label": "what"}
{"id": "65380", "raw_code": "private boolean pythonErrorIn(String output){\n  boolean isError=false;\n  String[] outputMultiline=output.split(\"\\n\");\n  Matcher errorMatcher;\n  for (  String row : outputMultiline) {\n    errorMatcher=errorInLastLine.matcher(row);\n    if (errorMatcher.find() == true) {\n      isError=true;\n      break;\n    }\n  }\n  return isError;\n}", "comment": "checks if there is a syntax error or an exception", "label": "what"}
{"id": "57345", "raw_code": "public static String numberToString(Number number) throws JSONException {\n  if (number == null) {\n    throw new JSONException(\"Number must be non-null\");\n  }\n  double doubleValue=number.doubleValue();\n  JSON.checkDouble(doubleValue);\n  if (number.equals(NEGATIVE_ZERO)) {\n    return \"-0\";\n  }\n  long longValue=number.longValue();\n  if (doubleValue == (double)longValue) {\n    return Long.toString(longValue);\n  }\n  return number.toString();\n}", "comment": "encodes the number as a json string .", "label": "what"}
{"id": "26465", "raw_code": "public static Map<String,String> strToMap(String str,String delim,boolean trim,String pairsSeparator){\n  if (str == null)   return null;\n  Map<String,String> decodedMap=new HashMap<String,String>();\n  List<String> elements=split(str,delim);\n  pairsSeparator=pairsSeparator == null ? \"=\" : pairsSeparator;\n  for (  String s : elements) {\n    List<String> e=split(s,pairsSeparator);\n    if (e.size() != 2) {\n      continue;\n    }\n    String name=e.get(0);\n    String value=e.get(1);\n    if (trim) {\n      if (name != null) {\n        name=name.trim();\n      }\n      if (value != null) {\n        value=value.trim();\n      }\n    }\n    try {\n      decodedMap.put(URLDecoder.decode(name,\"UTF-8\"),URLDecoder.decode(value,\"UTF-8\"));\n    }\n catch (    UnsupportedEncodingException e1) {\n      Debug.logError(e1,module);\n    }\n  }\n  return decodedMap;\n}", "comment": "creates a map from a name / value pair string", "label": "what"}
{"id": "53048", "raw_code": "public Set<T> keySet(){\n  return Collections.unmodifiableSet(map.keySet());\n}", "comment": "the item keys contained in the map .", "label": "what"}
{"id": "69965", "raw_code": "@SuppressWarnings(\"unchecked\") public PropagationImp(Stack<CompositeTransaction> lineage,boolean serial,long timeout){\n  serial_=serial;\n  lineage_=(Stack<CompositeTransaction>)lineage.clone();\n  timeout_=timeout;\n}", "comment": "construct a new instance .", "label": "what"}
{"id": "361", "raw_code": "public NativeRunner(File eclipsec){\n  this.eclipsec=Objects.requireNonNull(eclipsec);\n}", "comment": "pass it the location of the launcher file .", "label": "what"}
{"id": "10255", "raw_code": "public static String surround(String string,String prefix,String suffix){\n  if (string.startsWith(prefix) == false) {\n    string=prefix + string;\n  }\n  if (string.endsWith(suffix) == false) {\n    string+=suffix;\n  }\n  return string;\n}", "comment": "surrounds the string with provided prefix and suffix if such missing from string .", "label": "what"}
{"id": "15990", "raw_code": "public CipherParameters decrypt(byte[] in,int keyLen){\n  return decrypt(in,0,in.length,keyLen);\n}", "comment": "decrypt an encapsulated session key .", "label": "what"}
{"id": "17423", "raw_code": "private void beforeValue() throws JSONException {\n  if (stack.isEmpty()) {\n    return;\n  }\n  Scope context=peek();\n  if (context == Scope.EMPTY_ARRAY) {\n    replaceTop(Scope.NONEMPTY_ARRAY);\n    newline();\n  }\n else   if (context == Scope.NONEMPTY_ARRAY) {\n    out.append(',');\n    newline();\n  }\n else   if (context == Scope.DANGLING_KEY) {\n    out.append(indent == null ? \":\" : \": \");\n    replaceTop(Scope.NONEMPTY_OBJECT);\n  }\n else   if (context != Scope.NULL) {\n    throw new JSONException(\"Nesting problem\");\n  }\n}", "comment": "inserts any necessary separators and whitespace before a literal value , inline array , or inline object .", "label": "what"}
{"id": "9495", "raw_code": "public static byte[] hash(String input){\n  if (!TextUtils.isEmpty(input)) {\n    try {\n      byte[] inputBytes=input.getBytes(\"UTF-8\");\n      return hash(inputBytes);\n    }\n catch (    UnsupportedEncodingException e) {\n      Log.e(TAG,\"problem hashing \\\"\" + input + \"\\\" \"+ e.getMessage(),e);\n    }\n  }\n  return null;\n}", "comment": "created sha256 of input", "label": "what"}
{"id": "21687", "raw_code": "public static String generateTransportZoneNativeGuid(String transportType,String deviceType,String fabricId){\n  return String.format(\"%s+%s+%s\",transportType,_deviceTypeMap.get(deviceType),fabricId);\n}", "comment": "the format of this native guid is transporttype + devicetype + fabricwwn .", "label": "what"}
{"id": "8003", "raw_code": "@Override public boolean equalsValue(final Object other){\n  return Objects.equals(this.value,other);\n}", "comment": "indicates whether some other object is \" equal to \" the value .", "label": "what"}
{"id": "14468", "raw_code": "public static void error(String msg,Throwable t){\n  debugInst.debug(IDebug.ERROR,msg,t);\n}", "comment": "error level debug message", "label": "what"}
{"id": "23130", "raw_code": "public void removeEventListener(SIPTransactionEventListener oldListener){\n  eventListeners.remove(oldListener);\n}", "comment": "removed an event listener from this transaction .", "label": "what"}
{"id": "67907", "raw_code": "public void send(XTraceReport report){\n  outgoing.offer(report);\n}", "comment": "enqueues the provided report to be sent by the reporting thread", "label": "what"}
{"id": "11297", "raw_code": "public boolean fireMapMouseClicked(MouseEvent evt){\n  if (DEBUG) {\n    logger.fine(\"MapMouseSupport: fireMapMouseClicked\");\n  }\n  clickHappened=true;\n  boolean consumed=false;\n  evt=new MapMouseEvent(getParentMode(),evt);\n  if (priorityListener != null && evt.getClickCount() > 1) {\n    priorityListener.mouseClicked(evt);\n    consumed=true;\n  }\n  priorityListener=null;\n  if (proxy == null || evt.isShiftDown() || (proxyDistributionMask & PROXY_DISTRIB_MOUSE_CLICKED) > 0) {\n    Iterator<MapMouseListener> it=iterator();\n    while (it.hasNext() && !consumed) {\n      MapMouseListener target=it.next();\n      consumed=target.mouseClicked(evt) && consumeEvents;\n      if (consumed) {\n        priorityListener=target;\n      }\n    }\n  }\n  boolean ignoreConsumed=!consumed || (consumed && ((proxyDistributionMask & PROXY_ACK_CONSUMED_MOUSE_CLICKED) == 0));\n  if (proxy != null && ignoreConsumed && !evt.isShiftDown()) {\n    proxy.mouseClicked(evt);\n    consumed=true;\n  }\n  return consumed;\n}", "comment": "handle a mouseclicked mouselistener event .", "label": "what"}
{"id": "55131", "raw_code": "private void emitClass(DocComment comment){\n  String tagName=(comment.getType() == DocComment.CLASS) ? \"classRec\" : \"interfaceRec\";\n  xml.append(\"\\n<\");\n  xml.append(tagName);\n  xml.append(\" name='\");\n  xml.append(comment.getName());\n  xml.append(\"' fullname='\");\n  xml.append(comment.getFullname());\n  String sourcefile=comment.getSourceFile();\n  if (sourcefile != null) {\n    xml.append(\"' sourcefile='\");\n    xml.append(sourcefile);\n  }\n  xml.append(\"' namespace='\");\n  xml.append(comment.getNamespace());\n  xml.append(\"' access='\");\n  xml.append(comment.getAccess());\n  xml.append(\"' \");\n  if (comment.getType() == DocComment.INTERFACE) {\n    String[] baseClasses=comment.getBaseclasses();\n    if (baseClasses != null) {\n      xml.append(\"baseClasses='\");\n      for (int i=0; i < baseClasses.length; i++) {\n        String baseclass=baseClasses[i];\n        if (baseclass != null) {\n          if (i != 0)           xml.append(\";\");\n          xml.append(baseclass);\n        }\n      }\n      xml.append(\"' \");\n    }\n  }\n else {\n    xml.append(\"baseclass='\");\n    xml.append(comment.getBaseClass());\n    xml.append(\"' \");\n    String[] interfaces=comment.getInterfaces();\n    if (interfaces != null) {\n      xml.append(\"interfaces='\");\n      for (int i=0; i < interfaces.length; i++) {\n        String inter=interfaces[i];\n        if (inter != null) {\n          if (i != 0)           xml.append(\";\");\n          xml.append(inter);\n        }\n      }\n      xml.append(\"' \");\n    }\n  }\n  xml.append(\"isFinal='\");\n  xml.append(comment.isFinal());\n  xml.append(\"' \");\n  xml.append(\"isDynamic='\");\n  xml.append(comment.isDynamic());\n  xml.append(\"' \");\n  xml.append(\">\");\n  String desc=comment.getDescription();\n  if (desc != null)   appendTag(\"description\",comment.getDescription());\n  emitTags(comment.getAllTags());\n  if (comment.getMetadata() != null)   emitMetadata(comment.getMetadata());\n  xml.append(\"\\n</\");\n  xml.append(tagName);\n  xml.append(\">\");\n}", "comment": "appends a class or interface", "label": "what"}
{"id": "66420", "raw_code": "protected void paintContentBorderTopEdge(Graphics g,int x,int y,int w,int h,boolean drawBroken,Rectangle selRect,boolean isContentBorderPainted){\n  if (isContentBorderPainted) {\n    g.setColor(selectHighlight);\n    g.fillRect(x,y,w - 1,1);\n  }\n}", "comment": "draws the top edge of the border around the content area .", "label": "what"}
{"id": "83228", "raw_code": "public void analyzeAllItAndWriteResults(){\n  RunResultsLoader runDir=new RunResultsLoader(runDirectory,null);\n  PrintStream stream;\n  try {\n    stream=new PrintStream(new File(outputDir + \"routesAndTTs.txt\"));\n  }\n catch (  FileNotFoundException e) {\n    e.printStackTrace();\n    return;\n  }\n  String header=\"it\\ttotal tt[s]\\t#users up\\t#users mid\\t#users low\\tavg tt[s] up\\tavg tt[s] mid\\tavg tt[s] low\";\n  stream.println(header);\n  double totalTTIt;\n  double[] avgRouteTTsIt;\n  int[] routeUsersIt;\n  for (int i=0; i <= lastIteration; i++) {\n    log.info(\"Starting to analyze iteration \" + i + \" of \"+ lastIteration+ \" iterations.\");\n    String eventsFilename=runDir.getEventsFilename(i);\n    EventsManager eventsManager=new EventsManagerImpl();\n    TtAnalyzeBraess handler=new TtAnalyzeBraess();\n    eventsManager.addHandler(handler);\n    MatsimEventsReader reader=new MatsimEventsReader(eventsManager);\n    reader.readFile(eventsFilename);\n    totalTTIt=handler.getTotalTT();\n    avgRouteTTsIt=handler.calculateAvgRouteTTs();\n    routeUsersIt=handler.getRouteUsers();\n    StringBuffer line=new StringBuffer();\n    line.append(i + \"\\t\" + totalTTIt);\n    for (int j=0; j < 3; j++) {\n      line.append(\"\\t\" + routeUsersIt[j]);\n    }\n    for (int j=0; j < 3; j++) {\n      line.append(\"\\t\" + avgRouteTTsIt[j]);\n    }\n    stream.println(line.toString());\n  }\n  stream.close();\n  log.info(lastIteration + \" Iterations analyzed.\");\n}", "comment": "analyzes all iterations in terms of route choice and travel time", "label": "what"}
{"id": "71410", "raw_code": "public int executeUpdate(String sql) throws SQLException {\n  return Util.truncateAndConvertToInt(executeLargeUpdate(sql));\n}", "comment": "execute a sql insert , update or delete statement .", "label": "what"}
{"id": "71906", "raw_code": "public static Entry makeEntry(List<String> ldifLines){\n  return makeEntry(ldifLines.toArray(new String[ldifLines.size()]));\n}", "comment": "builds an entry from the provided lines of ldif .", "label": "what"}
{"id": "45001", "raw_code": "void clearParserHighlights(){\n  for (int i=0; i < parserHighlights.size(); i++) {\n    Object tag=parserHighlights.get(i);\n    if (tag instanceof LayeredHighlightInfo) {\n      LayeredHighlightInfo lhi=(LayeredHighlightInfo)tag;\n      if (lhi.width > 0 && lhi.height > 0) {\n        textArea.repaint(lhi.x,lhi.y,lhi.width,lhi.height);\n      }\n    }\n else {\n      HighlightInfo info=(HighlightInfo)tag;\n      TextUI ui=textArea.getUI();\n      ui.damageRange(textArea,info.getStartOffset(),info.getEndOffset());\n    }\n  }\n  parserHighlights.clear();\n}", "comment": "removes all parser highlights .", "label": "what"}
{"id": "25658", "raw_code": "public int format(int val,byte[] buf,int off,int len){\n  if (val == Integer.MIN_VALUE) {\n    if (len > ByteFormatter.NUMBER_BASE) {\n      return format(\"-2147483648\",buf,off,len);\n    }\n else {\n      truncationFiller(buf,off,len);\n      return off + len;\n    }\n  }\n  int pos=Math.abs(val);\n  int ndig=1;\n  int dmax=ByteFormatter.NUMBER_BASE;\n  while (ndig < ByteFormatter.NUMBER_BASE && pos >= dmax) {\n    ndig++;\n    dmax*=ByteFormatter.NUMBER_BASE;\n  }\n  if (val < 0) {\n    ndig++;\n  }\n  if (ndig > len || ndig > buf.length - off) {\n    truncationFiller(buf,off,len);\n    return off + len;\n  }\n  off+=ndig;\n  int xoff=off - 1;\n  do {\n    buf[xoff]=ByteFormatter.DIGITS[pos % ByteFormatter.NUMBER_BASE];\n    xoff--;\n    pos/=ByteFormatter.NUMBER_BASE;\n  }\n while (pos > 0);\n  if (val < 0) {\n    buf[xoff]=(byte)'-';\n  }\n  return off;\n}", "comment": "format an int into an existing array .", "label": "what"}
{"id": "79222", "raw_code": "public static boolean hasPermission(Security security,GenericValue userLogin,GenericValue orderHeader){\n  if (userLogin == null || orderHeader == null)   return false;\n  if (security.hasEntityPermission(\"ORDERMGR\",\"_VIEW\",userLogin)) {\n    return true;\n  }\n else   if (security.hasEntityPermission(\"ORDERMGR\",\"_ROLEVIEW\",userLogin)) {\n    List<GenericValue> orderRoles=null;\n    try {\n      orderRoles=orderHeader.getRelated(\"OrderRole\",UtilMisc.toMap(\"partyId\",userLogin.getString(\"partyId\")),null,false);\n    }\n catch (    GenericEntityException e) {\n      Debug.logError(e,\"Cannot get OrderRole from OrderHeader\",module);\n    }\n    if (UtilValidate.isNotEmpty(orderRoles)) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "checks to see if this user has read permission on the specified order", "label": "what"}
{"id": "23185", "raw_code": "private boolean isAnnotation(){\n  return implInterfaces.contains(\"java.lang.annotation.Annotation\");\n}", "comment": "sees if the class under test is actually an annotation .", "label": "what"}
{"id": "42399", "raw_code": "public final boolean isExceptionHandlerEquivalent(BasicBlock other){\n  if (exceptionHandlers != other.exceptionHandlers) {\n    Enumeration<BasicBlock> e1=getExceptionHandlers();\n    Enumeration<BasicBlock> e2=other.getExceptionHandlers();\n    while (e1.hasMoreElements()) {\n      if (!e2.hasMoreElements())       return false;\n      if (e1.nextElement() != e2.nextElement())       return false;\n    }\n    if (e2.hasMoreElements())     return false;\n  }\n  return true;\n}", "comment": "compare the in scope exception handlers of two blocks .", "label": "what"}
{"id": "1921", "raw_code": "public SecretBlock(Mario player,Group parent,int stageZone,float xPos,float yPos,float yoloWidth,Image... hitState){\n  super(BLOCK_COLLISION_DATA,xPos,yPos,0,0,(Image)null);\n  this.hitState=hitState[0];\n  yoloView=new ImageView(hitState[1]);\n  yoloView.setFitWidth(yoloWidth);\n  this.parent=parent;\n  zone=stageZone;\n}", "comment": "constructs a single secretblock ( tile which generates one - ups in original game , but \" yolo \" image in this game ) .", "label": "what"}
{"id": "74899", "raw_code": "@SuppressWarnings(\"UnusedReturnValue\") public int readOutlineFileMetadata(final PdfObject OutlinesObj,final PdfObjectReader currentPdfFile){\n  final int count=OutlinesObj.getInt(PdfDictionary.Count);\n  final PdfObject FirstObj=OutlinesObj.getDictionary(PdfDictionary.First);\n  currentPdfFile.checkResolved(FirstObj);\n  if (FirstObj != null) {\n    final Element root=OutlineDataXML.createElement(\"root\");\n    OutlineDataXML.appendChild(root);\n    final int level=0;\n    readOutlineLevel(root,currentPdfFile,FirstObj,level,false);\n  }\n  return count;\n}", "comment": "read the outline data", "label": "what"}
{"id": "75063", "raw_code": "private static byte[] streamToBytes(InputStream in,int length) throws IOException {\n  byte[] bytes=new byte[length];\n  int count;\n  int pos=0;\n  while (pos < length && ((count=in.read(bytes,pos,length - pos)) != -1)) {\n    pos+=count;\n  }\n  if (pos != length) {\n    throw new IOException(\"Expected \" + length + \" bytes, read \"+ pos+ \" bytes\");\n  }\n  return bytes;\n}", "comment": "reads the contents of an inputstream into a byte [ ] .", "label": "what"}
{"id": "53338", "raw_code": "public NoDuplicateValueGlobalConstraint(AbstractParameter<?,?>... parameters){\n  this.parameters=Arrays.asList(parameters);\n}", "comment": "constructs a not - equal - value global parameter constraint .", "label": "what"}
{"id": "31244", "raw_code": "public static RevocationHash bruteForceHash(byte[] seed,byte[] target,int maxChildTries,int maxSiblingTries){\n  for (int i=0; i < maxChildTries; i++) {\n    for (int j=0; j < maxSiblingTries; j++) {\n      RevocationHash test=HashDerivation.calculateRevocationHash(seed,0,j);\n      if (Arrays.equals(test.getSecretHash(),target)) {\n        return new RevocationHash(i,j,test.getSecret(),test.getSecretHash());\n      }\n    }\n    seed=Tools.hashSecret(seed);\n  }\n  return null;\n}", "comment": "the other party has breached the contract and submitted an old channel transaction .", "label": "what"}
{"id": "6412", "raw_code": "protected void loadValue(String sValue){\n  try {\n    value=Byte.parseByte(sValue.trim());\n  }\n catch (  NumberFormatException nfe) {\n    revertToDefault();\n  }\n}", "comment": "load value from property string value", "label": "what"}
{"id": "33732", "raw_code": "private void drawHook(Canvas canvas){\n  Path hookPath=new Path();\n  double sweepAngle=Math.PI / 180 * 180;\n  float y=(float)Math.sin(sweepAngle) * (getBigCircleRadius()) + rectF.height() / 2;\n  float x=(float)Math.cos(sweepAngle) * (getBigCircleRadius()) + rectF.width() / 2;\n  float i=getBigCircleRadius() / 2;\n  hookPath.addRoundRect(new RectF(i + i / 2,i + i / 2,i + i / 2 + 6,i + i + i / 2),3f,3f,Path.Direction.CCW);\n  hookPath.addRoundRect(new RectF(i + i / 2,(i + i + i / 2) - 3f,i + i / 2 + i + i,i + i + i / 2 + 3f),3f,3f,Path.Direction.CCW);\n  Matrix matrix=new Matrix();\n  matrix.reset();\n  int restoreCount=canvas.getSaveCount();\n  hookPath.close();\n  canvas.rotate(-45,rectF.centerX(),rectF.centerY());\n  canvas.drawPath(hookPath,mHookPaint);\n  canvas.restoreToCount(restoreCount);\n}", "comment": "there is some bug and it ' s not perfect .", "label": "what"}
{"id": "25463", "raw_code": "@HLEFunction(nid=0x9AC2EEAC,version=150) public int sceNetAdhocPtpFlush(@CheckArgument(\"checkPtpId\") int id,int timeout,int nonblock){\n  return 0;\n}", "comment": "wait for data in the buffer to be sent", "label": "what"}
{"id": "36429", "raw_code": "public void reset(){\n  displayCache.clear();\n  cachedID.clear();\n}", "comment": "resets the drawer and its caches .", "label": "what"}
{"id": "51939", "raw_code": "private void copyDirectory(File source,File dest) throws IOException {\n  for (  File f : source.listFiles()) {\n    File sourceFile=new File(source,f.getName());\n    File destFile=new File(dest,f.getName());\n    if (f.isDirectory()) {\n      destFile.mkdirs();\n      copyDirectory(sourceFile,destFile);\n    }\n else     copyFile(sourceFile,destFile);\n  }\n}", "comment": "copy an entire directory from one location to another .", "label": "what"}
{"id": "20646", "raw_code": "private synchronized void rebuildJournal() throws IOException {\n  if (mJournalWriter != null) {\n    mJournalWriter.close();\n  }\n  Writer writer=new BufferedWriter(new FileWriter(mJournalFileTmp),IO_BUFFER_SIZE);\n  writer.write(MAGIC);\n  writer.write(\"\\n\");\n  writer.write(VERSION_1);\n  writer.write(\"\\n\");\n  writer.write(Integer.toString(mAppVersion));\n  writer.write(\"\\n\");\n  writer.write(\"\\n\");\n  for (  CacheEntry cacheEntry : mLruEntries.values()) {\n    if (cacheEntry.isUnderEdit()) {\n      writer.write(sACTION_LIST[ACTION_DIRTY] + ' ' + cacheEntry.getKey()+ \" \"+ cacheEntry.getSize()+ '\\n');\n    }\n else {\n      writer.write(sACTION_LIST[ACTION_CLEAN] + ' ' + cacheEntry.getKey()+ \" \"+ cacheEntry.getSize()+ '\\n');\n    }\n  }\n  writer.close();\n  mJournalFileTmp.renameTo(mJournalFile);\n  mJournalWriter=new BufferedWriter(new FileWriter(mJournalFile,true),IO_BUFFER_SIZE);\n}", "comment": "creates a new journal that omits redundant information .", "label": "what"}
{"id": "78215", "raw_code": "private void recordLogData(){\n  try {\n    int size=mRecordingData.size();\n    if (size == 0) {\n      return;\n    }\n    Vector<String> recordingData=new Vector<>(mRecordingData);\n    File logDir=Constants.getRecordDir(this);\n    logDir.mkdirs();\n    File logFile=new File(logDir,mRecordingFilename);\n    FileWriter logFileWriter=new FileWriter(logFile,true);\n    for (int i=0; i < size; i++) {\n      logFileWriter.append(recordingData.elementAt(i) + \"\\n\");\n      mRecordingData.removeElementAt(0);\n    }\n    recordingData.removeAllElements();\n    logFileWriter.close();\n  }\n catch (  Exception e) {\n    Log.e(LOG_TAG,\"recordLogData:Error writing the log to file. Exception: \" + e.toString());\n  }\n}", "comment": "save log data to file", "label": "what"}
{"id": "57313", "raw_code": "private static List<Command> loadRewrites(String str){\n  assert str != null;\n  List<Command> commands=new ArrayList<>();\n  for (  String line : str.split(\"\\n\")) {\n    addLine(commands,line);\n  }\n  return commands;\n}", "comment": "loads the rewrites from tab - separated values .", "label": "what"}
{"id": "54487", "raw_code": "public String format(double val){\n  DecimalFormat df=getDoubleFormat();\n  if (df != null) {\n    return df.format(val);\n  }\n  return Double.toString(val);\n}", "comment": "formats the given double values .", "label": "what"}
{"id": "81528", "raw_code": "public void removePositions(Collection<Integer> positions){\n  ArrayList<Integer> positionsList=new ArrayList<Integer>(positions);\n  Collections.sort(positionsList);\n  Collections.reverse(positionsList);\n  for (  int position : positionsList) {\n    mItems.remove(position);\n  }\n  notifyDataSetChanged();\n}", "comment": "removes all elements at the specified positions in the list", "label": "what"}
{"id": "52259", "raw_code": "private void resetShapeBounds(){\n  RoundRectangle2D.Double rrect=(RoundRectangle2D.Double)shape;\n  rrect.setRoundRect(0,0,getBounds().width - 1,getBounds().height - 1,10,10);\n}", "comment": "rests the boundaries of the shape which is drawn as the rubberband .", "label": "what"}
{"id": "30245", "raw_code": "public static Colour attemptToGetAsColour(String part){\n  Colour col=null;\n  try {\n    col=Colour.valueOf(part.toUpperCase());\n  }\n catch (  Exception e) {\n  }\n  return col;\n}", "comment": "attempt to parse string as a colour", "label": "what"}
{"id": "39219", "raw_code": "public int rank(){\n  double eps=Math.pow(2.0,-52.0);\n  double tol=Math.max(m,n) * s[0] * eps;\n  int r=0;\n  for (int i=0; i < s.length; i++) {\n    if (s[i] > tol) {\n      r++;\n    }\n  }\n  return r;\n}", "comment": "effective numerical matrix rank", "label": "what"}
{"id": "38517", "raw_code": "public static boolean save(File file,String content){\n  boolean result;\n  BufferedWriter writer;\n  writer=null;\n  try {\n    writer=new BufferedWriter(new FileWriter(file));\n    writer.write(content);\n    writer.flush();\n    result=true;\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    result=false;\n  }\n finally {\n    if (writer != null) {\n      try {\n        writer.close();\n      }\n catch (      Exception e) {\n      }\n    }\n  }\n  return result;\n}", "comment": "saves the content to a file .", "label": "what"}
{"id": "78254", "raw_code": "private void deleteOldTemp(File fileCfg){\n  BufferedReader reader=null;\n  try {\n    int count=0;\n    reader=new BufferedReader(new FileReader(fileCfg));\n    String sLine;\n    while ((sLine=reader.readLine()) != null) {\n      File file=new File(sLine);\n      if (!file.exists()) {\n        continue;\n      }\n      if (file.delete()) {\n        count++;\n      }\n else {\n        hsDeleteOnExit.add(file);\n      }\n    }\n    logDebug(LogArea.CONFIG,\"Deleted %d old temp files listed in %s\",count,fileCfg.getAbsolutePath());\n  }\n catch (  IOException e) {\n  }\n finally {\n    if (reader != null) {\n      try {\n        reader.close();\n      }\n catch (      IOException e) {\n      }\n    }\n  }\n}", "comment": "deletes temporary files listed in the file .", "label": "what"}
{"id": "69882", "raw_code": "public void flush(){\n  final BigdataSailRepositoryConnection cxn=tlTx.get();\n  if (cxn != null) {\n    Code.wrapThrow(null);\n  }\n}", "comment": "flush the statement buffers to the indices without committing .", "label": "what"}
{"id": "64248", "raw_code": "public void despawn(VisibleObject object){\n  despawn(object,true);\n}", "comment": "despawn visibleobject , object will become invisible and object position will become invalid .", "label": "what"}
{"id": "10079", "raw_code": "@SuppressWarnings(\"rawtypes\") public static void createProjectConstraint(ZipFile zip,Project aProject,RepositoryService aRepository) throws IOException {\n  for (Enumeration zipEnumerate=zip.entries(); zipEnumerate.hasMoreElements(); ) {\n    ZipEntry entry=(ZipEntry)zipEnumerate.nextElement();\n    String entryName=normalizeEntryName(entry);\n    if (entryName.startsWith(CONSTRAINTS)) {\n      String filename=FilenameUtils.getName(entry.getName());\n      ConstraintSet constraintSet=new ConstraintSet();\n      constraintSet.setProject(aProject);\n      constraintSet.setName(filename);\n      aRepository.createConstraintSet(constraintSet);\n      aRepository.writeConstraintSet(constraintSet,zip.getInputStream(entry));\n      LOG.info(\"Imported constraint [\" + filename + \"] for project [\"+ aProject.getName()+ \"] with id [\"+ aProject.getId()+ \"]\");\n    }\n  }\n}", "comment": "copy constraints from the exported project", "label": "what"}
{"id": "84014", "raw_code": "public Operation copyTo(Extent target){\n  BlockTransformExtent extent=new BlockTransformExtent(original,transform,worldData.getBlockRegistry());\n  ForwardExtentCopy copy=new ForwardExtentCopy(extent,original.getRegion(),original.getOrigin(),target,original.getOrigin());\n  copy.setTransform(transform);\n  return copy;\n}", "comment": "create an operation to copy from the original clipboard to the given extent .", "label": "what"}
{"id": "40802", "raw_code": "private void pathStyleHelper(String style,String offset){\n  if (style == null) {\n    return;\n  }\n  if (style.equals(\"none\")) {\n    strokePaint.setPathEffect(null);\n    return;\n  }\n  StringTokenizer st=new StringTokenizer(style,\" ,\");\n  int count=st.countTokens();\n  float[] intervals=new float[(count & 1) == 1 ? count * 2 : count];\n  float max=0;\n  float current=1f;\n  int i=0;\n  while (st.hasMoreTokens()) {\n    intervals[i++]=current=toFloat(st.nextToken(),current);\n    max+=current;\n  }\n  for (int start=0; i < intervals.length; i++, start++) {\n    max+=intervals[i]=intervals[start];\n  }\n  float off=0f;\n  if (offset != null) {\n    try {\n      off=Float.parseFloat(offset) % max;\n    }\n catch (    NumberFormatException e) {\n    }\n  }\n  strokePaint.setPathEffect(new DashPathEffect(intervals,off));\n}", "comment": "set the path style ( if any ) stroke - dasharray = \" n1 , n2 , . . . \" stroke - dashoffset = n", "label": "what"}
{"id": "16573", "raw_code": "private Size parseOldBoundedSize(String token,boolean setMax){\n  int semicolonIndex=token.indexOf(';');\n  String sizeToken1=token.substring(4,semicolonIndex);\n  String sizeToken2=token.substring(semicolonIndex + 1,token.length() - 1);\n  Size size1=parseAtomicSize(sizeToken1);\n  Size size2=parseAtomicSize(sizeToken2);\n  if (isConstant(size1)) {\n    if (size2 instanceof Sizes.ComponentSize) {\n      return new BoundedSize(size2,setMax ? null : size1,setMax ? size1 : null);\n    }\n    throw new IllegalArgumentException(\"Bounded sizes must not be both constants.\");\n  }\n  if (isConstant(size2)) {\n    return new BoundedSize(size1,setMax ? null : size2,setMax ? size2 : null);\n  }\n  throw new IllegalArgumentException(\"Bounded sizes must not be both logical.\");\n}", "comment": "parses an encoded compound size and sets the size fields .", "label": "what"}
{"id": "82930", "raw_code": "public Namespace(PrincipalUser creator,String qualifier,PrincipalUser owner,Set<PrincipalUser> users){\n  super(creator);\n  setQualifier(qualifier);\n  setOwner(owner);\n  if (users != null && !users.isEmpty()) {\n    setUsers(users);\n  }\n  addUser(owner);\n}", "comment": "creates a new namespace object .", "label": "what"}
{"id": "68982", "raw_code": "public void update(long dt,float ratioY){\n  double step=2 * Math.PI / POINTS_PER_CIRCLE;\n  angle+=dt * BUBBLE_D_ANGLE;\n  float fromX=startX + (float)(0.05f * Math.sin(angle));\n  float toX=fromX + size;\n  float fromY=this.fromY + dt * speed;\n  float toY=fromY + size;\n  centerY+=dt * virtualSpeed;\n  getColor()[3]=(TOP_Y - centerY / TOP_Y);\n  vertexBuffer.put(0,Utils.normalizeGl(0,fromX,toX));\n  vertexBuffer.put(1,Utils.normalizeGl(centerY * ratioY,fromY,toY));\n  for (int i=1; i <= POINTS_PER_CIRCLE; i++) {\n    vertexBuffer.put(COORDS_PER_VERTEX * i,Utils.normalizeGl((float)Math.sin(-Math.PI + step * i),fromX,toX));\n    vertexBuffer.put(COORDS_PER_VERTEX * i + 1,Utils.normalizeGl((float)Math.cos(-Math.PI + step * i) * ratioY,fromY,toY));\n  }\n  this.fromY=fromY;\n}", "comment": "update position of bubble .", "label": "what"}
{"id": "15675", "raw_code": "public final void clear(){\n  if (GWT.isScript()) {\n    jsArray.clear();\n  }\n else {\n    javaArray.clear();\n  }\n}", "comment": "remove all elements on this list", "label": "what"}
{"id": "17680", "raw_code": "void fullyLock(){\n  putLock.lock();\n  takeLock.lock();\n}", "comment": "locks to prevent both puts and takes .", "label": "what"}
{"id": "22636", "raw_code": "@Override public synchronized void clear(){\n  File[] files=mRootDirectory.listFiles();\n  if (files != null) {\n    for (    File file : files) {\n      file.delete();\n    }\n  }\n  mEntries.clear();\n  VolleyLog.d(\"Cache cleared.\");\n}", "comment": "clears the cache .", "label": "what"}
{"id": "67148", "raw_code": "private void updatePodcastPublicationDateAndLastMediaUrl(Episode episode,Podcast podcast){\n  Date podcastPublicationDate=podcast.getPublicationDate();\n  boolean episodePubDateIsMoreRecent=episode.getPublicationDate() != null && (podcastPublicationDate == null || podcastPublicationDate.before(episode.getPublicationDate()));\n  if (episodePubDateIsMoreRecent) {\n    podcast.setPublicationDate(episode.getPublicationDate());\n    podcast.setLastEpisodeMediaUrl(episode.getMediaUrl());\n  }\n}", "comment": "set the podcast ' s publication date to the episode ' s if it is more recent", "label": "what"}
{"id": "9049", "raw_code": "private ResolvedMigration createAvailableMigration(int version){\n  ResolvedMigration migration=new ResolvedMigration();\n  migration.setVersion(MigrationVersion.fromVersion(Integer.toString(version)));\n  migration.setDescription(\"abc\");\n  migration.setScript(\"x\");\n  migration.setType(MigrationType.CQL);\n  return migration;\n}", "comment": "creates a new available migration with this version .", "label": "what"}
{"id": "58134", "raw_code": "public void comment(String data) throws SAXException {\n  m_docIsEmpty=false;\n  final int length=data.length();\n  if (length > m_charsBuff.length) {\n    m_charsBuff=new char[length * 2 + 1];\n  }\n  data.getChars(0,length,m_charsBuff,0);\n  comment(m_charsBuff,0,length);\n}", "comment": "receive notification of a comment .", "label": "what"}
{"id": "4965", "raw_code": "public void select_all(){\n  Arrays.fill(sel_array,true);\n}", "comment": "selects all item types .", "label": "what"}
{"id": "39835", "raw_code": "public NvpBuilder addRaw(final String name,final String value){\n  npv.put(name,value);\n  return this;\n}", "comment": "add raw name value pair .", "label": "what"}
{"id": "39853", "raw_code": "public List<CountryRO> viewAddressCountryOptions(final ShoppingCart cart,final Shop shop,final String addressType){\n  final List<Country> countries=addressBookFacade.getAllCountries(shop.getCode(),addressType);\n  return map(countries,CountryRO.class,Country.class);\n}", "comment": "common address book function .", "label": "what"}
{"id": "14171", "raw_code": "@Override public void makeImmutable(){\n  if (mutable) {\n    if (attrs != null) {\n      Iterator iter=attrs.iterator();\n      while (iter.hasNext()) {\n        Attribute attr=(Attribute)iter.next();\n        attr.makeImmutable();\n      }\n      attrs=Collections.unmodifiableList(attrs);\n    }\n    if (encAttrs != null) {\n      encAttrs=Collections.unmodifiableList(encAttrs);\n    }\n    mutable=false;\n  }\n}", "comment": "makes the object immutable .", "label": "what"}
{"id": "38236", "raw_code": "@Override public boolean batchFinished() throws Exception {\n  if (getInputFormat() == null) {\n    throw new IllegalStateException(\"No input instance format defined\");\n  }\n  Instances toFilter=getInputFormat();\n  if (!isFirstBatchDone()) {\n    Instances toFilterIgnoringAttributes=removeIgnored(toFilter);\n    File file=getSerializedClustererFile();\n    if (!file.isDirectory()) {\n      ObjectInputStream ois=new ObjectInputStream(new FileInputStream(file));\n      m_ActualClusterer=(Clusterer)ois.readObject();\n      Instances header=null;\n      try {\n        header=(Instances)ois.readObject();\n      }\n catch (      Exception e) {\n      }\n      ois.close();\n      if ((header != null) && (!header.equalHeaders(toFilterIgnoringAttributes))) {\n        throw new WekaException(\"Training header of clusterer and filter dataset don't match:\\n\" + header.equalHeadersMsg(toFilterIgnoringAttributes));\n      }\n    }\n else {\n      m_ActualClusterer=AbstractClusterer.makeCopy(m_Clusterer);\n      m_ActualClusterer.buildClusterer(toFilterIgnoringAttributes);\n    }\n    Instances filtered=new Instances(toFilter,0);\n    ArrayList<String> nominal_values=new ArrayList<String>(m_ActualClusterer.numberOfClusters());\n    for (int i=0; i < m_ActualClusterer.numberOfClusters(); i++) {\n      nominal_values.add(\"cluster\" + (i + 1));\n    }\n    filtered.insertAttributeAt(new Attribute(\"cluster\",nominal_values),filtered.numAttributes());\n    setOutputFormat(filtered);\n  }\n  for (int i=0; i < toFilter.numInstances(); i++) {\n    convertInstance(toFilter.instance(i));\n  }\n  flushInput();\n  m_NewBatch=true;\n  m_FirstBatchDone=true;\n  return (numPendingOutput() != 0);\n}", "comment": "signify that this batch of input to the filter is finished .", "label": "what"}
{"id": "67329", "raw_code": "public static UiResult openUrl(URI uri){\n  return openUrl(uri.toString());\n}", "comment": "launch url in a new window .", "label": "what"}
{"id": "36533", "raw_code": "public final void invalidateLine(int line){\n  repaint(0,textArea.lineToY(line) + fm.getMaxDescent() + fm.getLeading(),getWidth(),fm.getHeight());\n}", "comment": "marks a line as needing a repaint .", "label": "what"}
{"id": "48821", "raw_code": "public ByteBandedRaster(SampleModel sampleModel,Point origin){\n  this(sampleModel,sampleModel.createDataBuffer(),new Rectangle(origin.x,origin.y,sampleModel.getWidth(),sampleModel.getHeight()),origin,null);\n}", "comment": "constructs a bytebandedraster with the given samplemodel .", "label": "what"}
{"id": "58174", "raw_code": "private void initialize(URI p_other){\n  m_scheme=p_other.getScheme();\n  m_userinfo=p_other.getUserinfo();\n  m_host=p_other.getHost();\n  m_port=p_other.getPort();\n  m_path=p_other.getPath();\n  m_queryString=p_other.getQueryString();\n  m_fragment=p_other.getFragment();\n}", "comment": "initialize all fields of this uri from another uri .", "label": "what"}
{"id": "31709", "raw_code": "private Collection<String> readProcessOutput(Process proc) throws IOException {\n  BufferedReader rdr=new BufferedReader(new InputStreamReader(proc.getInputStream()));\n  Collection<String> res=new ArrayList<>();\n  String s;\n  while ((s=rdr.readLine()) != null)   res.add(s);\n  return res;\n}", "comment": "reads process output line - by - line .", "label": "what"}
{"id": "86864", "raw_code": "public void fillHeaderAndFooter(final HttpServletRequest request,final HttpServletResponse response,final Map<String,Object> dataModel) throws Exception {\n  fillHeader(request,response,dataModel);\n  fillFooter(dataModel);\n}", "comment": "fills header and footer .", "label": "what"}
{"id": "30716", "raw_code": "public void addOperand(ISpacePredicate operand){\n  if (_operandsList == null)   _operandsList=new ArrayList<ISpacePredicate>();\n  _operandsList.add(operand);\n}", "comment": "adds an operand at the end of the current operands list .", "label": "what"}
{"id": "29210", "raw_code": "public void skip(int count) throws IOException {\n  int skipCount=Math.min(limit - position,count);\n  while (true) {\n    position+=skipCount;\n    count-=skipCount;\n    if (count == 0)     break;\n    skipCount=Math.min(count,capacity);\n    require(skipCount);\n  }\n}", "comment": "discards the specified number of bytes .", "label": "what"}
{"id": "40910", "raw_code": "public void removeAllIms(){\n  ims.clear();\n}", "comment": "removes all im ' s from this user", "label": "what"}
{"id": "46431", "raw_code": "public boolean renameFile(File oldFile,File newFile){\nsynchronized (fileCache) {\n    if (oldFile.renameTo(newFile)) {\n      validateFileCache();\n      return true;\n    }\n    return false;\n  }\n}", "comment": "renames a file in the underlying file system .", "label": "what"}
{"id": "85549", "raw_code": "public static EnumSet<KindName> kindNames(int kind){\n  EnumSet<KindName> kinds=EnumSet.noneOf(KindName.class);\n  if ((kind & VAL) != 0)   kinds.add(((kind & VAL) == VAR) ? KindName.VAR : KindName.VAL);\n  if ((kind & MTH) != 0)   kinds.add(KindName.METHOD);\n  if ((kind & TYP) != 0)   kinds.add(KindName.CLASS);\n  if ((kind & PCK) != 0)   kinds.add(KindName.PACKAGE);\n  return kinds;\n}", "comment": "a set of kindname ( s ) representing a set of symbol ' s kinds .", "label": "what"}
{"id": "71334", "raw_code": "public static String serializeDigestResponse(Map<String,String> paramMap){\n  StringBuilder sb=new StringBuilder(\"Digest \");\n  boolean prefixComma=false;\n  for (  Map.Entry<String,String> entry : paramMap.entrySet()) {\n    if (!prefixComma) {\n      prefixComma=true;\n    }\n else {\n      sb.append(\", \");\n    }\n    sb.append(entry.getKey());\n    sb.append(\"=\");\n    sb.append(entry.getValue());\n  }\n  return sb.toString();\n}", "comment": "serialize a parameter map into a digest response .", "label": "what"}
{"id": "45746", "raw_code": "public long start(){\n  startTime=System.currentTimeMillis();\n  return startTime;\n}", "comment": "start the stop watch .", "label": "what"}
{"id": "62754", "raw_code": "public void next(){\n  if (iterator.hasNext()) {\n    View currentView=iterator.next();\n    if (isUsingDefaultListener())     currentView.setOnClickListener(null);\n    if (iterator.nextIndex() < mViews.size()) {\n      View nextView=mViews.get(iterator.nextIndex());\n      if (isUsingDefaultListener())       nextView.setOnClickListener(listener);\n      ControllerAnimator animator=getDefaultForwardAnimation();\n      animator.setOldView(currentView);\n      animator.setNewView(nextView);\n      currentView.startAnimation(animator);\n      if (iterator.nextIndex() == mViews.size() - 1)       if (hasControllerListener())       mListener.onEndReached();\n    }\n else {\n      if (mLoop) {\n        iterator=mViews.listIterator();\n        View nextView=mViews.get(0);\n        if (mUseDefaultListener)         nextView.setOnClickListener(listener);\n        ControllerAnimator animator=getDefaultForwardAnimation();\n        animator.setOldView(currentView);\n        animator.setNewView(nextView);\n        currentView.startAnimation(animator);\n      }\n    }\n  }\n}", "comment": "go to the next view", "label": "what"}
{"id": "61634", "raw_code": "public void simulateMethod(SootMethod method,ReferenceVariable thisVar,ReferenceVariable returnVar,ReferenceVariable params[]){\n  String subSignature=method.getSubSignature();\n  if (subSignature.equals(\"java.lang.Object allocateInstance(java.lang.Class)\")) {\n    sun_misc_Unsafe_allocateInstance(method,thisVar,returnVar,params);\n    return;\n  }\n{\n    defaultMethod(method,thisVar,returnVar,params);\n    return;\n  }\n}", "comment": "implements the abstract method simulatemethod .", "label": "what"}
{"id": "29131", "raw_code": "public static void close(@CheckForNull OutputStream outputStream){\n  if (outputStream == null) {\n    return;\n  }\n  try {\n    outputStream.close();\n  }\n catch (  IOException e) {\n  }\n}", "comment": "close given outputstream , ignoring any resulting exception .", "label": "what"}
{"id": "60469", "raw_code": "private int charToVisibleWidth(char c,@JdkConstants.FontStyle int fontType,int currentX){\n  if (c == '\\n') {\n    return 0;\n  }\n  if (c == '\\t') {\n    return EditorUtil.nextTabStop(currentX,this) - currentX;\n  }\n  return EditorUtil.charWidth(c,fontType,this);\n}", "comment": "allows to answer how much width requires given char to be represented on a screen .", "label": "what"}
{"id": "9094", "raw_code": "public static void createDir(File target) throws AdeUsageException {\n  if (!target.exists() && !target.mkdir() && !target.exists()) {\n    throw new AdeUsageException(\"Failed creating directory \" + target.getPath());\n  }\n}", "comment": "create directory if not already exists .", "label": "what"}
{"id": "69738", "raw_code": "public static String encode(final Coordinate[] coords){\n  long lastLat=0;\n  long lastLng=0;\n  final StringBuffer result=new StringBuffer();\n  for (  final Coordinate point : coords) {\n    long lat=Math.round(point.y * 1e5);\n    long lng=Math.round(point.x * 1e5);\n    long dLat=lat - lastLat;\n    long dLng=lng - lastLng;\n    encode(dLat,result);\n    encode(dLng,result);\n    lastLat=lat;\n    lastLng=lng;\n  }\n  return result.toString();\n}", "comment": "encodes a sequence of latlngs into an encoded path string .", "label": "what"}
{"id": "14424", "raw_code": "@Override public void close(){\n  try {\n    flush();\n  }\n catch (  AMLogException ale) {\n    Debug.error(tableName + \":DBHandler:close/flush error: \" + ale.getMessage());\n  }\n  if (conn != null) {\n    try {\n      conn.close();\n    }\n catch (    SQLException ce) {\n      Debug.error(tableName + \":DBHandler: Unable To Close Connection\",ce);\n    }\n  }\n  stopBufferTimer();\n}", "comment": "flush any buffered messages and close the current output stream .", "label": "what"}
{"id": "83785", "raw_code": "public boolean contains(List<Integer> hashes){\n  Iterator<Integer> ni=hashes.iterator();\n  for (int i=0; i < hashFunctions; ++i) {\n    if (!testBit((int)((ni.next() & 0xFFFFFFFFL) % (filter.length * 8)))) {\n      return false;\n    }\n  }\n  return true;\n}", "comment": "check if the filter contains data with precomputed hashes .", "label": "what"}
{"id": "19996", "raw_code": "private void ensureCapacity(int additionalData){\n  if ((this.position + additionalData) > this.byteBuffer.length) {\n    int newLength=(int)(this.byteBuffer.length * 1.25);\n    if (newLength < (this.byteBuffer.length + additionalData)) {\n      newLength=this.byteBuffer.length + (int)(additionalData * 1.25);\n    }\n    if (newLength < this.byteBuffer.length) {\n      newLength=this.byteBuffer.length + additionalData;\n    }\n    byte[] newBytes=new byte[newLength];\n    System.arraycopy(this.byteBuffer,0,newBytes,0,this.byteBuffer.length);\n    this.byteBuffer=newBytes;\n  }\n}", "comment": "ensure that there are additionaldata bytes available in the buffer .", "label": "what"}
{"id": "10009", "raw_code": "public boolean isValidNumber(PhoneNumber number){\n  String regionCode=getRegionCodeForNumber(number);\n  return isValidNumberForRegion(number,regionCode);\n}", "comment": "tests whether a phone number matches a valid pattern .", "label": "what"}
{"id": "52970", "raw_code": "public void stop(){\n  server.stop(0);\n}", "comment": "stop the web server .", "label": "what"}
{"id": "13182", "raw_code": "protected DateTimeData parse(String str,int durationType) throws SchemaDateTimeException {\n  int len=str.length();\n  DateTimeData date=new DateTimeData(str,this);\n  int start=0;\n  char c=str.charAt(start++);\n  if (c != 'P' && c != '-') {\n    throw new SchemaDateTimeException();\n  }\n else {\n    date.utc=(c == '-') ? '-' : 0;\n    if (c == '-' && str.charAt(start++) != 'P') {\n      throw new SchemaDateTimeException();\n    }\n  }\n  int negate=1;\n  if (date.utc == '-') {\n    negate=-1;\n  }\n  boolean designator=false;\n  int endDate=indexOf(str,start,len,'T');\n  if (endDate == -1) {\n    endDate=len;\n  }\n else   if (durationType == YEARMONTHDURATION_TYPE) {\n    throw new SchemaDateTimeException();\n  }\n  int end=indexOf(str,start,endDate,'Y');\n  if (end != -1) {\n    if (durationType == DAYTIMEDURATION_TYPE) {\n      throw new SchemaDateTimeException();\n    }\n    date.year=negate * parseInt(str,start,end);\n    start=end + 1;\n    designator=true;\n  }\n  end=indexOf(str,start,endDate,'M');\n  if (end != -1) {\n    if (durationType == DAYTIMEDURATION_TYPE) {\n      throw new SchemaDateTimeException();\n    }\n    date.month=negate * parseInt(str,start,end);\n    start=end + 1;\n    designator=true;\n  }\n  end=indexOf(str,start,endDate,'D');\n  if (end != -1) {\n    if (durationType == YEARMONTHDURATION_TYPE) {\n      throw new SchemaDateTimeException();\n    }\n    date.day=negate * parseInt(str,start,end);\n    start=end + 1;\n    designator=true;\n  }\n  if (len == endDate && start != len) {\n    throw new SchemaDateTimeException();\n  }\n  if (len != endDate) {\n    end=indexOf(str,++start,len,'H');\n    if (end != -1) {\n      date.hour=negate * parseInt(str,start,end);\n      start=end + 1;\n      designator=true;\n    }\n    end=indexOf(str,start,len,'M');\n    if (end != -1) {\n      date.minute=negate * parseInt(str,start,end);\n      start=end + 1;\n      designator=true;\n    }\n    end=indexOf(str,start,len,'S');\n    if (end != -1) {\n      date.second=negate * parseSecond(str,start,end);\n      start=end + 1;\n      designator=true;\n    }\n    if (start != len || str.charAt(--start) == 'T') {\n      throw new SchemaDateTimeException();\n    }\n  }\n  if (!designator) {\n    throw new SchemaDateTimeException();\n  }\n  return date;\n}", "comment": "parses , validates and computes normalized version of duration object", "label": "what"}
{"id": "42297", "raw_code": "final void copyIntoLocalState(Operand[] _localState){\n  localState=new Operand[_localState.length];\n  System.arraycopy(_localState,0,localState,0,_localState.length);\n  setLocalKnown();\n}", "comment": "save a shallow copy of the given local variable state into this .", "label": "what"}
{"id": "66585", "raw_code": "@SuppressWarnings(\"unchecked\") private HashMap<String,DBObject> loadDBObjects(Class objectClass){\n  HashMap<String,DBObject> objectMap=new HashMap<String,DBObject>();\n  DBObject dbObject=new DBObject(this,objectClass);\n  String objectToLoad=s_logger.localizeMessage(\"object\");\n  String objectsToLoad=s_logger.localizeMessage(\"objects\");\n  String sqlLoadHeaders=null;\n  String sqlLoadContents=null;\n  if (dbObject != null) {\n    objectToLoad=dbObject.getObjectType();\n    objectsToLoad=dbObject.getObjectTypes();\n    sqlLoadHeaders=dbObject.getLoadHeaderSQL();\n    sqlLoadContents=dbObject.getLoadContentSQL();\n  }\n  s_logger.log(Level.FINE,\"loadDBObjects\",new Object[]{objectsToLoad,getDirection()});\n  PreparedStatementWrapper stmtLoadHeaders=setPreparedStatement(sqlLoadHeaders);\n  PreparedStatementWrapper stmtLoadContents=setPreparedStatement(sqlLoadContents);\n  int counter=0;\n  if (dbObject != null) {\n    String sql=dbObject.getLoadObjectSQL();\n    Statement stmt=setStatement();\n    ResultSet rs=executeQuery(stmt,sql);\n    while (getResultSetNext(rs)) {\n      String s=getResultSetString(rs,\"OBJECT_NAME\");\n      if (!objectMap.containsKey(s)) {\n        DBObject obj=new DBObject(this,objectClass,s);\n        obj.populate(stmtLoadHeaders,stmtLoadContents);\n        if (obj.isPopulated()) {\n          objectMap.put(s.toUpperCase(),obj);\n          counter++;\n        }\n      }\n    }\n    releaseResultSet(rs);\n    releaseStatement(stmt);\n  }\n  releasePreparedStatement(stmtLoadHeaders);\n  releasePreparedStatement(stmtLoadContents);\n  if (counter == 1)   s_logger.log(Level.FINE,\"dbObjectsLoaded\",new Object[]{Integer.toString(counter),objectToLoad});\n else   s_logger.log(Level.FINE,\"dbObjectsLoaded\",new Object[]{Integer.toString(counter),objectsToLoad});\n  s_logger.flush();\n  return objectMap;\n}", "comment": "load objects defined in the database", "label": "what"}
{"id": "86779", "raw_code": "public synchronized boolean add(E e,boolean hasNext){\n  while (mInternalQueue.size() >= mMaxSize && !mClosed) {\n    notifyAll();\n    try {\n      wait(TIMEOUT);\n    }\n catch (    InterruptedException e1) {\n      mClosed=true;\n      ProgramState.checkAbort();\n      throw new IllegalStateException(\"Interrupted but program not aborting?\",e1);\n    }\n    ProgramState.checkAbort();\n  }\n  if (mClosed) {\n    return true;\n  }\n  final boolean wasEmpty=mInternalQueue.isEmpty();\n  mHasNext=hasNext;\n  mInternalQueue.add(e);\n  if (wasEmpty) {\n    notifyAll();\n  }\n  return true;\n}", "comment": "add method which also set whether there is a next value", "label": "what"}
{"id": "67999", "raw_code": "public void addPart(int index,PduPart part){\n  if (null == part) {\n    throw new NullPointerException();\n  }\n  putPartToMaps(part);\n  mParts.add(index,part);\n}", "comment": "inserts the specified part at the specified position .", "label": "what"}
{"id": "84105", "raw_code": "public StrBuilder insert(int index,boolean value){\n  validateIndex(index);\n  if (value) {\n    ensureCapacity(size + 4);\n    System.arraycopy(buffer,index,buffer,index + 4,size - index);\n    buffer[index++]='t';\n    buffer[index++]='r';\n    buffer[index++]='u';\n    buffer[index]='e';\n    size+=4;\n  }\n else {\n    ensureCapacity(size + 5);\n    System.arraycopy(buffer,index,buffer,index + 5,size - index);\n    buffer[index++]='f';\n    buffer[index++]='a';\n    buffer[index++]='l';\n    buffer[index++]='s';\n    buffer[index]='e';\n    size+=5;\n  }\n  return this;\n}", "comment": "inserts the value into this builder .", "label": "what"}
{"id": "80262", "raw_code": "public boolean hasNatureAndWeapon(Nature nature,String weapon){\n  return this.nature == nature && ((weapon == null && this.weapon == null) || (weapon != null && weapon.equals(this.weapon)));\n}", "comment": "check if this painter has the given nature an weapon .", "label": "what"}
{"id": "23788", "raw_code": "public void dump(String infoMsg){\n  storage.getOnlineMembers();\n  storage.getOfflineMembers();\n  storage.getOfflineAndEqualMembers();\n  storage.getMyInitializingID();\n  storage.getMyPersistentID();\n  final StringBuilder buf=new StringBuilder(2000);\n  if (infoMsg != null) {\n    buf.append(infoMsg);\n    buf.append(\": \");\n  }\n  buf.append(\"\\nMY PERSISTENT ID:\\n\");\n  buf.append(storage.getMyPersistentID());\n  buf.append(\"\\nMY INITIALIZING ID:\\n\");\n  buf.append(storage.getMyInitializingID());\n  buf.append(\"\\nONLINE MEMBERS:\\n\");\n  for (  PersistentMemberID id : storage.getOnlineMembers()) {\n    buf.append(\"\\t\");\n    buf.append(id);\n    buf.append(\"\\n\");\n  }\n  buf.append(\"\\nOFFLINE MEMBERS:\\n\");\n  for (  PersistentMemberID id : storage.getOfflineMembers()) {\n    buf.append(\"\\t\");\n    buf.append(id);\n    buf.append(\"\\n\");\n  }\n  buf.append(\"\\nOFFLINE AND EQUAL MEMBERS:\\n\");\n  for (  PersistentMemberID id : storage.getOfflineAndEqualMembers()) {\n    buf.append(\"\\t\");\n    buf.append(id);\n    buf.append(\"\\n\");\n  }\n  logger.debug(buf.toString());\n}", "comment": "callers should have already verified that debug output is enabled .", "label": "what"}
{"id": "16149", "raw_code": "private boolean advanceApiUpTo(TreeSet<AreaPanelInfo> sortedApiTree,AreaPanelInfo api,int time){\n  AreaPanel ap=api.ap();\n  TimeTree rootTt=ap.getTimeTree();\n  TimeTree tt=rootTt.getEncompassigTimeTreeOrMaxTimeTreeBeforeTime(time,true);\n  if (tt == null || tt.id == api.currTtId)   return false;\n  sortedApiTree.remove(api);\n  if (api.setTt(tt,Integer.MAX_VALUE))   sortedApiTree.add(api);\n  return true;\n}", "comment": "moves api to the latest value before time .", "label": "what"}
{"id": "45705", "raw_code": "@RequestMapping(value={\"/\",\"\"},method=RequestMethod.POST) @ResponseBody public RestWrapper update(@ModelAttribute(\"userroles\") @Valid UserRoles userRoles,BindingResult bindingResult,Principal principal){\n  RestWrapper restWrapper=null;\n  if (bindingResult.hasErrors()) {\n    BindingResultError bindingResultError=new BindingResultError();\n    return bindingResultError.errorMessage(bindingResult);\n  }\n  try {\n    com.wipro.ats.bdre.md.dao.jpa.UserRoles jpaUserRoles=new com.wipro.ats.bdre.md.dao.jpa.UserRoles();\n    jpaUserRoles.setUserRoleId(userRoles.getUserRoleId());\n    jpaUserRoles.setRole(userRoles.getRole());\n    Users users=new Users();\n    users.setUsername(userRoles.getUsername());\n    jpaUserRoles.setUsers(users);\n    userRolesDAO.update(jpaUserRoles);\n    restWrapper=new RestWrapper(userRoles,RestWrapper.OK);\n    LOGGER.info(\"Record with ID:\" + userRoles.getUserRoleId() + \" updated in UserRoles by User:\"+ principal.getName()+ userRoles);\n  }\n catch (  Exception e) {\n    LOGGER.error(e);\n    restWrapper=new RestWrapper(e.getMessage(),RestWrapper.ERROR);\n  }\n  return restWrapper;\n}", "comment": "this method calls proc updateuserroles and updates the values .", "label": "what"}
{"id": "61799", "raw_code": "private void sendRequestOption() throws IOException {\n  String request=\"OPTIONS rtsp://\" + mParameters.host + \":\"+ mParameters.port+ mParameters.path+ \" RTSP/1.0\\r\\n\"+ addHeaders();\n  Log.i(TAG,request.substring(0,request.indexOf(\"\\r\\n\")));\n  mOutputStream.write(request.getBytes(\"UTF-8\"));\n  Response.parseResponse(mBufferedReader);\n}", "comment": "forges and sends the options request", "label": "what"}
{"id": "62694", "raw_code": "public static void printThreadInfo(PrintWriter stream,String title){\n  final int STACK_DEPTH=20;\n  boolean contention=threadBean.isThreadContentionMonitoringEnabled();\n  long[] threadIds=threadBean.getAllThreadIds();\n  stream.println(\"Process Thread Dump: \" + title);\n  stream.println(threadIds.length + \" active threads\");\n  for (  long tid : threadIds) {\n    ThreadInfo info=threadBean.getThreadInfo(tid,STACK_DEPTH);\n    if (info == null) {\n      stream.println(\"  Inactive\");\n      continue;\n    }\n    stream.println(\"Thread \" + getTaskName(info.getThreadId(),info.getThreadName()) + \":\");\n    Thread.State state=info.getThreadState();\n    stream.println(\"  State: \" + state);\n    stream.println(\"  Blocked count: \" + info.getBlockedCount());\n    stream.println(\"  Waited count: \" + info.getWaitedCount());\n    if (contention) {\n      stream.println(\"  Blocked time: \" + info.getBlockedTime());\n      stream.println(\"  Waited time: \" + info.getWaitedTime());\n    }\n    if (state == Thread.State.WAITING) {\n      stream.println(\"  Waiting on \" + info.getLockName());\n    }\n else     if (state == Thread.State.BLOCKED) {\n      stream.println(\"  Blocked on \" + info.getLockName());\n      stream.println(\"  Blocked by \" + getTaskName(info.getLockOwnerId(),info.getLockOwnerName()));\n    }\n    stream.println(\"  Stack:\");\n    for (    StackTraceElement frame : info.getStackTrace()) {\n      stream.println(\"    \" + frame.toString());\n    }\n  }\n  stream.flush();\n}", "comment": "print all of the thread ' s information and stack traces .", "label": "what"}
{"id": "72407", "raw_code": "public static double max(final double a,final double b){\n  if (a > b) {\n    return a;\n  }\n  if (a < b) {\n    return b;\n  }\n  if (a != b) {\n    return Double.NaN;\n  }\n  long bits=Double.doubleToRawLongBits(a);\n  if (bits == 0x8000000000000000L) {\n    return b;\n  }\n  return a;\n}", "comment": "compute the maximum of two values", "label": "what"}
{"id": "84008", "raw_code": "public static Request request(){\n  return threadLocal.get();\n}", "comment": "get the current request , which is specific to the current thread .", "label": "what"}
{"id": "55462", "raw_code": "private void scheduleCommercial(int length){\n  Long delay=commercialDelay.getSettingValue();\n  if (delay == null) {\n    setCommercialResult(\"Invalid delay specified.\");\n    clearCommercialButtonsSelection();\n  }\n else {\n    scheduledCommercialTime=System.currentTimeMillis() + delay * 1000;\n    scheduledCommercialLength=length;\n    update();\n  }\n}", "comment": "schedules a commercial of the given length to be run after the delay currently set in the delay input field .", "label": "what"}
{"id": "68665", "raw_code": "public void unsubscribe(AWSIotMessage message) throws AWSIotException {\n  try {\n    unsubscribeTopic(message);\n  }\n catch (  AwsIotRetryableException e) {\n    if (client.getMaxOfflineQueueSize() > 0 && unsubscribeQueue.size() < client.getMaxOfflineQueueSize()) {\n      unsubscribeQueue.add(message);\n    }\n else {\n      LOGGER.info(\"Failed to unsubscribe to \" + message.getTopic());\n      throw new AWSIotException(e);\n    }\n  }\n}", "comment": "the actual unsubscribe method exposed by this class .", "label": "what"}
{"id": "46774", "raw_code": "public boolean endsWith(Name n){\n  if (n instanceof CompoundName) {\n    return (impl.endsWith(n.size(),n.getAll()));\n  }\n else {\n    return false;\n  }\n}", "comment": "determines whether a compound name is a suffix of this compound name .", "label": "what"}
{"id": "34848", "raw_code": "@SuppressWarnings(\"purity\") private static boolean isRegex(String s){\n  try {\n    Pattern.compile(s);\n  }\n catch (  PatternSyntaxException e) {\n    return false;\n  }\n  return true;\n}", "comment": "this method is a copy of regexutil . isregex .", "label": "what"}
{"id": "44392", "raw_code": "private String attachFooterToText(String content) throws MessagingException, IOException {\n  StringBuilder builder=new StringBuilder(content);\n  ensureTrailingCarriageReturn(content,builder);\n  builder.append(getFooterText());\n  return builder.toString();\n}", "comment": "prepends the content of the mimepart as text to the existing footer", "label": "what"}
{"id": "55566", "raw_code": "public static Sentence make(final Connective connective,final Sentence... children2){\n  return make(connective,Arrays.asList(children2));\n}", "comment": "conjoin a list of sentences .", "label": "what"}
{"id": "63248", "raw_code": "public synchronized void init(){\n  init=true;\n  for (  String mapName : store.getMapNames()) {\n    if (mapName.startsWith(\"temp.\")) {\n      MVMap<Object,Integer> temp=openTempMap(mapName);\n      store.removeMap(temp);\n    }\n  }\nsynchronized (undoLog) {\n    if (undoLog.size() > 0) {\n      for (      Long key : undoLog.keySet()) {\n        int transactionId=getTransactionId(key);\n        openTransactions.set(transactionId);\n      }\n    }\n  }\n}", "comment": "initialize the store .", "label": "what"}
{"id": "83319", "raw_code": "public static TDoubleDoubleHashMap createCumulativeHistogram(TDoubleDoubleHashMap histogram){\n  double[] keys=histogram.keys();\n  Arrays.sort(keys);\n  double sum=0;\n  for (  double key : keys) {\n    double val=histogram.get(key);\n    sum+=val;\n    histogram.put(key,sum);\n  }\n  return histogram;\n}", "comment": "creates a cumulative histogram where each bin height is the sum of the previous bin ' s height and the current bin ' s height .", "label": "what"}
{"id": "13194", "raw_code": "protected DateTimeData parse(String str) throws SchemaDateTimeException {\n  DateTimeData date=new DateTimeData(str,this);\n  int len=str.length();\n  int end=indexOf(str,0,len,'T');\n  int dateEnd=getDate(str,0,end,date);\n  getTime(str,end + 1,len,date);\n  if (dateEnd != end) {\n    throw new RuntimeException(str + \" is an invalid dateTime dataype value. \" + \"Invalid character(s) seprating date and time values.\");\n  }\n  validateDateTime(date);\n  saveUnnormalized(date);\n  if (date.utc != 0 && date.utc != 'Z') {\n    normalize(date);\n  }\n  return date;\n}", "comment": "parses , validates and computes normalized version of datetime object", "label": "what"}
{"id": "65315", "raw_code": "SegmentManager commitIndex(long commitIndex){\n  this.commitIndex=Math.max(this.commitIndex,commitIndex);\n  return this;\n}", "comment": "sets the log commit index .", "label": "what"}
{"id": "22689", "raw_code": "public void finishFragments(){\n  for (  Fragment comment : closingFragments) {\n    finishFragment(comment);\n  }\n  closingFragments.clear();\n}", "comment": "sets all the closing fragments into finished state .", "label": "what"}
{"id": "11874", "raw_code": "public Collection<Node> matchingScenariosAndExamples(final Feature feature){\n  final List<ScenarioDefinition> allScenarios=feature.getScenarioDefinitions();\n  final List<Node> matchingScenariosAndExamples=new LinkedList<Node>();\n  for (  final ScenarioDefinition scenario : allScenarios) {\n    final Set<Tag> allTagsForScenario=new HashSet<Tag>(scenario.getTags());\n    allTagsForScenario.addAll(feature.getTags());\n    if (scenario instanceof ScenarioOutline) {\n      matchingScenariosAndExamples.addAll(matchingExamples((ScenarioOutline)scenario,allTagsForScenario));\n    }\n else {\n      if (matches(allTagsForScenario)) {\n        matchingScenariosAndExamples.add(scenario);\n      }\n    }\n  }\n  return matchingScenariosAndExamples;\n}", "comment": "find the scenarios that match the required tags in the feature .", "label": "what"}
{"id": "84761", "raw_code": "private boolean traverse(Tree tree,NodeRef node,int[] operatorNumber,boolean flip){\n  boolean update=false;\n  int nodeNum=node.getNumber();\n  NodeRef parent=tree.getParent(node);\n  if (operatorNumber != null) {\n    operatorNumber[0]=-1;\n  }\n  if (parent != null && updateNode[nodeNum]) {\n    final double branchRate=branchRateModel.getBranchRate(tree,node);\n    final double branchTime=branchRate * (tree.getNodeHeight(parent) - tree.getNodeHeight(node));\n    if (branchTime < 0.0) {\n      throw new RuntimeException(\"Negative branch length: \" + branchTime);\n    }\n    if (flip) {\n      matrixBufferHelper.flipOffset(nodeNum);\n    }\n    final int eigenIndex=0;\n    final int updateCount=branchUpdateCount[eigenIndex];\n    matrixUpdateIndices[eigenIndex][updateCount]=matrixBufferHelper.getOffsetIndex(nodeNum);\n    branchLengths[eigenIndex][updateCount]=branchTime;\n    branchUpdateCount[eigenIndex]++;\n    update=true;\n  }\n  if (!tree.isExternal(node)) {\n    NodeRef child1=tree.getChild(node,0);\n    final int[] op1={-1};\n    final boolean update1=traverse(tree,child1,op1,flip);\n    NodeRef child2=tree.getChild(node,1);\n    final int[] op2={-1};\n    final boolean update2=traverse(tree,child2,op2,flip);\n    if (update1 || update2) {\n      int x=operationCount[operationListCount] * Beagle.OPERATION_TUPLE_SIZE;\n      if (flip) {\n        partialBufferHelper.flipOffset(nodeNum);\n      }\n      final int[] operations=this.operations[operationListCount];\n      operations[x]=partialBufferHelper.getOffsetIndex(nodeNum);\n      if (useScaleFactors) {\n        int n=nodeNum - tipCount;\n        if (recomputeScaleFactors) {\n          scaleBufferHelper.flipOffset(n);\n          scaleBufferIndices[n]=scaleBufferHelper.getOffsetIndex(n);\n          operations[x + 1]=scaleBufferIndices[n];\n          operations[x + 2]=Beagle.NONE;\n        }\n else {\n          operations[x + 1]=Beagle.NONE;\n          operations[x + 2]=scaleBufferIndices[n];\n        }\n      }\n else {\n        if (useAutoScaling) {\n          scaleBufferIndices[nodeNum - tipCount]=partialBufferHelper.getOffsetIndex(nodeNum);\n        }\n        operations[x + 1]=Beagle.NONE;\n        operations[x + 2]=Beagle.NONE;\n      }\n      operations[x + 3]=partialBufferHelper.getOffsetIndex(child1.getNumber());\n      operations[x + 4]=matrixBufferHelper.getOffsetIndex(child1.getNumber());\n      operations[x + 5]=partialBufferHelper.getOffsetIndex(child2.getNumber());\n      operations[x + 6]=matrixBufferHelper.getOffsetIndex(child2.getNumber());\n      operationCount[operationListCount]++;\n      update=true;\n    }\n  }\n  return update;\n}", "comment": "traverse the tree calculating partial likelihoods .", "label": "what"}
{"id": "14838", "raw_code": "public boolean validate(String value,String rule){\n  return (value.equalsIgnoreCase(rule));\n}", "comment": "determines whether the specified string is a valid boolean value", "label": "what"}
{"id": "58055", "raw_code": "public String findURIFromDoc(int owner){\n  int n=m_sourceTree.size();\n  for (int i=0; i < n; i++) {\n    SourceTree sTree=(SourceTree)m_sourceTree.elementAt(i);\n    if (owner == sTree.m_root)     return sTree.m_url;\n  }\n  return null;\n}", "comment": "given a document , find the url associated with that document .", "label": "what"}
{"id": "19730", "raw_code": "public boolean offer(E event,int taskId) throws InterruptedException {\n  assertNotDone();\n  if (predicate.match(event)) {\n    this.matched[taskId]=true;\n    for (    boolean match : matched) {\n      if (!match)       return true;\n    }\n    responseQueue.put(new EventHolder(event));\n    done=true;\n    return true;\n  }\n else   return false;\n}", "comment": "offer an event to this watch instance .", "label": "what"}
{"id": "44753", "raw_code": "private static AlgorithmParameterSpec algorithmParameterSpec(){\n  final SecureRandom random=new SecureRandom();\n  final byte[] bytes=new byte[CcAes.BLOCK];\n  random.nextBytes(bytes);\n  return new IvParameterSpec(bytes);\n}", "comment": "create algorithmparameterspec with the block size .", "label": "what"}
{"id": "47478", "raw_code": "static ZoneOffsetTransitionRule readExternal(DataInput in) throws IOException {\n  int data=in.readInt();\n  Month month=Month.of(data >>> 28);\n  int dom=((data & (63 << 22)) >>> 22) - 32;\n  int dowByte=(data & (7 << 19)) >>> 19;\n  DayOfWeek dow=dowByte == 0 ? null : DayOfWeek.of(dowByte);\n  int timeByte=(data & (31 << 14)) >>> 14;\n  TimeDefinition defn=TimeDefinition.values()[(data & (3 << 12)) >>> 12];\n  int stdByte=(data & (255 << 4)) >>> 4;\n  int beforeByte=(data & (3 << 2)) >>> 2;\n  int afterByte=(data & 3);\n  LocalTime time=(timeByte == 31 ? LocalTime.ofSecondOfDay(in.readInt()) : LocalTime.of(timeByte % 24,0));\n  ZoneOffset std=(stdByte == 255 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds((stdByte - 128) * 900));\n  ZoneOffset before=(beforeByte == 3 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds(std.getTotalSeconds() + beforeByte * 1800));\n  ZoneOffset after=(afterByte == 3 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds(std.getTotalSeconds() + afterByte * 1800));\n  return ZoneOffsetTransitionRule.of(month,dom,dow,time,timeByte == 24,defn,std,before,after);\n}", "comment": "reads the state from the stream .", "label": "what"}
{"id": "61533", "raw_code": "protected boolean isTokenChar(char ch){\n  if (Character.isLetterOrDigit(ch))   return true;\n  if (Character.isISOControl(ch))   return false;\n  if (isHttpSeparator(ch))   return false;\n  return true;\n}", "comment": "checks whether a character is a valid token character .", "label": "what"}
{"id": "63624", "raw_code": "public void drawLinesAndPoints(Graphics2D g2d,ArrayList<ComparableLabel> orderedDateSet,HashMap<ComparableLabel,Integer> dataPoints,long yMaxMark){\n  int sectionWidth=this.graphWidth / orderedDateSet.size();\n  int xOffset=sectionWidth / 2;\n  int yPrevValue;\n  int yCurrentValue;\n  float prevOffsetPerc;\n  float currentOffsetPerc;\n  g2d.setColor(this.lineColor);\n  for (int i=0; i < orderedDateSet.size(); i++) {\n    if (i != 0) {\n      yPrevValue=dataPoints.get(orderedDateSet.get(i - 1));\n      yCurrentValue=dataPoints.get(orderedDateSet.get(i));\n      prevOffsetPerc=yPrevValue / (float)yMaxMark;\n      currentOffsetPerc=yCurrentValue / (float)yMaxMark;\n      g2d.drawLine(this.graphLeft + (i - 1) * sectionWidth + xOffset,this.graphBottom - Math.round(prevOffsetPerc * this.graphHeight),this.graphLeft + i * sectionWidth + xOffset,Math.round(this.graphBottom - currentOffsetPerc * this.graphHeight));\n    }\n else {\n      yCurrentValue=dataPoints.get(orderedDateSet.get(i));\n      currentOffsetPerc=yCurrentValue / (float)yMaxMark;\n      g2d.fillOval(this.graphLeft + (i) * sectionWidth + xOffset - this.pointRadius,this.graphBottom - Math.round(currentOffsetPerc * this.graphHeight) - this.pointRadius,this.pointRadius * 2,this.pointRadius * 2);\n    }\n  }\n}", "comment": "draws the datapoints and the lines connecting the datapoints on the line graph", "label": "what"}
{"id": "52436", "raw_code": "public static String makeLogTag(Class cls){\n  return makeLogTag(cls.getSimpleName());\n}", "comment": "don ' t use this when obfuscating class names !", "label": "what"}
{"id": "55861", "raw_code": "public final synchronized byte[] toByteArray(){\n  ByteArrayOutputStream baos=null;\n  DataOutputStream dos=null;\n  try {\n    baos=new ByteArrayOutputStream(32768);\n    dos=new DataOutputStream(baos);\n    game.writeToStream(dos);\n    dos.flush();\n    return baos.toByteArray();\n  }\n catch (  IOException e) {\n    return null;\n  }\n finally {\n    if (dos != null)     try {\n      dos.close();\n    }\n catch (    IOException ex) {\n    }\n    if (baos != null)     try {\n      baos.close();\n    }\n catch (    IOException ex) {\n    }\n  }\n}", "comment": "serialize to byte array .", "label": "what"}
{"id": "60153", "raw_code": "public void addImport(@NotNull PsiElement importable,@NotNull PsiFile file,@Nullable PyImportElement importElement){\n  myImports.add(new ImportCandidateHolder(importable,file,importElement,null));\n}", "comment": "adds another import source .", "label": "what"}
{"id": "22693", "raw_code": "protected final void drawArrowHead(Graphics2D g,int x,int y,int sgn){\n  g.setStroke(Strokes.getStroke(StrokeType.SOLID,1));\n  int size=diagram().arrowSize;\nswitch (headType) {\ncase CLOSED:\n    Polygon p=new Polygon(new int[]{x,x + sgn * size,x + sgn * size,x},new int[]{y,y - size,y + size,y},4);\n  g.fillPolygon(p);\nbreak;\ncase OPEN:\ng.drawLine(x,y,x + sgn * size,y - size);\ng.drawLine(x,y,x + sgn * size,y + size);\nbreak;\ncase ROUNDED:\nint left=sgn == -1 ? x - 2 * size : x;\nint top=y - size;\ng.fillArc(left,top,size * 2,size * 2,90,sgn * 180);\n}\n}", "comment": "draws the head of a message arrow onto the diagram display .", "label": "what"}
{"id": "3830", "raw_code": "public void classLoaderInit(DynamicClassLoader loader){\n  EnvLoaderListener listener=_listenerRef.get();\n  if (listener != null)   listener.classLoaderInit(loader);\n}", "comment": "handles the case where a class loader is activated .", "label": "what"}
{"id": "24921", "raw_code": "private void loadDataFromService(){\n  List<ExceptionSensorData> exData=null;\n  if ((null != fromDate) && (null != toDate)) {\n    exData=dataAccessService.getUngroupedExceptionOverview(template,limit,fromDate,toDate,resultComparator);\n  }\n else {\n    exData=dataAccessService.getUngroupedExceptionOverview(template,limit,resultComparator);\n  }\n  exceptionSensorData.clear();\n  if (null != exData) {\n    exceptionSensorData.addAll(exData);\n  }\n}", "comment": "reloads the data from the service .", "label": "what"}
{"id": "79422", "raw_code": "public static String createResourceName(String resource,Locale locale,boolean removeExtension){\n  String resourceName=resource;\n  if (removeExtension) {\n    if (resourceName.endsWith(\".xml\")) {\n      resourceName=resourceName.replace(\".xml\",\"\");\n    }\n else     if (resourceName.endsWith(\".properties\")) {\n      resourceName=resourceName.replace(\".properties\",\"\");\n    }\n  }\n  if (locale != null) {\n    if (UtilValidate.isNotEmpty(locale.toString())) {\n      resourceName=resourceName + \"_\" + locale;\n    }\n  }\n  return resourceName;\n}", "comment": "create a localized resource name based on a resource name and a locale .", "label": "what"}
{"id": "35571", "raw_code": "public int syncQuery(String query){\n  long start=System.currentTimeMillis();\n  int modified=execute(\"update\",UPDATE_COUNT_RESPONSE,query);\n  log.debug(\"Update query took {} millis and modified {} statements\",System.currentTimeMillis() - start,modified);\n  return modified;\n}", "comment": "synchronizes the rdf repository ' s representation of an entity to be exactly the provided statements .", "label": "what"}
{"id": "71081", "raw_code": "public void remove(DirectedEdge de){\n  outEdges.remove(de);\n}", "comment": "drops a member of this directededgestar .", "label": "what"}
{"id": "69262", "raw_code": "@Override protected void onMessageOnProducerThread(T msg){\n  _lock.lock();\n  try {\n    if (_pending.isEmpty()) {\n      _queue.schedule(_flushRunnable,_interval,_timeUnit);\n    }\n    _pending.add(msg);\n  }\n  finally {\n    _lock.unlock();\n  }\n}", "comment": "receives message and batches as needed .", "label": "what"}
{"id": "50224", "raw_code": "private boolean isInThumbRange(float touchX,double normalizedThumbValue){\n  return Math.abs(touchX - normalizedToScreen(normalizedThumbValue)) <= mThumbHalfWidth;\n}", "comment": "decides if given x - coordinate in screen space needs to be interpreted as \" within \" the normalized thumb x - coordinate .", "label": "what"}
{"id": "49876", "raw_code": "public static void cleanupAllFiles(FileSystem fileSystem,String BaseUri) throws IOException {\n  try {\n    if (fileSystem != null) {\n      Path rootDir=new Path(BaseUri);\n      FileStatus[] files=fileSystem.listStatus(rootDir);\n      for (      FileStatus file : files) {\n        fileSystem.delete(file.getPath(),false);\n      }\n    }\n  }\n catch (  Exception e) {\n    LOG.error(\"Error in deleting all files.\");\n  }\n}", "comment": "deletes all files in a container", "label": "what"}
{"id": "7369", "raw_code": "public void update(long duration,TimeUnit unit){\n  update(unit.toNanos(duration));\n}", "comment": "adds a recorded duration .", "label": "what"}
{"id": "67367", "raw_code": "public void submit(String queueName,DispatcherTask dispatcherTask){\nsynchronized (syncRoot) {\n    DispatcherTaskRunner currentTaskRunner=currentTasksMap.get(queueName);\n    if (currentTaskRunner == null) {\n      currentTaskRunner=new DispatcherTaskRunner(queueName,dispatcherTask);\n      currentTasksMap.put(queueName,currentTaskRunner);\n      executorService.execute(currentTaskRunner);\n    }\n else {\n      enqueueNextTask(queueName,dispatcherTask);\n    }\n  }\n}", "comment": "submits task to the specific queue", "label": "what"}
{"id": "52709", "raw_code": "public static Executor createTaskDistributor(){\n  return Executors.newCachedThreadPool(createThreadFactory(Thread.NORM_PRIORITY,\"uil-pool-d-\"));\n}", "comment": "creates default implementation of task distributor", "label": "what"}
{"id": "12556", "raw_code": "public void dump(Writer writer){\n  PrintWriter pw=new PrintWriter(new BufferedWriter(writer));\n  pw.println(\"#========== Wave ==========\");\n  pw.println(\"#Type: NULL\");\n  pw.println(\"#Sample_Rate: \" + (int)audioFormat.getSampleRate());\n  pw.println(\"#Num_of_Samples: \" + samples.length / 2);\n  pw.println(\"#Num_of_Channels: \" + audioFormat.getChannels());\n  if (samples != null) {\n    for (int i=0; i < samples.length; i+=2) {\n      pw.println(WaveUtils.bytesToShort(samples[i],samples[i + 1]));\n    }\n  }\n  pw.flush();\n}", "comment": "dumps the wave out to the given stream", "label": "what"}
{"id": "4900", "raw_code": "public ExpandRoomFreespaceIncomplete add_incomplete_expansion_room(ShapeTile p_shape,int p_layer,ShapeTile p_contained_shape){\n  ExpandRoomFreespaceIncomplete new_room=new ExpandRoomFreespaceIncomplete(p_shape,p_layer,p_contained_shape);\n  incomplete_expansion_rooms.add(new_room);\n  return new_room;\n}", "comment": "creates a new freespaceexpansionroom and adds it to the room list .", "label": "what"}
{"id": "76878", "raw_code": "static double computeDesiredEllipsoidMagnitude(final PlanetModel planetModel,final double x,final double y,final double z){\n  return 1.0 / Math.sqrt(x * x * planetModel.inverseAbSquared + y * y * planetModel.inverseAbSquared + z * z * planetModel.inverseCSquared);\n}", "comment": "compute the desired magnitude of a unit vector projected to a given planet model .", "label": "what"}
{"id": "4898", "raw_code": "private ArtLocateResult calculate_next_trace(boolean p_layer_changed,boolean p_at_fanout_end){\n  Collection<PlaPointFloat> corner_list=new LinkedList<PlaPointFloat>();\n  corner_list.add(current_from_point);\n  if (!p_at_fanout_end) {\n    PlaPointFloat adjusted_start_corner=adjust_start_corner();\n    if (adjusted_start_corner != current_from_point) {\n      PlaPointFloat add_corner=calculate_additional_corner(current_from_point,adjusted_start_corner,true,angle_restriction);\n      corner_list.add(add_corner);\n      corner_list.add(adjusted_start_corner);\n      previous_from_point=current_from_point;\n      current_from_point=adjusted_start_corner;\n    }\n  }\n  PlaPointFloat prev_corner=current_from_point;\n  for (int c_limit=0; c_limit < 1000; c_limit++) {\n    Collection<PlaPointFloat> next_corners=calculate_next_trace_corners();\n    if (next_corners.isEmpty())     break;\n    for (    PlaPointFloat curr_next_corner : next_corners) {\n      if (curr_next_corner == prev_corner)       continue;\n      corner_list.add(curr_next_corner);\n      previous_from_point=current_from_point;\n      current_from_point=curr_next_corner;\n      prev_corner=curr_next_corner;\n    }\n  }\n  int next_layer=current_trace_layer;\n  if (p_layer_changed) {\n    current_from_door_index=current_target_door_index + 1;\n    ExpandRoomComplete next_room=backtrack_array[current_from_door_index].next_room;\n    if (next_room != null) {\n      next_layer=next_room.get_layer();\n    }\n  }\n  PlaPointIntAlist rounded_corner_list=new PlaPointIntAlist(corner_list.size());\n  PlaPointInt prev_point=null;\n  for (  PlaPointFloat a_float : corner_list) {\n    PlaPointInt curr_point=a_float.round();\n    if (curr_point.equals(prev_point))     continue;\n    rounded_corner_list.add(curr_point);\n    prev_point=curr_point;\n  }\n  ArtLocateResult result=new ArtLocateResult(rounded_corner_list,current_trace_layer);\n  current_trace_layer=next_layer;\n  return result;\n}", "comment": "calculates the next trace trace of the connection under construction .", "label": "what"}
{"id": "33804", "raw_code": "public static <ValueT>ByteBuffer toByteBuffer(ValueT obj) throws IOException {\n  byte[] bytes=null;\n  ByteArrayOutputStream bos=null;\n  ObjectOutputStream oos=null;\n  try {\n    bos=new ByteArrayOutputStream();\n    oos=new ObjectOutputStream(bos);\n    oos.writeObject(obj);\n    oos.flush();\n    bytes=bos.toByteArray();\n  }\n  finally {\n    if (oos != null) {\n      oos.close();\n    }\n    if (bos != null) {\n      bos.close();\n    }\n  }\n  return ByteBuffer.wrap(bytes);\n}", "comment": "serialize object to a bytebuffer object .", "label": "what"}
{"id": "73914", "raw_code": "@Override protected Sensor createNewSensor(String systemName,String userName){\n  if (log.isDebugEnabled()) {\n    log.debug(\"createNewSensor \" + systemName + \" \"+ userName);\n  }\n  Sensor s;\n  String sName=SerialAddress.normalizeSystemName(systemName);\n  if (sName.equals(\"\")) {\n    log.error(\"Invalid Sensor system name - \" + systemName);\n    return null;\n  }\n  s=getBySystemName(sName);\n  if (s != null) {\n    log.error(\"Sensor with this name already exists - \" + systemName);\n    return null;\n  }\n  String altName=SerialAddress.convertSystemNameToAlternate(sName);\n  s=getBySystemName(altName);\n  if (s != null) {\n    log.error(\"Sensor with name '\" + systemName + \"' already exists as '\"+ altName+ \"'\");\n    return null;\n  }\n  int bit=SerialAddress.getBitFromSystemName(sName);\n  if ((bit <= 0) || (bit >= SENSORSPERNODE)) {\n    log.error(\"Sensor bit number, \" + Integer.toString(bit) + \", is outside the supported range, 1-\"+ Integer.toString(SENSORSPERNODE - 1));\n    return null;\n  }\n  if (userName == null) {\n    s=new SerialSensor(sName);\n  }\n else {\n    s=new SerialSensor(sName,userName);\n  }\n  SerialNode node=SerialAddress.getNodeFromSystemName(sName);\n  if (node == null) {\n    log.warn(\"Sensor \" + sName + \" refers to an undefined Serial Node.\");\n    return s;\n  }\n  node.registerSensor(s,bit);\n  if (log.isDebugEnabled()) {\n    log.debug(\"register \" + s.getSystemName() + \" in node \"+ node);\n  }\n  return s;\n}", "comment": "create a new sensor if all checks are passed system name is normalized to ensure uniqueness .", "label": "what"}
{"id": "458", "raw_code": "public void goToCurrentDay(){\n  int monthDifference=FlexibleCalendarHelper.getMonthDifference(displayYear,displayMonth);\n  Calendar cal=Calendar.getInstance();\n  selectedDateItem.setDay(cal.get(Calendar.DAY_OF_MONTH));\n  selectedDateItem.setMonth(cal.get(Calendar.MONTH));\n  selectedDateItem.setYear(cal.get(Calendar.YEAR));\n  if (disableAutoDateSelection) {\n    this.userSelectedItem=selectedDateItem.clone();\n  }\n  if (monthDifference != 0) {\n    resetAdapters=true;\n    if (monthDifference < 0) {\n      monthInfPagerAdapter.setFakeCount(lastPosition);\n      monthInfPagerAdapter.notifyDataSetChanged();\n    }\n    shouldOverrideComputedDate=true;\n    moveToPosition(monthDifference);\n  }\n else {\n    FlexibleCalendarGridAdapter currentlyVisibleAdapter=monthViewPagerAdapter.getMonthAdapterAtPosition(lastPosition % MonthViewPagerAdapter.VIEWS_IN_PAGER);\n    currentlyVisibleAdapter.notifyDataSetChanged();\n  }\n}", "comment": "move the position to today ' s date", "label": "what"}
{"id": "23693", "raw_code": "public Object take() throws InterruptedException, ForceReattemptException {\n  throw new UnsupportedOperationException();\n}", "comment": "it removes the first key from the queue .", "label": "what"}
{"id": "3469", "raw_code": "private void destroy(){\n  if (log.isLoggable(Level.FINEST)) {\n    log.finest(this + \" destroying connection\");\n  }\n  try {\n    _socket.forceShutdown();\n  }\n catch (  Throwable e) {\n  }\n  try {\n    closeConnection();\n  }\n catch (  Throwable e) {\n    log.log(Level.FINER,e.toString(),e);\n  }\n  _port.removeConnection(this);\n}", "comment": "destroy kills the connection and drops it from the connection pool .", "label": "what"}
{"id": "81819", "raw_code": "int atom() throws RESyntaxException {\n  int ret=node(RE.OP_ATOM,0);\n  int lenAtom=0;\n  atomLoop:   while (idx < len) {\n    if ((idx + 1) < len) {\n      char c=pattern.charAt(idx + 1);\n      if (pattern.charAt(idx) == '\\\\') {\n        int idxEscape=idx;\n        escape();\n        if (idx < len) {\n          c=pattern.charAt(idx);\n        }\n        idx=idxEscape;\n      }\nswitch (c) {\ncase '{':\ncase '?':\ncase '*':\ncase '+':\n        if (lenAtom != 0) {\n          break atomLoop;\n        }\n    }\n  }\nswitch (pattern.charAt(idx)) {\ncase ']':\ncase '^':\ncase '$':\ncase '.':\ncase '[':\ncase '(':\ncase ')':\ncase '|':\n    break atomLoop;\ncase '{':\ncase '?':\ncase '*':\ncase '+':\n  if (lenAtom == 0) {\n    syntaxError(\"Missing operand to closure\");\n  }\nbreak atomLoop;\ncase '\\\\':\n{\nint idxBeforeEscape=idx;\nint c=escape();\nif ((c & ESC_MASK) == ESC_MASK) {\n  idx=idxBeforeEscape;\n  break atomLoop;\n}\nemit((char)c);\nlenAtom++;\n}\nbreak;\ndefault :\nemit(pattern.charAt(idx++));\nlenAtom++;\nbreak;\n}\n}\nif (lenAtom == 0) {\ninternalError();\n}\ninstruction[ret + RE.offsetOpdata]=(char)lenAtom;\nreturn ret;\n}", "comment": "absorb an atomic character string .", "label": "what"}
{"id": "70569", "raw_code": "public boolean isNetworkConnected(){\n  ConnectivityManager connectivityManager=(ConnectivityManager)getSystemService(CONNECTIVITY_SERVICE);\n  NetworkInfo networkInfo=connectivityManager.getActiveNetworkInfo();\n  return networkInfo != null && networkInfo.isConnectedOrConnecting();\n}", "comment": "check the current active network is available .", "label": "what"}
{"id": "64276", "raw_code": "public final void close(LsServerPacket closePacket,boolean forced){\nsynchronized (guard) {\n    if (isWriteDisabled()) {\n      return;\n    }\n    log.debug(\"sending packet: \" + closePacket + \" and closing connection after that.\");\n    pendingClose=true;\n    isForcedClosing=forced;\n    sendMsgQueue.clear();\n    sendMsgQueue.addLast(closePacket);\n    enableWriteInterest();\n  }\n}", "comment": "its guaranted that closepacket will be sent before closing connection , but all past and future packets wont .", "label": "what"}
{"id": "82716", "raw_code": "public SeaGlassTitlePane(JRootPane rootPane,SeaGlassRootPaneUI ui){\n  this.rootPane=rootPane;\n  this.rootPaneUI=ui;\n  rootParent=(RootPaneContainer)rootPane.getParent();\n  installTitlePane();\n}", "comment": "creates a new seaglasstitlepane object .", "label": "what"}
{"id": "51546", "raw_code": "public void writeLong(long value) throws IOException {\n  checkWritePrimitiveTypes();\n  primitiveTypes.writeLong(value);\n}", "comment": "writes a long ( 64 bit ) to the target stream .", "label": "what"}
{"id": "30512", "raw_code": "static public URL findContainerXML(String _containerName){\n  URL _containerNameURL=null;\n  String _containerNameFilePath=Constants.Container.CONTAINER_CONFIG_DIRECTORY + \"/\" + _containerName+ \".xml\";\n  _containerNameURL=getResourceURL(_containerNameFilePath);\n  if (_containerNameURL != null) {\n    if (_logger.isLoggable(Level.INFO)) {\n      _logger.info(\"Loaded the container xml file < \" + _containerNameURL + \" >.\");\n    }\n  }\n  return _containerNameURL;\n}", "comment": "look for the requested container xml file in the classpath ( resource ) under / config / . xml .", "label": "what"}
{"id": "35793", "raw_code": "public NSNumber(int i){\n  doubleValue=longValue=i;\n  type=INTEGER;\n}", "comment": "creates an integer number .", "label": "what"}
{"id": "16207", "raw_code": "public static void dump(String message,StackTraceElement[] stackTrace){\n  dump(message,Arrays.asList(stackTrace));\n}", "comment": "dumps the given message and stack to the system error console .", "label": "what"}
{"id": "79513", "raw_code": "public void execQuery(String sql,ExecQueryCallbackFunctionIF aListener) throws GenericEntityException {\n  if (_connection == null) {\n    getConnection();\n  }\n  try {\n    if (Debug.verboseOn())     Debug.logVerbose(\"[SQLProcessor.execQuery]: \" + sql,module);\n    executeQuery(sql);\n    boolean keepGoing=true;\n    while (keepGoing && _rs.next()) {\n      keepGoing=aListener.processNextRow(_rs);\n    }\n    if (_manualTX) {\n      _connection.commit();\n    }\n  }\n catch (  SQLException sqle) {\n    Debug.logWarning(\"[SQLProcessor.execQuery]: SQL Exception while executing the following:\\n\" + sql + \"\\nError was:\",module);\n    Debug.logWarning(sqle.getMessage(),module);\n    throw new GenericEntityException(\"SQL Exception while executing the following:\" + _sql,sqle);\n  }\n finally {\n    close();\n  }\n}", "comment": "execute a query based on the sql string given .", "label": "what"}
{"id": "85574", "raw_code": "private Name cacheName(String sig){\n  StringBuilder buf=new StringBuilder();\n  if (sig.startsWith(\"[\")) {\n    buf=buf.append(\"array\");\n    while (sig.startsWith(\"[\")) {\n      buf=buf.append(target.syntheticNameChar());\n      sig=sig.substring(1);\n    }\n    if (sig.startsWith(\"L\")) {\n      sig=sig.substring(0,sig.length() - 1);\n    }\n  }\n else {\n    buf=buf.append(\"class\" + target.syntheticNameChar());\n  }\n  buf=buf.append(sig.replace('.',target.syntheticNameChar()));\n  return names.fromString(buf.toString());\n}", "comment": "the name of the variable to cache t . class values .", "label": "what"}
{"id": "64014", "raw_code": "void clear(){\n  if (mViewTypeCount == 1) {\n    final ArrayList<View> scrap=mCurrentScrap;\n    final int scrapCount=scrap.size();\n    for (int i=0; i < scrapCount; i++) {\n      removeDetachedView(scrap.remove(scrapCount - 1 - i),false);\n    }\n  }\n else {\n    final int typeCount=mViewTypeCount;\n    for (int i=0; i < typeCount; i++) {\n      final ArrayList<View> scrap=mScrapViews[i];\n      final int scrapCount=scrap.size();\n      for (int j=0; j < scrapCount; j++) {\n        removeDetachedView(scrap.remove(scrapCount - 1 - j),false);\n      }\n    }\n  }\n  if (mTransientStateViews != null) {\n    mTransientStateViews.clear();\n  }\n}", "comment": "clears the scrap heap .", "label": "what"}
{"id": "45091", "raw_code": "public int read(char cbuf[],int off,int len){\n  int k;\n  if (position >= document.getLength()) {\n    return -1;\n  }\n  k=len;\n  if ((position + k) >= document.getLength())   k=document.getLength() - (int)position;\n  if (off + k >= cbuf.length)   k=cbuf.length - off;\n  try {\n    document.getText((int)position,k,segment);\n    position+=k;\n    System.arraycopy(segment.array,segment.offset,cbuf,off,k);\n    return k;\n  }\n catch (  BadLocationException ble) {\n    return -1;\n  }\n}", "comment": "reads characters into a portion of an array .", "label": "what"}
{"id": "45597", "raw_code": "Builder addLenient(String line){\n  int index=line.indexOf(\":\",1);\n  if (index != -1) {\n    return addLenient(line.substring(0,index),line.substring(index + 1));\n  }\n else   if (line.startsWith(\":\")) {\n    return addLenient(\"\",line.substring(1));\n  }\n else {\n    return addLenient(\"\",line);\n  }\n}", "comment": "add a header line without any validation .", "label": "what"}
{"id": "79737", "raw_code": "public static void mergeNodeChildren(TreeNode node){\n  DefaultMutableTreeNode masterNode=(DefaultMutableTreeNode)node;\n  for (int i=0; i < masterNode.getChildCount(); i++) {\n    DefaultMutableTreeNode child=(DefaultMutableTreeNode)masterNode.getChildAt(i);\n    if (!child.isLeaf()) {\n      MergeHelpUtilities.mergeNodeChildren(DEFAULT_MERGE_TYPE,child);\n    }\n  }\n}", "comment": "merge node children .", "label": "what"}
{"id": "21240", "raw_code": "private static Object createAndBindItem(ParameterAccess parameters,Class<?> itemType){\n  try {\n    Object value=itemType.newInstance();\n    bind(value,parameters);\n    return value;\n  }\n catch (  InstantiationException|IllegalAccessException e) {\n    throw new BindingException(\"Failed to instantiate new instance of \" + itemType,e);\n  }\n}", "comment": "creates and binds the parameters to a new item .", "label": "what"}
{"id": "38308", "raw_code": "public SimpleSetupPanel(Experiment exp){\n  this();\n  setExperiment(exp);\n}", "comment": "creates the setup panel with the supplied initial experiment .", "label": "what"}
{"id": "51980", "raw_code": "public static void addListener(Listener listener){\n  listeners.addLast(listener);\n}", "comment": "adds a listener of memory copying events .", "label": "what"}
{"id": "49352", "raw_code": "private static void processArgs(String[] args){\n  for (int i=0; i < args.length; i++) {\n    String arg=args[i];\n    if (arg.equals(\"-o\")) {\n      outputDir=args[++i];\n    }\n else     if (arg.equals(\"-spec\")) {\n      unicodeData=args[++i];\n    }\n else     if (arg.equals(\"-language\")) {\n      language=args[++i];\n    }\n else     if (arg.equals(\"-country\")) {\n      country=args[++i];\n    }\n else     if (arg.equals(\"-valiant\")) {\n      valiant=args[++i];\n    }\n else {\n      usage();\n    }\n  }\n  localeName=getLocaleName();\n}", "comment": "parses the specified arguments and sets up the variables .", "label": "what"}
{"id": "49798", "raw_code": "public boolean startsWith(CharSeq prefix){\n  return str.startsWith(prefix.str);\n}", "comment": "tests whether this charseq starts with the specified prefix", "label": "what"}
{"id": "38464", "raw_code": "public boolean containsWindow(Class<?> windowClass){\n  return (getWindow(windowClass) != null);\n}", "comment": "checks , whether an instance of the given window class is already in the window list .", "label": "what"}
{"id": "79852", "raw_code": "public void fadeToLayer(int index){\n  mTransitionState=TRANSITION_STARTING;\n  Arrays.fill(mIsLayerOn,false);\n  mIsLayerOn[index]=true;\n  invalidateSelf();\n}", "comment": "starts fading to the specified layer .", "label": "what"}
{"id": "1496", "raw_code": "public static int hashCode(boolean[] field){\n  return field == null || field.length == 0 ? 0 : Arrays.hashCode(field);\n}", "comment": "computes the hash code of a repeated boolean field .", "label": "what"}
{"id": "27007", "raw_code": "public AbstractSurfaceObject(AbstractSurfaceObject source){\n  super(source);\n  this.visible=source.visible;\n  this.uniqueId=nextUniqueId();\n  this.lastModifiedTime=System.currentTimeMillis();\n  this.enableBatchPicking=source.enableBatchPicking;\n}", "comment": "creates a shallow copy of the specified source shape .", "label": "what"}
{"id": "82877", "raw_code": "private void createNewReviewTask(TaskRepository repository,TaskData taskData) throws CoreException {\n  Repository repo=AppraisePluginUtils.getGitRepoForRepository(repository);\n  AppraisePluginReviewClient client;\n  try {\n    client=new AppraisePluginReviewClient(repository);\n  }\n catch (  GitClientException e1) {\n    throw new CoreException(new Status(IStatus.ERROR,AppraiseConnectorPlugin.PLUGIN_ID,\"Failed to initialize git client\"));\n  }\n  String currentBranch;\n  try {\n    currentBranch=repo.getFullBranch();\n  }\n catch (  IOException e) {\n    throw new CoreException(new Status(IStatus.ERROR,AppraiseConnectorPlugin.PLUGIN_ID,\"Error retrieving current branch\",e));\n  }\n  if (MASTER_REF.equals(currentBranch)) {\n    throw new CoreException(new Status(IStatus.ERROR,AppraiseConnectorPlugin.PLUGIN_ID,\"Cannot create review on master branch\"));\n  }\n  setAttributeValue(taskData,schema.REQUESTER,repository.getUserName());\n  setAttributeValue(taskData,schema.TARGET_REF,MASTER_REF);\n  setAttributeValue(taskData,schema.REVIEW_REF,currentBranch);\n  RevCommit reviewCommit;\n  try {\n    reviewCommit=client.getReviewCommit(currentBranch,MASTER_REF);\n  }\n catch (  GitClientException e) {\n    throw new CoreException(new Status(IStatus.ERROR,AppraiseConnectorPlugin.PLUGIN_ID,\"Cannot find a merge base\",e));\n  }\n  if (reviewCommit == null) {\n    throw new CoreException(new Status(IStatus.INFO,AppraiseConnectorPlugin.PLUGIN_ID,\"No commits to review on \" + currentBranch));\n  }\n  setAttributeValue(taskData,schema.DESCRIPTION,reviewCommit.getFullMessage());\n  setAttributeValue(taskData,schema.REVIEW_COMMIT,reviewCommit.getName());\n  try {\n    List<DiffEntry> diffs=client.getReviewDiffs(currentBranch,MASTER_REF);\n    populateDiffs(repository,diffs,taskData);\n  }\n catch (  Exception e) {\n    throw new CoreException(new Status(IStatus.ERROR,AppraiseConnectorPlugin.PLUGIN_ID,\"Failed to load review diffs\",e));\n  }\n}", "comment": "sets up a new review on the current branch , as a task .", "label": "what"}
{"id": "12962", "raw_code": "@Override public void startup() throws Exception {\n  Log.d(Mary.LOG,\"Register UnitSelection voices:\");\n  List<String> voiceNames=MaryProperties.getList(\"unitselection.voices.list\");\n  for (  String voiceName : voiceNames) {\n    long time=System.currentTimeMillis();\n    Voice unitSelVoice=new UnitSelectionVoice(voiceName,this);\n    Log.d(Mary.LOG,\"Voice '\" + unitSelVoice + \"'\");\n    Voice.registerVoice(unitSelVoice);\n    long newtime=System.currentTimeMillis() - time;\n    Log.i(Mary.LOG,\"Loading of voice \" + voiceName + \" took \"+ newtime+ \" milliseconds\");\n  }\n  Log.i(Mary.LOG,\"started.\");\n}", "comment": "start up the waveform synthesizer .", "label": "what"}
{"id": "78169", "raw_code": "public int findStartOfColumn(int column){\n  if (column == mColumns)   return getSpaceUsed();\n  int currentColumn=0;\n  int currentCharIndex=0;\n  while (true) {\n    int newCharIndex=currentCharIndex;\n    char c=mText[newCharIndex++];\n    boolean isHigh=Character.isHighSurrogate(c);\n    int codePoint=isHigh ? Character.toCodePoint(c,mText[newCharIndex++]) : c;\n    int wcwidth=WcWidth.width(codePoint);\n    if (wcwidth > 0) {\n      currentColumn+=wcwidth;\n      if (currentColumn == column) {\n        while (newCharIndex < mSpaceUsed) {\n          if (Character.isHighSurrogate(mText[newCharIndex])) {\n            if (WcWidth.width(Character.toCodePoint(mText[newCharIndex],mText[newCharIndex + 1])) <= 0) {\n              newCharIndex+=2;\n            }\n else {\n              break;\n            }\n          }\n else           if (WcWidth.width(mText[newCharIndex]) <= 0) {\n            newCharIndex++;\n          }\n else {\n            break;\n          }\n        }\n        return newCharIndex;\n      }\n else       if (currentColumn > column) {\n        return currentCharIndex;\n      }\n    }\n    currentCharIndex=newCharIndex;\n  }\n}", "comment": "note that the column may end of second half of wide character .", "label": "what"}
{"id": "9278", "raw_code": "public double distance(Vector o){\n  return Math.sqrt(NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z));\n}", "comment": "get the distance between this vector and another .", "label": "what"}
{"id": "450", "raw_code": "public void startObject(int numfields){\n  notNested();\n  if (vtable == null || vtable.length < numfields)   vtable=new int[numfields];\n  vtable_in_use=numfields;\n  Arrays.fill(vtable,0,vtable_in_use,0);\n  nested=true;\n  object_start=offset();\n}", "comment": "start encoding a new object in the buffer .", "label": "what"}
{"id": "31688", "raw_code": "private Map<String,String> produceStream(String topic){\n  List<ProducerRecord<String,String>> messages=new ArrayList<>(EVENT_CNT);\n  Map<String,String> keyValMap=new HashMap<>();\n  for (int evt=0; evt < EVENT_CNT; evt++) {\n    long runtime=System.currentTimeMillis();\n    String key=topic + \"_\" + String.valueOf(evt);\n    String msg=runtime + String.valueOf(evt);\n    messages.add(new ProducerRecord<>(topic,key,msg));\n    keyValMap.put(key,msg);\n  }\n  kafkaBroker.sendMessages(messages);\n  return keyValMap;\n}", "comment": "sends messages to kafka .", "label": "what"}
{"id": "43293", "raw_code": "public static void trim(CharSequence aText,int[] aSpan){\n  int begin=aSpan[0];\n  int end=aSpan[1] - 1;\n  CharSequence data=aText;\n  while ((begin < (data.length() - 1)) && trimChar(data.charAt(begin))) {\n    begin++;\n  }\n  while ((end > 0) && trimChar(data.charAt(end))) {\n    end--;\n  }\n  end++;\n  aSpan[0]=begin;\n  aSpan[1]=end;\n}", "comment": "remove trailing or leading whitespace from the annotation .", "label": "what"}
{"id": "1508", "raw_code": "public static double[] concatAllDouble(double[]... arrays){\n  int totalLength=0;\n  final int subArrayCount=arrays.length;\n  for (int i=0; i < subArrayCount; ++i) {\n    totalLength+=arrays[i].length;\n  }\n  double[] result=Arrays.copyOf(arrays[0],totalLength);\n  int offset=arrays[0].length;\n  for (int i=1; i < subArrayCount; ++i) {\n    System.arraycopy(arrays[i],0,result,offset,arrays[i].length);\n    offset+=arrays[i].length;\n  }\n  return result;\n}", "comment": "concatenates a list of double arrays into a single array .", "label": "what"}
{"id": "44405", "raw_code": "public void CONT(int sessionNumber) throws Exception {\n  this.maxSessionNumber=Math.max(this.maxSessionNumber,sessionNumber);\n  testElements.add(new ContinuationElement(sessionNumber));\n}", "comment": "adds a continuation .", "label": "what"}
{"id": "56157", "raw_code": "public static double calcRotationAngleInDegrees(PointF centerPt,PointF targetPt){\n  double theta=Math.atan2(targetPt.y - centerPt.y,targetPt.x - centerPt.x);\n  double angle=Math.toDegrees(theta);\n  if (angle < 0) {\n    angle+=360;\n  }\n  return angle;\n}", "comment": "calculates the angle from centerpt to targetpt in degrees .", "label": "what"}
{"id": "48231", "raw_code": "public DeltaCRLIndicatorExtension(int crlNum) throws IOException {\n  super(PKIXExtensions.DeltaCRLIndicator_Id,true,BigInteger.valueOf(crlNum),NAME,LABEL);\n}", "comment": "creates a delta crl indicator extension with the integer value .", "label": "what"}
{"id": "68960", "raw_code": "public static void v(String tag,String s,Object... args){\n  if (LOG.VERBOSE >= LOGLEVEL)   Log.v(tag,String.format(s,args));\n}", "comment": "verbose log message with printf formatting .", "label": "what"}
{"id": "9242", "raw_code": "static private double calcLogProb(int numAppear,double mu){\n  final double sigma=calcSigmaFromMu(mu);\n  final double logNumAppear=Math.log(numAppear);\n  final double overMu=Math.max(logNumAppear - mu,0.0);\n  final double res=-(1.0 / 2) * (overMu * overMu) / (sigma * sigma) - s_logSqrtTwoPi - Math.log(sigma);\n  assert (res <= 0);\n  return res;\n}", "comment": "calculate the log probability given the message ' s logarithm is normally distributed .", "label": "what"}
{"id": "54477", "raw_code": "protected static String extractSecretAccessKey(String s3uri){\n  return s3uri.substring(s3uri.indexOf(':',s3uri.indexOf(\"://\") + 1) + 1,s3uri.indexOf('@'));\n}", "comment": "extracts the secretaccesskey from the given uri", "label": "what"}
{"id": "70701", "raw_code": "private void dial(String contactInformation,boolean makeTheCall,boolean usePhoneSpeaker){\n  if (contactInformation.equals(\"\")) {\n    String lastRecipient=RecipientCmd.getLastRecipientNumber();\n    String lastRecipientName=RecipientCmd.getLastRecipientName();\n    if (lastRecipient != null) {\n      doDial(lastRecipientName,lastRecipient,makeTheCall,usePhoneSpeaker);\n    }\n else {\n      send(\"error: last recipient not set\");\n    }\n  }\n else {\n    ResolvedContact resolvedContact=mContactsResolver.resolveContact(contactInformation,ContactsResolver.TYPE_ALL);\n    if (resolvedContact == null) {\n      send(R.string.chat_no_match_for,contactInformation);\n    }\n else     if (resolvedContact.isDistinct()) {\n      doDial(resolvedContact.getName(),resolvedContact.getNumber(),makeTheCall,usePhoneSpeaker);\n    }\n else {\n      askForMoreDetails(resolvedContact.getCandidates());\n    }\n  }\n}", "comment": "dial the specified contact", "label": "what"}
{"id": "66860", "raw_code": "public void addSafeClass(SootClass clz){\n  safeClasses.add(clz.getName());\n}", "comment": "denote that all methods of a class are safe .", "label": "what"}
{"id": "64324", "raw_code": "private boolean activeListHasRoom(){\n  int maxDownloads=1;\n  return mActiveList.size() < maxDownloads;\n}", "comment": "check if there is room in the active list .", "label": "what"}
{"id": "76732", "raw_code": "protected static Map<String,Step> parse(Class<? extends RSLPStemmerBase> clazz,String resource){\n  try {\n    InputStream is=clazz.getResourceAsStream(resource);\n    LineNumberReader r=new LineNumberReader(new InputStreamReader(is,StandardCharsets.UTF_8));\n    Map<String,Step> steps=new HashMap<>();\n    String step;\n    while ((step=readLine(r)) != null) {\n      Step s=parseStep(r,step);\n      steps.put(s.name,s);\n    }\n    r.close();\n    return steps;\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}", "comment": "parse a resource file into an rslp stemmer description .", "label": "what"}
{"id": "57162", "raw_code": "private boolean checkMatchIp(Map<String,Object> rows){\n  boolean matchEther=false;\n  String val=(String)rows.get(StaticFlowEntryPusher.COLUMN_DL_TYPE);\n  if (val != null) {\n    int type=0;\n    if (val.startsWith(\"0x\")) {\n      type=Integer.parseInt(val.substring(2),16);\n    }\n else {\n      try {\n        type=Integer.parseInt(val);\n      }\n catch (      NumberFormatException e) {\n      }\n    }\n    if (type == 2048)     matchEther=true;\n  }\n  if ((rows.containsKey(StaticFlowEntryPusher.COLUMN_NW_DST) || rows.containsKey(StaticFlowEntryPusher.COLUMN_NW_SRC) || rows.containsKey(StaticFlowEntryPusher.COLUMN_NW_PROTO)|| rows.containsKey(StaticFlowEntryPusher.COLUMN_NW_TOS)) && (matchEther == false))   return false;\n  return true;\n}", "comment": "checks to see if the user matches ip information without checking for the correct ether - type ( 2048 ) .", "label": "what"}
{"id": "4807", "raw_code": "public static String write(POSMikheevCounter counter){\n  return POSBaseLineCounter.write(counter);\n}", "comment": "write an instance of posmikheevcounter class to json format", "label": "what"}
{"id": "35016", "raw_code": "private Map<String,AnnotationMirror> annosInPackage(PackageElement packageElement){\n  return createImportedAnnotationsMap(ElementFilter.typesIn(packageElement.getEnclosedElements()));\n}", "comment": "all annotations defined in the package .", "label": "what"}
{"id": "45787", "raw_code": "public final void updateCursor(){\n  updatePending.set(false);\n  updateCursorImpl();\n}", "comment": "sets the cursor to correspond the component currently under mouse .", "label": "what"}
{"id": "11500", "raw_code": "public void close() throws IOException {\n  try {\n    Debug.message(\"binaryfile\",\"StreamInputReader.close()\");\n    if (Debug.debugging(\"connection_problems\")) {\n      Thread.sleep(1000);\n    }\n    if (inputStream != null)     inputStream.close();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n  inputStream=null;\n}", "comment": "closes the underlying file", "label": "what"}
{"id": "1520", "raw_code": "private void readBinary(final LittleEndianDataInputStream dis) throws IOException {\n  RajLog.i(\"StlPaser: Reading Binary\");\n  dis.skip(80);\n  int facetCount=dis.readInt();\n  float[] verticesArr=new float[facetCount * 9];\n  float[] normalsArr=new float[facetCount * 9];\n  int[] indicesArr=new int[facetCount * 3];\n  float[] tempNorms=new float[3];\n  int vertPos=0, normPos=0;\n  for (int i=0; i < indicesArr.length; i++)   indicesArr[i]=i;\n  while (dis.available() > 0) {\n    for (int j=0; j < 3; j++) {\n      tempNorms[j]=dis.readFloat();\n      if (Float.isNaN(tempNorms[j]) || Float.isInfinite(tempNorms[j])) {\n        RajLog.w(\"STL contains bad normals of NaN or Infinite!\");\n        tempNorms[0]=0;\n        tempNorms[1]=0;\n        tempNorms[2]=0;\n        break;\n      }\n    }\n    for (int j=0; j < 3; j++) {\n      normalsArr[normPos++]=tempNorms[0];\n      normalsArr[normPos++]=tempNorms[1];\n      normalsArr[normPos++]=tempNorms[2];\n    }\n    for (int j=0; j < 9; j++)     verticesArr[vertPos++]=dis.readFloat();\n    dis.skip(2);\n  }\n  mRootObject.setData(verticesArr,normalsArr,null,null,indicesArr,false);\n}", "comment": "read stream as binary stl .", "label": "what"}
{"id": "85108", "raw_code": "public static void assertSpecificLang(String specificLang) throws XMPException {\n  if (specificLang == null || specificLang.length() == 0) {\n    throw new XMPException(\"Empty specific language\",XMPError.BADPARAM);\n  }\n}", "comment": "asserts that a specific language is set .", "label": "what"}
{"id": "84389", "raw_code": "public static void check(boolean cond,Object value){\n  if (!cond)   error(String.valueOf(value));\n}", "comment": "equivalent to assert cond : value ;", "label": "what"}
{"id": "68583", "raw_code": "public static SourceDataQuality fromXML(Element domElement){\n  NodeList fields=domElement.getChildNodes();\n  int fieldsCount=fields.getLength();\n  String fieldName;\n  String fieldValueString;\n  Node fieldNode;\n  SourceDataQuality result=new SourceDataQuality();\n  for (int i=0; i != fieldsCount; i++) {\n    fieldNode=fields.item(i);\n    if (fieldNode.getNodeType() == Node.ELEMENT_NODE) {\n      fieldName=fieldNode.getNodeName();\n      Node fieldValueNode=fieldNode.getFirstChild();\n      if (fieldValueNode != null) {\n        fieldValueString=fieldValueNode.getNodeValue();\n      }\n else {\n        fieldValueString=\"\";\n      }\n      if (fieldName.equals(XML_ELEMENT_QUALITY_CODE)) {\n        result.qualityCode=Short.parseShort(fieldValueString);\n      }\n else       if (fieldName.equals(XML_ELEMENT_QUALITY_DESC)) {\n        result.description=fieldValueString;\n      }\n    }\n  }\n  return result;\n}", "comment": "create a sourcedataquality object from its xml representation .", "label": "what"}
{"id": "476", "raw_code": "private static String generateJWT(String secret,String jwtID,String iss,Integer ttl,Map<String,String> claims) throws HmacException {\n  try {\n    return signJWT(secret,jwtID,ttl,iss,claims);\n  }\n catch (  JOSEException e) {\n    e.printStackTrace();\n    throw new HmacException(\"Cannot generate JWT\",e);\n  }\n}", "comment": "generate a new signed jwt", "label": "what"}
{"id": "38663", "raw_code": "@Override public synchronized void addDataSourceListener(DataSourceListener dsl){\n  m_dataSourceListeners.addElement(dsl);\n  if (m_format != null) {\n    DataSetEvent e=new DataSetEvent(this,m_format);\n    dsl.acceptDataSet(e);\n  }\n}", "comment": "add a datasource listener", "label": "what"}
{"id": "3945", "raw_code": "public boolean toFail(){\n  LifecycleState state;\nsynchronized (this) {\n    state=_state;\n    if (state.isAfterDestroying()) {\n      return false;\n    }\n    _state=FAILED;\n    _lastChangeTime=CurrentTime.currentTime();\n  }\n  if (_log != null && _log.isLoggable(_level))   _log.log(_level,\"fail \" + _name);\n  notifyListeners(state,FAILED);\n  _failCount++;\n  return true;\n}", "comment": "changes to the failed state .", "label": "what"}
{"id": "37883", "raw_code": "public double evaluate(VectorInstance x,VectorInstance y) throws Exception {\n  VectorInstance diff=x.subtract(y);\n  double result=-m_gamma * diff.dotProduct(diff);\n  return Math.exp(result);\n}", "comment": "compute the result of the kernel evaluation on the supplied vectors", "label": "what"}
{"id": "74523", "raw_code": "void cancelIncludedOnly(){\n  if (!_showAllInput) {\n    _inputAllButton.doClick();\n  }\n  if (!_showAllOutput) {\n    _outputAllButton.doClick();\n  }\n  if (!_showAllAlign) {\n    _alignAllButton.doClick();\n  }\n}", "comment": "cancels included only option", "label": "what"}
{"id": "41240", "raw_code": "public static void createErrorDialog(final String title,final String message){\n  final Alert alert=new Alert(AlertType.ERROR);\n  alert.setTitle(title);\n  alert.setContentText(message);\n  alert.setHeaderText(null);\n  alert.showAndWait();\n}", "comment": "shows an error dialog .", "label": "what"}
{"id": "21190", "raw_code": "public static String parseDiskString(String input){\n  String delims=\"[ ]+\";\n  String[] tokens=input.split(delims);\n  return tokens[0];\n}", "comment": "get the disk name out from the input string .", "label": "what"}
{"id": "71891", "raw_code": "public static PersistentSearchRequestControl newControl(final boolean isCritical,final boolean changesOnly,final boolean returnECs,final PersistentSearchChangeType... changeTypes){\n  Reject.ifNull((Object)changeTypes);\n  return newControl(isCritical,changesOnly,returnECs,Arrays.asList(changeTypes));\n}", "comment": "creates a new persistent search request control .", "label": "what"}
{"id": "8213", "raw_code": "public static Number multiply(Character left,Character right){\n  return multiply(Integer.valueOf(left),right);\n}", "comment": "multiply two characters .", "label": "what"}
{"id": "3831", "raw_code": "public StartListener(Object resource){\n  _resource=resource;\n}", "comment": "creates the new start listener .", "label": "what"}
{"id": "25770", "raw_code": "@Beta public void reset(){\n  schedulersHook.set(null);\n}", "comment": "reset any explicit or default - set hooks .", "label": "what"}
{"id": "24616", "raw_code": "public void parse(String string){\n  if (string == null) {\n    throw new NullPointerException(\"string is null\");\n  }\n  int bufferSize=Math.max(MIN_BUFFER_SIZE,Math.min(DEFAULT_BUFFER_SIZE,string.length()));\n  try {\n    parse(new StringReader(string),bufferSize);\n  }\n catch (  IOException exception) {\n    throw new RuntimeException(exception);\n  }\n}", "comment": "parses the given input string .", "label": "what"}
{"id": "29756", "raw_code": "@Override protected int sizePendingWorkers(){\n  return _pendingWorkers.size();\n}", "comment": "the size of pending workers", "label": "what"}
{"id": "46655", "raw_code": "public void insert(Component component,int index){\n  if (index < 0) {\n    throw new IllegalArgumentException(\"index less than zero.\");\n  }\n  int nitems=getComponentCount();\n  Vector<Component> tempItems=new Vector<Component>();\n  for (int i=index; i < nitems; i++) {\n    tempItems.addElement(getComponent(index));\n    remove(index);\n  }\n  add(component);\n  for (  Component tempItem : tempItems) {\n    add(tempItem);\n  }\n}", "comment": "inserts the specified component into the menu at a given position .", "label": "what"}
{"id": "36312", "raw_code": "public static List<String> unescape(String source,char escapeChar,char[] specialCharacters,char splitCharacter,int splitLimit){\n  List<String> result=new LinkedList<>();\n  StringBuilder b=new StringBuilder();\n  boolean readEscape=false;\n  int indexCount=-1;\n  for (  char c : source.toCharArray()) {\n    indexCount++;\n    if (readEscape) {\n      boolean found=false;\n      if (c == splitCharacter) {\n        found=true;\n        b.append(c);\n      }\n else       if (c == escapeChar) {\n        found=true;\n        b.append(c);\n      }\n else {\n        for (        char s : specialCharacters) {\n          if (s == c) {\n            found=true;\n            b.append(c);\n            break;\n          }\n        }\n      }\n      if (!found) {\n        throw new IllegalArgumentException(\"String '\" + source + \"' contains illegal escaped character '\"+ c+ \"'.\");\n      }\n      readEscape=false;\n    }\n else     if (c == escapeChar) {\n      readEscape=true;\n    }\n else     if (c == splitCharacter) {\n      readEscape=false;\n      result.add(b.toString());\n      if (splitLimit != -1) {\n        if (result.size() == splitLimit - 1) {\n          result.add(source.substring(indexCount + 1));\n          return result;\n        }\n      }\n      b=new StringBuilder();\n    }\n else {\n      readEscape=false;\n      b.append(c);\n    }\n  }\n  result.add(b.toString());\n  return result;\n}", "comment": "splits the string at every split character unless escaped .", "label": "what"}
{"id": "70489", "raw_code": "protected int drawLegend(Canvas canvas,DefaultRenderer renderer,String[] titles,int left,int right,int y,int width,int height,int legendSize,Paint paint,boolean calculate){\n  float size=32;\n  if (renderer.isShowLegend()) {\n    float currentX=left;\n    float currentY=y + height - legendSize + size;\n    paint.setTextAlign(Align.LEFT);\n    paint.setTextSize(renderer.getLegendTextSize());\n    int sLength=Math.min(titles.length,renderer.getSeriesRendererCount());\n    for (int i=0; i < sLength; i++) {\n      SimpleSeriesRenderer r=renderer.getSeriesRendererAt(i);\n      final float lineSize=getLegendShapeWidth(i);\n      if (r.isShowLegendItem()) {\n        String text=titles[i];\n        if (titles.length == renderer.getSeriesRendererCount()) {\n          paint.setColor(r.getColor());\n        }\n else {\n          paint.setColor(Color.LTGRAY);\n        }\n        float[] widths=new float[text.length()];\n        paint.getTextWidths(text,widths);\n        float sum=0;\n        for (        float value : widths) {\n          sum+=value;\n        }\n        float extraSize=lineSize + 10 + sum;\n        float currentWidth=currentX + extraSize;\n        if (i > 0 && getExceed(currentWidth,renderer,right,width)) {\n          currentX=left;\n          currentY+=renderer.getLegendTextSize();\n          size+=renderer.getLegendTextSize();\n          currentWidth=currentX + extraSize;\n        }\n        if (getExceed(currentWidth,renderer,right,width)) {\n          float maxWidth=right - currentX - lineSize- 10;\n          if (isVertical(renderer)) {\n            maxWidth=width - currentX - lineSize- 10;\n          }\n          int nr=paint.breakText(text,true,maxWidth,widths);\n          text=text.substring(0,nr) + \"...\";\n        }\n        if (!calculate) {\n          drawLegendShape(canvas,r,currentX,currentY,i,paint);\n          drawString(canvas,text,currentX + lineSize + 5,currentY + 5,paint);\n        }\n        currentX+=extraSize;\n      }\n    }\n  }\n  return Math.round(size + renderer.getLegendTextSize());\n}", "comment": "draws the chart legend .", "label": "what"}
{"id": "30637", "raw_code": "public EconomyConcurrentHashMap(Map<? extends K,? extends V> m,IHashEntryHandler<K,V> handler){\n  this(Math.max((int)(m.size() / DEFAULT_LOAD_FACTOR) + 1,DEFAULT_INITIAL_CAPACITY),DEFAULT_LOAD_FACTOR,DEFAULT_CONCURRENCY_LEVEL,handler);\n  putAll(m);\n}", "comment": "creates a new map with the same mappings as the given map .", "label": "what"}
{"id": "29859", "raw_code": "public Builder appendReadData(byte[] data){\n  Assertions.checkState(data != null && data.length > 0);\n  segments.add(new Segment(data,null));\n  return this;\n}", "comment": "appends to the underlying data .", "label": "what"}
{"id": "34210", "raw_code": "private boolean isLatestDssKeystore(TSLParserResult parseResult){\n  List<String> englishSchemeInformationURIs=parseResult.getEnglishSchemeInformationURIs();\n  return englishSchemeInformationURIs.contains(ojUrl);\n}", "comment": "this method checks if the oj url is still correct .", "label": "what"}
{"id": "17729", "raw_code": "private synchronized void initResourceBundle(String resourceBundleName){\n  String current=this.resourceBundleName;\n  if (current != null) {\n    if (current.equals(resourceBundleName)) {\n      return;\n    }\n else {\n      throw new IllegalArgumentException(\"Resource bundle name '\" + resourceBundleName + \"' is inconsistent with the existing '\"+ current+ \"'\");\n    }\n  }\n  if (resourceBundleName != null) {\n    this.resourceBundle=loadResourceBundle(resourceBundleName);\n    this.resourceBundleName=resourceBundleName;\n  }\n}", "comment": "initializes this logger ' s resource bundle .", "label": "what"}
{"id": "11788", "raw_code": "public LayerGraphicWarehouseSupport(){\n  initDrawingAttributes();\n  graphics=new OMGraphicList();\n  graphics.setTraverseMode(OMGraphicList.LAST_ADDED_ON_TOP);\n}", "comment": "construct an object , initializes graphiclist", "label": "what"}
{"id": "41464", "raw_code": "public boolean matchesNamingConvension(){\n  return packageName.matches(JAVA_PACKAGE_CONVENSION);\n}", "comment": "check whether the package name match standard java package name conventions .", "label": "what"}
{"id": "32350", "raw_code": "public ComputeTaskCancelledException(Throwable cause){\n  this(cause.getMessage(),cause);\n}", "comment": "creates new task cancellation exception given throwable as a cause and source of error message .", "label": "what"}
{"id": "48480", "raw_code": "public static int normalize(char[] src,int srcStart,int srcLimit,char[] dest,int destStart,int destLimit,Mode mode,int options){\n  int length=mode.normalize(src,srcStart,srcLimit,dest,destStart,destLimit,options);\n  if (length <= (destLimit - destStart)) {\n    return length;\n  }\n else {\n    throw new IndexOutOfBoundsException(Integer.toString(length));\n  }\n}", "comment": "normalize a string .", "label": "what"}
{"id": "29937", "raw_code": "private void removeObsoleteElements(List<String> names,Map<String,View> sharedElements,List<String> elementsToRemove){\n  if (elementsToRemove.size() > 0) {\n    names.removeAll(elementsToRemove);\n    for (    String elementToRemove : elementsToRemove) {\n      sharedElements.remove(elementToRemove);\n    }\n  }\n}", "comment": "removes obsolete elements from names and shared elements .", "label": "what"}
{"id": "73437", "raw_code": "public void removeAction(NetworkUpdateAction action){\n  actionList.remove(action);\n  for (  UpdateManagerListener listener : listeners) {\n    listener.actionRemoved(action);\n  }\n}", "comment": "completely remove an action .", "label": "what"}
{"id": "71211", "raw_code": "public static double bufferDistanceError(int quadSegs){\n  double alpha=Math.PI / 2.0 / quadSegs;\n  return 1 - Math.cos(alpha / 2.0);\n}", "comment": "computes the maximum distance error due to a given level of approximation to a true arc .", "label": "what"}
{"id": "20838", "raw_code": "public Pair<String,String> next(){\n  try {\n    currentHeaderPosition=nextHeaderPosition;\n    String readHeader=nextLine;\n    nextHeaderPosition+=readHeader.length() + endOfLineBytes;\n    readHeader=\">\" + readHeader.substring(1);\n    String readSequence=r.readLine();\n    nextHeaderPosition+=readSequence.length() + endOfLineBytes;\n    String comments=r.readLine();\n    nextHeaderPosition+=comments.length() + endOfLineBytes;\n    if (comments.startsWith(\"+\")) {\n      String qualityValues=r.readLine();\n      nextHeaderPosition+=qualityValues.length() + endOfLineBytes;\n    }\n    nextLine=r.readLine();\n    return new Pair<>(readHeader,readSequence);\n  }\n catch (  IOException e) {\n    Basic.caught(e);\n  }\n  return null;\n}", "comment": "gets next fasta record", "label": "what"}
{"id": "43945", "raw_code": "public void removeChild(Group theGroup){\n  mChildren.remove(theGroup);\n}", "comment": "remove a child from this group", "label": "what"}
{"id": "21518", "raw_code": "protected StoragePort checkPortExistsInDB(String nativeGuid) throws IOException {\n  StoragePort port=null;\n  List<StoragePort> portInDB=CustomQueryUtility.getActiveStoragePortByNativeGuid(_dbClient,nativeGuid);\n  if (portInDB != null && !portInDB.isEmpty()) {\n    port=portInDB.get(0);\n  }\n  return port;\n}", "comment": "check if port exists in db .", "label": "what"}
{"id": "43309", "raw_code": "public void appendSplitElement(Fragment aSplit){\n  splits.add(aSplit);\n}", "comment": "adds a split element at the end", "label": "what"}
{"id": "53622", "raw_code": "public OsmHandler(MapBuilder meConsumer){\n  osmElementProcessor=new OsmElementProcessor(null,meConsumer);\n}", "comment": "creates a new instance .", "label": "what"}
{"id": "40792", "raw_code": "public RespokeDirectConnection directConnection(){\n  if (null != directConnectionReference) {\n    return directConnectionReference.get();\n  }\n else {\n    return null;\n  }\n}", "comment": "get the active direct connection with this endpoint ( if any )", "label": "what"}
{"id": "10018", "raw_code": "private String appendNationalNumber(String nationalNumber){\n  int prefixBeforeNationalNumberLength=prefixBeforeNationalNumber.length();\n  if (shouldAddSpaceAfterNationalPrefix && prefixBeforeNationalNumberLength > 0 && prefixBeforeNationalNumber.charAt(prefixBeforeNationalNumberLength - 1) != SEPARATOR_BEFORE_NATIONAL_NUMBER) {\n    return new String(prefixBeforeNationalNumber) + SEPARATOR_BEFORE_NATIONAL_NUMBER + nationalNumber;\n  }\n else {\n    return prefixBeforeNationalNumber + nationalNumber;\n  }\n}", "comment": "combines the national number with any prefix ( idd / + and country code or national prefix ) that was collected .", "label": "what"}
{"id": "73310", "raw_code": "public void cut(){\n  copy();\n  deleteSelectedObjects();\n}", "comment": "cut to the clipboard .", "label": "what"}
{"id": "19833", "raw_code": "public synchronized void release(){\n  index.clear();\n}", "comment": "releases resources in the index .", "label": "what"}
{"id": "19728", "raw_code": "public void configure(){\n  if (cmdPrefix != null) {\n    prefix=cmdPrefix.split(\" \");\n  }\n}", "comment": "configure the helper .", "label": "what"}
{"id": "44124", "raw_code": "protected void writeTransform(AffineTransform t) throws IOException {\n  pageStream.matrix(t);\n}", "comment": "write the given transformation matrix to the file .", "label": "what"}
{"id": "82208", "raw_code": "public PainterChain prependPainter(Painter p){\n  Painter[] newChain=new Painter[chain.length + 1];\n  System.arraycopy(chain,1,newChain,0,chain.length);\n  newChain[0]=p;\n  return new PainterChain(newChain);\n}", "comment": "creates a new chain based on the existing chain with the new element added at the beginning", "label": "what"}
{"id": "35224", "raw_code": "@Override public boolean dragTo(Selector obj,Selector destObj,int steps) throws UiObjectNotFoundException, NotImplementedException {\n  return dragTo(device.findObject(obj.toUiSelector()),destObj,steps);\n}", "comment": "drags this object to a destination uiobject .", "label": "what"}
{"id": "70466", "raw_code": "public synchronized void removeSeries(int index){\n  mSeries.remove(index);\n}", "comment": "removes the xy series from the list .", "label": "what"}
{"id": "75820", "raw_code": "public static void writeResultToFile(Result result,String fname) throws Exception {\n  PrintWriter outer=new PrintWriter(new BufferedWriter(new FileWriter(fname)));\n  outer.write(result.toString());\n  outer.close();\n}", "comment": "writeresulttofile - - write a result ' result ' out in plain text format to file ' fname ' .", "label": "what"}
{"id": "78953", "raw_code": "protected void writeBlockletInfoToFile(List<BlockletInfoColumnar> infoList,FileChannel channel,String filePath) throws CarbonDataWriterException {\n  try {\n    long currentPosition=channel.size();\n    CarbonFooterWriter writer=new CarbonFooterWriter(filePath);\n    FileFooter convertFileMeta=CarbonMetadataUtil.convertFileFooter(infoList,localCardinality.length,localCardinality,thriftColumnSchemaList,segmentProperties);\n    fillBlockIndexInfoDetails(infoList,convertFileMeta.getNum_rows(),filePath,currentPosition);\n    writer.writeFooter(convertFileMeta,currentPosition);\n  }\n catch (  IOException e) {\n    throw new CarbonDataWriterException(\"Problem while writing the carbon file: \",e);\n  }\n}", "comment": "this method will write metadata at the end of file file format in thrift format", "label": "what"}
{"id": "16721", "raw_code": "private static void renderTree(Tree tree,int indent,boolean parentLabelNull,boolean firstSibling,boolean leftSiblingPreTerminal,boolean topLevel,StringBuilder sb){\n  boolean suppressIndent=(parentLabelNull || (firstSibling && tree.isPreTerminal()) || (leftSiblingPreTerminal && tree.isPreTerminal()));\n  if (suppressIndent) {\n    sb.append(' ');\n  }\n else {\n    if (!topLevel) {\n      sb.append('\\n');\n    }\n    for (int i=0; i < indent; i++) {\n      sb.append(\"  \");\n    }\n  }\n  if (tree.isLeaf() || tree.isPreTerminal()) {\n    renderFlat(tree,sb);\n    return;\n  }\n  sb.append('(');\n  sb.append(tree.getLabel());\n  renderChildren(tree.getChildren(),indent + 1,false,sb);\n  sb.append(')');\n}", "comment": "display a node , implementing penn treebank style layout", "label": "what"}
{"id": "65915", "raw_code": "public static StringBuffer replaceRegex(StringBuffer original,String regex,String replace,boolean CASE_INSENSITIVE){\n  int flags=0;\n  if (CASE_INSENSITIVE)   flags=Pattern.CASE_INSENSITIVE;\n  Pattern p=Pattern.compile(regex,flags);\n  Matcher m=p.matcher(original);\n  StringBuffer newSB=new StringBuffer();\n  boolean result=m.find();\n  while (result) {\n    m.appendReplacement(newSB,replace);\n    result=m.find();\n  }\n  m.appendTail(newSB);\n  return newSB;\n}", "comment": "run regex expression against original string", "label": "what"}
{"id": "63376", "raw_code": "public boolean equalsChars(String a,int ai,String b,int bi,boolean ignoreCase){\n  char ca=a.charAt(ai);\n  char cb=b.charAt(bi);\n  if (ignoreCase) {\n    ca=Character.toUpperCase(ca);\n    cb=Character.toUpperCase(cb);\n  }\n  return ca == cb;\n}", "comment": "compare two characters in a string .", "label": "what"}
{"id": "5018", "raw_code": "private static Collection<Collection<DsnNetPin>> create_ordered_subnets(Collection<DsnNetPin> p_pin_list){\n  Collection<Collection<DsnNetPin>> result=new LinkedList<Collection<DsnNetPin>>();\n  if (p_pin_list.isEmpty()) {\n    return result;\n  }\n  Iterator<DsnNetPin> it=p_pin_list.iterator();\n  DsnNetPin prev_pin=it.next();\n  while (it.hasNext()) {\n    DsnNetPin next_pin=it.next();\n    Set<DsnNetPin> curr_subnet_pin_list=new java.util.TreeSet<DsnNetPin>();\n    curr_subnet_pin_list.add(prev_pin);\n    curr_subnet_pin_list.add(next_pin);\n    result.add(curr_subnet_pin_list);\n    prev_pin=next_pin;\n  }\n  return result;\n}", "comment": "creates a sequence of subnets with 2 pins from p _ pin _ list", "label": "what"}
{"id": "70410", "raw_code": "@Override public void run(int connID,String[] args){\n  if (args.length == 1) {\n    server.sendServerChat(connID,\"Server Side nova command\");\n    server.sendServerChat(connID,\"/nova print : will print all of your current nova networks and unlinked units.\");\n    server.sendServerChat(connID,\"/nova print id : will print the network status for the Unit with ID id.\");\n    server.sendServerChat(connID,\"/nova link id1 id2 : will link the units with ID id1 and id2.\");\n    server.sendServerChat(connID,\"+++Will Disconnect them from all prior nets.\");\n    server.sendServerChat(connID,\"/nova link id1 id2 id3 : will link the three units with ID id1 id2 and id3.\");\n    server.sendServerChat(connID,\"+++Will Disconnect them from all prior nets.\");\n    server.sendServerChat(connID,\"/nova unlink : will unlink all your novaCEWS units.\");\n    server.sendServerChat(connID,\"/nova unlink id : will unlink unit with ID id from all nova networks.\");\n  }\n  try {\n    if (args.length > 1) {\n      String cmd=args[1];\n      if (cmd.equalsIgnoreCase(\"print\")) {\n        if (args.length > 2) {\n          int id=Integer.parseInt(args[2]);\n          server.sendServerChat(connID,strListNetwork(connID,id,true));\n        }\n else {\n          server.sendServerChat(connID,strListNetworks(connID,true));\n        }\n      }\n else       if (cmd.equalsIgnoreCase(\"printcurrent\")) {\n        if (args.length > 2) {\n          int id=Integer.parseInt(args[2]);\n          server.sendServerChat(connID,strListNetwork(connID,id,false));\n        }\n else {\n          server.sendServerChat(connID,strListNetworks(connID,false));\n        }\n      }\n else       if (cmd.equalsIgnoreCase(\"debug\")) {\n        debug(connID,server);\n      }\n else       if (cmd.equalsIgnoreCase(\"link\")) {\n        if (args.length > 4) {\n          int id1=Integer.parseInt(args[2]);\n          int id2=Integer.parseInt(args[3]);\n          int id3=Integer.parseInt(args[4]);\n          server.sendServerChat(connID,strLink3(connID,id1,id2,id3));\n        }\n else         if (args.length > 3) {\n          int id1=Integer.parseInt(args[2]);\n          int id2=Integer.parseInt(args[3]);\n          server.sendServerChat(connID,strLink2(connID,id1,id2));\n        }\n      }\n else       if (cmd.equalsIgnoreCase(\"unlink\")) {\n        if (args.length > 2) {\n          int id=Integer.parseInt(args[2]);\n          server.sendServerChat(connID,strUnlinkID(connID,id));\n        }\n else {\n          server.sendServerChat(connID,strUnlinkAll(connID));\n        }\n      }\n else {\n        String failstr=args[0];\n        for (int i=1; i < args.length; i++) {\n          failstr+=\" \" + args[i];\n        }\n        server.sendServerChat(connID,\"I do not understand \" + failstr + \". /nova for help.\\n\");\n      }\n    }\n  }\n catch (  NumberFormatException nfe) {\n    server.sendServerChat(connID,\"Error parsing the command. NFE\");\n  }\ncatch (  NullPointerException npe) {\n    server.sendServerChat(connID,\"Error parsing the command. NPE\");\n  }\ncatch (  IndexOutOfBoundsException ioobe) {\n    server.sendServerChat(connID,\"Error parsing the command. IOOBE\");\n  }\n}", "comment": "run this command with the arguments supplied", "label": "what"}
{"id": "46549", "raw_code": "private char[] parseEntityReference() throws IOException {\n  int pos=strpos;\n  if ((ch=readCh()) == '#') {\n    int n=0;\n    ch=readCh();\n    if ((ch >= '0') && (ch <= '9') || ch == 'x' || ch == 'X') {\n      if ((ch >= '0') && (ch <= '9')) {\n        while ((ch >= '0') && (ch <= '9')) {\n          n=(n * 10) + ch - '0';\n          ch=readCh();\n        }\n      }\n else {\n        ch=readCh();\n        char lch=(char)Character.toLowerCase(ch);\n        while ((lch >= '0') && (lch <= '9') || (lch >= 'a') && (lch <= 'f')) {\n          if (lch >= '0' && lch <= '9') {\n            n=(n * 16) + lch - '0';\n          }\n else {\n            n=(n * 16) + lch - 'a' + 10;\n          }\n          ch=readCh();\n          lch=(char)Character.toLowerCase(ch);\n        }\n      }\nswitch (ch) {\ncase '\\n':\n        ln++;\n      ch=readCh();\n    lfCount++;\n  break;\ncase '\\r':\nln++;\nif ((ch=readCh()) == '\\n') {\nch=readCh();\ncrlfCount++;\n}\n else {\ncrCount++;\n}\nbreak;\ncase ';':\nch=readCh();\nbreak;\n}\nchar data[]=mapNumericReference(n);\nreturn data;\n}\naddString('#');\nif (!parseIdentifier(false)) {\nerror(\"ident.expected\");\nstrpos=pos;\nchar data[]={'&','#'};\nreturn data;\n}\n}\n else if (!parseIdentifier(false)) {\nchar data[]={'&'};\nreturn data;\n}\nboolean semicolon=false;\nswitch (ch) {\ncase '\\n':\nln++;\nch=readCh();\nlfCount++;\nbreak;\ncase '\\r':\nln++;\nif ((ch=readCh()) == '\\n') {\nch=readCh();\ncrlfCount++;\n}\n else {\ncrCount++;\n}\nbreak;\ncase ';':\nsemicolon=true;\nch=readCh();\nbreak;\n}\nString nm=getString(pos);\nEntity ent=dtd.getEntity(nm);\nif (!strict && (ent == null)) {\nent=dtd.getEntity(nm.toLowerCase());\n}\nif ((ent == null) || !ent.isGeneral()) {\nif (nm.length() == 0) {\nerror(\"invalid.entref\",nm);\nreturn new char[0];\n}\nString str=\"&\" + nm + (semicolon ? \";\" : \"\");\nchar b[]=new char[str.length()];\nstr.getChars(0,b.length,b,0);\nreturn b;\n}\nreturn ent.getData();\n}", "comment": "parse an entity reference .", "label": "what"}
{"id": "84950", "raw_code": "private static String createJsMethodInvocationExpression(String methodName,boolean isStatic,String... paramNames){\n  StringBuilder sb=new StringBuilder();\n  sb.append(isStatic ? WND : THIS);\n  sb.append(\".\");\n  sb.append(methodName);\n  sb.append(\"(\");\n  for (int i=0; i < paramNames.length; i++) {\n    if (i != 0) {\n      sb.append(\", \");\n    }\n    sb.append(paramNames[i]);\n  }\n  sb.append(\");\");\n  return sb.toString();\n}", "comment": "creates a jsni method invocation expression .", "label": "what"}
{"id": "65319", "raw_code": "private Segment createDiskSegment(SegmentDescriptor descriptor){\n  File segmentFile=SegmentFile.createSegmentFile(name,storage.directory(),descriptor.id(),descriptor.version());\n  Buffer buffer=FileBuffer.allocate(segmentFile,Math.min(DEFAULT_BUFFER_SIZE,descriptor.maxSegmentSize()),Integer.MAX_VALUE);\n  descriptor.copyTo(buffer);\n  Segment segment=new Segment(new SegmentFile(segmentFile),buffer.slice(),descriptor,createIndex(descriptor),new OffsetPredicate(),serializer.clone(),this);\n  LOGGER.debug(\"Created segment: {}\",segment);\n  return segment;\n}", "comment": "creates a new segment .", "label": "what"}
{"id": "82901", "raw_code": "public Boolean exists(String email){\n  for (  Person person : people) {\n    if (email.equals(person.getEmail())) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "given an email checks if the person exists in the manager .", "label": "what"}
{"id": "58384", "raw_code": "public void assertURIEquals(String assertID,String scheme,String path,String host,String file,String name,String query,String fragment,Boolean isAbsolute,String actual){\n  assertNotNull(assertID,actual);\n  String uri=actual;\n  int lastPound=actual.lastIndexOf(\"#\");\n  String actualFragment=\"\";\n  if (lastPound != -1) {\n    uri=actual.substring(0,lastPound);\n    actualFragment=actual.substring(lastPound + 1);\n  }\n  if (fragment != null) {\n    assertEquals(assertID,fragment,actualFragment);\n  }\n  int lastQuestion=uri.lastIndexOf(\"?\");\n  String actualQuery=\"\";\n  if (lastQuestion != -1) {\n    uri=actual.substring(0,lastQuestion);\n    actualQuery=actual.substring(lastQuestion + 1);\n  }\n  if (query != null) {\n    assertEquals(assertID,query,actualQuery);\n  }\n  int firstColon=uri.indexOf(\":\");\n  int firstSlash=uri.indexOf(\"/\");\n  String actualPath=uri;\n  String actualScheme=\"\";\n  if (firstColon != -1 && firstColon < firstSlash) {\n    actualScheme=uri.substring(0,firstColon);\n    actualPath=uri.substring(firstColon + 1);\n  }\n  if (scheme != null) {\n    assertEquals(assertID,scheme,actualScheme);\n  }\n  if (path != null) {\n    assertEquals(assertID,path,actualPath);\n  }\n  if (host != null) {\n    String actualHost=\"\";\n    if (actualPath.startsWith(\"//\")) {\n      int termSlash=actualPath.indexOf(\"/\",2);\n      actualHost=actualPath.substring(0,termSlash);\n    }\n    assertEquals(assertID,host,actualHost);\n  }\n  String actualFile=actualPath;\n  if (file != null || name != null) {\n    int finalSlash=actualPath.lastIndexOf(\"/\");\n    if (finalSlash != -1) {\n      actualFile=actualPath.substring(finalSlash + 1);\n    }\n    if (file != null) {\n      assertEquals(assertID,file,actualFile);\n    }\n  }\n  if (name != null) {\n    String actualName=actualFile;\n    int finalPeriod=actualFile.lastIndexOf(\".\");\n    if (finalPeriod != -1) {\n      actualName=actualFile.substring(0,finalPeriod);\n    }\n    assertEquals(assertID,name,actualName);\n  }\n  if (isAbsolute != null) {\n    assertEquals(assertID,isAbsolute.booleanValue(),actualPath.startsWith(\"/\") || actualPath.startsWith(\"file:/\"));\n  }\n}", "comment": "asserts aspects of a uri", "label": "what"}
{"id": "24624", "raw_code": "public boolean matchesWord(){\n  return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));\n}", "comment": "test if the queue matches a word character ( letter or digit ) .", "label": "what"}
{"id": "53526", "raw_code": "public VacuumEnvironment(){\n  Random r=new Random();\n  envState=new VacuumEnvironmentState(0 == r.nextInt(2) ? LocationState.Clean : LocationState.Dirty,0 == r.nextInt(2) ? LocationState.Clean : LocationState.Dirty);\n}", "comment": "constructs a vacuum environment with two locations , in which dirt is placed at random .", "label": "what"}
{"id": "5809", "raw_code": "public BaseViewHolder addOnLongClickListener(int viewId){\n  itemChildLongClickViewIds.add(viewId);\n  return this;\n}", "comment": "add long click view id", "label": "what"}
{"id": "80628", "raw_code": "public void remove(final CreatureRespawnPoint point){\n  respawnPoints.remove(point);\n}", "comment": "remove a creature respawn point from the zone .", "label": "what"}
{"id": "22938", "raw_code": "public Photo(File d,File f) throws IOException, NumberFormatException {\n  ExtendedExifInterface exif=new ExtendedExifInterface(f.toString());\n  String lonStr=exif.getAttribute(ExifInterface.TAG_GPS_LONGITUDE);\n  if (lonStr == null) {\n    throw new IOException(\"No EXIF tag\");\n  }\n  float lonf=convertToDegree(lonStr);\n  String lonRef=exif.getAttribute(ExifInterface.TAG_GPS_LONGITUDE_REF);\n  if (lonRef != null && !lonRef.equals(\"E\")) {\n    lonf=-lonf;\n  }\n  float latf=convertToDegree(exif.getAttribute(ExifInterface.TAG_GPS_LATITUDE));\n  String latRef=exif.getAttribute(ExifInterface.TAG_GPS_LATITUDE_REF);\n  if (latRef != null && !latRef.equals(\"N\")) {\n    latf=-latf;\n  }\n  lat=(int)(latf * 1E7d);\n  lon=(int)(lonf * 1E7d);\n  Log.d(\"Photo\",\"lat: \" + lat + \" lon: \"+ lon);\n  ref=d.getAbsolutePath() + \"/\" + f.getName();\n  String dir=exif.getAttribute(ExtendedExifInterface.TAG_GPS_IMG_DIRECTION);\n  if (dir != null) {\n    direction=(int)Double.parseDouble(dir);\n    directionRef=exif.getAttribute(ExtendedExifInterface.TAG_GPS_IMG_DIRECTION_REF);\n    Log.d(\"Photo\",\"dir \" + dir + \" direction \"+ direction+ \" ref \"+ directionRef);\n  }\n}", "comment": "create a bug from an osb gpx xml wpt element .", "label": "what"}
{"id": "40515", "raw_code": "protected int unicodeEscapeLexer(int c) throws IOException {\n  int ret=0;\n  c=in.read();\n  code.clear();\n  try {\n    for (int i=0; i < 4; i++) {\n      c=in.read();\n      if (isEndOfFile(c) || isEndOfLine(c)) {\n        throw new NumberFormatException(\"number too short\");\n      }\n      code.append((char)c);\n    }\n    ret=Integer.parseInt(code.toString(),16);\n  }\n catch (  NumberFormatException e) {\n    throw new IOException(\"(line \" + getLineNumber() + \") Wrong unicode escape sequence found '\"+ code.toString()+ \"'\"+ e.toString());\n  }\n  return ret;\n}", "comment": "decodes unicode escapes .", "label": "what"}
{"id": "73970", "raw_code": "@Override public void mouseEntered(MouseEvent evt){\n  delegate.mouseMoved(evt);\n}", "comment": "pass mouseevent straight through to delegate", "label": "what"}
{"id": "10422", "raw_code": "public static String removeFormatting(String line){\n  int length=line.length();\n  StringBuilder buffer=new StringBuilder();\n  for (int i=0; i < length; i++) {\n    char ch=line.charAt(i);\n    if (ch != '\\u000f' && ch != '\\u0002' && ch != '\\u001f' && ch != '\\u0016')     buffer.append(ch);\n  }\n  return buffer.toString();\n}", "comment": "remove formatting from a line of irc text .", "label": "what"}
{"id": "46781", "raw_code": "public boolean isEmpty(){\n  return rdns.isEmpty();\n}", "comment": "determines whether this ldap name is empty .", "label": "what"}
{"id": "85779", "raw_code": "private void writeLocalCSV(MedtronicSensorRecord mostRecentData,Context context){\n  try {\n    if (mostRecentData == null || mostRecentData.bGValue == null)     log.debug(\"writeLocalCSV SAVING  EMPTY!!\");\n else     log.debug(\"writeLocalCSV SAVING --> \" + mostRecentData.bGValue);\n    ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(new File(context.getFilesDir(),\"save.bin\")));\n    oos.writeObject(mostRecentData);\n    oos.flush();\n    oos.close();\n  }\n catch (  Exception e) {\n    Log.e(TAG,\"write to OutputStream failed\",e);\n    log.error(\"write to OutputStream failed\",e);\n  }\n}", "comment": "this method saves a file with the last record read from the device", "label": "what"}
{"id": "13758", "raw_code": "public void deleteAuthenticationDomain(String realm,String cotName) throws AMConsoleException {\n  String[] param={realm,cotName};\n  logEvent(\"ATTEMPT_DELETE_AUTH_DOMAINS\",param);\n  try {\n    CircleOfTrustManager manager=getCircleOfTrustManager();\n    manager.deleteCircleOfTrust(realm,cotName);\n    logEvent(\"SUCCEED_DELETE_AUTH_DOMAIN\",param);\n  }\n catch (  COTException e) {\n    String strError=getErrorString(e);\n    String[] paramsEx={realm,cotName,strError};\n    logEvent(\"FEDERATION_EXCEPTION_DELETE_AUTH_DOMAIN\",paramsEx);\n    throw new AMConsoleException(strError);\n  }\n}", "comment": "deletes an authentication domain ( circle of trust ) within a given realm .", "label": "what"}
{"id": "81010", "raw_code": "void eventPreModify(ActionType type,long position,boolean isSingle){\n  if (type != currentActionType || !isSingle || System.currentTimeMillis() - previousTime > MERGE_TIME || (type == ActionType.INSERT || type == ActionType.OVERWRITE) && actionExclusiveEnd() != position || type == ActionType.DELETE && actionPosition() != position && actionPosition() - 1L != position) {\n    startAction(type,isSingle);\n  }\n else {\n    isBackspace=actionPosition() > position;\n  }\n  if (isSingle && type == ActionType.INSERT) {\n    updateNewRange(position);\n    previousTime=System.currentTimeMillis();\n  }\n}", "comment": "user event : single / block delete / insert / overwrite .", "label": "what"}
{"id": "44267", "raw_code": "public boolean markSupported(){\n  return fInputStream.markSupported();\n}", "comment": "tell whether this stream supports the mark ( ) operation .", "label": "what"}
{"id": "63685", "raw_code": "public ByteColumn(int nrows,int capacity,byte defaultValue){\n  super(byte.class,new Byte(defaultValue));\n  if (capacity < nrows) {\n    throw new IllegalArgumentException(\"Capacity value can not be less than the row count.\");\n  }\n  m_values=new byte[capacity];\n  Arrays.fill(m_values,defaultValue);\n  m_size=nrows;\n}", "comment": "create a new intcolumn .", "label": "what"}
{"id": "43872", "raw_code": "public final boolean isClosed(){\n  return closed.get();\n}", "comment": "checks whether this closeableiteration has been closed .", "label": "what"}
{"id": "41545", "raw_code": "void start(){\n  this.running=true;\n  Thread thread=new Thread(this,\"IceConnector@\" + hashCode());\n  thread.setDaemon(true);\n  thread.start();\n}", "comment": "start the network listening thread .", "label": "what"}
{"id": "52611", "raw_code": "protected void drawChartValuesText(Canvas canvas,XYSeries series,XYSeriesRenderer renderer,Paint paint,List<Float> points,int seriesIndex,int startIndex){\n  if (points.size() > 1) {\n    float previousPointX=points.get(0);\n    float previousPointY=points.get(1);\n    for (int k=0; k < points.size(); k+=2) {\n      if (k == 2) {\n        if (Math.abs(points.get(2) - points.get(0)) > renderer.getDisplayChartValuesDistance() || Math.abs(points.get(3) - points.get(1)) > renderer.getDisplayChartValuesDistance()) {\n          drawText(canvas,getLabel(renderer.getChartValuesFormat(),series.getY(startIndex)),points.get(0),points.get(1) - renderer.getChartValuesSpacing(),paint,0);\n          drawText(canvas,getLabel(renderer.getChartValuesFormat(),series.getY(startIndex + 1)),points.get(2),points.get(3) - renderer.getChartValuesSpacing(),paint,0);\n          previousPointX=points.get(2);\n          previousPointY=points.get(3);\n        }\n      }\n else       if (k > 2) {\n        if (Math.abs(points.get(k) - previousPointX) > renderer.getDisplayChartValuesDistance() || Math.abs(points.get(k + 1) - previousPointY) > renderer.getDisplayChartValuesDistance()) {\n          drawText(canvas,getLabel(renderer.getChartValuesFormat(),series.getY(startIndex + k / 2)),points.get(k),points.get(k + 1) - renderer.getChartValuesSpacing(),paint,0);\n          previousPointX=points.get(k);\n          previousPointY=points.get(k + 1);\n        }\n      }\n    }\n  }\n else {\n    for (int k=0; k < points.size(); k+=2) {\n      drawText(canvas,getLabel(renderer.getChartValuesFormat(),series.getY(startIndex + k / 2)),points.get(k),points.get(k + 1) - renderer.getChartValuesSpacing(),paint,0);\n    }\n  }\n}", "comment": "the graphical representation of the series values as text .", "label": "what"}
{"id": "53970", "raw_code": "public MongoClient clientForMembers(ServerAddress... seeds){\n  List<ServerAddress> addresses=new ArrayList<>();\n  for (  ServerAddress seedAddress : seeds) {\n    if (seedAddress != null)     addresses.add(seedAddress);\n  }\n  return clientForMembers(addresses);\n}", "comment": "obtain a client connection to the replica set or cluster .", "label": "what"}
{"id": "67141", "raw_code": "public void generateClassFile(OutputStream os){\n  ClassWriter cw=new SootASMClassWriter(ClassWriter.COMPUTE_FRAMES);\n  cv=cw;\n  generateByteCode();\n  try {\n    os.write(cw.toByteArray());\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"Could not write class file in the ASM-backend!\",e);\n  }\n}", "comment": "outputs the bytecode generated as a class file", "label": "what"}
{"id": "11254", "raw_code": "public static void main(String[] args){\n  new GeneratorTester(args);\n}", "comment": "test the image generator .", "label": "what"}
{"id": "32301", "raw_code": "private void checkShutdown(){\nsynchronized (mux) {\n    if (isBeingShutdown)     throw new RejectedExecutionException(\"Failed to execute command during executor shutdown.\");\n  }\n}", "comment": "checks if service is being shutdown .", "label": "what"}
{"id": "57758", "raw_code": "public void fireIndexedPropertyChange(String propertyName,int index,boolean oldValue,boolean newValue){\n  if (oldValue != newValue) {\n    fireIndexedPropertyChange(propertyName,index,Boolean.valueOf(oldValue),Boolean.valueOf(newValue));\n  }\n}", "comment": "fires a property change of a boolean property with the given name .", "label": "what"}
{"id": "74397", "raw_code": "protected void removeMarkers(){\n  for (int i=markerImage.size(); i > 0; i--) {\n    LocoIcon il=markerImage.get(i - 1);\n    if ((il != null) && (il.isActive())) {\n      markerImage.remove(i - 1);\n      il.remove();\n      il.dispose();\n      setDirty(true);\n    }\n  }\n  super.removeMarkers();\n  repaint();\n}", "comment": "remove marker icons from panel", "label": "what"}
{"id": "13372", "raw_code": "public void initialize(Context context,HapticFeedbackController hapticFeedbackController,int initialHoursOfDay,int initialMinutes,boolean is24HourMode){\n  if (mTimeInitialized) {\n    Log.e(TAG,\"Time has already been initialized.\");\n    return;\n  }\n  mHapticFeedbackController=hapticFeedbackController;\n  mIs24HourMode=is24HourMode;\n  mHideAmPm=mAccessibilityManager.isTouchExplorationEnabled() ? true : mIs24HourMode;\n  mCircleView.initialize(context,mHideAmPm);\n  mCircleView.invalidate();\n  if (!mHideAmPm) {\n    mAmPmCirclesView.initialize(context,initialHoursOfDay < 12 ? AM : PM);\n    mAmPmCirclesView.invalidate();\n  }\n  Resources res=context.getResources();\n  int[] hours={12,1,2,3,4,5,6,7,8,9,10,11};\n  int[] hours_24={0,13,14,15,16,17,18,19,20,21,22,23};\n  int[] minutes={0,5,10,15,20,25,30,35,40,45,50,55};\n  String[] hoursTexts=new String[12];\n  String[] innerHoursTexts=new String[12];\n  String[] minutesTexts=new String[12];\n  for (int i=0; i < 12; i++) {\n    hoursTexts[i]=is24HourMode ? String.format(\"%02d\",hours_24[i]) : String.format(\"%d\",hours[i]);\n    innerHoursTexts[i]=String.format(\"%d\",hours[i]);\n    minutesTexts[i]=String.format(\"%02d\",minutes[i]);\n  }\n  mHourRadialTextsView.initialize(res,hoursTexts,(is24HourMode ? innerHoursTexts : null),mHideAmPm,true);\n  mHourRadialTextsView.invalidate();\n  mMinuteRadialTextsView.initialize(res,minutesTexts,null,mHideAmPm,false);\n  mMinuteRadialTextsView.invalidate();\n  setValueForItem(HOUR_INDEX,initialHoursOfDay);\n  setValueForItem(MINUTE_INDEX,initialMinutes);\n  int hourDegrees=(initialHoursOfDay % 12) * HOUR_VALUE_TO_DEGREES_STEP_SIZE;\n  mHourRadialSelectorView.initialize(context,mHideAmPm,is24HourMode,true,hourDegrees,isHourInnerCircle(initialHoursOfDay));\n  int minuteDegrees=initialMinutes * MINUTE_VALUE_TO_DEGREES_STEP_SIZE;\n  mMinuteRadialSelectorView.initialize(context,mHideAmPm,false,false,minuteDegrees,false);\n  mTimeInitialized=true;\n}", "comment": "initialize the layout with starting values .", "label": "what"}
{"id": "35946", "raw_code": "void checkFrameValue(final Object value){\n  if (value == Opcodes.TOP || value == Opcodes.INTEGER || value == Opcodes.FLOAT || value == Opcodes.LONG || value == Opcodes.DOUBLE || value == Opcodes.NULL || value == Opcodes.UNINITIALIZED_THIS) {\n    return;\n  }\n  if (value instanceof String) {\n    checkInternalName((String)value,\"Invalid stack frame value\");\n    return;\n  }\n  if (!(value instanceof Label)) {\n    throw new IllegalArgumentException(\"Invalid stack frame value: \" + value);\n  }\n else {\n    usedLabels.add((Label)value);\n  }\n}", "comment": "checks a stack frame value .", "label": "what"}
{"id": "63902", "raw_code": "protected void sqrtLayout(VisualTable labels){\n  Rectangle2D b=getLayoutBounds();\n  double breadth=getBreadth(b);\n  double span=m_hi - m_lo;\n  double splo=MathLib.safeSqrt(m_prevlo);\n  double spspan=MathLib.safeSqrt(m_prevhi) - splo;\n  double vlo=Math.pow(10,Math.floor(MathLib.safeLog10(m_lo)));\n  double slo=MathLib.safeSqrt(m_lo);\n  double sspan=MathLib.safeSqrt(m_hi) - slo;\n  Iterator iter=labels.tuples();\n  while (iter.hasNext()) {\n    VisualItem item=(VisualItem)iter.next();\n    reset(item);\n    double v=item.getDouble(VALUE);\n    double x=span == 0 ? 0 : ((MathLib.safeSqrt(v) - slo) / sspan) * breadth;\n    set(item,x,b);\n  }\n  Index index=labels.index(VALUE);\n  double step=getLinearStep(span,breadth / span);\n  if (step == 0)   step=1;\n  int r;\n  for (double x, v=vlo; v <= m_hi; v+=step) {\n    x=((MathLib.safeSqrt(v) - slo) / sspan) * breadth;\n    if (x < -0.5) {\n      continue;\n    }\n else     if ((r=index.get(v)) >= 0) {\n      VisualItem item=labels.getItem(r);\n      item.setVisible(true);\n      item.setEndVisible(true);\n    }\n else {\n      VisualItem item=labels.addItem();\n      item.set(LABEL,m_nf.format(v));\n      item.setDouble(VALUE,v);\n      double f=spspan == 0 ? 0 : ((MathLib.safeSqrt(v) - splo) / spspan);\n      if (f <= 0 || f >= 1.0) {\n        item.setStartVisible(true);\n      }\n      set(item,f * breadth,b);\n      set(item,x,b);\n    }\n  }\n}", "comment": "calculates a quantitative , square root scaled layout .", "label": "what"}
{"id": "62109", "raw_code": "public static Template create(String value){\n  if (Settings.isFunction(value)) {\n    return new FunctionalTemplate(value);\n  }\n  if (Graph.isRelational(value)) {\n    try {\n      return new RelationalTemplate(value);\n    }\n catch (    Exception e) {\n      log.warning(\"illegal relational structure: \" + value + \")\");\n      return new StringTemplate(value);\n    }\n  }\n else   if (RegexTemplate.isPossibleRegex(value)) {\n    try {\n      if (ArithmeticTemplate.isArithmeticExpression(value)) {\n        return new ArithmeticTemplate(value);\n      }\n      return new RegexTemplate(value);\n    }\n catch (    PatternSyntaxException e) {\n      log.warning(\"illegal pattern: \" + value + \")\");\n      return new StringTemplate(value);\n    }\n  }\n else {\n    return new StringTemplate(value);\n  }\n}", "comment": "creates a new template based on the string value .", "label": "what"}
{"id": "32075", "raw_code": "public static boolean isExtension(String filename,Collection<String> extensions){\n  if (filename == null)   return false;\n  if (extensions == null || extensions.isEmpty())   return indexOfExtension(filename) == -1;\n  String fileExt=getExtension(filename);\n  for (  String extension : extensions) {\n    if (fileExt.equals(extension))     return true;\n  }\n  return false;\n}", "comment": "checks whether the extension of the filename is one of those specified .", "label": "what"}
{"id": "5378", "raw_code": "private void writeJarPostResource(Element postResourceEl,String path){\n  postResourceEl.setAttribute(\"className\",JAR_RESOURCE_SET);\n  postResourceEl.setAttribute(\"base\",path.replace(\"&\",\"&amp;\"));\n}", "comment": "write jar post resource", "label": "what"}
{"id": "63311", "raw_code": "public void closeFile() throws IOException {\n  file.close();\n  file=null;\n}", "comment": "close the file .", "label": "what"}
{"id": "13525", "raw_code": "public TypedEventListener(EventListener<E> wrappedListener,Class<E> eventClass){\n  this.eventClass=eventClass;\n  this.wrappedListener=wrappedListener;\n}", "comment": "constructs a new single typed event listener .", "label": "what"}
{"id": "75503", "raw_code": "public static Corleone context(String jobContext){\n  if (jobContext == null || jobContext.equals(\"\")) {\n    throw new IllegalArgumentException(\"Job context must not be null or empty.\");\n  }\n  contexts.clear();\n  contexts.add(jobContext);\n  return getInstance();\n}", "comment": "provides a corleone instance to work on the given context .", "label": "what"}
{"id": "6617", "raw_code": "private static Frame showInitialSplash(){\n  Frame splashFrame=null;\n  Image image=null;\n  URL imageURL=getChosenSplashURL();\n  if (imageURL != null) {\n    try {\n      image=ImageIO.read(imageURL);\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n    }\n    if (image != null) {\n      splashFrame=AWTSplashWindow.splash(image);\n    }\n  }\n  return splashFrame;\n}", "comment": "shows the initial splash window .", "label": "what"}
{"id": "33722", "raw_code": "private float spacing(MotionEvent event){\n  float x=event.getX(0) - event.getX(1);\n  float y=event.getY(0) - event.getY(1);\n  return (float)Math.sqrt(x * x + y * y);\n}", "comment": "determine the space between the first two fingers", "label": "what"}
{"id": "42904", "raw_code": "public JKTagMapping(final String sourceQName,final String targetQName,final JKNamespace namespace){\n  logger.info(String.format(\"creating TagMapping with sourceTag(%s) and (%s)\",sourceQName,targetQName));\n  this.sourceQName=sourceQName;\n  this.targetQName=targetQName;\n  this.namespace=namespace;\n  this.auto=true;\n}", "comment": "instantiates a new jk tag mapping .", "label": "what"}
{"id": "22898", "raw_code": "private void ensureFileOpen(){\n  if (savingDisabled) {\n    Log.e(TAG,\"Saving disabled but tried to ensureFileOpen\");\n    return;\n  }\n  if (saveFileStream != null)   return;\n  File saveFile=new File(ctx.getFilesDir(),SAVEFILE);\n  try {\n    FileOutputStream fileOutput=null;\n    DataOutputStream out=null;\n    if (saveFile.exists()) {\n      fileOutput=ctx.openFileOutput(SAVEFILE,Context.MODE_APPEND);\n      out=new DataOutputStream(new BufferedOutputStream(fileOutput));\n    }\n else {\n      fileOutput=ctx.openFileOutput(SAVEFILE,Context.MODE_PRIVATE);\n      out=new DataOutputStream(new BufferedOutputStream(fileOutput));\n      out.writeInt(TrackPoint.FORMAT_VERSION);\n      savedTrackPoints=0;\n    }\n    saveFileStream=out;\n  }\n catch (  Exception e) {\n    markSavingBroken(\"Failed to open track save file\",e);\n  }\n}", "comment": "opens the savefilestream if necessary", "label": "what"}
{"id": "74587", "raw_code": "public static void print(Object x){\n  out.print(x);\n  out.flush();\n}", "comment": "prints an object to standard output and flushes standard output .", "label": "what"}
{"id": "68478", "raw_code": "@Override public void stop(Runnable arg0){\n  stop();\n  arg0.run();\n}", "comment": "smart lifecycle stop implementation .", "label": "what"}
{"id": "78966", "raw_code": "private static void generateGraphFile(TransMeta transMeta,String graphFile) throws GraphGeneratorException {\n  DataOutputStream dos=null;\n  try {\n    String xml=transMeta.getXML();\n    dos=new DataOutputStream(new FileOutputStream(new File(graphFile)));\n    dos.write(xml.getBytes(CarbonCommonConstants.DEFAULT_CHARSET));\n  }\n catch (  KettleException kettelException) {\n    throw new GraphGeneratorException(\"Error while getting the graph XML\",kettelException);\n  }\ncatch (  FileNotFoundException e) {\n    throw new GraphGeneratorException(\"Unable to find the graph fileL\",e);\n  }\ncatch (  UnsupportedEncodingException ue) {\n    throw new GraphGeneratorException(\"Error while Converting the graph xml string to bytes\",ue);\n  }\ncatch (  IOException ioe) {\n    throw new GraphGeneratorException(\"Error while writing the graph file\",ioe);\n  }\n finally {\n    if (dos != null) {\n      try {\n        dos.close();\n      }\n catch (      IOException e) {\n        e.getMessage();\n      }\n    }\n  }\n}", "comment": "generate the graph file . . .", "label": "what"}
{"id": "41325", "raw_code": "public static void closeOutputStream(OutputStream stream,String tag){\n  if (stream != null) {\n    try {\n      stream.close();\n    }\n catch (    IOException e) {\n      Log.e(tag,\"Exception occured when closing ByteArrayOutputStream.\" + e);\n    }\n  }\n}", "comment": "close a bytearrayoutputstream passed in .", "label": "what"}
{"id": "14017", "raw_code": "public void createEntityConfig(String realm,FederationConfigElement config) throws WSFederationMetaException {\n  String federationId=config.getFederationID();\n  if (federationId == null) {\n    debug.error(\"WSFederationMetaManager.createEntityConfig: \" + \"entity ID is null\");\n    String[] data={realm};\n    LogUtil.error(Level.INFO,LogUtil.NO_ENTITY_ID_CREATE_ENTITY_CONFIG,data,null);\n    throw new WSFederationMetaException(\"empty_entityid\",null);\n  }\n  if (realm == null) {\n    realm=\"/\";\n  }\n  String[] objs={federationId,realm};\n  try {\n    Map attrs=WSFederationMetaUtils.convertJAXBToAttrMap(ATTR_ENTITY_CONFIG,config);\n    Map oldAttrs=configInst.getConfiguration(realm,federationId);\n    if (oldAttrs == null) {\n      LogUtil.error(Level.INFO,LogUtil.NO_ENTITY_DESCRIPTOR_CREATE_ENTITY_CONFIG,objs,null);\n      throw new WSFederationMetaException(\"entity_descriptor_not_exist\",objs);\n    }\n    Set oldValues=(Set)oldAttrs.get(ATTR_ENTITY_CONFIG);\n    if (oldValues != null && !oldValues.isEmpty()) {\n      LogUtil.error(Level.INFO,LogUtil.ENTITY_CONFIG_EXISTS,objs,null);\n      throw new WSFederationMetaException(\"entity_config_exists\",objs);\n    }\n    configInst.setConfiguration(realm,federationId,attrs);\n    LogUtil.access(Level.INFO,LogUtil.ENTITY_CONFIG_CREATED,objs,null);\n    SPSSOConfigElement spconfig=getSPSSOConfig(realm,federationId);\n    if (spconfig != null) {\n      addToCircleOfTrust(spconfig,realm,federationId);\n    }\n    IDPSSOConfigElement idpconfig=getIDPSSOConfig(realm,federationId);\n    if (idpconfig != null) {\n      addToCircleOfTrust(idpconfig,realm,federationId);\n    }\n  }\n catch (  ConfigurationException e) {\n    debug.error(\"WSFederationMetaManager.createEntityConfig:\",e);\n    String[] data={e.getMessage(),federationId,realm};\n    LogUtil.error(Level.INFO,LogUtil.CONFIG_ERROR_CREATE_ENTITY_CONFIG,data,null);\n    throw new WSFederationMetaException(e);\n  }\ncatch (  JAXBException jaxbe) {\n    debug.error(\"WSFederationMetaManager.createEntityConfig:\",jaxbe);\n    LogUtil.error(Level.INFO,LogUtil.CREATE_INVALID_ENTITY_CONFIG,objs,null);\n    throw new WSFederationMetaException(\"invalid_config\",objs);\n  }\n}", "comment": "creates the extended entity configuration under the realm .", "label": "what"}
{"id": "4510", "raw_code": "private void loadUserInfoIntoActionBar(){\n  if (!TextUtils.isEmpty(mWithUserImage)) {\n    Utils.loadCircularImage(getActivity(),mWithImageView,mWithUserImage,AvatarBitmapTransformation.AvatarSize.NORMAL);\n  }\n}", "comment": "loads the user image into the action bar profile pic", "label": "what"}
{"id": "78622", "raw_code": "public TraceGraph(Collection<Span> spans){\n  this.spansByParent=new SpansByParent(spans);\n  this.spansByTracerId=new SpansByTracerId(spans);\n}", "comment": "create a new tracegraph", "label": "what"}
{"id": "26922", "raw_code": "protected void handleMesosFailure(String taskId){\n  int attempt=TaskUtils.getAttemptForTaskId(taskId);\n  BaseContainer container=containersInfo.get(TaskUtils.getContainerIndexForTaskId(taskId));\n  boolean hasAttemptsLeft=attempt < container.retries;\n  if (hasAttemptsLeft) {\n    LOG.warning(String.format(\"Retrying task: %s, attempt: %d\",container.name,attempt + 1));\n    String newTaskId=TaskUtils.getTaskId(container.name,attempt + 1);\n    scheduleNewTask(newTaskId);\n  }\n else {\n    LOG.severe(\"Would not restart the job since it is beyond retries: \" + attempt);\n  }\n}", "comment": "restart a failed task unless exceeding the retires limitation", "label": "what"}
{"id": "23927", "raw_code": "public static File findConfigInWorkingDirectory(){\n  for (  final String suffix : SUFFIXES) {\n    final File configFile=new File(System.getProperty(\"user.dir\"),PREFIX + suffix);\n    if (configFile.isFile()) {\n      return configFile;\n    }\n  }\n  return null;\n}", "comment": "finds a log4j configuration file in the current working directory .", "label": "what"}
{"id": "7712", "raw_code": "@Override public void drawRangeMarker(Graphics2D g2,XYPlot plot,ValueAxis rangeAxis,Marker marker,Rectangle2D dataArea){\n  if (marker instanceof ValueMarker) {\n    ValueMarker vm=(ValueMarker)marker;\n    double value=vm.getValue();\n    Range range=rangeAxis.getRange();\n    if (!range.contains(value)) {\n      return;\n    }\n    double v=rangeAxis.valueToJava2D(value,dataArea,plot.getRangeAxisEdge());\n    PlotOrientation orientation=plot.getOrientation();\n    Line2D line=null;\n    if (orientation == PlotOrientation.HORIZONTAL) {\n      line=new Line2D.Double(v,dataArea.getMinY(),v,dataArea.getMaxY());\n    }\n else     if (orientation == PlotOrientation.VERTICAL) {\n      line=new Line2D.Double(dataArea.getMinX(),v,dataArea.getMaxX(),v);\n    }\n else {\n      throw new IllegalStateException(\"Unrecognised orientation.\");\n    }\n    final Composite originalComposite=g2.getComposite();\n    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,marker.getAlpha()));\n    g2.setPaint(marker.getPaint());\n    g2.setStroke(marker.getStroke());\n    g2.draw(line);\n    String label=marker.getLabel();\n    RectangleAnchor anchor=marker.getLabelAnchor();\n    if (label != null) {\n      Font labelFont=marker.getLabelFont();\n      g2.setFont(labelFont);\n      Point2D coords=calculateRangeMarkerTextAnchorPoint(g2,orientation,dataArea,line.getBounds2D(),marker.getLabelOffset(),LengthAdjustmentType.EXPAND,anchor);\n      Rectangle2D r=TextUtils.calcAlignedStringBounds(label,g2,(float)coords.getX(),(float)coords.getY(),marker.getLabelTextAnchor());\n      g2.setPaint(marker.getLabelBackgroundColor());\n      g2.fill(r);\n      g2.setPaint(marker.getLabelPaint());\n      TextUtilities.drawAlignedString(label,g2,(float)coords.getX(),(float)coords.getY(),marker.getLabelTextAnchor());\n    }\n    g2.setComposite(originalComposite);\n  }\n else   if (marker instanceof IntervalMarker) {\n    IntervalMarker im=(IntervalMarker)marker;\n    double start=im.getStartValue();\n    double end=im.getEndValue();\n    Range range=rangeAxis.getRange();\n    if (!(range.intersects(start,end))) {\n      return;\n    }\n    double start2d=rangeAxis.valueToJava2D(start,dataArea,plot.getRangeAxisEdge());\n    double end2d=rangeAxis.valueToJava2D(end,dataArea,plot.getRangeAxisEdge());\n    double low=Math.min(start2d,end2d);\n    double high=Math.max(start2d,end2d);\n    PlotOrientation orientation=plot.getOrientation();\n    Rectangle2D rect=null;\n    if (orientation == PlotOrientation.HORIZONTAL) {\n      low=Math.max(low,dataArea.getMinX());\n      high=Math.min(high,dataArea.getMaxX());\n      rect=new Rectangle2D.Double(low,dataArea.getMinY(),high - low,dataArea.getHeight());\n    }\n else     if (orientation == PlotOrientation.VERTICAL) {\n      low=Math.max(low,dataArea.getMinY());\n      high=Math.min(high,dataArea.getMaxY());\n      rect=new Rectangle2D.Double(dataArea.getMinX(),low,dataArea.getWidth(),high - low);\n    }\n    final Composite originalComposite=g2.getComposite();\n    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,marker.getAlpha()));\n    Paint p=marker.getPaint();\n    if (p instanceof GradientPaint) {\n      GradientPaint gp=(GradientPaint)p;\n      GradientPaintTransformer t=im.getGradientPaintTransformer();\n      if (t != null) {\n        gp=t.transform(gp,rect);\n      }\n      g2.setPaint(gp);\n    }\n else {\n      g2.setPaint(p);\n    }\n    g2.fill(rect);\n    if (im.getOutlinePaint() != null && im.getOutlineStroke() != null) {\n      if (orientation == PlotOrientation.VERTICAL) {\n        Line2D line=new Line2D.Double();\n        double x0=dataArea.getMinX();\n        double x1=dataArea.getMaxX();\n        g2.setPaint(im.getOutlinePaint());\n        g2.setStroke(im.getOutlineStroke());\n        if (range.contains(start)) {\n          line.setLine(x0,start2d,x1,start2d);\n          g2.draw(line);\n        }\n        if (range.contains(end)) {\n          line.setLine(x0,end2d,x1,end2d);\n          g2.draw(line);\n        }\n      }\n else {\n        Line2D line=new Line2D.Double();\n        double y0=dataArea.getMinY();\n        double y1=dataArea.getMaxY();\n        g2.setPaint(im.getOutlinePaint());\n        g2.setStroke(im.getOutlineStroke());\n        if (range.contains(start)) {\n          line.setLine(start2d,y0,start2d,y1);\n          g2.draw(line);\n        }\n        if (range.contains(end)) {\n          line.setLine(end2d,y0,end2d,y1);\n          g2.draw(line);\n        }\n      }\n    }\n    String label=marker.getLabel();\n    RectangleAnchor anchor=marker.getLabelAnchor();\n    if (label != null) {\n      Font labelFont=marker.getLabelFont();\n      g2.setFont(labelFont);\n      Point2D coords=calculateRangeMarkerTextAnchorPoint(g2,orientation,dataArea,rect,marker.getLabelOffset(),marker.getLabelOffsetType(),anchor);\n      Rectangle2D r=TextUtils.calcAlignedStringBounds(label,g2,(float)coords.getX(),(float)coords.getY(),marker.getLabelTextAnchor());\n      g2.setPaint(marker.getLabelBackgroundColor());\n      g2.fill(r);\n      g2.setPaint(marker.getLabelPaint());\n      TextUtilities.drawAlignedString(label,g2,(float)coords.getX(),(float)coords.getY(),marker.getLabelTextAnchor());\n    }\n    g2.setComposite(originalComposite);\n  }\n}", "comment": "draws a line on the chart perpendicular to the y - axis to mark a value or range of values .", "label": "what"}
{"id": "74952", "raw_code": "protected boolean attemptToAddWord(Word word){\n  double additionalLength=word.getWordWidth();\n  additionalLength+=!words.isEmpty() ? spaceSize : 0;\n  if (currentLineLength + additionalLength <= maxLength || maxLength == -1) {\n    words.add(word);\n    currentLineLength+=additionalLength;\n    return true;\n  }\n else {\n    return false;\n  }\n}", "comment": "attempt to add a word to the line .", "label": "what"}
{"id": "23265", "raw_code": "public void readWwwAuthenticateHeader(String header){\n  if (header != null) {\n    mIsDigestAuthentication=header.startsWith(HttpDigestMd5Authentication.HTTP_DIGEST_SCHEMA);\n    if (!mIsDigestAuthentication) {\n      return;\n    }\n    String value=getValue(header,\"realm\");\n    mDigest.setRealm(value);\n    value=getValue(header,\"opaque\");\n    mDigest.setOpaque(value);\n    value=getValue(header,\"qop\");\n    mDigest.setQop(value);\n    value=getValue(header,\"nonce\");\n    mDigest.setNextnonce(value);\n  }\n}", "comment": "read the www - authenticate header", "label": "what"}
{"id": "53952", "raw_code": "public boolean exists(String key){\n  return exists(key,false);\n}", "comment": "check existence of config section element", "label": "what"}
{"id": "39526", "raw_code": "public ActivityMonitorSample(){\n  initComponents();\n  ownerARadio.setActionCommand(\"A\");\n  ownerBRadio.setActionCommand(\"B\");\n  ownerCRadio.setActionCommand(\"C\");\n  indicatorA.setActivityOwner(\"A\");\n  indicatorB.setActivityOwner(\"B\");\n  indicatorC.setActivityOwner(\"C\");\n  JActivityWindow.getInstance();\n}", "comment": "creates new form activitymonitorsample", "label": "what"}
{"id": "23027", "raw_code": "private void initCheckbox(CheckBoxPreference checkbox,boolean checked,boolean enabled){\n  checkbox.setChecked(checked);\n  checkbox.setEnabled(enabled);\n}", "comment": "initialize the service activation checkbox", "label": "what"}
{"id": "82785", "raw_code": "private void paintCheckIconEnabledAndSelected(Graphics2D g,int width,int height){\n  Shape s=shapeGenerator.createCheckMark(0,0,width,height);\n  g.setPaint(iconEnabledSelected);\n  g.fill(s);\n}", "comment": "paint the check mark in enabled state .", "label": "what"}
{"id": "66214", "raw_code": "private void writeLog(String cmd){\n  try {\n    if (m_writer == null) {\n      File file=File.createTempFile(\"create\",\".log\");\n      m_writer=new PrintWriter(new FileWriter(file));\n      log.info(file.toString());\n    }\n    m_writer.println(cmd);\n    m_writer.flush();\n  }\n catch (  Exception e) {\n    log.severe(e.toString());\n  }\n}", "comment": "write to file log", "label": "what"}
{"id": "12249", "raw_code": "public void reload(String why){\n  mFullPhotoPaths=mRootDir.list(MediaScanner.JPG_FILENAME_FILTER);\n  if ((mFullPhotoPaths != null) && (mFullPhotoPaths.length == 0)) {\n    mFullPhotoPaths=null;\n    Log.i(Global.LOG_CONTEXT,mDebugPrefix + why + \"AdapterArrayHelper.refreshLocal(\"+ mRootDir+ \") \"+ 0);\n  }\n else   if (mFullPhotoPaths != null) {\n    if (Global.debugEnabled) {\n      Log.i(Global.LOG_CONTEXT,mDebugPrefix + why + \"AdapterArrayHelper.refreshLocal(\"+ mRootDir+ \") \"+ mFullPhotoPaths.length);\n    }\n    String parentDirString=mRootDir.getAbsolutePath();\n    for (int i=0; i < mFullPhotoPaths.length; i++) {\n      mFullPhotoPaths[i]=parentDirString + \"/\" + mFullPhotoPaths[i];\n    }\n  }\n}", "comment": "refreshlocal files from inital path", "label": "what"}
{"id": "55827", "raw_code": "DNSRecord(String name,DNSRecordType type,DNSRecordClass recordClass,boolean unique,int ttl){\n  super(name,type,recordClass,unique);\n  this._ttl=ttl;\n  this._created=System.currentTimeMillis();\n}", "comment": "create a dnsrecord with a name , type , class , and ttl .", "label": "what"}
{"id": "47665", "raw_code": "private void growSpine(){\n  spine=new int[(spine.length << 1) + 1];\n  threshold=(int)(spine.length * loadFactor);\n  Arrays.fill(spine,-1);\n  for (int i=0; i < size; i++) {\n    insert(objs[i],i);\n  }\n}", "comment": "expands the hash \" spine \" - - equivalent to increasing the number of buckets in a conventional hash table .", "label": "what"}
{"id": "73769", "raw_code": "public void reconnect(){\n  if (opened && !allowConnectionRecovery) {\n    return;\n  }\n  reconnectwait thread=new reconnectwait();\n  thread.start();\n  try {\n    thread.join();\n  }\n catch (  InterruptedException e) {\n    log.error(\"Unable to join to the reconnection thread \" + e.getMessage());\n  }\n  if (!opened) {\n    log.error(\"Failed to re-establish connectivity\");\n  }\n else {\n    log.info(\"Reconnected to \" + getCurrentPortName());\n    resetupConnection();\n  }\n}", "comment": "attempts to reconnect to a failed server", "label": "what"}
{"id": "13263", "raw_code": "protected void resetXML11() throws XNIException {\n  int count=fXML11Components.size();\n  for (int i=0; i < count; i++) {\n    XMLComponent c=(XMLComponent)fXML11Components.get(i);\n    c.reset(this);\n  }\n}", "comment": "reset all components before parsing and namespace context", "label": "what"}
{"id": "27066", "raw_code": "public float distanceToOtherCircle(Circle circle){\n  return (float)Math.abs(Math.sqrt(Math.pow(circle.center.x - center.x,2) + Math.pow(circle.center.y - center.y,2)));\n}", "comment": "distance between circle center", "label": "what"}
{"id": "31008", "raw_code": "public SimpleCommand(String commandName,String... args){\n  this(commandName,(Argument)null);\n  ArrayList<Argument> argList=new ArrayList<Argument>();\n  for (  String arg : args)   argList.add(new Argument(arg));\n  _arguments=argList.toArray(new Argument[0]);\n}", "comment": "constructs a simplecommand from the given command name and the list of arguments .", "label": "what"}
{"id": "18192", "raw_code": "private void grow(){\n  m_allocatedSize*=2;\n  boolean newVector[]=new boolean[m_allocatedSize];\n  System.arraycopy(m_values,0,newVector,0,m_index + 1);\n  m_values=newVector;\n}", "comment": "grows the size of the stack", "label": "what"}
{"id": "65140", "raw_code": "public PickingGraphMousePlugin(int selectionModifiers,int addToSelectionModifiers){\n  super(selectionModifiers);\n  this.addToSelectionModifiers=addToSelectionModifiers;\n  this.lensPaintable=new LensPaintable();\n  this.cursor=Cursor.getPredefinedCursor(Cursor.HAND_CURSOR);\n}", "comment": "create an instance with overides", "label": "what"}
{"id": "3588", "raw_code": "public ViewRefRender(ViewRender<T> view,Class<T> type,int priority){\n  Objects.requireNonNull(view);\n  _view=view;\n  _type=type;\n  _priority=priority;\n}", "comment": "creates the view and analyzes the type", "label": "what"}
{"id": "61325", "raw_code": "public void checkNumberArgs(int argNum) throws WrongNumberArgsException {\n  if (argNum < 2)   reportWrongNumberArgs();\n}", "comment": "check that the number of arguments passed to this function is correct .", "label": "what"}
{"id": "11155", "raw_code": "public DrawingAttributes(){\n  propertyChangeSupport=new PropertyChangeSupport(this);\n}", "comment": "create a drawingattributes with the default settings - clear fill paint and pattern , sold black edge line of width 1 .", "label": "what"}
{"id": "74605", "raw_code": "public void close(){\n  scanner.close();\n}", "comment": "closes this input stream .", "label": "what"}
{"id": "14666", "raw_code": "static void createPolicyTree(String configName,String configId,ServiceConfigManager scm,String org) throws NoPermissionException, PolicyException, SSOException {\n  try {\n    ServiceConfig pConfig=scm.getOrganizationConfig(org,null);\n    if (pConfig == null) {\n      scm.createOrganizationConfig(org,null);\n      pConfig=scm.getOrganizationConfig(org,null);\n    }\n    pConfig.addSubConfig(configName,configId,0,null);\n  }\n catch (  ServiceAlreadyExistsException se) {\n    if (debug.messageEnabled()) {\n      debug.message(\"PolicyManager->createPolicyTree: Name: \" + configName + \" ID: \"+ configId+ \" Policy service already exists under org->\"+ org);\n    }\n  }\ncatch (  SMSException e) {\n    String[] objs={org};\n    if (e.getExceptionCode() == SMSException.STATUS_NO_PERMISSION) {\n      throw (new NoPermissionException(ResBundleUtils.rbName,\"insufficient_access_rights\",null));\n    }\n else {\n      throw (new PolicyException(ResBundleUtils.rbName,\"unable_to_create_policy_for_org\",objs,e));\n    }\n  }\n}", "comment": "creates the policy tree , ou = policy , ou = services , . . .", "label": "what"}
{"id": "55879", "raw_code": "public void readPrefs(SharedPreferences settings,ActionFactory factory){\n  boolean visible=false;\n  String actionId=settings.getString(\"button_action_\" + name + \"_0\",\"\");\n  mainAction=factory.getAction(actionId);\n  if (mainAction != null)   visible=true;\n  menuActions.clear();\n  for (int i=0; i < maxMenuActions; i++) {\n    actionId=settings.getString(\"button_action_\" + name + \"_\"+ (i + 1),\"\");\n    UIAction a=factory.getAction(actionId);\n    if (a != null)     visible=true;\n    menuActions.add(a);\n  }\n  if (button != null)   button.setVisibility(visible ? View.VISIBLE : View.GONE);\n}", "comment": "update button actions from preferences settings .", "label": "what"}
{"id": "64325", "raw_code": "public boolean addToActiveList(DownloadInfoRunnable downloadInfoRunnable){\n  return activeListHasRoom() && mActiveList.add(downloadInfoRunnable);\n}", "comment": "tries to add a download object to the active list .", "label": "what"}
{"id": "33055", "raw_code": "private boolean isUpperCaseCamelCaseHunk(String hunk){\n  if (hunk.length() < 2)   return false;\n  for (int i=0; i < hunk.length(); i++) {\n    if (!isLegalChar(hunk.charAt(i)))     return false;\n  }\n  return true;\n}", "comment": "true if hunk is longer than 1 character and all letters in the hunk are uppercase .", "label": "what"}
{"id": "62931", "raw_code": "public void type(String string){\n  for (int i=0; i < string.length(); i++) {\n    char c=string.charAt(i);\n    type(c);\n  }\n}", "comment": "simulate keyboard type to type out a string .", "label": "what"}
{"id": "33409", "raw_code": "public boolean providesIdentifier(){\n  return false;\n}", "comment": "simple registration doesn ' t implement authentication services .", "label": "what"}
{"id": "40743", "raw_code": "protected void doResumeUpdates(){\n  Calendar cal=Calendar.getInstance(Locale.getDefault());\n  mFirstDayOfWeek=cal.getFirstDayOfWeek() - 1;\n  mShowWeekNumber=false;\n  updateHeader();\n  goTo(mSelectedDay.toMillis(true),false,false,false);\n  mAdapter.setSelectedDay(mSelectedDay);\n  mTodayUpdater.run();\n}", "comment": "updates the user preference fields .", "label": "what"}
{"id": "80387", "raw_code": "private void storeLastUsed(){\n  put(LAST_USE,(int)(System.currentTimeMillis() / 1000));\n}", "comment": "store current system time as the last used", "label": "what"}
{"id": "76124", "raw_code": "private boolean canContain(ElementContainmentInfo child,ElementContainmentInfo top,int topIndex){\n  int childTypes=child.types;\n  int contents=top.contents;\n  int transparencyAllowed=childTypes & (top.transparentToContents & ~contents);\n  for (int containerIndex=topIndex - 1; transparencyAllowed != 0; --containerIndex) {\n    if (containerIndex < 0) {\n      contents|=transparencyAllowed;\n      break;\n    }\n    ElementContainmentInfo container=openElements.get(containerIndex);\n    contents|=transparencyAllowed & container.contents;\n    transparencyAllowed=transparencyAllowed & container.transparentToContents & ~contents;\n  }\n  return (contents & childTypes) != 0;\n}", "comment": "takes into account transparency when figuring out what can be contained .", "label": "what"}
{"id": "9551", "raw_code": "public static int[] extractArcs(ASN1ObjectIdentifier oid) throws InvalidObjectIdException {\n  String oidStr=oid.getId();\n  StringTokenizer strTokCnt=new StringTokenizer(oidStr,\".\",false);\n  int arcCount=strTokCnt.countTokens();\n  StringTokenizer strTok=new StringTokenizer(oidStr,\".\",true);\n  boolean expectDelimiter=false;\n  int[] arcs=new int[arcCount];\n  int i=0;\n  while (strTok.hasMoreTokens()) {\n    String token=strTok.nextToken();\n    if (expectDelimiter && (!token.equals(\".\") || !strTok.hasMoreTokens())) {\n      throw new InvalidObjectIdException(res.getString(\"InvalidOidNotNonNegativeIntSequence.exception.message\"));\n    }\n else     if (!expectDelimiter) {\n      try {\n        arcs[i]=Integer.parseInt(token);\n        if (arcs[i] < 0) {\n          throw new InvalidObjectIdException(res.getString(\"InvalidOidNotNonNegativeIntSequence.exception.message\"));\n        }\n        i++;\n      }\n catch (      NumberFormatException ex) {\n        throw new InvalidObjectIdException(res.getString(\"InvalidOidNotNonNegativeIntSequence.exception.message\"));\n      }\n    }\n    expectDelimiter=!expectDelimiter;\n  }\n  return arcs;\n}", "comment": "extract the arcs from an object identifier .", "label": "what"}
{"id": "3455", "raw_code": "@Override public PollResult startPoll(PollController conn){\n  if (!_lifecycle.isActive()) {\n    log.warning(this + \" select disabled\");\n    return PollResult.CLOSED;\n  }\n  SocketBar socket=conn.getSocket();\n  if (socket == null) {\n    log.warning(this + \" socket empty for \" + conn);\n    return PollResult.CLOSED;\n  }\n  SelectableChannel selChannel=socket.selectableChannel();\n  if (selChannel == null) {\n    log.warning(this + \" no channel for \" + socket);\n    return PollResult.CLOSED;\n  }\n  _connectionCount.incrementAndGet();\n  _activeCount.incrementAndGet();\n  _registerQueue.offer(conn);\n  return PollResult.START;\n}", "comment": "adds a keepalive connection .", "label": "what"}
{"id": "30596", "raw_code": "public ClusterPolicy createClusterPolicy(String clusterMemberName) throws CreateException {\n  long time1=System.currentTimeMillis();\n  if (_clusterPolicies == null) {\n    _clusterMemberNames=getClusterMemberNames();\n    if (_clusterMemberNames != null && _clusterMemberNames.length > 0) {\n      _clusterPolicies=new HashMap<String,ClusterPolicy>();\n      ClusterPolicy[] tempPolicy=new ClusterPolicy[_clusterMemberNames.length];\n      for (int i=0; i < _clusterMemberNames.length; i++)       tempPolicy[i]=createClusterPolicyInternal(_clusterMemberNames[i]);\n      ArrayList<ReplicationPolicy> selectedReplPolicies=new ArrayList<ReplicationPolicy>(_clusterMemberNames.length);\n      List<String> selectedReplGroupNames=new ArrayList<String>(_clusterMemberNames.length);\n      for (int i=0; i < tempPolicy.length; i++)       if (tempPolicy[i].m_ReplicationPolicy != null && !selectedReplGroupNames.contains(tempPolicy[i].m_ReplicationPolicy.m_ReplicationGroupName)) {\n        selectedReplPolicies.add(tempPolicy[i].m_ReplicationPolicy);\n        selectedReplGroupNames.add(tempPolicy[i].m_ReplicationPolicy.m_ReplicationGroupName);\n      }\n      if (selectedReplPolicies.isEmpty())       selectedReplPolicies=null;\n else       selectedReplPolicies.trimToSize();\n      for (int i=0; i < _clusterMemberNames.length; i++) {\n        tempPolicy[i].m_ReplicationGroups=selectedReplPolicies;\n        _clusterPolicies.put(_clusterMemberNames[i],tempPolicy[i]);\n      }\n    }\n  }\n  ClusterPolicy result=_clusterPolicies.get(clusterMemberName);\n  if (result == null)   result=createClusterPolicyInternal(clusterMemberName);\n  long time2=System.currentTimeMillis();\n  if (_logger.isLoggable(Level.FINE)) {\n    _logger.fine(\"Creation of ClusterPolicy instance for \\\"\" + clusterMemberName + \"\\\" cluster member took \"+ (time2 - time1)+ \" msec.\");\n  }\n  return result;\n}", "comment": "creating cluster policy object .", "label": "what"}
{"id": "29489", "raw_code": "public ConfigureCoerceiveParsingDialog_NB(CoerciveParsing coerciveParsing){\n  this.coerciveParsing=coerciveParsing;\n  initComponents();\n  final IterateModel numberOfTagsIterator=coerciveParsing.getNumberOfTagsIterator();\n  configureIterateModel_NB2.setStartAt(String.valueOf(numberOfTagsIterator.getStartAt()));\n  configureIterateModel_NB2.setStopAt(String.valueOf(numberOfTagsIterator.getStopAt()));\n  configureIterateModel_NB2.setIncrement(String.valueOf(numberOfTagsIterator.getIncrement()));\n  configureIterateModel_NB2.setIterateStrategie(numberOfTagsIterator.getIterateStrategie());\n  List<String> tagNames=Arrays.asList(coerciveParsing.getTagNames());\n  configureStringList_NB1.setStringList(tagNames);\n}", "comment": "creates new form configurecoerceiveparsingdialog _ nb", "label": "what"}
{"id": "30262", "raw_code": "public static double logOfBase(double number,int base){\n  return Math.log(number) / Math.log(base);\n}", "comment": "gets the log at a certain base of a number .", "label": "what"}
{"id": "26788", "raw_code": "public static void UF6(double[] x,double[] f,int nx){\n  int count1=0;\n  int count2=0;\n  double sum1=0.0;\n  double sum2=0.0;\n  double prod1=1.0;\n  double prod2=1.0;\n  double yj;\n  double hj;\n  double pj;\n  double N=2.0;\n  double E=0.1;\n  for (int j=2; j <= nx; j++) {\n    yj=x[j - 1] - Math.sin(6.0 * PI * x[0] + j * PI / nx);\n    pj=Math.cos(20.0 * yj * PI / Math.sqrt(j + 0.0));\n    if (j % 2 == 0) {\n      sum2+=yj * yj;\n      prod2*=pj;\n      count2++;\n    }\n else {\n      sum1+=yj * yj;\n      prod1*=pj;\n      count1++;\n    }\n  }\n  hj=2.0 * (0.5 / N + E) * Math.sin(2.0 * N * PI* x[0]);\n  if (hj < 0.0) {\n    hj=0.0;\n  }\n  f[0]=x[0] + hj + 2.0 * (4.0 * sum1 - 2.0 * prod1 + 2.0) / (double)count1;\n  f[1]=1.0 - x[0] + hj + 2.0 * (4.0 * sum2 - 2.0 * prod2 + 2.0) / (double)count2;\n}", "comment": "evaluates the uf6 problem .", "label": "what"}
{"id": "60393", "raw_code": "public FileSaverDescriptor(@NotNull String title,@NotNull String description,String... extensions){\n  super(true,true,true,true,false,false);\n  setTitle(title);\n  setDescription(description);\n  this.extensions=Arrays.asList(extensions);\n}", "comment": "constructs save dialog properties", "label": "what"}
{"id": "17006", "raw_code": "protected int readBlock(){\n  blockSize=read();\n  int n=0;\n  if (blockSize > 0) {\n    try {\n      int count;\n      while (n < blockSize) {\n        count=blockSize - n;\n        rawData.get(block,n,count);\n        n+=count;\n      }\n    }\n catch (    final Exception e) {\n      Log.w(TAG,\"Error Reading Block\",e);\n      status=STATUS_FORMAT_ERROR;\n    }\n  }\n  return n;\n}", "comment": "reads next variable length block from input .", "label": "what"}
{"id": "42096", "raw_code": "public void addRun(final Run run){\n  runs.add(run);\n  run.setId(runIdCounter++);\n}", "comment": "will add the run to the list .", "label": "what"}
{"id": "16113", "raw_code": "void copyInto(Converter[] converters){\n  System.arraycopy(iConverters,0,converters,0,iConverters.length);\n}", "comment": "copies all the converters in the set to the given array .", "label": "what"}
{"id": "3733", "raw_code": "public void init(SocketChannel channel){\n  _channel=channel;\n  _readBuffer.clear();\n  _readBuffer.flip();\n  _needsFlush=false;\n}", "comment": "initialize the socketstream with a new socket .", "label": "what"}
{"id": "49858", "raw_code": "public void reset(){\n  Timber.i(\"resetting QueuedMediaPlayer...\");\n  mCurrentPlayer.reset();\n  mNextPlayer.reset();\n  mQueue=Collections.emptyList();\n  mQueueIndex=0;\n  mRequestedSeekPosition=0;\n  mPlayWhenPrepared=false;\n}", "comment": "resets both mediaplayers , and clears the queue .", "label": "what"}
{"id": "8000", "raw_code": "@Override public Expected<T> ifPresent(final Consumer<? super T> consumer){\n  if (this.value != null)   consumer.accept(this.value);\n  return this;\n}", "comment": "if a value is present , invoke the consumer with the value .", "label": "what"}
{"id": "73659", "raw_code": "protected void sendIntensity(double intensity){\n  if (log.isDebugEnabled()) {\n    log.debug(\"sendIntensity(\" + intensity + \")\"+ \" lastOutputStep: \"+ lastOutputStep+ \" maxDimStep: \"+ maxDimStep);\n  }\n  int newStep=(int)Math.round(intensity * maxDimStep);\n  if ((newStep < 0) || (newStep > maxDimStep)) {\n    log.error(\"newStep wrong: \" + newStep + \" intensity: \"+ intensity);\n  }\n  if (newStep == 0) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"intensity \" + intensity + \" within current step, return\");\n    }\n    return;\n  }\n  X10Sequence out=new X10Sequence();\n  out.addExtData(housecode,devicecode,X10Sequence.EXTCMD_DIM,newStep);\n  tc.sendX10Sequence(out,null);\n  lastOutputStep=newStep;\n  if (log.isDebugEnabled()) {\n    log.debug(\"sendIntensity(\" + intensity + \") house \"+ X10Sequence.houseValueToText(housecode)+ \" device \"+ devicecode+ \" newStep: \"+ newStep);\n  }\n}", "comment": "send a dim / bright commands to the x10 hardware to reach a specific intensity .", "label": "what"}
{"id": "79156", "raw_code": "public GlowScheduler(GlowServer server,WorldScheduler worlds){\n  this.server=server;\n  this.worlds=worlds;\n  inTickTaskCondition=worlds.getAdvanceCondition();\n  tickEndRun=null;\n  primaryThread=Thread.currentThread();\n}", "comment": "creates a new task scheduler .", "label": "what"}
{"id": "13415", "raw_code": "private int calculateLayoutWidth(int widthSize,int mode){\n  initResourcesIfNecessary();\n  itemsLayout.setLayoutParams(new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT));\n  itemsLayout.measure(MeasureSpec.makeMeasureSpec(widthSize,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));\n  int width=itemsLayout.getMeasuredWidth();\n  if (mode == MeasureSpec.EXACTLY) {\n    width=widthSize;\n  }\n else {\n    width+=2 * PADDING;\n    width=Math.max(width,getSuggestedMinimumWidth());\n    if (mode == MeasureSpec.AT_MOST && widthSize < width) {\n      width=widthSize;\n    }\n  }\n  itemsLayout.measure(MeasureSpec.makeMeasureSpec(width - 2 * PADDING,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));\n  return width;\n}", "comment": "calculates control width and creates text layouts", "label": "what"}
{"id": "42580", "raw_code": "public void characters(char[] ch,int start,int length) throws SAXException {\n  try {\n    stopTerminator();\n    if (w == null)     return;\n    int end=start + length;\n    for (int i=start; i < end; i++) {\n      char c=ch[i];\nswitch (c) {\ncase '&':\n        w.write(\"&amp;\");\n      break;\ncase '<':\n    w.write(\"&lt;\");\n  break;\ncase '>':\nw.write(\"&gt;\");\nbreak;\ncase '\\n':\ncase '\\r':\ncase '\\t':\nw.write(c);\nbreak;\ndefault :\nif (canEncode(c)) {\nw.write(c);\n}\n else {\nw.write(\"&#\");\nw.write(Integer.toString(c));\nw.write(\";\");\n}\nbreak;\n}\n}\n}\n catch (IOException e) {\nthrow new SAXException(e);\n}\n}", "comment": "inserts a string of characters into the document .", "label": "what"}
{"id": "23232", "raw_code": "@Override public IChatMessage sendMessage(final String text) throws RemoteException {\n  if (TextUtils.isEmpty(text)) {\n    throw new ServerApiIllegalArgumentException(\"GroupChat message must not be null or empty!\");\n  }\n  int messageLength=text.length();\n  int maxMessageLength=mRcsSettings.getMaxGroupChatMessageLength();\n  if (messageLength > maxMessageLength) {\n    throw new ServerApiIllegalArgumentException(\"chat message length: \" + messageLength + \" exceeds max group chat message length: \"+ maxMessageLength+ \"!\");\n  }\n  if (!isAllowedToSendMessage()) {\n    throw new ServerApiPermissionDeniedException(\"Not allowed to send GroupChat message on the connected IMS server!\");\n  }\n  try {\n    mImService.removeGroupChatComposingStatus(mChatId);\n    long timestamp=System.currentTimeMillis();\n    final ChatMessage msg=ChatUtils.createTextMessage(null,text,timestamp,timestamp);\n    ChatMessagePersistedStorageAccessor persistedStorage=new ChatMessagePersistedStorageAccessor(mMessagingLog,msg.getMessageId(),msg.getRemoteContact(),text,msg.getMimeType(),mChatId,Direction.OUTGOING);\n    addOutgoingGroupChatMessage(msg,Content.Status.QUEUED,Content.ReasonCode.UNSPECIFIED);\n    if (!mChatService.isGroupChatActive(mChatId)) {\n      mChatService.setGroupChatStateAndReasonCode(mChatId,GroupChat.State.STARTED,GroupChat.ReasonCode.UNSPECIFIED);\n    }\n    mImService.tryToDequeueGroupChatMessagesAndGroupFileTransfers(mChatId);\n    return new ChatMessageImpl(persistedStorage);\n  }\n catch (  ServerApiBaseException e) {\n    if (!e.shouldNotBeLogged()) {\n      sLogger.error(ExceptionUtil.getFullStackTrace(e));\n    }\n    throw e;\n  }\ncatch (  Exception e) {\n    sLogger.error(ExceptionUtil.getFullStackTrace(e));\n    throw new ServerApiGenericException(e);\n  }\n}", "comment": "sends a text message to the group", "label": "what"}
{"id": "63423", "raw_code": "void remove(TcpServerThread t){\n  running.remove(t);\n}", "comment": "remove a thread from the list .", "label": "what"}
{"id": "30017", "raw_code": "public DockNodeEventHandler(Node node){\n  this.node=node;\n}", "comment": "creates a default dock node event handler that will help this dock pane track the current docking area .", "label": "what"}
{"id": "56371", "raw_code": "private int readSourceToLog(Settings settings){\n  String sourceToLog=settings.get(INDEX_INDEXING_SLOWLOG_MAX_SOURCE_CHARS_TO_LOG,\"1000\");\n  try {\n    return Integer.parseInt(sourceToLog,10);\n  }\n catch (  NumberFormatException e) {\n    return Booleans.parseBoolean(sourceToLog,true) ? Integer.MAX_VALUE : 0;\n  }\n}", "comment": "reads how much of the source to log .", "label": "what"}
{"id": "21107", "raw_code": "private void deleteCurrentLicenseFileOnDisk(){\n  File licenseFile=new File(LicenseConstants.LICENSE_FILE_PATH);\n  if (licenseFile.exists()) {\n    licenseFile.delete();\n  }\n}", "comment": "deletes current version of license file in / tmp / . license", "label": "what"}
{"id": "61780", "raw_code": "@Override public void run(){\nsynchronized (mSync) {\n    mRequestStop=false;\n    mRequestDrain=0;\n    mSync.notify();\n  }\n  final boolean isRunning=true;\n  boolean localRequestStop;\n  boolean localRequestDrain;\n  while (isRunning) {\nsynchronized (mSync) {\n      localRequestStop=mRequestStop;\n      localRequestDrain=(mRequestDrain > 0);\n      if (localRequestDrain)       mRequestDrain--;\n    }\n    if (localRequestStop) {\n      drain();\n      signalEndOfInputStream();\n      drain();\n      release();\n      break;\n    }\n    if (localRequestDrain) {\n      drain();\n    }\n else {\nsynchronized (mSync) {\n        try {\n          mSync.wait();\n        }\n catch (        final InterruptedException e) {\n          break;\n        }\n      }\n    }\n  }\n  if (DEBUG)   Log.d(TAG,\"Encoder thread exiting\");\nsynchronized (mSync) {\n    mRequestStop=true;\n    mIsCapturing=false;\n  }\n}", "comment": "encoding loop on private thread", "label": "what"}
{"id": "55865", "raw_code": "public final void readFromStream(DataInputStream dis,int version) throws IOException, ChessParseError {\n  event=dis.readUTF();\n  site=dis.readUTF();\n  date=dis.readUTF();\n  round=dis.readUTF();\n  white=dis.readUTF();\n  black=dis.readUTF();\n  startPos=TextIO.readFEN(dis.readUTF());\n  currentPos=new Position(startPos);\n  timeControl=dis.readUTF();\n  if (version >= 2) {\n    whiteTimeControl=dis.readUTF();\n    blackTimeControl=dis.readUTF();\n  }\n else {\n    whiteTimeControl=\"?\";\n    blackTimeControl=\"?\";\n  }\n  int nTags=dis.readInt();\n  tagPairs.clear();\n  for (int i=0; i < nTags; i++) {\n    TagPair tp=new TagPair();\n    tp.tagName=dis.readUTF();\n    tp.tagValue=dis.readUTF();\n    tagPairs.add(tp);\n  }\n  rootNode=new Node();\n  Node.readFromStream(dis,rootNode);\n  currentNode=rootNode;\n  int pathLen=dis.readInt();\n  for (int i=0; i < pathLen; i++)   goForward(dis.readInt());\n  updateListener();\n}", "comment": "de - serialize from input stream .", "label": "what"}
{"id": "9716", "raw_code": "public DNetscapeCaPolicyUrl(JDialog parent){\n  super(parent);\n  setTitle(res.getString(\"DNetscapeCaPolicyUrl.Title\"));\n  initComponents();\n}", "comment": "creates a new dnetscapecapolicyurl dialog .", "label": "what"}
{"id": "35409", "raw_code": "public static Path createDirectory(final Path parent,final String folderName){\n  final File file=new File(parent.toFile(),folderName);\n  if (!file.exists()) {\n    if (!file.mkdir()) {\n      throw new RuntimeException(\"Error while trying to create folder at \" + parent + \" with \"+ folderName+ \".\");\n    }\n  }\n  file.deleteOnExit();\n  return file.toPath();\n}", "comment": "creates a new directory with the given parent folder and folder name .", "label": "what"}
{"id": "34472", "raw_code": "protected Set<FunctionInterface> findUnusedFunctions(Set<UnitInterface> units){\n  Set<FunctionInterface> allFunctions=new HashSet<FunctionInterface>();\n  Set<FunctionInterface> usedFunctions=new HashSet<FunctionInterface>();\n  for (  UnitInterface unit : units) {\n    List<FunctionInterface> unitFunctions=getUnitFunctions(unit);\n    allFunctions.addAll(unitFunctions);\n    for (    FunctionInterface unitFunction : unitFunctions) {\n      for (      FunctionInterface usedFunction : unitFunction.getCalledFunctions()) {\n        usedFunctions.add(usedFunction);\n      }\n    }\n  }\n  allFunctions.removeAll(usedFunctions);\n  return allFunctions;\n}", "comment": "find unused functions in a unit", "label": "what"}
{"id": "42857", "raw_code": "public static synchronized List<Proxy> noProxyList(){\n  if (noProxyList == null) {\n    ArrayList<Proxy> list=new ArrayList<Proxy>(1);\n    list.add(Proxy.NO_PROXY);\n    noProxyList=Collections.unmodifiableList(list);\n  }\n  return noProxyList;\n}", "comment": "gets an unmodifiable proxy list that will have as it ' s only entry an direct proxy .", "label": "what"}
{"id": "26691", "raw_code": "protected void add(double value,int group){\n  if ((group < 0) || (group >= numberOfGroups)) {\n    throw new IllegalArgumentException();\n  }\n  data.add(new RankedObservation(value,group));\n}", "comment": "adds a new observation with the specified value and group .", "label": "what"}
{"id": "41935", "raw_code": "public int read(byte[] b,int off,int len) throws IOException {\n  if (closed) {\n    throw new IOException(\"Attempted read from closed stream.\");\n  }\n  if (eof) {\n    return -1;\n  }\n  if (pos >= chunkSize) {\n    nextChunk();\n    if (eof) {\n      return -1;\n    }\n  }\n  len=Math.min(len,chunkSize - pos);\n  int count=in.read(b,off,len);\n  pos+=count;\n  return count;\n}", "comment": "read some bytes from the stream .", "label": "what"}
{"id": "71923", "raw_code": "public LDIFEntryReader(final String... ldifLines){\n  super(Arrays.asList(ldifLines));\n}", "comment": "creates a new ldif entry reader which will read lines of ldif from the provided array of ldif lines .", "label": "what"}
{"id": "83238", "raw_code": "public void updatePresonInfo(){\n  this.leftPerson=person2LeavingPersonInfo.get(this.personId);\n  this.enteredPerson=person2EnteringPersonInfo.get(this.personId);\n}", "comment": "a person may re - appear on the same link .", "label": "what"}
{"id": "3106", "raw_code": "public MyMap remove(int position){\n  MyMap mm=null;\n  if (position >= 0 && position < getItemCount()) {\n    mm=myMaps.remove(position);\n    notifyItemRemoved(position);\n  }\n  return mm;\n}", "comment": "remove item at the given position", "label": "what"}
{"id": "5745", "raw_code": "public static GeoTimeSerie detect(GeoTimeSerie gts,int alphabetSize,int wordLen,int windowLen,Collection<String> patterns,boolean standardizePAA) throws WarpScriptException {\n  GeoTimeSerie gtsPatterns=GTSHelper.bSAX(gts,alphabetSize,wordLen,windowLen,standardizePAA);\n  GTSHelper.sort(gtsPatterns);\n  GeoTimeSerie detected=new GeoTimeSerie(gts.lastbucket,gts.bucketcount,gts.bucketspan,16);\n  detected.setMetadata(gts.getMetadata());\n  int lastidx=-1;\n  for (int i=0; i < gtsPatterns.values; i++) {\n    if (!patterns.contains(gtsPatterns.stringValues[i])) {\n      continue;\n    }\n    for (int j=0; j < windowLen; j++) {\n      if (i + j > lastidx) {\n        lastidx=i + j;\n        GTSHelper.setValue(detected,GTSHelper.tickAtIndex(gts,lastidx),GTSHelper.locationAtIndex(gts,lastidx),GTSHelper.elevationAtIndex(gts,lastidx),GTSHelper.valueAtIndex(gts,lastidx),false);\n      }\n    }\n  }\n  return detected;\n}", "comment": "detect patterns in a geo time serie instance .", "label": "what"}
{"id": "52801", "raw_code": "private StringBuilder debugDumpCandidates(StringBuilder msg,List<? extends Itemset> candidates,VectorFieldTypeInformation<BitVector> meta){\n  msg.append(':');\n  for (  Itemset itemset : candidates) {\n    msg.append(\" [\");\n    itemset.appendTo(msg,meta);\n    msg.append(']');\n  }\n  return msg;\n}", "comment": "debug method : output all itemsets .", "label": "what"}
{"id": "73618", "raw_code": "public static final void writeBooleanArrayXml(boolean[] val,String name,XmlSerializer out) throws XmlPullParserException, java.io.IOException {\n  if (val == null) {\n    out.startTag(null,\"null\");\n    out.endTag(null,\"null\");\n    return;\n  }\n  out.startTag(null,\"boolean-array\");\n  if (name != null) {\n    out.attribute(null,\"name\",name);\n  }\n  final int N=val.length;\n  out.attribute(null,\"num\",Integer.toString(N));\n  for (int i=0; i < N; i++) {\n    out.startTag(null,\"item\");\n    out.attribute(null,\"value\",Boolean.toString(val[i]));\n    out.endTag(null,\"item\");\n  }\n  out.endTag(null,\"boolean-array\");\n}", "comment": "flatten a boolean [ ] into an xmlserializer .", "label": "what"}
{"id": "42092", "raw_code": "public void addOutboundRule(final OutboundRule outboundRule){\n  outboundRule.setId(outboundRuleIdCounter++);\n  outboundRules.add(outboundRule);\n}", "comment": "will add the rule to the rules list .", "label": "what"}
{"id": "63970", "raw_code": "public Skype(String username,String password){\n  this.username=username;\n  this.password=password;\n}", "comment": "builds a new skype connection without connecting to anything .", "label": "what"}
{"id": "49083", "raw_code": "private void addFlags(int newflags){\n  flags=getLayoutFlags() | newflags;\n}", "comment": "or newflags with existing flags .", "label": "what"}
{"id": "9615", "raw_code": "public static String matchCertificate(KeyStore keyStore,X509Certificate cert) throws CryptoException {\n  try {\n    for (Enumeration aliases=keyStore.aliases(); aliases.hasMoreElements(); ) {\n      String alias=(String)aliases.nextElement();\n      if (keyStore.isCertificateEntry(alias)) {\n        X509Certificate compCert=X509CertUtil.convertCertificate(keyStore.getCertificate(alias));\n        if (cert.equals(compCert)) {\n          return alias;\n        }\n      }\n    }\n    return null;\n  }\n catch (  KeyStoreException ex) {\n    throw new CryptoException(res.getString(\"NoMatchCertificate.exception.message\"),ex);\n  }\n}", "comment": "check whether or not a trusted certificate in the supplied keystore matches the supplied x . 509 certificate .", "label": "what"}
{"id": "78110", "raw_code": "void purgeLastArticles(int amountToPurge){\n  if (!isDBAvailable())   return;\n  long time=System.currentTimeMillis();\n  String query=\"_id IN ( SELECT _id FROM \" + TABLE_ARTICLES + \" WHERE isPublished=0 AND isStarred=0 ORDER BY updateDate DESC LIMIT -1 OFFSET \"+ (Utils.ARTICLE_LIMIT - amountToPurge + \")\");\n  safelyDeleteArticles(query,null);\n  Log.d(TAG,\"purgeLastArticles took \" + (System.currentTimeMillis() - time) + \"ms\");\n}", "comment": "delete given amount of last updated articles from db .", "label": "what"}
{"id": "71796", "raw_code": "public void paint(Graphics g){\n  g.translate(0,translateY);\n  super.paint(g);\n}", "comment": "displays our component in the location ( 0 , translatey ) .", "label": "what"}
{"id": "57350", "raw_code": "private void beforeKey() throws JSONException {\n  Scope context=peek();\n  if (context == Scope.NONEMPTY_OBJECT) {\n    out.append(',');\n  }\n else   if (context != Scope.EMPTY_OBJECT) {\n    throw new JSONException(\"Nesting problem\");\n  }\n  newline();\n  replaceTop(Scope.DANGLING_KEY);\n}", "comment": "inserts any necessary separators and whitespace before a name .", "label": "what"}
{"id": "85097", "raw_code": "private void serializeCompactRDFGeneralQualifier(int indent,XMPNode node) throws IOException, XMPException {\n  write(\" rdf:parseType=\\\"Resource\\\">\");\n  writeNewline();\n  serializeCanonicalRDFProperty(node,false,true,indent + 1);\n  for (Iterator iq=node.iterateQualifier(); iq.hasNext(); ) {\n    XMPNode qualifier=(XMPNode)iq.next();\n    serializeCanonicalRDFProperty(qualifier,false,false,indent + 1);\n  }\n}", "comment": "serializes the general qualifier .", "label": "what"}
{"id": "68817", "raw_code": "public void push(){\n  state.cliprgn=g.getClipBounds();\n  stack.push(state);\n  state=(GraphicsState)state.clone();\n}", "comment": "push the current graphics state onto the stack .", "label": "what"}
{"id": "82307", "raw_code": "public E peek(){\n  if (isEmpty()) {\n    return null;\n  }\n  return elements[0];\n}", "comment": "gets but does not remove the head of the queue .", "label": "what"}
{"id": "66298", "raw_code": "private String convertLessThanOneThousand(int number){\n  String soFar;\n  if (number % 100 < 20) {\n    soFar=numNames[number % 100];\n    number/=100;\n  }\n else {\n    soFar=numNames[number % 10];\n    number/=10;\n    String s=Integer.toString(number);\n    if (s.endsWith(\"2\") && !soFar.equals(\"\"))     soFar=\" VINT-I-\" + soFar.trim();\n else     if (soFar.equals(\"\"))     soFar=tensNames[number % 10] + soFar;\n else     soFar=tensNames[number % 10] + \"-\" + soFar;\n    number/=10;\n  }\n  if (number == 0)   return tensNames[number % 10] + soFar;\n  if (number > 1)   soFar=\"S\" + soFar;\n  if (number == 1 && !soFar.equals(\"\"))   number=0;\n  return numNames[number] + \" CENT\" + soFar;\n}", "comment": "convert less than one thousand", "label": "what"}
{"id": "68399", "raw_code": "public static boolean isEmbeddedBase64Image(String uri){\n  return (uri != null && uri.startsWith(\"data:image/\"));\n}", "comment": "detect if an uri represents an embedded base 64 image .", "label": "what"}
{"id": "50322", "raw_code": "private static void insertCommentsInNode(Node node,List<Comment> commentsToAttribute){\n  if (commentsToAttribute.size() == 0)   return;\n  List<Node> children=node.getChildrenNodes();\n  PositionUtils.sortByBeginPosition(children);\n  for (  Node child : children) {\n    List<Comment> commentsInsideChild=new LinkedList<Comment>();\n    for (    Comment c : commentsToAttribute) {\n      if (PositionUtils.nodeContains(child,c,_doNotConsiderAnnotationsAsNodeStartForCodeAttribution)) {\n        commentsInsideChild.add(c);\n      }\n    }\n    commentsToAttribute.removeAll(commentsInsideChild);\n    insertCommentsInNode(child,commentsInsideChild);\n  }\n  List<Comment> attributedComments=new LinkedList<Comment>();\n  for (  Comment comment : commentsToAttribute) {\n    if (comment.isLineComment()) {\n      for (      Node child : children) {\n        if (child.getEndLine() == comment.getBeginLine()) {\n          if (attributeLineCommentToNodeOrChild(child,comment.asLineComment())) {\n            attributedComments.add(comment);\n          }\n        }\n      }\n    }\n  }\n  Comment previousComment=null;\n  attributedComments=new LinkedList<Comment>();\n  List<Node> childrenAndComments=new LinkedList<Node>();\n  childrenAndComments.addAll(children);\n  childrenAndComments.addAll(commentsToAttribute);\n  PositionUtils.sortByBeginPosition(childrenAndComments,_doNotConsiderAnnotationsAsNodeStartForCodeAttribution);\n  for (  Node thing : childrenAndComments) {\n    if (thing instanceof Comment) {\n      previousComment=(Comment)thing;\n      if (!previousComment.isOrphan()) {\n        previousComment=null;\n      }\n    }\n else {\n      if (previousComment != null && !thing.hasComment()) {\n        if (!_doNotAssignCommentsPreceedingEmptyLines || !thereAreLinesBetween(previousComment,thing)) {\n          thing.setComment(previousComment);\n          attributedComments.add(previousComment);\n          previousComment=null;\n        }\n      }\n    }\n  }\n  commentsToAttribute.removeAll(attributedComments);\n  for (  Comment c : commentsToAttribute) {\n    if (c.isOrphan()) {\n      node.addOrphanComment(c);\n    }\n  }\n}", "comment": "this method try to attributes the nodes received to child of the node .", "label": "what"}
{"id": "41810", "raw_code": "public static String readFileAsString(File file) throws FileNotFoundException {\n  return readFileAsString(file.getAbsolutePath());\n}", "comment": "devuelve el contenido de un file como string", "label": "what"}
{"id": "3261", "raw_code": "public synchronized void checkAccess(LicenseCheckerCallback callback){\n  if (mPolicy.allowAccess()) {\n    Log.i(TAG,\"Using cached license response\");\n    callback.allow(Policy.LICENSED);\n  }\n else {\n    LicenseValidator validator=new LicenseValidator(mPolicy,new NullDeviceLimiter(),callback,generateNonce(),mPackageName,mVersionCode);\n    if (mService == null) {\n      Log.i(TAG,\"Binding to licensing service.\");\n      try {\n        boolean bindResult=mContext.bindService(new Intent(new String(Base64.decode(\"Y29tLmFuZHJvaWQudmVuZGluZy5saWNlbnNpbmcuSUxpY2Vuc2luZ1NlcnZpY2U=\"))),this,Context.BIND_AUTO_CREATE);\n        if (bindResult) {\n          mPendingChecks.offer(validator);\n        }\n else {\n          Log.e(TAG,\"Could not bind to service.\");\n          handleServiceConnectionError(validator);\n        }\n      }\n catch (      SecurityException e) {\n        callback.applicationError(LicenseCheckerCallback.ERROR_MISSING_PERMISSION);\n      }\ncatch (      Base64DecoderException e) {\n        e.printStackTrace();\n      }\n    }\n else {\n      mPendingChecks.offer(validator);\n      runChecks();\n    }\n  }\n}", "comment": "checks if the user should have access to the app .", "label": "what"}
{"id": "22900", "raw_code": "public void close(){\n  if (!isOpen)   return;\n  Log.d(TAG,\"Trying to close track\");\n  loadingLock.lock();\n  try {\n    save();\n    if (saveFileStream != null) {\n      SavingHelper.close(saveFileStream);\n      saveFileStream=null;\n    }\n    savingDisabled=true;\n    isOpen=false;\n    Log.i(TAG,\"Track closed\");\n  }\n  finally {\n    loadingLock.unlock();\n  }\n}", "comment": "saves and closes the track .", "label": "what"}
{"id": "25782", "raw_code": "public static String convertBooleanArrToString(Boolean[] noDictionaryDimsMapping){\n  StringBuilder builder=new StringBuilder();\n  int index=0;\n  for (; index < noDictionaryDimsMapping.length; index++) {\n    builder.append(noDictionaryDimsMapping[index]);\n    builder.append(CarbonCommonConstants.COMA_SPC_CHARACTER);\n  }\n  int lastIndex=builder.lastIndexOf(CarbonCommonConstants.COMA_SPC_CHARACTER);\n  String str=-1 != lastIndex ? builder.substring(0,lastIndex) : builder.toString();\n  return str;\n}", "comment": "this method will convert boolean [ ] to string with comma separated .", "label": "what"}
{"id": "48589", "raw_code": "public ByteBuffer decodeBufferToByteBuffer(String inputString) throws IOException {\n  return ByteBuffer.wrap(decodeBuffer(inputString));\n}", "comment": "decode the contents of the string into a bytebuffer .", "label": "what"}
{"id": "38329", "raw_code": "public void clear(){\n  m_Model.clear();\n  setButtons(null);\n}", "comment": "clears the content of the panel", "label": "what"}
{"id": "680", "raw_code": "public static int brighter(int c){\n  int r=red(c), g=green(c), b=blue(c);\n  int i=(int)(1.0 / (1.0 - scale));\n  if (r == 0 && g == 0 && b == 0) {\n    return rgba(i,i,i,alpha(c));\n  }\n  if (r > 0 && r < i)   r=i;\n  if (g > 0 && g < i)   g=i;\n  if (b > 0 && b < i)   b=i;\n  return rgba(Math.min(255,(int)(r / scale)),Math.min(255,(int)(g / scale)),Math.min(255,(int)(b / scale)),alpha(c));\n}", "comment": "get a brighter shade of an input color .", "label": "what"}
{"id": "81990", "raw_code": "public void shutdown(){\n  running=false;\n  if (networkThreads != null) {\n    for (    NetworkThread n : networkThreads) {\n      n.stopped=true;\n    }\n  }\n  networkThreads=null;\nsynchronized (LOCK) {\n    LOCK.notifyAll();\n  }\n}", "comment": "shuts down the network thread , this will trigger failures if you have network requests", "label": "what"}
{"id": "73911", "raw_code": "public SerialMessage(byte[] a){\n  super(String.valueOf(a));\n  setBinary(true);\n}", "comment": "this ctor interprets the byte array as a sequence of characters to send .", "label": "what"}
{"id": "63054", "raw_code": "public void writeGolomb(int divisor,int value){\n  int q=value / divisor;\n  for (int i=0; i < q; i++) {\n    writeBit(1);\n  }\n  writeBit(0);\n  int r=value - q * divisor;\n  int bit=31 - Integer.numberOfLeadingZeros(divisor - 1);\n  if (r < ((2 << bit) - divisor)) {\n    bit--;\n  }\n else {\n    r+=(2 << bit) - divisor;\n  }\n  for (; bit >= 0; bit--) {\n    writeBit((r >>> bit) & 1);\n  }\n}", "comment": "write the golomb code of a value .", "label": "what"}
{"id": "86648", "raw_code": "public boolean overlaps(String sequence,int start,int end){\n  if (start == MISSING || end == MISSING || end < start) {\n    throw new IllegalArgumentException();\n  }\n  if (!mSequence.equals(sequence)) {\n    return false;\n  }\n  if ((mEnd != MISSING && start >= mEnd) || (end <= mStart)) {\n    return false;\n  }\n  return true;\n}", "comment": "test whether the specified range overlaps the current region", "label": "what"}
{"id": "9363", "raw_code": "public OkapiBM25(double k1,double b){\n  if (Double.isNaN(k1) || Double.isInfinite(k1) || k1 < 0)   throw new IllegalArgumentException(\"coefficient k1 must be a non negative constant, not \" + k1);\n  this.k1=k1;\n  if (Double.isNaN(b) || b < 0 || b > 1)   throw new IllegalArgumentException(\"coefficient b must be in the range [0,1], not \" + b);\n  this.b=b;\n}", "comment": "creates a new okapi object", "label": "what"}
{"id": "66371", "raw_code": "protected void prepare(){\n  for (  ProcessInfoParameter para : getParameter()) {\n    String name=para.getParameterName();\n    if (para.getParameter() == null)     ;\n else     if (name.equals(PARAM_M_Warehouse_ID))     p_M_Warehouse_ID=para.getParameterAsInt();\n else     log.log(Level.SEVERE,\"Unknown Parameter: \" + name);\n  }\n  p_C_Invoice_ID=getRecord_ID();\n}", "comment": "prepare - e . g . , get parameters .", "label": "what"}
{"id": "74438", "raw_code": "public boolean makeBackupFile(String directory,File file){\n  if (file == null) {\n    log.info(\"No file to backup\");\n  }\n else   if (file.canWrite()) {\n    String backupFullName=directory + File.separator + createFileNameWithDate(file.getName());\n    if (log.isDebugEnabled()) {\n      log.debug(\"new backup file: \" + backupFullName);\n    }\n    File backupFile=findFile(backupFullName);\n    if (backupFile != null) {\n      if (backupFile.delete()) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"deleted backup file \" + backupFullName);\n        }\n      }\n    }\n else {\n      backupFile=new File(backupFullName);\n    }\n    File parentDir=backupFile.getParentFile();\n    if (!parentDir.exists()) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"creating backup directory: \" + parentDir.getName());\n      }\n      if (!parentDir.mkdirs()) {\n        log.error(\"backup directory not created\");\n        return false;\n      }\n    }\n    if (file.renameTo(new File(backupFullName))) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"created new backup file \" + backupFullName);\n      }\n    }\n else {\n      if (log.isDebugEnabled()) {\n        log.debug(\"could not create backup file \" + backupFullName);\n      }\n      return false;\n    }\n  }\n  return true;\n}", "comment": "move original file to backup directory .", "label": "what"}
{"id": "18318", "raw_code": "public final void pushPair(int v1,int v2){\n  if (null == m_map) {\n    m_map=new int[m_blocksize];\n    m_mapSize=m_blocksize;\n  }\n else {\n    if ((m_firstFree + 2) >= m_mapSize) {\n      m_mapSize+=m_blocksize;\n      int newMap[]=new int[m_mapSize];\n      System.arraycopy(m_map,0,newMap,0,m_firstFree);\n      m_map=newMap;\n    }\n  }\n  m_map[m_firstFree]=v1;\n  m_map[m_firstFree + 1]=v2;\n  m_firstFree+=2;\n}", "comment": "push a pair of nodes into the stack .", "label": "what"}
{"id": "54756", "raw_code": "private void appendContainerConfig(DockerSlaveTemplate slaveTemplate,CreateContainerCmd containerConfig){\n  Map<String,String> labels=containerConfig.getLabels();\n  if (labels == null) {\n    labels=new HashMap<>();\n  }\n  labels.put(DOCKER_CLOUD_LABEL,getDisplayName());\n  labels.put(DOCKER_TEMPLATE_LABEL,slaveTemplate.getId());\n  containerConfig.withLabels(labels);\n}", "comment": "cloud specific container config options", "label": "what"}
{"id": "15002", "raw_code": "public void deleteUsers(Set users) throws AMException, SSOException {\n  Iterator iter=users.iterator();\n  while (iter.hasNext()) {\n    String userDN=(String)iter.next();\n    AMUser user=new AMUserImpl(super.token,userDN);\n    user.delete();\n  }\n}", "comment": "removes users from the organization .", "label": "what"}
{"id": "45385", "raw_code": "@Override public boolean accept(File file){\n  String name=file.getName();\n  for (  String wildcard : wildcards) {\n    if (FilenameUtils.wildcardMatch(name,wildcard,caseSensitivity)) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "checks to see if the filename matches one of the wildcards .", "label": "what"}
{"id": "73882", "raw_code": "public void removeRegion(Region r){\n  regions.remove(r);\n}", "comment": "include a region in the model", "label": "what"}
{"id": "10649", "raw_code": "@RequiresPermission(Manifest.permission.CAMERA) public CameraSource start() throws IOException {\nsynchronized (mCameraLock) {\n    if (mCamera != null) {\n      return this;\n    }\n    mCamera=createCamera();\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n      mDummySurfaceTexture=new SurfaceTexture(DUMMY_TEXTURE_NAME);\n      mCamera.setPreviewTexture(mDummySurfaceTexture);\n    }\n else {\n      mDummySurfaceView=new SurfaceView(mContext);\n      mCamera.setPreviewDisplay(mDummySurfaceView.getHolder());\n    }\n    mCamera.startPreview();\n    isSafeToTakePicture=true;\n    mProcessingThread=new Thread(mFrameProcessor);\n    mFrameProcessor.setActive(true);\n    mProcessingThread.start();\n  }\n  return this;\n}", "comment": "opens the camera and starts sending preview frames to the underlying detector .", "label": "what"}
{"id": "36207", "raw_code": "public void addBreakpointListener(final BreakpointListener listener){\n  breakpointListeners.add(listener);\n}", "comment": "adds a breakpoint listener .", "label": "what"}
{"id": "47738", "raw_code": "public void update(Graphics g){\n  if (isShowing()) {\n    if (!(peer instanceof LightweightPeer)) {\n      g.clearRect(0,0,width,height);\n    }\n    paint(g);\n  }\n}", "comment": "updates the container .", "label": "what"}
{"id": "85466", "raw_code": "@Override public Void visitType(TypeElement e,Void p){\n  scan(e.getTypeParameters(),p);\n  checkCamelCase(e,true);\n  super.visitType(e,p);\n  return null;\n}", "comment": "check the name of a type and its enclosed elements and type parameters .", "label": "what"}
{"id": "80407", "raw_code": "public Block(boolean multiPush){\n  this(multiPush,\"block\",null,Arrays.asList(\"scrape-1\",\"scrape-2\"));\n}", "comment": "create a new block with default style at ( startx , starty )", "label": "what"}
{"id": "11778", "raw_code": "protected Expression findExpression(String source){\n  if (source != null && source.length() > 0) {\n    source=source.trim();\n    if (source.length() == 0) {\n      return null;\n    }\n    String leftSide=source;\n    String rightSide=null;\n    Connector op=findOp(leftSide);\n    if (op != null) {\n      rightSide=op.getRightSide(leftSide);\n      leftSide=leftSide.substring(0,op.sourceLoc);\n      Expression leftExpression=findExpression(leftSide);\n      Expression rightExpression=findExpression(rightSide);\n      if (leftExpression != null) {\n        op.addExpr(leftExpression);\n      }\n      if (rightExpression != null) {\n        op.addExpr(rightExpression);\n      }\n      return op;\n    }\n    op=findMiniOp(leftSide);\n    if (op != null) {\n      rightSide=op.getRightSide(leftSide);\n      leftSide=leftSide.substring(0,op.sourceLoc);\n      Expression leftExpression=findExpression(leftSide);\n      Expression rightExpression=findExpression(rightSide);\n      if (leftExpression != null) {\n        op.addExpr(leftExpression);\n      }\n      if (rightExpression != null) {\n        op.addExpr(rightExpression);\n      }\n      return op;\n    }\n    if (logger.isLoggable(Level.FINER)) {\n      logger.finer(\"need to break up: \" + source);\n    }\n    return findMathOp(source);\n  }\n  return null;\n}", "comment": "recursive parsing statement .", "label": "what"}
{"id": "39883", "raw_code": "private void deleteFilesInDir(File dir){\n  for (  File child : dir.listFiles()) {\n    child.delete();\n  }\n}", "comment": "deletes all files in a folder", "label": "what"}
{"id": "71506", "raw_code": "@SuppressLint(\"Assert\") void release(){\n  assert (mProcessingThread.getState() == State.TERMINATED);\n  mDetector.release();\n  mDetector=null;\n}", "comment": "releases the underlying receiver .", "label": "what"}
{"id": "56250", "raw_code": "public static String trimLeadingCharacter(String str,char leadingCharacter){\n  if (!hasLength(str)) {\n    return str;\n  }\n  StringBuilder sb=new StringBuilder(str);\n  while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\n    sb.deleteCharAt(0);\n  }\n  return sb.toString();\n}", "comment": "trim all occurrences of the supplied leading character from the given string .", "label": "what"}
{"id": "70955", "raw_code": "public boolean threadSafeTimeout(long delayTime,TimeUnit unit,Action0 action){\n  boolean scheduled=true;\n  Thread currentThread=Thread.currentThread();\n  if (currentThread.equals(dutyThread)) {\n    timerWheel.newTimeout(delayTime,unit,null);\n  }\n else {\n    scheduled=actions.offer(null);\n  }\n  return scheduled;\n}", "comment": "schedules timeout on the timerwheel in a thread - safe manner", "label": "what"}
{"id": "3318", "raw_code": "void submit(ProcessAndDisplayImageTask task){\n  initExecutorsIfNeed();\n  taskExecutorForCachedImages.execute(task);\n}", "comment": "submits task to execution pool", "label": "what"}
{"id": "82169", "raw_code": "void addAttributeSelection(String exp){\n  int index=exp.indexOf('=');\n  String value=null;\n  int constraint=AttString.EQUALS;\n  if (index != -1) {\n    if (index == 0) {\n      setTagId(TAG_CSS_ILLEGAL_SELECTOR);\n      return;\n    }\n    int opIndex=index;\n    char c=exp.charAt(index - 1);\n    if (c == '~') {\n      constraint=AttString.CONTAINS_WORD;\n      opIndex--;\n    }\n else     if (c == '|') {\n      constraint=AttString.BEGINS_WITH;\n      opIndex--;\n    }\n    value=exp.substring(index + 1);\n    if (((value.startsWith(\"\\\"\")) && (value.endsWith(\"\\\"\"))) || ((value.startsWith(\"'\")) && (value.endsWith(\"'\")))) {\n      value=value.substring(1,value.length() - 1);\n    }\n    exp=exp.substring(0,opIndex);\n  }\n  if (attributeSelections == null) {\n    attributeSelections=new Vector();\n  }\n  attributeSelections.addElement(new AttString(exp,constraint,value));\n}", "comment": "adds the given attribute selection", "label": "what"}
{"id": "45459", "raw_code": "private void createLeftOver(){\n  int lineLengthBytes=currentLastBytePos + 1;\n  if (lineLengthBytes > 0) {\n    leftOver=new byte[lineLengthBytes];\n    System.arraycopy(data,0,leftOver,0,lineLengthBytes);\n  }\n else {\n    leftOver=null;\n  }\n  currentLastBytePos=-1;\n}", "comment": "creates the buffer containing any left over bytes .", "label": "what"}
{"id": "22190", "raw_code": "public static boolean isNextWindow(URI id){\n  return id == null || NEXT.equals(id);\n}", "comment": "determines if this id corresponds to the ' next ' execution window .", "label": "what"}
{"id": "50403", "raw_code": "public static boolean isVisible(Class<?> clazz,ClassLoader classLoader){\n  if (classLoader == null) {\n    return true;\n  }\n  try {\n    Class<?> actualClass=classLoader.loadClass(clazz.getName());\n    return (clazz == actualClass);\n  }\n catch (  ClassNotFoundException ex) {\n    return false;\n  }\n}", "comment": "check whether the given class is visible in the given classloader .", "label": "what"}
{"id": "23480", "raw_code": "void remove(SuperCardToast superCardToast){\n  mList.remove(superCardToast);\n}", "comment": "removes a supercardtoast from the list .", "label": "what"}
{"id": "35115", "raw_code": "public static SecretKeys generateKeyFromPassword(String password,String salt) throws GeneralSecurityException {\n  return generateKeyFromPassword(password,Base64.decode(salt,BASE64_FLAGS));\n}", "comment": "a function that generates password - based aes & hmac keys .", "label": "what"}
{"id": "53644", "raw_code": "@Override public void step(MessageLogger logger){\n  try {\n    addAgent();\n    env.step();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}", "comment": "executes one simulation step .", "label": "what"}
{"id": "64279", "raw_code": "public static AttackStatus calculatePhysicalStatus(Creature attacker,Creature attacked,boolean isMainHand){\n  return calculatePhysicalStatus(attacker,attacked,isMainHand,0,100,false,false);\n}", "comment": "manage attack status rate", "label": "what"}
{"id": "77467", "raw_code": "private void validateReplicaAvailability(Slice slice,String shard,String collectionName,int count){\n  if (slice != null) {\n    Collection<Replica> allReplicasForShard=slice.getReplicas();\n    if (allReplicasForShard == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"No replicas found  in shard/collection: \" + shard + \"/\"+ collectionName);\n    }\n    if (allReplicasForShard.size() == 1) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"There is only one replica available in shard/collection: \" + shard + \"/\"+ collectionName+ \". Cannot delete that.\");\n    }\n    if (allReplicasForShard.size() <= count) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"There are lesser num replicas requested to be deleted than are available in shard/collection : \" + shard + \"/\"+ collectionName+ \" Requested: \"+ count+ \" Available: \"+ allReplicasForShard.size()+ \".\");\n    }\n  }\n}", "comment": "validate if there is less replicas than requested to remove .", "label": "what"}
{"id": "32180", "raw_code": "public void addPutAndGetTimeNanos(long duration){\n  putTimeNanos.addAndGet(duration);\n  getTimeNanos.addAndGet(duration);\n  if (delegate != null)   delegate.addPutAndGetTimeNanos(duration);\n}", "comment": "increments put and get time accumulators .", "label": "what"}
{"id": "73328", "raw_code": "private float checkSaturationValid(final float val){\n  float tempval=val;\n  if (val > 1) {\n    tempval=1;\n  }\n  if (val < 0) {\n    tempval=0;\n  }\n  return tempval;\n}", "comment": "check whether the specified saturation is valid or not .", "label": "what"}
{"id": "70681", "raw_code": "public static String runCmd(File directory,List<String> cmd,String errorMessage) throws Exception {\n  ProcessBuilder pb=new ProcessBuilder(cmd);\n  pb.directory(directory);\n  pb.redirectErrorStream(true);\n  Process p=pb.start();\n  String s;\n  StringBuilder sb=new StringBuilder();\n  BufferedReader stdout=new BufferedReader(new InputStreamReader(p.getInputStream()));\n  while ((s=stdout.readLine()) != null) {\n    logger.info(s);\n    sb.append(s);\n    sb.append('\\n');\n  }\n  String sbs=sb.toString();\n  int exitValue=p.waitFor();\n  if (exitValue != 0)   throw new Exception(errorMessage + \" exit value \" + exitValue+ \"  \"+ sbs);\n  return sbs;\n}", "comment": "run command cmd in separate process in directory", "label": "what"}
{"id": "79176", "raw_code": "public static String fromTag(ByteArrayTag tag){\n  StringBuilder builder=new StringBuilder();\n  builder.append(ARRAY_START);\n  boolean start=true;\n  for (  byte value : tag.getValue()) {\n    ByteTag b=new ByteTag(value);\n    if (start) {\n      start=false;\n    }\n else {\n      builder.append(ELEMENT_SEPERATOR);\n    }\n    builder.append(fromTag(b));\n  }\n  builder.append(ARRAY_END);\n  return builder.toString();\n}", "comment": "creates a mojangson string from the given bytearray tag .", "label": "what"}
{"id": "67649", "raw_code": "public static DateTime parseRfc822(String str) throws ParseException {\n  Date date;\nsynchronized (dateTimeFormat822) {\n    try {\n      date=dateTimeFormat822.parse(str);\n    }\n catch (    java.text.ParseException e) {\n      throw new ParseException(e);\n    }\n  }\n  return new DateTime(date);\n}", "comment": "parses the value as an rfc 822 date / time .", "label": "what"}
{"id": "44561", "raw_code": "public Model validateModel(Dataset dataset,URI shapesGraphURI,Resource minSeverity,boolean validateShapes,Function<RDFNode,String> labelFunction,ProgressMonitor monitor) throws InterruptedException {\n  if (dataset.getDefaultModel() == null) {\n    throw new IllegalArgumentException(\"Dataset requires a default model\");\n  }\n  Model shapesModel=dataset.getNamedModel(shapesGraphURI.toString());\n  if (monitor != null) {\n    monitor.subTask(\"Preparing execution plan\");\n  }\n  List<Property> constraintProperties=SHACLUtil.getAllConstraintProperties(validateShapes);\n  Map<Resource,List<SHConstraint>> map=buildShape2ConstraintsMap(shapesModel,dataset.getDefaultModel(),constraintProperties,validateShapes);\n  if (monitor != null) {\n    monitor.subTask(\"\");\n  }\n  if (monitor != null) {\n    monitor.beginTask(\"Validating constraints for \" + map.size() + \" shapes...\",map.size());\n  }\n  Model results=JenaUtil.createMemoryModel();\n  results.setNsPrefixes(dataset.getDefaultModel());\n  for (  Resource shape : map.keySet()) {\n    for (    SHConstraint constraint : map.get(shape)) {\n      validateConstraintForShape(dataset,shapesGraphURI,minSeverity,constraint,shape,results,labelFunction,monitor);\n      if (monitor != null) {\n        monitor.worked(1);\n        if (monitor.isCanceled()) {\n          throw new InterruptedException();\n        }\n      }\n    }\n  }\n  return results;\n}", "comment": "validates all resources in a given model , which is expected to be the default graph of a given dataset .", "label": "what"}
{"id": "14039", "raw_code": "public static String findPreferredIDP(String realm,HttpServletRequest request){\n  if (request == null) {\n    return null;\n  }\n  String succinctID=request.getParameter(IFSConstants.PROVIDER_ID_KEY);\n  if ((succinctID == null) || succinctID.length() == 0) {\n    debug.message(\"FSUtils.findPreferredIDP::Pref IDP not found.\");\n    return null;\n  }\n  succinctID=succinctID.trim();\n  String preferredSuccinctId=null;\n  StringTokenizer st=new StringTokenizer(succinctID,\" \");\n  while (st.hasMoreTokens()) {\n    preferredSuccinctId=st.nextToken();\n    if ((preferredSuccinctId.length() < 28) && st.hasMoreTokens()) {\n      preferredSuccinctId=preferredSuccinctId + \"+\" + st.nextToken();\n    }\n  }\n  preferredSuccinctId=SAMLUtils.byteArrayToString(Base64.decode(preferredSuccinctId));\n  return getProviderIDFromSuccinctID(realm,preferredSuccinctId);\n}", "comment": "finds the preferred idp from the httpservletrequest .", "label": "what"}
{"id": "21548", "raw_code": "private void checkAndCreateDirectory(final String directoryName){\n  try {\n    final File dir=new File(directoryName);\n    if (!dir.exists() && dir.mkdirs()) {\n      _logger.debug(\"Debug dump directory created successfully.\");\n    }\n  }\n catch (  Exception ex) {\n    _logger.error(\"Debug dump directory creation failed due to {}\",ex.getMessage());\n  }\n}", "comment": "verify whether directory already exists or not .", "label": "what"}
{"id": "86586", "raw_code": "@SafeVarargs public final AssertSubscriber<T> assertValuesWith(Consumer<T>... expectations){\n  if (!valuesStorage) {\n    throw new IllegalStateException(\"Using assertNoValues() requires enabling values storage\");\n  }\n  final int expectedValueCount=expectations.length;\n  if (expectedValueCount != values.size()) {\n    throw new AssertionError(\"Different value count: expected = \" + expectedValueCount + \", actual = \"+ valueCount,null);\n  }\n  for (int i=0; i < expectedValueCount; i++) {\n    Consumer<T> consumer=expectations[i];\n    T actualValue=values.get(i);\n    consumer.accept(actualValue);\n  }\n  return this;\n}", "comment": "assert the specified values have been received in the declared order .", "label": "what"}
{"id": "40727", "raw_code": "public int findEventPositionNearestTime(Time time,long id){\n  if (mRowInfo == null) {\n    return 0;\n  }\n  long millis=time.toMillis(false);\n  long minDistance=Integer.MAX_VALUE;\n  long idFoundMinDistance=Integer.MAX_VALUE;\n  int minIndex=0;\n  int idFoundMinIndex=0;\n  int eventInTimeIndex=-1;\n  int allDayEventInTimeIndex=-1;\n  int allDayEventDay=0;\n  int minDay=0;\n  boolean idFound=false;\n  int len=mRowInfo.size();\n  for (int index=0; index < len; index++) {\n    RowInfo row=mRowInfo.get(index);\n    if (row.mType == TYPE_DAY) {\n      continue;\n    }\n    if (row.mEventId == id) {\n      if (row.mEventStartTimeMilli == millis) {\n        return index;\n      }\n      long distance=Math.abs(millis - row.mEventStartTimeMilli);\n      if (distance < idFoundMinDistance) {\n        idFoundMinDistance=distance;\n        idFoundMinIndex=index;\n      }\n      idFound=true;\n    }\n    if (!idFound) {\n      if (millis >= row.mEventStartTimeMilli && millis <= row.mEventEndTimeMilli) {\n        if (row.mAllDay) {\n          if (allDayEventInTimeIndex == -1) {\n            allDayEventInTimeIndex=index;\n            allDayEventDay=row.mDay;\n          }\n        }\n else         if (eventInTimeIndex == -1) {\n          eventInTimeIndex=index;\n        }\n      }\n else       if (eventInTimeIndex == -1) {\n        long distance=Math.abs(millis - row.mEventStartTimeMilli);\n        if (distance < minDistance) {\n          minDistance=distance;\n          minIndex=index;\n          minDay=row.mDay;\n        }\n      }\n    }\n  }\n  if (idFound) {\n    return idFoundMinIndex;\n  }\n  if (eventInTimeIndex != -1) {\n    return eventInTimeIndex;\n  }\n else   if (allDayEventInTimeIndex != -1 && minDay != allDayEventDay) {\n    return allDayEventInTimeIndex;\n  }\n  return minIndex;\n}", "comment": "finds the position in the cursor of the event that best matches the time and id .", "label": "what"}
{"id": "3696", "raw_code": "final public void println(float v){\n  String s=String.valueOf(v);\n  write(s,0,s.length());\n  println();\n}", "comment": "prints a float followed by a newline .", "label": "what"}
{"id": "37334", "raw_code": "private static TranslationResult extractRegister(final ITranslationEnvironment environment,final long offset,final String subRegister) throws InternalTranslationException {\n  final ArrayList<ReilInstruction> instructions=new ArrayList<ReilInstruction>();\n  final String parentRegister=getParentRegister(subRegister);\n  final OperandSize archSize=environment.getArchitectureSize();\n  if (isHigher8BitRegister(subRegister)) {\n    final String maskResult=environment.getNextVariableString();\n    final String shiftResult=environment.getNextVariableString();\n    instructions.add(ReilHelpers.createAnd(offset,archSize,parentRegister,OperandSize.WORD,\"65280\",OperandSize.WORD,maskResult));\n    instructions.add(ReilHelpers.createBsh(offset + 1,OperandSize.WORD,maskResult,OperandSize.WORD,\"-8\",OperandSize.BYTE,shiftResult));\n    return new TranslationResult(shiftResult,OperandSize.BYTE,TranslationResultType.REGISTER,null,instructions,offset);\n  }\n else {\n    final OperandSize subRegisterSize=getRegisterSize(subRegister);\n    final String mask=String.valueOf(TranslationHelpers.getAllBitsMask(subRegisterSize));\n    final String result=environment.getNextVariableString();\n    instructions.add(ReilHelpers.createAnd(offset,archSize,parentRegister,subRegisterSize,mask,subRegisterSize,result));\n    return new TranslationResult(result,subRegisterSize,TranslationResultType.REGISTER,null,instructions,offset);\n  }\n}", "comment": "extracts a subregister ( like ax , al , ah ) from a parent register ( like eax )", "label": "what"}
{"id": "14544", "raw_code": "public void onLoginFailure(Map requestParamsMap,HttpServletRequest req,HttpServletResponse res) throws AuthenticationException {\n  debug.message(\"ReplayPasswd.onLoginFailure: called\");\n}", "comment": "post processing on failed authentication .", "label": "what"}
{"id": "41943", "raw_code": "public Interceptor[] buildMethodInterceptors(Method method){\n  Interceptors before=method.getAnnotation(Interceptors.class);\n  return before != null ? createInterceptors(before) : NULL_INTERCEPTOR_ARRAY;\n}", "comment": "build interceptors of method", "label": "what"}
{"id": "22007", "raw_code": "private static void lookForChanges(DataObject left,DataObject right,HashMap<String,Change> changes,Set<String> included,Set<String> excluded,Set<String> contained){\n  Class refClass=left.getClass();\n  Method[] methods=refClass.getMethods();\n  for (  Method method : methods) {\n    boolean contain=false;\n    Name nameAnn=method.getAnnotation(Name.class);\n    if (nameAnn == null) {\n      continue;\n    }\n    String key=nameAnn.value();\n    if (contained != null && contained.contains(key)) {\n      contain=true;\n    }\n else     if (included != null && !included.contains(key)) {\n      continue;\n    }\n    if (excluded.contains(key)) {\n      continue;\n    }\n    Class type=method.getReturnType();\n    try {\n      Object obja=method.invoke(left);\n      Object objb=method.invoke(right);\n      if (type == StringSet.class) {\n        if (contain) {\n          analyzeNewStringSetContainsOldStringSetValues((StringSet)obja,(StringSet)objb,key,changes);\n        }\n else {\n          analyzeStringSets((StringSet)obja,(StringSet)objb,key,changes);\n        }\n      }\n else       if (type == StringMap.class) {\n        analyzeStringMaps((StringMap)obja,(StringMap)objb,key,changes);\n      }\n else       if (type == StringSetMap.class) {\n        analyzeStringSetMaps((StringSetMap)obja,(StringSetMap)objb,key,changes);\n      }\n else {\n        if (!isEqual(obja,objb)) {\n          Change change=new Change(key,obja,objb,nameAnn.value());\n          changes.put(key,change);\n        }\n      }\n    }\n catch (    IllegalAccessException ex) {\n      throw new ServiceCodeException(ServiceCode.UNFORSEEN_ERROR,ex,ex.getMessage(),new String[]{});\n    }\ncatch (    InvocationTargetException ex) {\n      throw new ServiceCodeException(ServiceCode.UNFORSEEN_ERROR,ex,ex.getMessage(),new String[]{});\n    }\n  }\n}", "comment": "scans the methods looking for ones annotated with the name annotation .", "label": "what"}
{"id": "42349", "raw_code": "static void removeAllPhis(IR ir){\n  for (Instruction s=ir.firstInstructionInCodeOrder(), sentinel=ir.lastInstructionInCodeOrder(), nextInstr=null; s != sentinel; s=nextInstr) {\n    nextInstr=s.nextInstructionInCodeOrder();\n    if (Phi.conforms(s))     s.remove();\n  }\n}", "comment": "remove all phi instructions from the ir .", "label": "what"}
{"id": "41944", "raw_code": "public Interceptor[] buildRouteInterceptors(Interceptor[] defaultInters,Interceptor[] resourceInters,Class<? extends Resource> resourceClass,Interceptor[] methodInters,Method method){\n  List<Interceptor> allInters=new ArrayList<Interceptor>();\n  for (  Interceptor defaultInter : defaultInters) {\n    allInters.add(defaultInter);\n  }\n  for (  Interceptor resourceInter : resourceInters) {\n    allInters.add(resourceInter);\n  }\n  for (  Interceptor methodInter : methodInters) {\n    allInters.add(methodInter);\n  }\n  Class<? extends Interceptor>[] resourceClears=getResourceClears(resourceClass);\n  Class<? extends Interceptor>[] methodClears=getMethodClears(method);\n  if ((resourceClears != null && resourceClears.length > 0) || (methodClears != null && methodClears.length > 0)) {\n    for (int i=0; i < allInters.size(); i++) {\n      i=clearInterceptor(allInters,resourceClears,i);\n      i=clearInterceptor(allInters,methodClears,i);\n    }\n  }\n  return allInters.toArray(new Interceptor[allInters.size()]);\n}", "comment": "build interceptors of action", "label": "what"}
{"id": "74632", "raw_code": "public static boolean checkGMLFootprint(String footprint){\n  try {\n    Configuration configuration=new GMLConfiguration();\n    Parser parser=new Parser(configuration);\n    Geometry geom=(Geometry)parser.parse(new InputSource(new StringReader(footprint)));\n    if (!geom.isEmpty() && !geom.isValid()) {\n      logger.error(\"Wrong footprint\");\n      return false;\n    }\n  }\n catch (  Exception e) {\n    logger.error(\"Error in extracted footprint: \" + e.getMessage());\n    return false;\n  }\n  return true;\n}", "comment": "check gml footprint validity", "label": "what"}
{"id": "83184", "raw_code": "public static void main(String[] args){\n  double preBuffer=Double.parseDouble(args[4]);\n  double postBuffer=Double.parseDouble(args[5]);\n  run(args[0],args[1],args[2],args[3],preBuffer,postBuffer);\n}", "comment": "creates a timetable ( network change events file )", "label": "what"}
{"id": "32979", "raw_code": "public OrionEditorInit(final TextEditorConfiguration configuration,final CodeAssistantFactory codeAssistantFactory,final QuickAssistAssistant quickAssist,final OrionEditorPresenter textEditor){\n  this.configuration=configuration;\n  this.codeAssistantFactory=codeAssistantFactory;\n  this.quickAssist=quickAssist;\n  this.textEditor=textEditor;\n}", "comment": "the quick assist assistant .", "label": "what"}
{"id": "48719", "raw_code": "final void putByte(int offset,byte value){\n  unsafe.putByte(offset + address,value);\n}", "comment": "writes a byte at the specified offset from this native object ' s base address .", "label": "what"}
{"id": "24484", "raw_code": "public static void parseOptionSettingTo(String optionSetting,Map<String,String> dst){\n  int eqIndex=optionSetting.indexOf('=');\n  if (eqIndex == -1) {\n    throw new InternalError(\"Option setting has does not match the pattern <name>=<value>: \" + optionSetting);\n  }\n  dst.put(optionSetting.substring(0,eqIndex),optionSetting.substring(eqIndex + 1));\n}", "comment": "parses a given option setting string to a map of settings .", "label": "what"}
{"id": "16023", "raw_code": "public BigInteger generateClientCredentials(byte[] salt,byte[] identity,byte[] password){\n  this.x=SRP6Util.calculateX(digest,N,salt,identity,password);\n  this.a=selectPrivateValue();\n  this.A=g.modPow(a,N);\n  return A;\n}", "comment": "generates client ' s credentials given the client ' s salt , identity and password", "label": "what"}
{"id": "77464", "raw_code": "public void build(SolrCore core,SolrIndexSearcher searcher) throws IOException {\n  LOG.info(\"SolrSuggester.build(\" + name + \")\");\n  dictionary=dictionaryFactory.create(core,searcher);\n  lookup.build(dictionary);\n  if (storeDir != null) {\n    File target=getStoreFile();\n    if (!lookup.store(new FileOutputStream(target))) {\n      LOG.error(\"Store Lookup build failed\");\n    }\n else {\n      LOG.info(\"Stored suggest data to: \" + target.getAbsolutePath());\n    }\n  }\n}", "comment": "build the underlying lucene suggester", "label": "what"}
{"id": "56185", "raw_code": "private void connect() throws IOException {\n  JMXServiceURL jmxUrl=new JMXServiceURL(String.format(fmtUrl,host,port));\n  Map<String,Object> env=new HashMap<String,Object>();\n  if (username != null) {\n    String[] creds={username,password};\n    env.put(JMXConnector.CREDENTIALS,creds);\n  }\n  env.put(\"com.sun.jndi.rmi.factory.socket\",getRMIClientSocketFactory());\n  jmxc=JMXConnectorFactory.connect(jmxUrl,env);\n  mbeanServerConn=jmxc.getMBeanServerConnection();\n  try {\n    ObjectName name=new ObjectName(ssObjName);\n    ssProxy=JMX.newMBeanProxy(mbeanServerConn,name,StorageServiceMBean.class);\n    name=new ObjectName(MessagingService.MBEAN_NAME);\n    msProxy=JMX.newMBeanProxy(mbeanServerConn,name,MessagingServiceMBean.class);\n    name=new ObjectName(StreamManagerMBean.OBJECT_NAME);\n    streamProxy=JMX.newMBeanProxy(mbeanServerConn,name,StreamManagerMBean.class);\n    name=new ObjectName(CompactionManager.MBEAN_OBJECT_NAME);\n    compactionProxy=JMX.newMBeanProxy(mbeanServerConn,name,CompactionManagerMBean.class);\n    name=new ObjectName(FailureDetector.MBEAN_NAME);\n    fdProxy=JMX.newMBeanProxy(mbeanServerConn,name,FailureDetectorMBean.class);\n    name=new ObjectName(CacheService.MBEAN_NAME);\n    cacheService=JMX.newMBeanProxy(mbeanServerConn,name,CacheServiceMBean.class);\n    name=new ObjectName(StorageProxy.MBEAN_NAME);\n    spProxy=JMX.newMBeanProxy(mbeanServerConn,name,StorageProxyMBean.class);\n    name=new ObjectName(HintedHandOffManager.MBEAN_NAME);\n    hhProxy=JMX.newMBeanProxy(mbeanServerConn,name,HintedHandOffManagerMBean.class);\n    name=new ObjectName(GCInspector.MBEAN_NAME);\n    gcProxy=JMX.newMBeanProxy(mbeanServerConn,name,GCInspectorMXBean.class);\n    name=new ObjectName(Gossiper.MBEAN_NAME);\n    gossProxy=JMX.newMBeanProxy(mbeanServerConn,name,GossiperMBean.class);\n  }\n catch (  MalformedObjectNameException e) {\n    throw new RuntimeException(\"Invalid ObjectName? Please report this as a bug.\",e);\n  }\n  memProxy=ManagementFactory.newPlatformMXBeanProxy(mbeanServerConn,ManagementFactory.MEMORY_MXBEAN_NAME,MemoryMXBean.class);\n  runtimeProxy=ManagementFactory.newPlatformMXBeanProxy(mbeanServerConn,ManagementFactory.RUNTIME_MXBEAN_NAME,RuntimeMXBean.class);\n}", "comment": "create a connection to the jmx agent and setup the m [ x ] bean proxies .", "label": "what"}
{"id": "20381", "raw_code": "public void addListener(T listener){\n  if (listener == null) {\n    throw new NullPointerException();\n  }\n  listeners.add(listener);\n}", "comment": "registers a listener to receive events .", "label": "what"}
{"id": "57450", "raw_code": "public static File createTemporaryDirectory(String prefix){\n  while (true) {\n    String candidateName=prefix + TEMPORARY_DIRECTORY_PRNG.nextInt();\n    File result=new File(System.getProperty(\"java.io.tmpdir\"),candidateName);\n    if (result.mkdir()) {\n      return result;\n    }\n  }\n}", "comment": "creates a unique new temporary directory under \" java . io . tmpdir \" .", "label": "what"}
{"id": "26007", "raw_code": "Task<Void> synchronizeAllAuthDataAsync(){\n  Map<String,Map<String,String>> authData;\nsynchronized (mutex) {\n    if (!isCurrentUser()) {\n      return Task.forResult(null);\n    }\n    authData=getAuthData();\n  }\n  List<Task<Void>> tasks=new ArrayList<>(authData.size());\n  for (  String authType : authData.keySet()) {\n    tasks.add(synchronizeAuthDataAsync(authType));\n  }\n  return Task.whenAll(tasks);\n}", "comment": "ensures that all auth sources have auth data ( e . g . access tokens , etc . ) that matches this user .", "label": "what"}
{"id": "45902", "raw_code": "public static Element createElementInEncryptionSpace(Document doc,String elementName){\n  if (doc == null) {\n    throw new RuntimeException(\"Document is null\");\n  }\n  if ((xencPrefix == null) || (xencPrefix.length() == 0)) {\n    return doc.createElementNS(EncryptionConstants.EncryptionSpecNS,elementName);\n  }\n  return doc.createElementNS(EncryptionConstants.EncryptionSpecNS,xencPrefix + \":\" + elementName);\n}", "comment": "creates an element in the xml encryption specification namespace .", "label": "what"}
{"id": "35541", "raw_code": "void scrapActiveViews(){\n  final View[] activeViews=mActiveViews;\n  final boolean multipleScraps=mViewTypeCount > 1;\n  ArrayList<View> scrapViews=mCurrentScrap;\n  final int count=activeViews.length;\n  for (int i=count - 1; i >= 0; i--) {\n    final View victim=activeViews[i];\n    if (victim != null) {\n      final LayoutParams lp=(LayoutParams)victim.getLayoutParams();\n      activeViews[i]=null;\n      final boolean scrapHasTransientState=ViewCompat.hasTransientState(victim);\n      int viewType=lp.viewType;\n      if (!shouldRecycleViewType(viewType) || scrapHasTransientState) {\n        if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER || scrapHasTransientState) {\n          removeDetachedView(victim,false);\n        }\n        if (scrapHasTransientState) {\n          if (mTransientStateViews == null) {\n            mTransientStateViews=new SparseArrayCompat<View>();\n          }\n          mTransientStateViews.put(mFirstActivePosition + i,victim);\n        }\n        continue;\n      }\n      if (multipleScraps) {\n        scrapViews=mScrapViews[viewType];\n      }\n      lp.position=mFirstActivePosition + i;\n      scrapViews.add(victim);\n    }\n  }\n  pruneScrapViews();\n}", "comment": "move all views remaining in mactiveviews to mscrapviews .", "label": "what"}
{"id": "70743", "raw_code": "private void drawWind(Canvas canvas,float y,float xOffset){\n  float cof=(mScreenWidth + xOffset) / (LOADING_ANIMATION_COEFFICIENT / SLOW_DOWN_ANIMATION_COEFFICIENT);\n  float time=mLoadingAnimationTime;\n  if (mLastAnimationTime - mLoadingAnimationTime > 0) {\n    mInverseDirection=true;\n    time=(LOADING_ANIMATION_COEFFICIENT / SLOW_DOWN_ANIMATION_COEFFICIENT) - mLoadingAnimationTime;\n  }\n else {\n    mNewWindSet=true;\n    mInverseDirection=false;\n  }\n  float x=(mScreenWidth - (time * cof)) + xOffset - mWindLineWidth;\n  float xEnd=x + mWindLineWidth;\n  canvas.drawLine(x,y,xEnd,y,mWindPaint);\n}", "comment": "draw wind on loading animation", "label": "what"}
{"id": "42894", "raw_code": "private boolean hasProxySettings(Properties settings){\n  String proxyHost=settings.getProperty(\"org.gnome.system.proxy.http host\",null);\n  return proxyHost != null && proxyHost.length() > 0;\n}", "comment": "checks if we have proxy configuration settings in the properties .", "label": "what"}
{"id": "48633", "raw_code": "public boolean equalsDefault(){\n  return (Double.doubleToLongBits(value) == 0);\n}", "comment": "check if the expression is equal to its default static value", "label": "what"}
{"id": "34720", "raw_code": "@Nullable public static WebsiteAddress create(String originOrHostOrPattern){\n  if (originOrHostOrPattern == null || originOrHostOrPattern.isEmpty()) {\n    return null;\n  }\n  if (originOrHostOrPattern.startsWith(ANY_SUBDOMAIN_PATTERN)) {\n    String origin=null;\n    String scheme=null;\n    String host=originOrHostOrPattern.substring(ANY_SUBDOMAIN_PATTERN.length());\n    boolean omitProtocolAndPort=true;\n    return new WebsiteAddress(originOrHostOrPattern,origin,scheme,host,omitProtocolAndPort);\n  }\n  if (originOrHostOrPattern.indexOf(SCHEME_SUFFIX) != -1) {\n    Uri uri=Uri.parse(originOrHostOrPattern);\n    String origin=trimTrailingBackslash(originOrHostOrPattern);\n    boolean omitProtocolAndPort=HTTP_SCHEME.equals(uri.getScheme()) && (uri.getPort() == -1 || uri.getPort() == 80);\n    return new WebsiteAddress(originOrHostOrPattern,origin,uri.getScheme(),uri.getHost(),omitProtocolAndPort);\n  }\n  String origin=null;\n  String scheme=null;\n  boolean omitProtocolAndPort=true;\n  return new WebsiteAddress(originOrHostOrPattern,origin,scheme,originOrHostOrPattern,omitProtocolAndPort);\n}", "comment": "creates a new websiteaddress from | originorhostorpattern | .", "label": "what"}
{"id": "70254", "raw_code": "public void resetTeleMissileAttacks(){\n  pendingTeleMissileAttacks.removeAllElements();\n}", "comment": "resets the pending rams list .", "label": "what"}
{"id": "41006", "raw_code": "private void notifyActivityStateChanged(Bundle bundle){\n  if (!mRecords.isEmpty()) {\n    Log.d(TAG,\"notifyActivityStatusChanged:clients = \" + mRecords.size());\nsynchronized (mRecords) {\n      Iterator<Record> iterator=mRecords.iterator();\n      while (iterator.hasNext()) {\n        Record record=(Record)iterator.next();\n        FmRadioListener listener=record.mCallback;\n        if (listener == null) {\n          iterator.remove();\n          return;\n        }\n        listener.onCallBack(bundle);\n      }\n    }\n  }\n}", "comment": "call back from service to activity", "label": "what"}
{"id": "68686", "raw_code": "public double elasticity(final double spot){\n  final double val=value();\n  final double del=delta(spot);\n  if (val > Constants.QL_EPSILON)   return del / val * spot;\n else   if (Math.abs(del) < Constants.QL_EPSILON)   return 0.0;\n else   if (del > 0.0)   return Double.MAX_VALUE;\n else   return Double.MIN_VALUE;\n}", "comment": "sensitivity in percent to a percent change in the underlying spot price .", "label": "what"}
{"id": "70617", "raw_code": "private byte[] entityToBytes(HttpEntity entity,Request request) throws IOException, ServerError {\n  PoolingByteArrayOutputStream bytes=new PoolingByteArrayOutputStream(mPool,(int)entity.getContentLength());\n  byte[] buffer=null;\n  try {\n    InputStream in=entity.getContent();\n    if (in == null) {\n      throw new ServerError();\n    }\n    buffer=mPool.getBuf(1024);\n    int progress=0;\n    int count;\n    while ((count=in.read(buffer)) != -1) {\n      bytes.write(buffer,0,count);\n      progress+=count;\n      request.progressUpdate(progress);\n    }\n    return bytes.toByteArray();\n  }\n  finally {\n    try {\n      entity.consumeContent();\n    }\n catch (    IOException e) {\n      VinciLog.d(\"Error occured when calling consumingContent\");\n    }\n    mPool.returnBuf(buffer);\n    bytes.close();\n  }\n}", "comment": "reads the contents of httpentity into a byte [ ] .", "label": "what"}
{"id": "81227", "raw_code": "@AssistedInject public RunnerImpl(@NotNull RunnerLocalizationConstant locale,@NotNull RunnerCounter runnerCounter,@NotNull GetEnvironmentsUtil util,@NotNull @Assisted RunOptions runOptions,@NotNull @Assisted Scope environmentScope,@Nullable @Assisted String environmentName){\n  this.runOptions=runOptions;\n  this.ram=runOptions.getMemorySize();\n  this.title=RUNNER_NAME + runnerCounter.getRunnerNumber() + (environmentName == null ? \"\" : \" - \" + getCorrectName(environmentName));\n  this.activeTab=locale.runnerTabConsole();\n  this.status=IN_QUEUE;\n  this.scope=environmentScope;\n  creationTime=System.currentTimeMillis();\n  String environmentId=runOptions.getEnvironmentId();\n  if (environmentId == null || environmentId.startsWith(\"project:/\")) {\n    this.type=util.getType();\n  }\n else {\n    this.type=util.getCorrectCategoryName(runOptions.getEnvironmentId());\n  }\n  if (environmentId != null) {\n    runOptions.setEnvironmentId(environmentId);\n  }\n}", "comment": "this runner needs runner options ( user configurations ) and environment name ( inputted by user ) .", "label": "what"}
{"id": "44735", "raw_code": "public static boolean isSameElementType(ASTNode node1,ASTNode node2){\n  return node1 != null && node2 != null && node1.getElementType() == node1.getElementType();\n}", "comment": "checks if ielementtype of both nodes are the same .", "label": "what"}
{"id": "21153", "raw_code": "@Override public LogMessage readNextLogMessage(){\n  try {\n    if (reader == null) {\n      return null;\n    }\n    while (true) {\n      String line=reader.readLine();\n      if (line == null) {\n        close();\n        if (currentLog != null && matchRegex(currentLog)) {\n          incrementLogCount(currentLog);\n          return currentLog;\n        }\n        return null;\n      }\n      fileLineNumber++;\n      LogMessage nextLog=null;\n      if (parser != null) {\n        nextLog=parser.parseLine(line,request);\n      }\n else {\n        for (        LogParser parser : parserTable) {\n          nextLog=parser.parseLine(line,request);\n          if (!nextLog.isContinuation()) {\n            this.parser=parser;\n            break;\n          }\n        }\n        if (nextLog == null || nextLog.isContinuation()) {\n          status.appendInfo(this.filePath,fileLineNumber);\n          continue;\n        }\n      }\n      if (nextLog.isContinuation()) {\n        if (currentLog != null) {\n          currentLog.appendMessage(LogUtil.stringToBytes(line));\n        }\n      }\n else       if (nextLog.isRejected()) {\n        if (currentLog != null) {\n          LogMessage returnedLog=currentLog;\n          currentLog=null;\n          if (matchRegex(returnedLog)) {\n            incrementLogCount(returnedLog);\n            return returnedLog;\n          }\n        }\n      }\n else       if (nextLog.isRejectedLast()) {\n        if (currentLog != null) {\n          LogMessage returnedLog=currentLog;\n          currentLog=null;\n          if (matchRegex(returnedLog)) {\n            incrementLogCount(returnedLog);\n            return returnedLog;\n          }\n        }\n        break;\n      }\n else {\n        if (currentLog != null) {\n          LogMessage returnedLog=currentLog;\n          currentLog=nextLog;\n          if (returnedLog.isHeader() && currentLog.isHeader()) {\n            continue;\n          }\n          if (matchRegex(returnedLog)) {\n            incrementLogCount(returnedLog);\n            return returnedLog;\n          }\n        }\n else {\n          currentLog=nextLog;\n        }\n      }\n    }\n  }\n catch (  IOException e) {\n    status.appendErrFileName(filePath);\n  }\n  return null;\n}", "comment": "read one log message from log file", "label": "what"}
{"id": "12615", "raw_code": "private void loadBinary(DataInputStream is) throws IOException {\n  if (is.readInt() != MAGIC) {\n    throw new Error(\"Bad magic in db\");\n  }\n  if (is.readInt() != VERSION) {\n    throw new Error(\"Bad VERSION in db\");\n  }\n  continuityWeight=is.readInt();\n  optimalCoupling=is.readInt();\n  extendSelections=is.readInt();\n  joinMethod=is.readInt();\n  joinWeightShift=is.readInt();\n  int weightLength=is.readInt();\n  joinWeights=new int[weightLength];\n  for (int i=0; i < joinWeights.length; i++) {\n    joinWeights[i]=is.readInt();\n  }\n  int unitsLength=is.readInt();\n  units=new DatabaseClusterUnit[unitsLength];\n  for (int i=0; i < units.length; i++) {\n    units[i]=new DatabaseClusterUnit(is);\n  }\n  int unitTypesLength=is.readInt();\n  unitTypes=new UnitType[unitTypesLength];\n  for (int i=0; i < unitTypes.length; i++) {\n    unitTypes[i]=new UnitType(is);\n  }\n  sts=new SampleSet(is);\n  mcep=new SampleSet(is);\n  int numCarts=is.readInt();\n  cartMap=new HashMap();\n  for (int i=0; i < numCarts; i++) {\n    String name=Utilities.getString(is);\n    CART cart=CARTImpl.loadBinary(is);\n    cartMap.put(name,cart);\n    if (defaultCart == null) {\n      defaultCart=cart;\n    }\n  }\n}", "comment": "loads the database from the given input stream .", "label": "what"}
{"id": "60976", "raw_code": "@Override public synchronized void reset(){\n  pos=0;\n}", "comment": "resets this stream to the beginning of the source string .", "label": "what"}
{"id": "17117", "raw_code": "private static char[] zzUnpackCMap(String packed){\n  char[] map=new char[0x10000];\n  int i=0;\n  int j=0;\n  while (i < 1788) {\n    int count=packed.charAt(i++);\n    char value=packed.charAt(i++);\n    do     map[j++]=value;\n while (--count > 0);\n  }\n  return map;\n}", "comment": "unpacks the compressed character translation table .", "label": "what"}
{"id": "78013", "raw_code": "public static int readSingleByte(InputStream in) throws IOException {\n  byte[] buffer=new byte[1];\n  int result=in.read(buffer,0,1);\n  return (result != -1) ? buffer[0] & 0xff : -1;\n}", "comment": "implements inputstream . read ( int ) in terms of inputstream . read ( byte [ ] , int , int ) .", "label": "what"}
{"id": "67326", "raw_code": "private void compileProlog(ObjectId prolog,File tempDir) throws IOException, CompileException {\n  File tempRules=copyToTempFile(prolog,tempDir);\n  try {\n    Compiler comp=new Compiler();\n    comp.prologToJavaSource(tempRules.getPath(),tempDir.getPath());\n  }\n  finally {\n    tempRules.delete();\n  }\n}", "comment": "creates a copy of rules . pl and compiles it into java sources .", "label": "what"}
{"id": "70973", "raw_code": "public Spring removeAllListeners(){\n  mListeners.clear();\n  return this;\n}", "comment": "remove all of the listeners", "label": "what"}
{"id": "36548", "raw_code": "public SelectionInputDialog(Window owner,String key,boolean editable,T[] selectionValues,T initialSelectionValue,InputValidator<T> inputValidator,Object... keyArguments){\n  this(owner,key,selectionValues,initialSelectionValue,inputValidator,keyArguments);\n  comboBox.setEditable(editable);\n}", "comment": "create a selectioninputdialog whose combobox can be editable .", "label": "what"}
{"id": "40606", "raw_code": "public void build(SolrCore core,SolrIndexSearcher searcher) throws IOException {\n  LOG.info(\"build()\");\n  dictionary=dictionaryFactory.create(core,searcher);\n  lookup.build(dictionary);\n  if (storeDir != null) {\n    File target=new File(storeDir,factory.storeFileName());\n    if (!lookup.store(new FileOutputStream(target))) {\n      LOG.error(\"Store Lookup build failed\");\n    }\n else {\n      LOG.info(\"Stored suggest data to: \" + target.getAbsolutePath());\n    }\n  }\n}", "comment": "build the underlying lucene suggester", "label": "what"}
{"id": "57697", "raw_code": "public URI(String scheme,String schemeSpecificPart,String fragment) throws URISyntaxException {\n  StringBuilder uri=new StringBuilder();\n  if (scheme != null) {\n    uri.append(scheme);\n    uri.append(':');\n  }\n  if (schemeSpecificPart != null) {\n    ALL_LEGAL_ENCODER.appendEncoded(uri,schemeSpecificPart);\n  }\n  if (fragment != null) {\n    uri.append('#');\n    ALL_LEGAL_ENCODER.appendEncoded(uri,fragment);\n  }\n  parseURI(uri.toString(),false);\n}", "comment": "creates a new uri instance of the given unencoded component parts .", "label": "what"}
{"id": "32063", "raw_code": "public byte[] toByteArray(){\n  return Arrays.copyOf(buf,cnt);\n}", "comment": "creates a newly allocated byte array .", "label": "what"}
{"id": "59912", "raw_code": "public void createDiskAsync(final String projectId,final DiskCreateSpec diskCreateSpec,final FutureCallback<Task> responseCallback) throws IOException {\n  final String path=String.format(\"%s/%s/disks\",getBasePath(),projectId);\n  createObjectAsync(path,serializeObjectAsJson(diskCreateSpec),responseCallback);\n}", "comment": "create a disk in the specified project .", "label": "what"}
{"id": "4715", "raw_code": "@Override public boolean domainMatch(final String host,final String domain){\n  return host.endsWith(domain);\n}", "comment": "performs domain - match as described in the netscape draft .", "label": "what"}
{"id": "46826", "raw_code": "public synchronized void disableAttribute(String name){\n  enabledAttributes.removeElement(name);\n}", "comment": "disables all the attribute change notifications the attribute name of which equals the specified attribute name to be sent to the listener .", "label": "what"}
{"id": "46920", "raw_code": "public void push(final Handle handle){\n  mv.visitLdcInsn(handle);\n}", "comment": "generates the instruction to push a handle on the stack .", "label": "what"}
{"id": "23360", "raw_code": "@Deprecated public static String encodePostBody(Bundle parameters,String boundary){\n  if (parameters == null)   return \"\";\n  StringBuilder sb=new StringBuilder();\n  for (  String key : parameters.keySet()) {\n    Object parameter=parameters.get(key);\n    if (!(parameter instanceof String)) {\n      continue;\n    }\n    sb.append(\"Content-Disposition: form-data; name=\\\"\" + key + \"\\\"\\r\\n\\r\\n\"+ (String)parameter);\n    sb.append(\"\\r\\n\" + \"--\" + boundary + \"\\r\\n\");\n  }\n  return sb.toString();\n}", "comment": "generate the multi - part post body providing the parameters and boundary string", "label": "what"}
{"id": "25730", "raw_code": "public static IFitsHeader lookup(String key){\n  int keyLength=key.length();\n  if (keyLength > 0 && Character.isDigit(key.charAt(keyLength - 1))) {\n    StringBuilder builder=new StringBuilder();\n    for (int index=0; index < keyLength; index++) {\n      char character=key.charAt(index);\n      if (Character.isDigit(character)) {\n        if (builder.charAt(builder.length() - 1) != 'n') {\n          builder.append('n');\n        }\n      }\n else {\n        builder.append(character);\n      }\n    }\n    return STANDARD_KEYS.get(builder.toString());\n  }\n  return STANDARD_KEYS.get(key);\n}", "comment": "lookup a string key in the standard key sets .", "label": "what"}
{"id": "57196", "raw_code": "private static void assertChangeEvents(Collection<PortChangeEvent> earlyEvents,Collection<PortChangeEvent> lateEvents,Collection<PortChangeEvent> anytimeEvents,Collection<PortChangeEvent> actualEvents){\n  String inputDesc=String.format(\"earlyEvents=%s, lateEvents=%s, \" + \"anytimeEvents=%s, actualEvents=%s\",earlyEvents,lateEvents,anytimeEvents,actualEvents);\n  Collection<PortChangeEvent> early=new ArrayList<PortChangeEvent>(earlyEvents);\n  Collection<PortChangeEvent> late=new ArrayList<PortChangeEvent>(lateEvents);\n  Collection<PortChangeEvent> any=new ArrayList<PortChangeEvent>(anytimeEvents);\n  for (  PortChangeEvent ev : early) {\n    assertFalse(\"Test setup error. Early and late overlap\",late.contains(ev));\n    assertFalse(\"Test setup error. Early and anytime overlap\",any.contains(ev));\n  }\n  for (  PortChangeEvent ev : late) {\n    assertFalse(\"Test setup error. Late and early overlap\",early.contains(ev));\n    assertFalse(\"Test setup error. Late and any overlap\",any.contains(ev));\n  }\n  for (  PortChangeEvent ev : any) {\n    assertFalse(\"Test setup error. Anytime and early overlap\",early.contains(ev));\n    assertFalse(\"Test setup error. Anytime and late overlap\",late.contains(ev));\n  }\n  for (  PortChangeEvent a : actualEvents) {\n    if (early.remove(a)) {\n      continue;\n    }\n    if (any.remove(a)) {\n      continue;\n    }\n    if (late.remove(a)) {\n      if (!early.isEmpty()) {\n        fail(a + \" is in late list, but haven't seen all required \" + \"early events. \"+ inputDesc);\n      }\n else {\n        continue;\n      }\n    }\n    fail(a + \" was not expected. \" + inputDesc);\n  }\n  if (!early.isEmpty())   fail(\"Elements left in early: \" + early + \". \"+ inputDesc);\n  if (!late.isEmpty())   fail(\"Elements left in late: \" + late + \". \"+ inputDesc);\n  if (!any.isEmpty())   fail(\"Elements left in any: \" + any + \". \"+ inputDesc);\n}", "comment": "assert that the expected portchangeevents have been recevied , asserting the expected ordering .", "label": "what"}
{"id": "29364", "raw_code": "public void reverse(){\n  final ArrayList<Animator> animators=mAnimatedVectorState.mAnimators;\n  final int size=animators.size();\n  for (int i=0; i < size; i++) {\n    final Animator animator=animators.get(i);\n    if (canReverse(animator)) {\n      reverse(animator);\n    }\n else {\n      Log.w(LOG_TAG,\"AnimatedVectorDrawable can't reverse()\");\n    }\n  }\n}", "comment": "reverses ongoing animations or starts pending animations in reverse .", "label": "what"}
{"id": "23238", "raw_code": "public void start(){\n  if (sLogger.isActivated()) {\n    sLogger.info(\"Start address book monitoring\");\n  }\n  mCleanupExecutor=Executors.newSingleThreadExecutor();\n  if (!mObserverIsRegistered) {\n    mContactsContractObserver=new ContactsContractObserver(new Handler());\n    mContactsContractCursor=mContentResolver.query(Phone.CONTENT_URI,null,null,null,null);\n    CursorUtil.assertCursorIsNotNull(mContactsContractCursor,Phone.CONTENT_URI);\n    mContactsContractCursor.registerContentObserver(mContactsContractObserver);\n    mObserverIsRegistered=true;\n  }\n}", "comment": "start address book monitoring", "label": "what"}
{"id": "74622", "raw_code": "public void obtain(long timeout_ms) throws IOException, InterruptedException, TimeoutException {\n  Long quit_time=System.currentTimeMillis() + timeout_ms;\n  if (fileLock != null && fileLock.isValid()) {\n    return;\n  }\n  do {\n    try {\n      fileLock=fileToLock.tryLock();\n      return;\n    }\n catch (    OverlappingFileLockException e) {\n      Thread.sleep(1000);\n    }\n  }\n while (System.currentTimeMillis() < quit_time);\n  throw new TimeoutException();\n}", "comment": "locks the file , with a timeout ( non - blocking ) .", "label": "what"}
{"id": "25717", "raw_code": "@Deprecated public void pointToData(Data o) throws FitsException {\n  o.fillHeader(this);\n}", "comment": "create a header which points to the given data object .", "label": "what"}
{"id": "6214", "raw_code": "public void updatePosition(Particle particle,long elapsedTime){\n  Vector3f speed=particle.getSpeed();\n  float delta=elapsedTime / 1000.0f;\n  float dx=speed.x * delta;\n  float dy=speed.y * delta;\n  float dz=speed.z * delta;\n  Vector3f pos=particle.getPosition();\n  particle.setPosition(pos.x + dx,pos.y + dy,pos.z + dz);\n}", "comment": "updates a particle position", "label": "what"}
{"id": "54198", "raw_code": "protected void update(int length){\n  tickLabelValues.clear();\n  tickLabels.clear();\n  tickLabelPositions.clear();\n  if (scale.isLogScaleEnabled()) {\n    updateTickLabelForLogScale(length);\n  }\n else {\n    updateTickLabelForLinearScale(length);\n  }\n  updateTickVisibility();\n  updateTickLabelMaxLengthAndHeight();\n}", "comment": "updates the tick labels .", "label": "what"}
{"id": "28112", "raw_code": "static public void assertStatementIndicesConsistent(final AbstractTripleStore db,final int maxerrors){\n  if (log.isInfoEnabled())   log.info(\"Verifying statement indices\");\n  final AtomicInteger nerrs=new AtomicInteger(0);\n  final int from, to;\n  if (db.getSPOKeyArity() == 3) {\n    from=SPOKeyOrder.FIRST_TRIPLE_INDEX;\n    to=SPOKeyOrder.LAST_TRIPLE_INDEX;\n  }\n else {\n    from=SPOKeyOrder.FIRST_QUAD_INDEX;\n    to=SPOKeyOrder.LAST_QUAD_INDEX;\n  }\n  for (int i=from; i <= to; i++) {\n    for (int j=from; j <= to; j++) {\n      if (i <= j) {\n        continue;\n      }\n      assertSameStatements(db,SPOKeyOrder.valueOf(i),SPOKeyOrder.valueOf(j),nerrs,maxerrors);\n    }\n  }\n  assertEquals(0,nerrs.get());\n}", "comment": "validates that the same statements are found in each of the statement indices .", "label": "what"}
{"id": "75492", "raw_code": "public Options put(String option,Integer value){\n  if (value == null) {\n    return remove(option);\n  }\n  options.put(option,value.toString());\n  return this;\n}", "comment": "put an option integer value .", "label": "what"}
{"id": "24768", "raw_code": "private int determineTargetPage(int currentPage,float pageOffset,int velocity,int deltaX){\n  int targetPage;\n  if (Math.abs(deltaX) > flingDistance && Math.abs(velocity) > minimumVelocity) {\n    if (virtualPos < 0) {\n      targetPage=velocity > 0 ? currentPage : currentPage + 1;\n    }\n else {\n      targetPage=velocity > 0 ? currentPage + 1 : currentPage;\n    }\n  }\n else {\n    final float truncator=currentPage >= currentItem ? 0.4f : 0.6f;\n    targetPage=(int)(currentPage + pageOffset + truncator);\n  }\n  if (items.size() > 0) {\n    final ItemInfo firstItem=items.get(0);\n    final ItemInfo lastItem=items.get(items.size() - 1);\n    targetPage=Math.max(firstItem.position,Math.min(targetPage,lastItem.position));\n  }\n  if (targetPage > currentPage && onCardChangeListener != null) {\n    onCardChangeListener.onCardDismissed(currentPage,virtualPos > 0);\n  }\n  return targetPage;\n}", "comment": "figure out what the target page would be given current scroll and velocity .", "label": "what"}
{"id": "16330", "raw_code": "public static String[] splitWithoutEscaped(String str,char separatorChar,boolean retainEmpty){\n  int len=str.length();\n  if (len == 0) {\n    return new String[0];\n  }\n  List<String> list=new ArrayList<String>();\n  int i=0;\n  int start=0;\n  boolean match=false;\n  while (i < len) {\n    if (str.charAt(i) == '\\\\') {\n      match=true;\n      i+=2;\n    }\n else     if (str.charAt(i) == separatorChar) {\n      if (retainEmpty || match) {\n        list.add(str.substring(start,i));\n        match=false;\n      }\n      start=++i;\n    }\n else {\n      match=true;\n      i++;\n    }\n  }\n  if (retainEmpty || match) {\n    list.add(str.substring(start,i));\n  }\n  return list.toArray(new String[list.size()]);\n}", "comment": "does not take into account escaped separators", "label": "what"}
{"id": "42376", "raw_code": "private static HashMap<BasicBlockPair,HashSet<Register>> findSplitPoints(IR ir,LiveAnalysis live,LSTGraph lst){\n  HashMap<BasicBlockPair,HashSet<Register>> result=new HashMap<BasicBlockPair,HashSet<Register>>(10);\n  for (Enumeration<GraphNode> e=lst.enumerateNodes(); e.hasMoreElements(); ) {\n    LSTNode node=(LSTNode)e.nextElement();\n    BasicBlock header=node.getHeader();\n    BitVector loop=node.getLoop();\n    if (loop == null)     continue;\n    for (Enumeration<BasicBlock> in=header.getIn(); in.hasMoreElements(); ) {\n      BasicBlock bb=in.nextElement();\n      if (loop.get(bb.getNumber()))       continue;\n      HashSet<Register> liveRegisters=live.getLiveRegistersOnEdge(bb,header);\n      for (      Register r : liveRegisters) {\n        if (r.isSymbolic()) {\n          HashSet<Register> s=findOrCreateSplitSet(result,bb,header);\n          s.add(r);\n        }\n      }\n    }\n    for (int i=0; i < loop.length(); i++) {\n      if (loop.get(i)) {\n        BasicBlock bb=ir.getBasicBlock(i);\n        for (Enumeration<BasicBlock> out=bb.getNormalOut(); out.hasMoreElements(); ) {\n          BasicBlock dest=out.nextElement();\n          if (loop.get(dest.getNumber()))           continue;\n          HashSet<Register> liveRegisters=live.getLiveRegistersOnEdge(bb,dest);\n          for (          Register r : liveRegisters) {\n            if (r.isSymbolic()) {\n              HashSet<Register> s=findOrCreateSplitSet(result,bb,dest);\n              s.add(r);\n            }\n          }\n        }\n      }\n    }\n  }\n  addEntriesForInfrequentBlocks(ir,live,result);\n  return result;\n}", "comment": "find the points the ir where live ranges should be split .", "label": "what"}
{"id": "52674", "raw_code": "@SuppressWarnings(\"unchecked\") public DictionaryAdapter(Context context,File dbPath,String dbName,String defaultTable){\n  mContext=context;\n  mDbName=dbName;\n  mDefaultTable=defaultTable;\n  mDbPath=dbPath;\n  mDbFile=new File(dbPath,mDbName);\n  if (mDbFile.exists()) {\n    open();\n  }\n}", "comment": "open the database if it exists or create it if it doesn ' t .", "label": "what"}
{"id": "34724", "raw_code": "public boolean isTabAssociatedWithNonDestroyedActivity(boolean isIncognito,int tabId){\n  List<WeakReference<Activity>> activities=ApplicationStatus.getRunningActivities();\n  for (  WeakReference<Activity> ref : activities) {\n    Activity activity=ref.get();\n    if (activity != null && isValidActivity(isIncognito,activity.getIntent()) && getTabIdFromIntent(activity.getIntent()) == tabId && !isActivityDestroyed(activity)) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "check if the tab is associated with an activity that hasn ' t been destroyed .", "label": "what"}
{"id": "3645", "raw_code": "HttpStreamWrapper(HttpStream stream) throws IOException {\n  _stream=stream;\n}", "comment": "create a new http stream .", "label": "what"}
{"id": "10938", "raw_code": "public boolean handleFile(File file){\n  if (DEBUG) {\n    logger.fine(\"searching finds: \" + file.getAbsolutePath());\n  }\n  filenames.add(file);\n  return true;\n}", "comment": "when a file is found , add it .", "label": "what"}
{"id": "83406", "raw_code": "public boolean looksLikeNumberComing(){\n  if (n >= s.length())   return false;\n  return Character.isDigit(s.charAt(n));\n}", "comment": "peeks the next char , without gobbling it .", "label": "what"}
{"id": "5487", "raw_code": "public PartialHull(IPoint first,IPoint second){\n  points.add(first);\n  points.add(second);\n}", "comment": "construct the initial partial hull .", "label": "what"}
{"id": "51528", "raw_code": "public short readShort() throws IOException {\n  return primitiveTypes.readShort();\n}", "comment": "reads a short ( 16 bit ) from the source stream .", "label": "what"}
{"id": "51491", "raw_code": "public void print(int inum){\n  print(String.valueOf(inum));\n}", "comment": "prints the string representation of the specified integer to the target .", "label": "what"}
{"id": "37419", "raw_code": "public static <NodeType extends IViewNode<?>>ZyProximityNode<?> createProximityNode(final Graph2D graph,final ZyGraphNode<?> attachedNode,final int degree,final boolean isIncoming){\n  Preconditions.checkNotNull(graph,\"Graph argument can not be null\");\n  Preconditions.checkNotNull(attachedNode,\"Target node argument can not be null\");\n  final ZyLabelContent labelcontent=new ZyLabelContent(null);\n  labelcontent.addLineContent(new ZyLineContent(String.valueOf(degree),new Font(\"New Courier\",Font.PLAIN,12),null));\n  final ZyProximityNodeRealizer<NodeType> r=new ZyProximityNodeRealizer<NodeType>(labelcontent);\n  final Node node=graph.createNode(r);\n  @SuppressWarnings(\"unchecked\") final ZyProximityNode<NodeType> infoNode=new ZyProximityNode<NodeType>(node,r,(ZyGraphNode<NodeType>)attachedNode,isIncoming);\n  final ZyNodeData<ZyProximityNode<NodeType>> data=new ZyNodeData<ZyProximityNode<NodeType>>(infoNode);\n  r.setUserData(data);\n  return infoNode;\n}", "comment": "creates a proximity browsing node .", "label": "what"}
{"id": "6133", "raw_code": "public void reply(List<String> responseHeaders,boolean out) throws IOException {\n  assert (!Thread.holdsLock(SpdyStream.this));\n  boolean outFinished=false;\nsynchronized (this) {\n    if (responseHeaders == null) {\n      throw new NullPointerException(\"responseHeaders == null\");\n    }\n    if (isLocallyInitiated()) {\n      throw new IllegalStateException(\"cannot reply to a locally initiated stream\");\n    }\n    if (this.responseHeaders != null) {\n      throw new IllegalStateException(\"reply already sent\");\n    }\n    this.responseHeaders=responseHeaders;\n    if (!out) {\n      this.out.finished=true;\n      outFinished=true;\n    }\n  }\n  connection.writeSynReply(id,outFinished,responseHeaders);\n}", "comment": "sends a reply to an incoming stream .", "label": "what"}
{"id": "6919", "raw_code": "protected CCAnimation(String name,float delay,ArrayList<CCSpriteFrame> frames){\n  delay_=delay;\n  name_=name;\n  frames_=new ArrayList<CCSpriteFrame>();\n  if (frames != null)   frames_.addAll(frames);\n}", "comment": "initializes a ccanimation with a name , delay and an array of ccspriteframes .", "label": "what"}
{"id": "10593", "raw_code": "private void navigateToDump(){\n  TreePath currentPath=tree.getSelectionPath();\n  tree.setSelectionPath(currentPath.getParentPath());\n  tree.scrollPathToVisible(currentPath.getParentPath());\n}", "comment": "navigate to root node of currently active dump", "label": "what"}
{"id": "81556", "raw_code": "public static Cache.Entry makeRandomCacheEntry(byte[] data,boolean isExpired,boolean needsRefresh){\n  Random random=new Random();\n  Cache.Entry entry=new Cache.Entry();\n  if (data != null) {\n    entry.data=data;\n  }\n else {\n    entry.data=new byte[random.nextInt(1024)];\n  }\n  entry.etag=String.valueOf(random.nextLong());\n  entry.serverDate=random.nextLong();\n  entry.ttl=isExpired ? 0 : Long.MAX_VALUE;\n  entry.softTtl=needsRefresh ? 0 : Long.MAX_VALUE;\n  return entry;\n}", "comment": "makes a random cache entry .", "label": "what"}
{"id": "39989", "raw_code": "public int swap(){\n  if (!egl.eglSwapBuffers(eglDisplay,eglSurface)) {\n    return egl.eglGetError();\n  }\n  return EGL10.EGL_SUCCESS;\n}", "comment": "display the current render surface .", "label": "what"}
{"id": "62578", "raw_code": "public static List<Window> windows(String words,int windowSize){\n  StringTokenizer tokenizer=new StringTokenizer(words);\n  List<String> list=new ArrayList<String>();\n  while (tokenizer.hasMoreTokens())   list.add(tokenizer.nextToken());\n  return windows(list,windowSize);\n}", "comment": "constructs a list of window of size windowsize .", "label": "what"}
{"id": "55811", "raw_code": "protected void drawCenterText(Canvas c){\n  CharSequence centerText=mChart.getCenterText();\n  if (mChart.isDrawCenterTextEnabled() && centerText != null) {\n    MPPointF center=mChart.getCenterCircleBox();\n    MPPointF offset=mChart.getCenterTextOffset();\n    float x=center.x + offset.x;\n    float y=center.y + offset.y;\n    float innerRadius=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled() ? mChart.getRadius() * (mChart.getHoleRadius() / 100f) : mChart.getRadius();\n    RectF holeRect=mRectBuffer[0];\n    holeRect.left=x - innerRadius;\n    holeRect.top=y - innerRadius;\n    holeRect.right=x + innerRadius;\n    holeRect.bottom=y + innerRadius;\n    RectF boundingRect=mRectBuffer[1];\n    boundingRect.set(holeRect);\n    float radiusPercent=mChart.getCenterTextRadiusPercent() / 100f;\n    if (radiusPercent > 0.0) {\n      boundingRect.inset((boundingRect.width() - boundingRect.width() * radiusPercent) / 2.f,(boundingRect.height() - boundingRect.height() * radiusPercent) / 2.f);\n    }\n    if (!centerText.equals(mCenterTextLastValue) || !boundingRect.equals(mCenterTextLastBounds)) {\n      mCenterTextLastBounds.set(boundingRect);\n      mCenterTextLastValue=centerText;\n      float width=mCenterTextLastBounds.width();\n      mCenterTextLayout=new StaticLayout(centerText,0,centerText.length(),mCenterTextPaint,(int)Math.max(Math.ceil(width),1.f),Layout.Alignment.ALIGN_CENTER,1.f,0.f,false);\n    }\n    float layoutHeight=mCenterTextLayout.getHeight();\n    c.save();\n    if (Build.VERSION.SDK_INT >= 18) {\n      Path path=mDrawCenterTextPathBuffer;\n      path.reset();\n      path.addOval(holeRect,Path.Direction.CW);\n      c.clipPath(path);\n    }\n    c.translate(boundingRect.left,boundingRect.top + (boundingRect.height() - layoutHeight) / 2.f);\n    mCenterTextLayout.draw(c);\n    c.restore();\n    MPPointF.recycleInstance(center);\n    MPPointF.recycleInstance(offset);\n  }\n}", "comment": "draws the unit text in the center of the pie chart makes most sense when center - hole is enabled", "label": "what"}
{"id": "72364", "raw_code": "public double doubleValue(){\n  return d.doubleValue();\n}", "comment": "get the double value corresponding to the instance .", "label": "what"}
{"id": "11491", "raw_code": "public FileInputReader(File f) throws IOException {\n  if (Debug.debugging(\"binaryfile\")) {\n    Debug.output(\"FileInputReader created from \" + f.getAbsolutePath());\n  }\n  name=f.getName();\n  absolutePath=f.getAbsolutePath();\n  inputFile=init(f);\n}", "comment": "constructs a new binaryfile with the specified file as the input .", "label": "what"}
{"id": "44882", "raw_code": "public static Result verify(String sid,String code){\n  String id=\"//captcha/\" + sid;\n  Code c=(Code)Cache.get(id);\n  if (c == null) {\n    log.warn(\"no code in cache, sid=\" + sid);\n    return Result.badcode;\n  }\n else   if (!X.isSame(code,c.code)) {\n    log.warn(\"is not same, code.server=\" + c.code + \", code.client=\"+ code);\n    return Result.badcode;\n  }\n else   if (c.expired < System.currentTimeMillis()) {\n    log.warn(\"expired, expired=\" + c.expired);\n    return Result.expired;\n  }\n  return Result.ok;\n}", "comment": "verify the code associated", "label": "what"}
{"id": "47517", "raw_code": "@Override public JapaneseDate dateYearDay(int prolepticYear,int dayOfYear){\n  return new JapaneseDate(LocalDate.ofYearDay(prolepticYear,dayOfYear));\n}", "comment": "obtains a local date in japanese calendar system from the proleptic - year and day - of - year fields .", "label": "what"}
{"id": "48367", "raw_code": "private Pair<Entry,char[]> recoverEntry(KeyStore ks,String alias,char[] pstore,char[] pkey) throws Exception {\n  if (ks.containsAlias(alias) == false) {\n    MessageFormat form=new MessageFormat(rb.getString(\"Alias.alias.does.not.exist\"));\n    Object[] source={alias};\n    throw new Exception(form.format(source));\n  }\n  PasswordProtection pp=null;\n  Entry entry;\n  try {\n    entry=ks.getEntry(alias,pp);\n    pkey=null;\n  }\n catch (  UnrecoverableEntryException une) {\n    if (P11KEYSTORE.equalsIgnoreCase(ks.getType()) || KeyStoreUtil.isWindowsKeyStore(ks.getType())) {\n      throw une;\n    }\n    if (pkey != null) {\n      pp=new PasswordProtection(pkey);\n      entry=ks.getEntry(alias,pp);\n    }\n else {\n      try {\n        pp=new PasswordProtection(pstore);\n        entry=ks.getEntry(alias,pp);\n        pkey=pstore;\n      }\n catch (      UnrecoverableEntryException une2) {\n        if (P12KEYSTORE.equalsIgnoreCase(ks.getType())) {\n          throw une2;\n        }\n else {\n          pkey=getKeyPasswd(alias,null,null);\n          pp=new PasswordProtection(pkey);\n          entry=ks.getEntry(alias,pp);\n        }\n      }\n    }\n  }\n  return Pair.of(entry,pkey);\n}", "comment": "recovers entry associated with given alias .", "label": "what"}
{"id": "34885", "raw_code": "URLClassLoader newLoader(URL base){\n  return new URLClassLoader(new URL[]{base});\n}", "comment": "creates a class loader with the given base url as its classpath .", "label": "what"}
{"id": "40262", "raw_code": "public Wiser(){\n  this.server=new SMTPServer(new SimpleMessageListenerAdapter(this));\n}", "comment": "create a new smtp server with this class as the listener .", "label": "what"}
{"id": "32516", "raw_code": "protected static int[] concat(@Nullable int[] arr,int... obj){\n  int[] newArr;\n  if (arr == null || arr.length == 0)   newArr=obj;\n else {\n    newArr=Arrays.copyOf(arr,arr.length + obj.length);\n    System.arraycopy(obj,0,newArr,arr.length,obj.length);\n  }\n  return newArr;\n}", "comment": "concatenates elements to an int array .", "label": "what"}
{"id": "17354", "raw_code": "public void truckCamera(float size){\n  moveToPosition(-(float)(targetXoff + (size * Math.sin(Math.toRadians(zrot - 90)))),-(float)(targetYoff + (size * Math.cos(Math.toRadians(zrot - 90)))));\n}", "comment": "change camera position horizontally ( left or right ) .", "label": "what"}
{"id": "62252", "raw_code": "public static byte[] decode2(String encoded){\n  if (encoded == null) {\n    return null;\n  }\n  char[] base64Data=encoded.toCharArray();\n  int len=removeWhiteSpace(base64Data);\n  if (len % FOURBYTE != 0) {\n    return null;\n  }\n  int numberQuadruple=(len / FOURBYTE);\n  if (numberQuadruple == 0) {\n    return new byte[0];\n  }\n  byte decodedData[]=null;\n  byte b1=0, b2=0, b3=0, b4=0;\n  char d1=0, d2=0, d3=0, d4=0;\n  int i=0;\n  int encodedIndex=0;\n  int dataIndex=0;\n  decodedData=new byte[(numberQuadruple) * 3];\n  for (; i < numberQuadruple - 1; i++) {\n    if (!isData((d1=base64Data[dataIndex++])) || !isData((d2=base64Data[dataIndex++])) || !isData((d3=base64Data[dataIndex++]))|| !isData((d4=base64Data[dataIndex++]))) {\n      return null;\n    }\n    b1=base64Alphabet[d1];\n    b2=base64Alphabet[d2];\n    b3=base64Alphabet[d3];\n    b4=base64Alphabet[d4];\n    decodedData[encodedIndex++]=(byte)(b1 << 2 | b2 >> 4);\n    decodedData[encodedIndex++]=(byte)(((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n    decodedData[encodedIndex++]=(byte)(b3 << 6 | b4);\n  }\n  if (!isData((d1=base64Data[dataIndex++])) || !isData((d2=base64Data[dataIndex++]))) {\n    return null;\n  }\n  b1=base64Alphabet[d1];\n  b2=base64Alphabet[d2];\n  d3=base64Data[dataIndex++];\n  d4=base64Data[dataIndex++];\n  if (!isData((d3)) || !isData((d4))) {\n    if (isPad(d3) && isPad(d4)) {\n      if ((b2 & 0xf) != 0) {\n        return null;\n      }\n      byte[] tmp=new byte[i * 3 + 1];\n      System.arraycopy(decodedData,0,tmp,0,i * 3);\n      tmp[encodedIndex]=(byte)(b1 << 2 | b2 >> 4);\n      return tmp;\n    }\n else     if (!isPad(d3) && isPad(d4)) {\n      b3=base64Alphabet[d3];\n      if ((b3 & 0x3) != 0) {\n        return null;\n      }\n      byte[] tmp=new byte[i * 3 + 2];\n      System.arraycopy(decodedData,0,tmp,0,i * 3);\n      tmp[encodedIndex++]=(byte)(b1 << 2 | b2 >> 4);\n      tmp[encodedIndex]=(byte)(((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n      return tmp;\n    }\n else {\n      return null;\n    }\n  }\n else {\n    b3=base64Alphabet[d3];\n    b4=base64Alphabet[d4];\n    decodedData[encodedIndex++]=(byte)(b1 << 2 | b2 >> 4);\n    decodedData[encodedIndex++]=(byte)(((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n    decodedData[encodedIndex++]=(byte)(b3 << 6 | b4);\n  }\n  return decodedData;\n}", "comment": "decodes base64 data into octects", "label": "what"}
{"id": "30069", "raw_code": "public void shutdown(){\n  scheduledExecutorService.shutdownNow();\n}", "comment": "shut down the health checker .", "label": "what"}
{"id": "34931", "raw_code": "public Builder clear(){\n  localeBuilder.clear();\n  return this;\n}", "comment": "resets the builder to its initial , empty state .", "label": "what"}
{"id": "9383", "raw_code": "protected int splitListIndex(List<Pair<Double,Integer>> S){\n  return S.size() / 2;\n}", "comment": "determines which index to use as the splitting index for the vp radius", "label": "what"}
{"id": "42612", "raw_code": "public static void e(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_ERROR) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.e(tag,msg);\n}", "comment": "send an error log message", "label": "what"}
{"id": "13644", "raw_code": "private static void cleanDirectory(File path){\n  if (path == null)   return;\n  if (path.exists()) {\n    for (    File f : path.listFiles()) {\n      if (f.isDirectory())       cleanDirectory(f);\n      f.delete();\n    }\n  }\n}", "comment": "recursive remove all from directory", "label": "what"}
{"id": "10187", "raw_code": "public void add(int index,int element){\n  checkRangeIncludingEndpoint(index);\n  ensureCapacity(size + 1);\n  int numtomove=size - index;\n  System.arraycopy(array,index,array,index + 1,numtomove);\n  array[index]=element;\n  size++;\n}", "comment": "inserts the specified element at the specified position in this list .", "label": "what"}
{"id": "62868", "raw_code": "public MultiplexManager(DataStore... dataStores){\n  this.dataStores=Arrays.asList(dataStores);\n}", "comment": "create a single datastore to handle provided managers within a single transaction .", "label": "what"}
{"id": "71792", "raw_code": "public void paintComponent(Graphics g){\n  g.drawImage(track,0,0,null);\n  Graphics2D g2d=(Graphics2D)g.create();\n  g2d.translate(carPosition.x,carPosition.y);\n  g2d.rotate(Math.toRadians(carRotation));\n  g2d.translate(-(carPosition.x),-(carPosition.y));\n  g2d.drawImage(car,carPosition.x - carWHalf,carPosition.y - carHHalf,null);\n}", "comment": "render the track and car", "label": "what"}
{"id": "53263", "raw_code": "public static double crossTrackDistanceRad(double lat1,double lon1,double lat2,double lon2,double latQ,double lonQ){\n  final double dlon12=lon2 - lon1;\n  final double dlon1Q=lonQ - lon1;\n  final double dlat1Q=latQ - lat1;\n  final double clat1=Math.cos(lat1), slat1=MathUtil.cosToSin(lat1,clat1);\n  final double clatQ=Math.cos(latQ), slatQ=MathUtil.cosToSin(latQ,clatQ);\n  final double clat2=Math.cos(lat2), slat2=MathUtil.cosToSin(lat2,clat2);\n  final double slat=Math.sin(dlat1Q * .5);\n  final double slon=Math.sin(dlon1Q * .5);\n  final double a=slat * slat + slon * slon * clat1* clatQ;\n  final double angDist1Q=2 * Math.atan2(Math.sqrt(a),Math.sqrt(1 - a));\n  final double sdlon12=Math.sin(dlon12), cdlon12=MathUtil.sinToCos(dlon12,sdlon12);\n  final double sdlon1Q=Math.sin(dlon1Q), cdlon1Q=MathUtil.sinToCos(dlon1Q,sdlon1Q);\n  final double yE=sdlon12 * clat2;\n  final double yQ=sdlon1Q * clatQ;\n  final double xE=clat1 * slat2 - slat1 * clat2 * cdlon12;\n  final double xQ=clat1 * slatQ - slat1 * clatQ * cdlon1Q;\n  final double crs12=Math.atan2(yE,xE);\n  final double crs1Q=Math.atan2(yQ,xQ);\n  return Math.asin(Math.sin(angDist1Q) * Math.sin(crs1Q - crs12));\n}", "comment": "compute the cross - track distance .", "label": "what"}
{"id": "84784", "raw_code": "public static double pdf(double x,double shape,double scale,double factor){\n  if (x <= 0)   return 0.0;\n  final double a=Math.exp(shape * Math.log(scale) - (shape + 1) * Math.log(x) - (scale / x) - GammaFunction.lnGamma(shape));\n  return factor * a;\n}", "comment": "probability density function of the gamma distribution", "label": "what"}
{"id": "66030", "raw_code": "public String charge(Properties ctx,int WindowNo,GridTab mTab,GridField mField,Object value){\n  Integer C_Charge_ID=(Integer)value;\n  if (C_Charge_ID == null || C_Charge_ID.intValue() == 0)   return \"\";\n  String sql=\"SELECT ChargeAmt FROM C_Charge WHERE C_Charge_ID=?\";\n  PreparedStatement pstmt=null;\n  ResultSet rs=null;\n  try {\n    pstmt=DB.prepareStatement(sql,null);\n    pstmt.setInt(1,C_Charge_ID.intValue());\n    rs=pstmt.executeQuery();\n    if (rs.next()) {\n      mTab.setValue(\"PriceEntered\",rs.getBigDecimal(1));\n    }\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sql,e);\n    return e.getLocalizedMessage();\n  }\n finally {\n    DB.close(rs,pstmt);\n    rs=null;\n    pstmt=null;\n  }\n  return tax(ctx,WindowNo,mTab,mField,value);\n}", "comment": "invoice batch line - charge .", "label": "what"}
{"id": "35247", "raw_code": "protected Array<Actor> parse(){\n  actors=GdxArrays.newArray(Actor.class);\n  invokePreListeners(actors);\n  final StringBuilder builder=new StringBuilder();\n  while (templateReader.hasNextCharacter()) {\n    final char character=templateReader.nextCharacter();\n    if (character == syntax.getArgumentOpening()) {\n      processArgument();\n    }\n else     if (character == syntax.getTagOpening()) {\n      if (isNextCharacterCommentOpening()) {\n        processComment();\n        continue;\n      }\n      if (currentParentTag != null) {\n        currentParentTag.handleDataBetweenTags(builder);\n      }\n      Strings.clearBuilder(builder);\n      processTag(builder);\n    }\n else {\n      builder.append(character);\n    }\n  }\n  if (currentParentTag != null) {\n    throwError('\"' + currentParentTag.getTagName() + \"\\\" tag was never closed.\");\n  }\n  invokePortListeners(actors);\n  return actors;\n}", "comment": "does the actual parsing", "label": "what"}
{"id": "67972", "raw_code": "public void flush() throws IOException {\n  WspUtil.writeUint8(os_,0x01);\n  writePublicIdentifier(os_,publicID_);\n  WspUtil.writeUintvar(os_,WapConstants.MIB_ENUM_UTF_8);\n  writeStringTable(os_);\n  wbxmlBody_.close();\n  wbxmlBody_.writeTo(os_);\n  os_.flush();\n}", "comment": "writes the wbxml to stream .", "label": "what"}
{"id": "67949", "raw_code": "public static void discard(){\n  current.remove();\n}", "comment": "discards any active baggage currently in this thread", "label": "what"}
{"id": "35342", "raw_code": "private Token toASIToken(ILeafNode leaf){\n  if (leaf.isHidden()) {\n    return newSemicolonToken(leaf);\n  }\n else {\n    if (!leafNodes.hasNext()) {\n      int tokenType=tokenTypeMapper.getInternalTokenType(leaf);\n      int semicolonTokenType=tokenTypeMapper.getInternalTokenType(semicolon);\n      if (tokenType == semicolonTokenType) {\n        return new CommonToken(semicolonTokenType,leaf.getText());\n      }\n      if (leaf.getTotalEndOffset() == endOffset) {\n        leafNodes=Iterators.emptyIterator();\n        return new CommonToken(tokenType,leaf.getText());\n      }\n      next=new CommonToken(semicolonTokenType,leaf.getText());\n      return new CommonToken(tokenType,leaf.getText());\n    }\n else     if (leaf.getGrammarElement() == rightCurlyInBlock || leaf.getGrammarElement() == rightCurlyInArrowExpression) {\n      int tokenType=tokenTypeMapper.getInternalTokenType(leaf);\n      next=new CommonToken(tokenType);\n      return new CommonToken(tokenTypeMapper.getInternalTokenType(semicolon),leaf.getText());\n    }\n else {\n      return newSemicolonToken(leaf);\n    }\n  }\n}", "comment": "produces either one or two tokens from the given leaf which represents a location where the production parser inserted a semicolon .", "label": "what"}
{"id": "59570", "raw_code": "@Override public PacketBuffer write(PacketBuffer buf){\n  values.forEach(null);\n  return buf;\n}", "comment": "writes this packet to the given buffer", "label": "what"}
{"id": "60394", "raw_code": "public final void registerFileType(@NotNull FileType type,@NonNls @Nullable String... defaultAssociatedExtensions){\n  List<FileNameMatcher> matchers=new ArrayList<FileNameMatcher>();\n  if (defaultAssociatedExtensions != null) {\n    for (    String extension : defaultAssociatedExtensions) {\n      matchers.add(new ExtensionFileNameMatcher(extension));\n    }\n  }\n  registerFileType(type,matchers);\n}", "comment": "registers a file type .", "label": "what"}
{"id": "55613", "raw_code": "private void drawHost(Graphics2D g2){\n  Coord loc=node.getLocation();\n  if (drawCoverage && node.isRadioActive()) {\n    ArrayList<NetworkInterface> interfaces=new ArrayList<NetworkInterface>();\n    interfaces.addAll(node.getInterfaces());\n    for (    NetworkInterface ni : interfaces) {\n      double range=ni.getTransmitRange();\n      Ellipse2D.Double coverage;\n      coverage=new Ellipse2D.Double(scale(loc.getX() - range),scale(loc.getY() - range),scale(range * 2),scale(range * 2));\n      g2.setColor(rangeColor);\n      g2.draw(coverage);\n    }\n  }\n  if (drawConnections) {\n    g2.setColor(conColor);\n    Coord c1=node.getLocation();\n    ArrayList<Connection> conList=new ArrayList<Connection>();\n    conList.addAll(node.getConnections());\n    for (    Connection c : conList) {\n      DTNHost otherNode=c.getOtherNode(node);\n      Coord c2;\n      if (otherNode == null) {\n        continue;\n      }\n      c2=otherNode.getLocation();\n      g2.drawLine(scale(c1.getX()),scale(c1.getY()),scale(c2.getX()),scale(c2.getY()));\n    }\n  }\n  g2.setColor(hostColor);\n  g2.drawRect(scale(loc.getX() - 1),scale(loc.getY() - 1),scale(2),scale(2));\n  if (isHighlighted()) {\n    g2.setColor(highlightedNodeColor);\n    g2.fillRect(scale(loc.getX()) - 3,scale(loc.getY()) - 3,6,6);\n  }\n  if (drawNodeName) {\n    g2.setColor(hostNameColor);\n    g2.drawString(node.toString(),scale(loc.getX()),scale(loc.getY()));\n  }\n}", "comment": "visualize node ' s location , radio ranges and connections", "label": "what"}
{"id": "76896", "raw_code": "public boolean intersects(final PlanetModel planetModel,final Plane q,final GeoPoint[] notablePoints,final GeoPoint[] moreNotablePoints,final Membership[] bounds,final Membership... moreBounds){\n  if (isNumericallyIdentical(q)) {\n    for (    GeoPoint p : notablePoints) {\n      if (meetsAllBounds(p,bounds,moreBounds)) {\n        return true;\n      }\n    }\n    for (    GeoPoint p : moreNotablePoints) {\n      if (meetsAllBounds(p,bounds,moreBounds)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  final double lineVectorX=y * q.z - z * q.y;\n  final double lineVectorY=z * q.x - x * q.z;\n  final double lineVectorZ=x * q.y - y * q.x;\n  if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n    return false;\n  }\n  double x0;\n  double y0;\n  double z0;\n  final double denomYZ=this.y * q.z - this.z * q.y;\n  final double denomXZ=this.x * q.z - this.z * q.x;\n  final double denomXY=this.x * q.y - this.y * q.x;\n  if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n    if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n      return false;\n    }\n    final double denom=1.0 / denomYZ;\n    x0=0.0;\n    y0=(-this.D * q.z - this.z * -q.D) * denom;\n    z0=(this.y * -q.D + this.D * q.y) * denom;\n  }\n else   if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n    if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n      return false;\n    }\n    final double denom=1.0 / denomXZ;\n    x0=(-this.D * q.z - this.z * -q.D) * denom;\n    y0=0.0;\n    z0=(this.x * -q.D + this.D * q.x) * denom;\n  }\n else {\n    if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n      return false;\n    }\n    final double denom=1.0 / denomXY;\n    x0=(-this.D * q.y - this.y * -q.D) * denom;\n    y0=(this.x * -q.D + this.D * q.x) * denom;\n    z0=0.0;\n  }\n  final double A=lineVectorX * lineVectorX * planetModel.inverseAbSquared + lineVectorY * lineVectorY * planetModel.inverseAbSquared + lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n  final double B=2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n  final double C=x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n  final double BsquaredMinus=B * B - 4.0 * A * C;\n  if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n    final double inverse2A=1.0 / (2.0 * A);\n    final double t=-B * inverse2A;\n    final double pointX=lineVectorX * t + x0;\n    final double pointY=lineVectorY * t + y0;\n    final double pointZ=lineVectorZ * t + z0;\n    for (    final Membership bound : bounds) {\n      if (!bound.isWithin(pointX,pointY,pointZ)) {\n        return false;\n      }\n    }\n    for (    final Membership bound : moreBounds) {\n      if (!bound.isWithin(pointX,pointY,pointZ)) {\n        return false;\n      }\n    }\n    return true;\n  }\n else   if (BsquaredMinus > 0.0) {\n    final double inverse2A=1.0 / (2.0 * A);\n    final double sqrtTerm=Math.sqrt(BsquaredMinus);\n    final double t1=(-B + sqrtTerm) * inverse2A;\n    final double t2=(-B - sqrtTerm) * inverse2A;\n    final double point1X=lineVectorX * t1 + x0;\n    final double point1Y=lineVectorY * t1 + y0;\n    final double point1Z=lineVectorZ * t1 + z0;\n    boolean point1Valid=true;\n    for (    final Membership bound : bounds) {\n      if (!bound.isWithin(point1X,point1Y,point1Z)) {\n        point1Valid=false;\n        break;\n      }\n    }\n    if (point1Valid) {\n      for (      final Membership bound : moreBounds) {\n        if (!bound.isWithin(point1X,point1Y,point1Z)) {\n          point1Valid=false;\n          break;\n        }\n      }\n    }\n    if (point1Valid) {\n      return true;\n    }\n    final double point2X=lineVectorX * t2 + x0;\n    final double point2Y=lineVectorY * t2 + y0;\n    final double point2Z=lineVectorZ * t2 + z0;\n    for (    final Membership bound : bounds) {\n      if (!bound.isWithin(point2X,point2Y,point2Z)) {\n        return false;\n      }\n    }\n    for (    final Membership bound : moreBounds) {\n      if (!bound.isWithin(point2X,point2Y,point2Z)) {\n        return false;\n      }\n    }\n    return true;\n  }\n else {\n    return false;\n  }\n}", "comment": "determine whether the plane intersects another plane within the bounds provided .", "label": "what"}
{"id": "34164", "raw_code": "public static long longFromBase64(String value){\n  int pos=0;\n  long longVal=base64Values[value.charAt(pos++)];\n  int len=value.length();\n  while (pos < len) {\n    longVal<<=6;\n    longVal|=base64Values[value.charAt(pos++)];\n  }\n  return longVal;\n}", "comment": "decode a base64 string into a long value .", "label": "what"}
{"id": "68638", "raw_code": "public EipModelWizardInitialObjectCreationPage(String pageId){\n  super(pageId);\n}", "comment": "pass in the selection .", "label": "what"}
{"id": "31989", "raw_code": "private void unwrapData() throws IgniteCheckedException, SSLException {\n  if (log.isDebugEnabled())   log.debug(\"Unwrapping received data.\");\n  inNetBuf.flip();\n  SSLEngineResult res=unwrap0();\n  inNetBuf.compact();\n  checkStatus(res);\n  renegotiateIfNeeded(res);\n}", "comment": "unwraps user data to the application buffer .", "label": "what"}
{"id": "14556", "raw_code": "private void storePassword(String password){\n  if (isStore && sharedState != null) {\n    sharedState.put(getPwdKey(),password);\n  }\n}", "comment": "stores password into shared state map .", "label": "what"}
{"id": "48099", "raw_code": "void deleteChild(PolicyNode childNode){\n  if (isImmutable) {\n    throw new IllegalStateException(\"PolicyNode is immutable\");\n  }\n  mChildren.remove(childNode);\n}", "comment": "deletes the specified child node of this node , if it exists .", "label": "what"}
{"id": "7199", "raw_code": "public static List<Fragment> parsePlaceholder(String parseString) throws PlaceholderParseException {\n  List<Fragment> result=new ArrayList<Fragment>();\n  int currOutputIndex=0;\n  int currSearchIndex=0;\n  while (true) {\n    if (currSearchIndex == parseString.length()) {\n      break;\n    }\n    int startIndex=parseString.indexOf(\"${\",currSearchIndex);\n    if (startIndex == -1) {\n      if (currOutputIndex < parseString.length()) {\n        String endString=parseString.substring(currOutputIndex,parseString.length());\n        TextFragment textFragment=new TextFragment(endString);\n        result.add(textFragment);\n      }\n      break;\n    }\n    if (startIndex > 0) {\n      String textSoFar=parseString.substring(currOutputIndex,startIndex);\n      if (textSoFar.length() != 0) {\n        result.add(new TextFragment(textSoFar));\n      }\n    }\n    if ((startIndex > 0) && (parseString.charAt(startIndex - 1) == '$')) {\n      currOutputIndex=startIndex + 1;\n      currSearchIndex=startIndex + 1;\n      continue;\n    }\n    int endIndex=parseString.indexOf('}',startIndex);\n    if (endIndex == -1) {\n      throw new PlaceholderParseException(\"Syntax error in property or variable: '\" + parseString.substring(startIndex,parseString.length()) + \"'\");\n    }\n    String between=parseString.substring(startIndex + 2,endIndex);\n    ParameterFragment parameterFragment=new ParameterFragment(between);\n    result.add(parameterFragment);\n    currOutputIndex=endIndex + 1;\n    currSearchIndex=endIndex;\n  }\n  LinkedList<Fragment> fragments=new LinkedList<Fragment>();\n  fragments.add(result.get(0));\n  for (int i=1; i < result.size(); i++) {\n    Fragment fragment=result.get(i);\n    if (!(result.get(i) instanceof TextFragment)) {\n      fragments.add(fragment);\n      continue;\n    }\n    if (!(fragments.getLast() instanceof TextFragment)) {\n      fragments.add(fragment);\n      continue;\n    }\n    TextFragment textFragment=(TextFragment)fragments.getLast();\n    fragments.removeLast();\n    fragments.add(new TextFragment(textFragment.getValue() + fragment.getValue()));\n  }\n  return fragments;\n}", "comment": "parses a string to find placeholders of format $ { placeholder } .", "label": "what"}
{"id": "2975", "raw_code": "private void routeSingleGetRequest(RequestAndResponse requestAndResponse,String uri) throws IOException, ServletException {\n  if (uri.startsWith(\"/notebooks/\")) {\n    handleHtmlShowNotebooks(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/quotations/\")) {\n    handleHtmlShowQuotations(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/sources/\")) {\n    handleHtmlShowSources(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/source/\")) {\n    handleHtmlShowSource(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/notebook/\")) {\n    handleHtmlShowNotebook(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/search/\")) {\n    handleHtmlSearch(requestAndResponse);\n  }\n else   if (uri.equals(\"/help/\")) {\n    handleHtmlBasicHelp(requestAndResponse);\n  }\n else   if (uri.equals(\"/advancedHelp/\")) {\n    handleHtmlAdvancedHelp(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/help/\")) {\n    handleHtmlHelp(requestAndResponse);\n  }\n else   if (uri.equals(\"/backup/\")) {\n    handleHtmlUserBackupForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/restore/\")) {\n    handleHtmlUserRestoreForm(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/account/\")) {\n    handleHtmlShowAccount(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/accounts/\")) {\n    handleHtmlShowAccounts(requestAndResponse);\n  }\n else   if (uri.equals(\"/shutdown/\")) {\n    handleHtmlShutdownForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/clear/\")) {\n    handleHtmlClearForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/onlineBackup/\")) {\n    handleHtmlOnlineBackupForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/checkForErrors/\")) {\n    handleHtmlCheckForErrorsForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/backups/\")) {\n    handleHtmlShowDBBackups(requestAndResponse);\n  }\n else   if (uri.equals(\"/offlineBackup/\")) {\n    handleHtmlOfflineDbBackupForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/noteJson/\")) {\n    handleJsonShowEntry(requestAndResponse);\n  }\n else   if (uri.equals(\"/noteParentJson/\")) {\n    handleJsonShowEntryParent(requestAndResponse);\n  }\n else   if (uri.equals(\"/noteChildrenJson/\")) {\n    handleJsonShowEntryChildren(requestAndResponse);\n  }\n else   if (uri.equals(\"/searchNotesJson/\")) {\n    handleJsonSearchNotes(requestAndResponse);\n  }\n else   if (uri.equals(\"/newNotebook/\")) {\n    handleHtmlNewNotebookForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/nothing/\")) {\n    handleHtmlNothing(requestAndResponse);\n  }\n else   if (uri.equals(\"/couldNotCreateNote/\")) {\n    handleHtmlCouldNotCreateNote(requestAndResponse);\n  }\n else   if (uri.equals(\"/restoreBackupCommand/\")) {\n    handleHtmlShowRestoreDbBackupCommand(requestAndResponse);\n  }\n else   if (uri.equals(\"/signedOut/\")) {\n    handleHtmlShowSignedOut(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/changePassword/\")) {\n    handleHtmlChangePassword(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/changeAccount/\")) {\n    handleHtmlChangeAccount(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/closeAccount/\")) {\n    handleHtmlCloseAccount(requestAndResponse);\n  }\n else   if (uri.equals(\"/isSignedIn/\")) {\n    handleJsonIsSignedIn(requestAndResponse);\n  }\n else   if (uri.equals(\"/restoreFrame/\")) {\n    handleHtmlUserRestoreFrame(requestAndResponse);\n  }\n else {\n    returnHtml404(requestAndResponse);\n  }\n}", "comment": "routes a single get request .", "label": "what"}
{"id": "10081", "raw_code": "private void changeAnnotationDocumentState(SourceDocument aSourceDocument,User aUser,AnnotationDocumentStateTransition aAnnotationDocumentStateTransition){\n  AnnotationDocument annotationDocument=repository.getAnnotationDocument(aSourceDocument,aUser);\n  annotationDocument.setState(AnnotationDocumentStateTransition.transition(aAnnotationDocumentStateTransition));\n  try {\n    repository.createAnnotationDocument(annotationDocument);\n  }\n catch (  IOException e) {\n    LOG.info(\"Unable to get the LOG file\");\n  }\n}", "comment": "change the state of an annotation document .", "label": "what"}
{"id": "83326", "raw_code": "boolean removeEdge(SparseEdge e){\n  boolean removedEdge=edges.remove(e);\n  boolean removedNeighbour=neighbours.remove(e.getOpposite(this));\n  if (removedEdge && removedNeighbour)   return true;\n else   if (!removedEdge && !removedNeighbour)   return false;\n else   throw new RuntimeException(\"Graph connectivity appears to be inconsitent!\");\n}", "comment": "disconnects this vertex from an edge .", "label": "what"}
{"id": "57335", "raw_code": "public int fileWrite(long handle,byte[] buffer,int offset,int count){\n  if ((offset | count) < 0 || offset > buffer.length || buffer.length - offset < count) {\n    throw new ArrayIndexOutOfBoundsException(\"length=\" + buffer.length + \"; regionStart=\"+ offset+ \"; regionLength=\"+ count);\n  }\n  if (count == 0) {\n    return 0;\n  }\n  byte[] data=buffer;\n  if (offset > 0) {\n    data=new byte[count];\n    System.arraycopy(buffer,offset,data,0,count);\n  }\n  IntOut bytesWrittenOut=new IntOut();\n  try {\n    checkResult(LibIMobileDevice.afc_file_write(getRef(),handle,data,count,bytesWrittenOut));\n    int bytesWritten=bytesWrittenOut.getValue();\n    return bytesWritten;\n  }\n  finally {\n    bytesWrittenOut.delete();\n  }\n}", "comment": "writes a given number of bytes to a file .", "label": "what"}
{"id": "49350", "raw_code": "private static void generateFiles(){\n  String[] classNames;\n  ResourceBundle rules, info;\n  info=ResourceBundle.getBundle(\"sun.text.resources.BreakIteratorInfo\",new Locale(language,country,valiant),BreakIteratorRBControl.INSTANCE);\n  classNames=info.getStringArray(\"BreakIteratorClasses\");\n  rules=ResourceBundle.getBundle(\"sun.text.resources.BreakIteratorRules\",new Locale(language,country,valiant),BreakIteratorRBControl.INSTANCE);\n  if (info.containsKey(\"CharacterData\")) {\n    generateDataFile(info.getString(\"CharacterData\"),rules.getString(\"CharacterBreakRules\"),classNames[0]);\n  }\n  if (info.containsKey(\"WordData\")) {\n    generateDataFile(info.getString(\"WordData\"),rules.getString(\"WordBreakRules\"),classNames[1]);\n  }\n  if (info.containsKey(\"LineData\")) {\n    generateDataFile(info.getString(\"LineData\"),rules.getString(\"LineBreakRules\"),classNames[2]);\n  }\n  if (info.containsKey(\"SentenceData\")) {\n    generateDataFile(info.getString(\"SentenceData\"),rules.getString(\"SentenceBreakRules\"),classNames[3]);\n  }\n}", "comment": "generate data files whose names are included in sun . text . resources . breakiteratorinfo +", "label": "what"}
{"id": "50404", "raw_code": "public static boolean isCglibProxy(Object object){\n  return ClassUtils.isCglibProxyClass(object.getClass());\n}", "comment": "check whether the given object is a cglib proxy .", "label": "what"}
{"id": "70740", "raw_code": "private float[] calculateImageIndents(){\n  mTempMatrix.reset();\n  mTempMatrix.setRotate(-getCurrentAngle());\n  float[] unrotatedImageCorners=Arrays.copyOf(mCurrentImageCorners,mCurrentImageCorners.length);\n  float[] unrotatedCropBoundsCorners=RectUtils.getCornersFromRect(mCropRect);\n  mTempMatrix.mapPoints(unrotatedImageCorners);\n  mTempMatrix.mapPoints(unrotatedCropBoundsCorners);\n  RectF unrotatedImageRect=RectUtils.trapToRect(unrotatedImageCorners);\n  RectF unrotatedCropRect=RectUtils.trapToRect(unrotatedCropBoundsCorners);\n  float deltaLeft=unrotatedImageRect.left - unrotatedCropRect.left;\n  float deltaTop=unrotatedImageRect.top - unrotatedCropRect.top;\n  float deltaRight=unrotatedImageRect.right - unrotatedCropRect.right;\n  float deltaBottom=unrotatedImageRect.bottom - unrotatedCropRect.bottom;\n  float indents[]=new float[4];\n  indents[0]=(deltaLeft > 0) ? deltaLeft : 0;\n  indents[1]=(deltaTop > 0) ? deltaTop : 0;\n  indents[2]=(deltaRight < 0) ? deltaRight : 0;\n  indents[3]=(deltaBottom < 0) ? deltaBottom : 0;\n  mTempMatrix.reset();\n  mTempMatrix.setRotate(getCurrentAngle());\n  mTempMatrix.mapPoints(indents);\n  return indents;\n}", "comment": "first , un - rotate image and crop rectangles ( make image rectangle axis - aligned ) .", "label": "what"}
{"id": "77787", "raw_code": "public static boolean equals(boolean[] field1,boolean[] field2){\n  if (field1 == null || field1.length == 0) {\n    return field2 == null || field2.length == 0;\n  }\n else {\n    return Arrays.equals(field1,field2);\n  }\n}", "comment": "checks repeated boolean field equality ; null - value and 0 - length fields are considered equal .", "label": "what"}
{"id": "36424", "raw_code": "public void toFront(final WorkflowAnnotation anno){\n  if (anno == null) {\n    throw new IllegalArgumentException(\"anno must not be null!\");\n  }\nsynchronized (lock) {\n    if (annotationsDrawOrder.remove(anno)) {\n      annotationsDrawOrder.add(anno);\n    }\n    if (annotationsEventOrder.remove(anno)) {\n      annotationsEventOrder.add(0,anno);\n    }\n  }\n}", "comment": "bring the given annotation to the front .", "label": "what"}
{"id": "52338", "raw_code": "public static String printCodePointAsString(int codePoint){\n  StringBuilder builder=new StringBuilder(12);\n  builder.append('\"');\n  try {\n    printStringCodePoint(builder,codePoint);\n  }\n catch (  IOException e) {\n    throw new Error(e);\n  }\n  builder.append('\"');\n  return builder.toString();\n}", "comment": "builds a string denoting an ascii - encoded ion string , with double - quotes surrounding a single unicode code point .", "label": "what"}
{"id": "2875", "raw_code": "boolean closeOutbound() throws SSLException {\n  if (sslEngine == null || sslEngine.isOutboundDone()) {\n    return false;\n  }\n  sslEngine.closeOutbound();\n  createOutNetBuffer(0);\n  SSLEngineResult result;\n  for (; ; ) {\n    result=sslEngine.wrap(emptyBuffer.buf(),outNetBuffer.buf());\n    if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n      outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n      outNetBuffer.limit(outNetBuffer.capacity());\n    }\n else {\n      break;\n    }\n  }\n  if (result.getStatus() != SSLEngineResult.Status.CLOSED) {\n    throw new SSLException(\"Improper close state: \" + result);\n  }\n  outNetBuffer.flip();\n  return true;\n}", "comment": "start ssl shutdown process .", "label": "what"}
{"id": "82899", "raw_code": "@Nullable private static Bitmap extractThumbnail(Bitmap source,int width,int height){\n  return extractThumbnail(source,width,height,OPTIONS_NONE);\n}", "comment": "creates a centered bitmap of the desired size .", "label": "what"}
{"id": "28790", "raw_code": "private void writePkgInfo() throws BuildException {\n  File pkgInfo=new File(mContentsDir,\"PkgInfo\");\n  PrintWriter writer=null;\n  try {\n    writer=new PrintWriter(new BufferedWriter(new FileWriter(pkgInfo)));\n    writer.print(bundleProperties.getCFBundlePackageType());\n    writer.println(bundleProperties.getCFBundleSignature());\n    writer.flush();\n  }\n catch (  IOException ex) {\n    throw new BuildException(\"Cannot create PkgInfo file: \" + ex);\n  }\n finally {\n    mFileUtils.close(writer);\n  }\n}", "comment": "write the pkginfo file into the application bundle", "label": "what"}
{"id": "48190", "raw_code": "private byte[] decode(DerInputStream in) throws IOException {\n  DerValue val=in.getDerValue();\n  byte[] derEncoding=val.toByteArray();\n  derEncoding[0]=DerValue.tag_SetOf;\n  DerInputStream derIn=new DerInputStream(derEncoding);\n  DerValue[] derVals=derIn.getSet(3,true);\n  PKCS9Attribute attrib;\n  ObjectIdentifier oid;\n  boolean reuseEncoding=true;\n  for (int i=0; i < derVals.length; i++) {\n    try {\n      attrib=new PKCS9Attribute(derVals[i]);\n    }\n catch (    ParsingException e) {\n      if (ignoreUnsupportedAttributes) {\n        reuseEncoding=false;\n        continue;\n      }\n else {\n        throw e;\n      }\n    }\n    oid=attrib.getOID();\n    if (attributes.get(oid) != null)     throw new IOException(\"Duplicate PKCS9 attribute: \" + oid);\n    if (permittedAttributes != null && !permittedAttributes.containsKey(oid))     throw new IOException(\"Attribute \" + oid + \" not permitted in this attribute set\");\n    attributes.put(oid,attrib);\n  }\n  return reuseEncoding ? derEncoding : generateDerEncoding();\n}", "comment": "decode this set of pkcs9 attributes from the contents of its der encoding .", "label": "what"}
{"id": "9356", "raw_code": "@Override public CategoricalResults clone(){\n  CategoricalResults copy=new CategoricalResults(n);\n  copy.probabilities=Arrays.copyOf(probabilities,probabilities.length);\n  return copy;\n}", "comment": "creates a deep clone of this", "label": "what"}
{"id": "45402", "raw_code": "private static StringBuilder dump(StringBuilder _lbuffer,long value){\n  for (int j=0; j < 8; j++) {\n    _lbuffer.append(_hexcodes[(int)(value >> _shifts[j]) & 15]);\n  }\n  return _lbuffer;\n}", "comment": "dump a long value into a stringbuilder .", "label": "what"}
{"id": "62932", "raw_code": "private boolean typeSpecialChar(char c){\nswitch (c) {\ncase '\\t':\n    controller.keyPress(KeyEvent.VK_TAB);\n  controller.keyRelease(KeyEvent.VK_TAB);\nreturn true;\ncase '\\n':\ncontroller.keyPress(KeyEvent.VK_ENTER);\ncontroller.keyRelease(KeyEvent.VK_ENTER);\nreturn true;\ndefault :\nreturn false;\n}\n}", "comment": "simulate keyboard to type out a special character .", "label": "what"}
{"id": "64261", "raw_code": "protected final void writeC(ByteBuffer buf,int value){\n  buf.put((byte)value);\n}", "comment": "write byte to buffer .", "label": "what"}
{"id": "66421", "raw_code": "protected void paintContentBorderBottomEdge(Graphics g,int x,int y,int w,int h,boolean drawBroken,Rectangle selRect,boolean isContentBorderPainted){\n  if (isContentBorderPainted) {\n    g.setColor(darkShadow);\n    g.fillRect(x,y + h - 1,w - 1,1);\n  }\n}", "comment": "draws the bottom edge of the border around the content area .", "label": "what"}
{"id": "28685", "raw_code": "public String read(String filename) throws IOException {\n  return ProcFile.readFile(String.format(\"/proc/%d/%s\",pid,filename));\n}", "comment": "read the contents of a file in / proc / [ pid ] / [ filename ] .", "label": "what"}
{"id": "56045", "raw_code": "private long calculateAnimationDuration(float initialVelocity,float displacement){\n  return MathUtils.clamp(Math.round(Math.abs(2000 * displacement / initialVelocity)),MINIMUM_ANIMATION_DURATION_MS,MAXIMUM_ANIMATION_DURATION_MS);\n}", "comment": "calculates the animation duration given the | initialvelocity | and a desired | displacement | .", "label": "what"}
{"id": "86891", "raw_code": "@RequestProcessing(value=\"/member/{userName}/points\",method=HTTPRequestMethod.GET) @Before(adviceClass={StopwatchStartAdvice.class,AnonymousViewCheck.class,UserBlockCheck.class}) @After(adviceClass=StopwatchEndAdvice.class) public void showHomePoints(final HTTPRequestContext context,final HttpServletRequest request,final HttpServletResponse response,final String userName) throws Exception {\n  final JSONObject user=(JSONObject)request.getAttribute(User.USER);\n  request.setAttribute(Keys.TEMAPLTE_DIR_NAME,Symphonys.get(\"skinDirName\"));\n  final AbstractFreeMarkerRenderer renderer=new SkinRenderer();\n  context.setRenderer(renderer);\n  renderer.setTemplateName(\"/home/points.ftl\");\n  final Map<String,Object> dataModel=renderer.getDataModel();\n  filler.fillHeaderAndFooter(request,response,dataModel);\n  String pageNumStr=request.getParameter(\"p\");\n  if (Strings.isEmptyOrNull(pageNumStr) || !Strings.isNumeric(pageNumStr)) {\n    pageNumStr=\"1\";\n  }\n  final int pageNum=Integer.valueOf(pageNumStr);\n  final int pageSize=Symphonys.getInt(\"userHomePointsCnt\");\n  final int windowSize=Symphonys.getInt(\"userHomePointsWindowSize\");\n  fillHomeUser(dataModel,user);\n  avatarQueryService.fillUserAvatarURL(user);\n  final String followingId=user.optString(Keys.OBJECT_ID);\n  dataModel.put(Follow.FOLLOWING_ID,followingId);\n  final JSONObject userPointsResult=pointtransferQueryService.getUserPoints(user.optString(Keys.OBJECT_ID),pageNum,pageSize);\n  final List<JSONObject> userPoints=CollectionUtils.<JSONObject>jsonArrayToList(userPointsResult.optJSONArray(Keys.RESULTS));\n  dataModel.put(Common.USER_HOME_POINTS,userPoints);\n  final boolean isLoggedIn=(Boolean)dataModel.get(Common.IS_LOGGED_IN);\n  if (isLoggedIn) {\n    final JSONObject currentUser=(JSONObject)dataModel.get(Common.CURRENT_USER);\n    final String followerId=currentUser.optString(Keys.OBJECT_ID);\n    final boolean isFollowing=followQueryService.isFollowing(followerId,user.optString(Keys.OBJECT_ID));\n    dataModel.put(Common.IS_FOLLOWING,isFollowing);\n  }\n  user.put(UserExt.USER_T_CREATE_TIME,new Date(user.getLong(Keys.OBJECT_ID)));\n  final int pointsCnt=userPointsResult.optInt(Pagination.PAGINATION_RECORD_COUNT);\n  final int pageCount=(int)Math.ceil((double)pointsCnt / (double)pageSize);\n  final List<Integer> pageNums=Paginator.paginate(pageNum,pageSize,pageCount,windowSize);\n  if (!pageNums.isEmpty()) {\n    dataModel.put(Pagination.PAGINATION_FIRST_PAGE_NUM,pageNums.get(0));\n    dataModel.put(Pagination.PAGINATION_LAST_PAGE_NUM,pageNums.get(pageNums.size() - 1));\n  }\n  dataModel.put(Pagination.PAGINATION_CURRENT_PAGE_NUM,pageNum);\n  dataModel.put(Pagination.PAGINATION_PAGE_COUNT,pageCount);\n  dataModel.put(Pagination.PAGINATION_PAGE_NUMS,pageNums);\n}", "comment": "shows user home points page .", "label": "what"}
{"id": "70081", "raw_code": "private int measureHeight(int measureSpec){\n  float result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=mPaintSelected.getStrokeWidth() + getPaddingTop() + getPaddingBottom();\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return (int)((float)Math.ceil(result));\n}", "comment": "determines the height of this view", "label": "what"}
{"id": "3970", "raw_code": "public void add(int i,int data){\n  if (_length + 1 > _capacity)   ensureCapacity(_length + 1);\n  System.arraycopy(_buffer,i,_buffer,i + 1,_length - i);\n  _buffer[i]=(byte)data;\n  _length+=1;\n}", "comment": "inserts a byte array", "label": "what"}
{"id": "12509", "raw_code": "private double mean(double[] vec){\n  double result=0;\n  for (int i=0; i < vec.length; i++)   result+=vec[i];\n  return result / vec.length;\n}", "comment": "the mean of the values in the double array", "label": "what"}
{"id": "32774", "raw_code": "public void close(){\n  out.close();\n}", "comment": "closes the output stream .", "label": "what"}
{"id": "28294", "raw_code": "public void init(String flagzDirectory) throws FlagException, EtcdFlagFieldUpdaterException {\n  this.directoryPrefix=MoreObjects.firstNonNull(flagzDirectory,directoryFlag.get());\n  client=new EtcdClient(uris.toArray(new URI[uris.size()]));\n  client.setRetryHandler(retryPolicy);\n  initialSetAllFlagz();\n}", "comment": "init performs the initial read of values from etcd .", "label": "what"}
{"id": "1106", "raw_code": "public static void closeEL(InputStream is){\n  try {\n    if (is != null)     is.close();\n  }\n catch (  Throwable t) {\n  }\n}", "comment": "close inputstream without a exception", "label": "what"}
{"id": "77280", "raw_code": "public static boolean waitForAllActiveAndLiveReplicas(ZkStateReader zkStateReader,int timeoutInMs){\n  return waitForAllActiveAndLiveReplicas(zkStateReader,null,timeoutInMs);\n}", "comment": "wait to see * all * cores live and active .", "label": "what"}
{"id": "51346", "raw_code": "public synchronized void addElement(E object){\n  if (elementCount == elementData.length) {\n    growByOne();\n  }\n  elementData[elementCount++]=object;\n  modCount++;\n}", "comment": "adds the specified object at the end of this vector .", "label": "what"}
{"id": "21014", "raw_code": "public boolean checkForRp(){\n  return NullColumnValueGetter.isNotNullValue(getRpCopyName());\n}", "comment": "uses a field in the volume to determine if the volume is an rp volume .", "label": "what"}
{"id": "62903", "raw_code": "public static List<String> splitPath(File file){\n  List<String> output=new ArrayList<>();\n  File current=file;\n  while (current != null) {\n    output.add(current.getName());\n    current=current.getParentFile();\n  }\n  Collections.reverse(output);\n  return output;\n}", "comment": "split a file into a list of directories ending with the file name", "label": "what"}
{"id": "81871", "raw_code": "protected int drawLabelText(Object nativeGraphics,int textDecoration,boolean rtl,boolean isTickerRunning,boolean endsWith3Points,Object nativeFont,int txtW,int textSpaceW,int shiftText,String text,int x,int y,int fontHeight){\n  if ((!isTickerRunning) || rtl) {\n    if (txtW > textSpaceW && textSpaceW > 0) {\n      if (rtl) {\n        if ((!isTickerRunning) && endsWith3Points) {\n          String points=\"...\";\n          int pointsW=stringWidth(nativeFont,points);\n          drawString(nativeGraphics,nativeFont,points,shiftText + x,y,textDecoration,fontHeight);\n          clipRect(nativeGraphics,pointsW + shiftText + x,y,textSpaceW - pointsW,fontHeight);\n        }\n        x=x - txtW + textSpaceW;\n      }\n else       if (endsWith3Points) {\n        String points=\"...\";\n        int index=1;\n        int widest=charWidth(nativeFont,'W');\n        int pointsW=stringWidth(nativeFont,points);\n        int textLen=text.length();\n        while (fastCharWidthCheck(text,index,textSpaceW - pointsW,widest,nativeFont) && index < textLen) {\n          index++;\n        }\n        text=text.substring(0,Math.min(textLen,Math.max(1,index - 1))) + points;\n        txtW=stringWidth(nativeFont,text);\n      }\n    }\n  }\n  drawString(nativeGraphics,nativeFont,text,shiftText + x,y,textDecoration,fontHeight);\n  return Math.min(txtW,textSpaceW);\n}", "comment": "draws the text of a label", "label": "what"}
{"id": "4360", "raw_code": "public boolean hasMapObjects(){\n  return mapObjects != null && !mapObjects.isEmpty();\n}", "comment": "indicates whether this map layer has any map objects .", "label": "what"}
{"id": "398", "raw_code": "public void performActions() throws Throwable {\n  for (  Throwing.Runnable action : actions) {\n    action.run();\n  }\n}", "comment": "runs the commands that have been queued up .", "label": "what"}
{"id": "23094", "raw_code": "public javax2.sip.address.TelURL createTelURL(String uri) throws ParseException {\n  if (uri == null)   throw new NullPointerException(\"null url\");\n  String telUrl=\"tel:\" + uri;\n  try {\n    StringMsgParser smp=new StringMsgParser();\n    TelURLImpl timp=(TelURLImpl)smp.parseUrl(telUrl);\n    return (TelURL)timp;\n  }\n catch (  ParseException ex) {\n    throw new ParseException(ex.getMessage(),0);\n  }\n}", "comment": "creates a telurl based on given uri string .", "label": "what"}
{"id": "36172", "raw_code": "public EvoSVMModel(ExampleSet exampleSet,List<SupportVector> supportVectors,Kernel kernel,double bias){\n  super(exampleSet,ExampleSetUtilities.SetsCompareOption.ALLOW_SUPERSET,ExampleSetUtilities.TypesCompareOption.ALLOW_SAME_PARENTS);\n  this.supportVectors=supportVectors;\n  if (supportVectors == null || supportVectors.size() == 0) {\n    throw new IllegalArgumentException(\"Null or empty support vector collection: not possible to predict values!\");\n  }\n  this.kernel=kernel;\n  this.bias=bias;\n  if (this.kernel instanceof DotKernel) {\n    this.weights=new double[getNumberOfAttributes()];\n    for (int i=0; i < getNumberOfSupportVectors(); i++) {\n      SupportVector sv=getSupportVector(i);\n      if (sv != null) {\n        double[] x=sv.getX();\n        double alpha=sv.getAlpha();\n        double y=sv.getY();\n        for (int j=0; j < weights.length; j++) {\n          weights[j]+=y * alpha * x[j];\n        }\n      }\n else {\n        this.weights=null;\n        break;\n      }\n    }\n  }\n}", "comment": "creates a classification model .", "label": "what"}
{"id": "1055", "raw_code": "private synchronized boolean _restart() throws ServletException {\n  if (singelton != null)   singelton.reset();\n  initEngine();\n  System.gc();\n  return true;\n}", "comment": "restart the cfml engine", "label": "what"}
{"id": "38800", "raw_code": "public Sorter(){\n  useDefaultVisual();\n  setLayout(new BorderLayout());\n  add(m_visual,BorderLayout.CENTER);\n  m_env=Environment.getSystemWide();\n  m_stopRequested=new AtomicBoolean(false);\n}", "comment": "constructs a new sorter", "label": "what"}
{"id": "53155", "raw_code": "public static double logpdf(double x,double mu,double shape){\n  if (!(x > 0) || x == Double.POSITIVE_INFINITY) {\n    return Double.NEGATIVE_INFINITY;\n  }\n  final double v=(x - mu) / mu;\n  return v < Double.MAX_VALUE ? 0.5 * Math.log(shape / (MathUtil.TWOPI * x * x* x)) - shape * v * v / (2. * x) : Double.NEGATIVE_INFINITY;\n}", "comment": "probability density function of the wald distribution .", "label": "what"}
{"id": "23007", "raw_code": "public static Format generateFormat(String codec){\n  return (Format)SUPPORTED_CODECS.get(codec.toLowerCase());\n}", "comment": "generate the format associated to the codec name", "label": "what"}
{"id": "18187", "raw_code": "public void comment(char ch[],int start,int length) throws org.xml.sax.SAXException {\n  int start_old=start;\n  if (m_inEntityRef)   return;\n  if (m_elemContext.m_startTagOpen) {\n    closeStartTag();\n    m_elemContext.m_startTagOpen=false;\n  }\n else   if (m_needToCallStartDocument) {\n    startDocumentInternal();\n    m_needToCallStartDocument=false;\n  }\n  try {\n    final int limit=start + length;\n    boolean wasDash=false;\n    if (m_cdataTagOpen)     closeCDATA();\n    if (shouldIndent())     indent();\n    final java.io.Writer writer=m_writer;\n    writer.write(COMMENT_BEGIN);\n    for (int i=start; i < limit; i++) {\n      if (wasDash && ch[i] == '-') {\n        writer.write(ch,start,i - start);\n        writer.write(\" -\");\n        start=i + 1;\n      }\n      wasDash=(ch[i] == '-');\n    }\n    if (length > 0) {\n      final int remainingChars=(limit - start);\n      if (remainingChars > 0)       writer.write(ch,start,remainingChars);\n      if (ch[limit - 1] == '-')       writer.write(' ');\n    }\n    writer.write(COMMENT_END);\n  }\n catch (  IOException e) {\n    throw new SAXException(e);\n  }\n  m_startNewLine=true;\n  if (m_tracer != null)   super.fireCommentEvent(ch,start_old,length);\n}", "comment": "receive notification of an xml comment anywhere in the document .", "label": "what"}
{"id": "27546", "raw_code": "public T findByCommitCounter(final long commitCounter){\n  if (commitCounter < 0L)   throw new IllegalArgumentException();\n  final Lock lock=readLock();\n  lock.lock();\n  try {\n    @SuppressWarnings(\"unchecked\") final ITupleIterator<T> itr=rangeIterator(null,null,0,IRangeQuery.DEFAULT | IRangeQuery.REVERSE,null);\n    while (itr.hasNext()) {\n      final ITuple<T> t=itr.next();\n      final T r=t.getObject();\n      final IRootBlockView rb=r.getRootBlock();\n      if (rb.getCommitCounter() <= commitCounter) {\n        return r;\n      }\n    }\n    return null;\n  }\n  finally {\n    lock.unlock();\n  }\n}", "comment": "find the oldest entry whose commit counter is lte the specified commit counter .", "label": "what"}
{"id": "44007", "raw_code": "public static String traceExcetion(Throwable ex){\n  final Writer result=new StringWriter();\n  final PrintWriter printWriter=new PrintWriter(result);\n  ex.printStackTrace(printWriter);\n  String stacktrace=result.toString();\n  Log.e(TAG,\"ERROR ---> \" + stacktrace);\n  return stacktrace;\n}", "comment": "write exception throw in log", "label": "what"}
{"id": "7021", "raw_code": "private void stopVideoFadingEdgesScreenTimer(){\n  if (null != mVideoFadingEdgesTimer) {\n    mVideoFadingEdgesTimer.cancel();\n    mVideoFadingEdgesTimer=null;\n    mVideoFadingEdgesTimerTask=null;\n  }\n}", "comment": "stop the video fading timer .", "label": "what"}
{"id": "39095", "raw_code": "protected static void processGenericPropertiesCreatorProps(File propsFile){\n  try {\n    Properties expProps=new Properties();\n    BufferedInputStream bi=new BufferedInputStream(new FileInputStream(propsFile));\n    expProps.load(bi);\n    bi.close();\n    bi=null;\n    Properties GPCInputProps=GenericPropertiesCreator.getGlobalInputProperties();\n    Set<Object> keys=expProps.keySet();\n    Iterator<Object> keysI=keys.iterator();\n    while (keysI.hasNext()) {\n      String key=(String)keysI.next();\n      String existingVal=GPCInputProps.getProperty(key,\"\");\n      if (existingVal.length() > 0) {\n        String newVal=expProps.getProperty(key);\n        if (existingVal.indexOf(newVal) < 0) {\n          newVal=existingVal + \",\" + newVal;\n          GPCInputProps.put(key,newVal);\n        }\n      }\n else {\n        String newVal=expProps.getProperty(key);\n        GPCInputProps.put(key,newVal);\n      }\n    }\n  }\n catch (  Exception ex) {\n  }\n}", "comment": "process a package ' s genericpropertiescreator . props file", "label": "what"}
{"id": "39614", "raw_code": "private static String randomElement(ArrayList<String> list){\n  int index=random.nextInt(list.size());\n  return list.get(index);\n}", "comment": "utility to grab a random element from an array of strings .", "label": "what"}
{"id": "24390", "raw_code": "public static void join(final AsyncInvocation<?> async,final long timeoutMilliseconds){\n  join(async.getThread(),timeoutMilliseconds);\n}", "comment": "wait for a thread to join .", "label": "what"}
{"id": "48641", "raw_code": "void define(MemberDefinition field,int slot,int from,int to){\n  if (from >= to) {\n    return;\n  }\n  for (int i=0; i < len; i++) {\n    if ((locals[i].field == field) && (locals[i].slot == slot) && (from <= locals[i].to)&& (to >= locals[i].from)) {\n      locals[i].from=Math.min(locals[i].from,from);\n      locals[i].to=Math.max(locals[i].to,to);\n      return;\n    }\n  }\n  if (len == locals.length) {\n    LocalVariable newlocals[]=new LocalVariable[len * 2];\n    System.arraycopy(locals,0,newlocals,0,len);\n    locals=newlocals;\n  }\n  locals[len++]=new LocalVariable(field,slot,from,to);\n}", "comment": "define a new local variable .", "label": "what"}
{"id": "32370", "raw_code": "protected Connection openConnection(boolean autocommit) throws SQLException {\n  Connection conn=dataSrc.getConnection();\n  conn.setAutoCommit(autocommit);\n  return conn;\n}", "comment": "gets connection from a pool .", "label": "what"}
{"id": "8471", "raw_code": "public Object apply(String source,int lineNo,int columnNo,Object funcBody,Vector paramNames,Vector arguments) throws BSFException {\n  Object object=eval(source,lineNo,columnNo,funcBody);\n  if (object instanceof Closure) {\n    Closure closure=(Closure)object;\n    return closure.call(arguments.toArray());\n  }\n  return object;\n}", "comment": "allow an anonymous function to be declared and invoked", "label": "what"}
{"id": "60218", "raw_code": "public void output(List list,Writer out) throws IOException {\n  printContentRange(out,list,0,list.size(),0,createNamespaceStack());\n  out.flush();\n}", "comment": "this will handle printing out a list of nodes .", "label": "what"}
{"id": "15904", "raw_code": "private int[] mod(int[] a,int[] f){\n  int df=computeDegree(f);\n  if (df == -1) {\n    throw new ArithmeticException(\"Division by zero\");\n  }\n  int[] result=new int[a.length];\n  int hc=headCoefficient(f);\n  hc=field.inverse(hc);\n  System.arraycopy(a,0,result,0,result.length);\n  while (df <= computeDegree(result)) {\n    int[] q;\n    int coeff=field.mult(headCoefficient(result),hc);\n    q=multWithMonomial(f,computeDegree(result) - df);\n    q=multWithElement(q,coeff);\n    result=add(q,result);\n  }\n  return result;\n}", "comment": "reduce a polynomial modulo another polynomial .", "label": "what"}
{"id": "13302", "raw_code": "private void addToken(int token){\n  try {\n    fTokens[fTokenCount]=token;\n  }\n catch (  ArrayIndexOutOfBoundsException ex) {\n    int[] oldList=fTokens;\n    fTokens=new int[fTokenCount << 1];\n    System.arraycopy(oldList,0,fTokens,0,fTokenCount);\n    fTokens[fTokenCount]=token;\n  }\n  fTokenCount++;\n}", "comment": "add the specified int token", "label": "what"}
{"id": "45721", "raw_code": "private P filterLargeValueSets(FilterSpec fs,MetaDataObject rootMeta,F root,boolean forceEntityBased,JoinType defaultPredicateJoinType){\n  ArrayList<FilterSpec> specs=new ArrayList<>();\n  List<?> list=new ArrayList<>((Collection<?>)fs.getValue());\n  for (int i=0; i < list.size(); i+=ORACLE_PARAM_LIMIT) {\n    int nextOffset=i + Math.min(list.size() - i,ORACLE_PARAM_LIMIT);\n    List<?> batchList=list.subList(i,nextOffset);\n    specs.add(new FilterSpec(fs.getAttributePath(),fs.getOperator(),batchList));\n  }\n  FilterSpec orSpec=FilterSpec.or(specs);\n  return filterSpecListToPredicate(rootMeta,root,orSpec,forceEntityBased,defaultPredicateJoinType);\n}", "comment": "split filters with two many value possibilities .", "label": "what"}
{"id": "4261", "raw_code": "public int compare(String s1,String s2){\n  final Matcher match1=MATCH_ID_PATTERN.matcher(s1);\n  final Matcher match2=MATCH_ID_PATTERN.matcher(s2);\n  final boolean match1matches=match1.matches();\n  final boolean match2matches=match2.matches();\n  if (match1matches ^ match2matches) {\n    return (match1matches) ? 1 : -1;\n  }\n else   if (match1matches && match2matches) {\n    int signature1=Integer.parseInt(match1.group(1));\n    int signature2=Integer.parseInt(match2.group(1));\n    int comparison=(signature1 < signature2) ? -1 : (signature1 > signature2) ? 1 : 0;\n    if (comparison == 0) {\n      int start1=Integer.parseInt(match1.group(2));\n      int start2=Integer.parseInt(match2.group(2));\n      comparison=(start1 < start2) ? -1 : (start1 > start2) ? 1 : 0;\n    }\n    if (comparison == 0) {\n      int end1=Integer.parseInt(match1.group(3));\n      int end2=Integer.parseInt(match2.group(3));\n      comparison=(end1 < end2) ? -1 : (end1 > end2) ? 1 : 0;\n    }\n    return comparison;\n  }\n else {\n    int seqLength1=s1.length(), n2=s2.length();\n    for (int i1=0, i2=0; i1 < seqLength1 && i2 < n2; i1++, i2++) {\n      char c1=s1.charAt(i1);\n      char c2=s2.charAt(i2);\n      if (c1 != c2) {\n        c1=Character.toUpperCase(c1);\n        c2=Character.toUpperCase(c2);\n        if (c1 != c2) {\n          c1=Character.toLowerCase(c1);\n          c2=Character.toLowerCase(c2);\n          if (c1 != c2) {\n            return c1 - c2;\n          }\n        }\n      }\n    }\n    return seqLength1 - n2;\n  }\n}", "comment": "sorts on the following : 1 .", "label": "what"}
{"id": "65506", "raw_code": "public static LeftRegularBipartiteGraphSegment buildRandomLeftRegularBipartiteGraph(int leftSize,int rightSize,int leftDegree,Random random){\n  LeftRegularBipartiteGraphSegment leftRegularBipartiteGraphSegment=new LeftRegularBipartiteGraphSegment(leftSize / 2,leftDegree,rightSize / 2,leftSize / 2,2.0,Integer.MAX_VALUE,new IdentityEdgeTypeMask(),new NullStatsReceiver());\n  LongSet addedIds=new LongOpenHashSet(leftDegree);\n  for (int i=0; i < leftSize; i++) {\n    addedIds.clear();\n    for (int j=0; j < leftDegree; j++) {\n      long idToAdd;\n      do {\n        idToAdd=random.nextInt(rightSize);\n      }\n while (addedIds.contains(idToAdd));\n      addedIds.add(idToAdd);\n      leftRegularBipartiteGraphSegment.addEdge(i,idToAdd,(byte)0);\n    }\n  }\n  return leftRegularBipartiteGraphSegment;\n}", "comment": "build a random left - regular bipartite graph of given left and right sizes .", "label": "what"}
{"id": "25556", "raw_code": "@Override public void addFocusables(ArrayList<View> views,int direction,int focusableMode){\n  final int focusableCount=views.size();\n  final int descendantFocusability=getDescendantFocusability();\n  if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {\n    for (int i=0; i < getChildCount(); i++) {\n      final View child=getChildAt(i);\n      if (child.getVisibility() == VISIBLE) {\n        ItemInfo ii=infoForChild(child);\n        if (ii != null && ii.position == mCurItem) {\n          child.addFocusables(views,direction,focusableMode);\n        }\n      }\n    }\n  }\n  if (descendantFocusability != FOCUS_AFTER_DESCENDANTS || (focusableCount == views.size())) {\n    if (!isFocusable()) {\n      return;\n    }\n    if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && isInTouchMode() && !isFocusableInTouchMode()) {\n      return;\n    }\n    if (views != null) {\n      views.add(this);\n    }\n  }\n}", "comment": "we only want the current page that is being shown to be focusable .", "label": "what"}
{"id": "75882", "raw_code": "protected HttpURLConnection configureRequest(final HttpURLConnection request){\n  if (credentials != null)   request.setRequestProperty(HEADER_AUTHORIZATION,credentials);\n  request.setRequestProperty(HEADER_USER_AGENT,userAgent);\n  request.setRequestProperty(HEADER_ACCEPT,getHeaderAccept());\n  return request;\n}", "comment": "configure request with standard headers", "label": "what"}
{"id": "29277", "raw_code": "public static String convertToTitle(int n){\n  if (n <= 0)   return \"\";\n  StringBuilder title=new StringBuilder();\n  while (n > 0) {\n    n--;\n    int r=n % 26;\n    title.insert(0,(char)('A' + r));\n    n=n / 26;\n  }\n  return title.toString();\n}", "comment": "get the remainder in each loop it should be the last digit note that the map shall have 1 offset", "label": "what"}
{"id": "19768", "raw_code": "private ReplicatorRuntimeConf(String serviceName){\n  replicatorHomeDir=locateReplicatorHomeDir();\n  replicatorLogDir=locateReplicatorLogDir();\n  replicatorConfDir=locateReplicatorConfDir();\n  replicatorProperties=new File(locateReplicatorConfDir(),\"static-\" + serviceName + \".properties\");\n  if (!replicatorProperties.isFile() || !replicatorProperties.canRead()) {\n    throw new ServerRuntimeException(\"Replicator static properties does not exist or is invalid: \" + replicatorProperties);\n  }\n  replicatorDynamicProperties=new File(replicatorConfDir,\"dynamic-\" + serviceName + \".properties\");\n  replicatorDynamicRole=new File(replicatorConfDir,\"dynamic-\" + serviceName + \".role\");\n  this.clearDynamicProperties=Boolean.parseBoolean(System.getProperty(CLEAR_DYNAMIC_PROPERTIES));\n}", "comment": "creates a new instance .", "label": "what"}
{"id": "61631", "raw_code": "public void simulateMethod(SootMethod method,ReferenceVariable thisVar,ReferenceVariable returnVar,ReferenceVariable params[]){\n  String subSignature=method.getSubSignature();\n  if (subSignature.equals(\"java.lang.Object doPrivileged(java.security.PrivilegedAction)\")) {\n    java_security_AccessController_doPrivileged(method,thisVar,returnVar,params);\n    return;\n  }\n else   if (subSignature.equals(\"java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)\")) {\n    java_security_AccessController_doPrivileged(method,thisVar,returnVar,params);\n    return;\n  }\n else   if (subSignature.equals(\"java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)\")) {\n    java_security_AccessController_doPrivileged(method,thisVar,returnVar,params);\n    return;\n  }\n else   if (subSignature.equals(\"java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)\")) {\n    java_security_AccessController_doPrivileged(method,thisVar,returnVar,params);\n    return;\n  }\n else   if (subSignature.equals(\"java.security.AccessControlContext getStackAccessControlContext()\")) {\n    java_security_AccessController_getStackAccessControlContext(method,thisVar,returnVar,params);\n    return;\n  }\n else   if (subSignature.equals(\"java.security.AccessControlContext getInheritedAccessControlContext()\")) {\n    java_security_AccessController_getInheritedAccessControlContext(method,thisVar,returnVar,params);\n    return;\n  }\n else {\n    defaultMethod(method,thisVar,returnVar,params);\n    return;\n  }\n}", "comment": "implements the abstract method simulatemethod .", "label": "what"}
{"id": "31610", "raw_code": "public static String formatListToString(List<String> list){\n  String result=\"\";\n  for (  String s : list)   result+=s + \"\\t\\t\";\n  result=result.trim();\n  return result.toUpperCase();\n}", "comment": "formats the list objects from the pokemodel into formatted strings that are easily readable .", "label": "what"}
{"id": "45987", "raw_code": "@Override public void removeNotificationListener(NotificationListener listener) throws ListenerNotFoundException {\n  if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINEST)) {\n    SNMP_ADAPTOR_LOGGER.logp(Level.FINEST,dbgTag,\"removeNotificationListener\",\"Removing listener \" + listener);\n  }\n  notifBroadcaster.removeNotificationListener(listener);\n}", "comment": "removes the specified listener from this communicatorserver .", "label": "what"}
{"id": "8878", "raw_code": "private static String reportListContents(Collection<ProcessErrorStateInfo> errList){\n  if (errList == null)   return null;\n  StringBuilder builder=new StringBuilder();\n  Iterator<ProcessErrorStateInfo> iter=errList.iterator();\n  while (iter.hasNext()) {\n    ProcessErrorStateInfo entry=iter.next();\n    String condition;\nswitch (entry.condition) {\ncase ActivityManager.ProcessErrorStateInfo.CRASHED:\n      condition=\"a CRASH\";\n    break;\ncase ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING:\n  condition=\"an ANR\";\nbreak;\ndefault :\ncondition=\"an unknown error\";\nbreak;\n}\nbuilder.append(String.format(\"Process %s encountered %s (%s)\",entry.processName,condition,entry.shortMsg));\nif (entry.condition == ActivityManager.ProcessErrorStateInfo.CRASHED) {\nbuilder.append(String.format(\" with stack trace:\\n%s\\n\",entry.stackTrace));\n}\nbuilder.append(\"\\n\");\n}\nreturn builder.toString();\n}", "comment": "this helper function will dump the actual error reports .", "label": "what"}
{"id": "63205", "raw_code": "@Override public XADataSource createXADataSource(Properties properties) throws SQLException {\n  Properties propertiesCopy=new Properties();\n  if (properties != null) {\n    propertiesCopy.putAll(properties);\n  }\n  rejectUnsupportedOptions(propertiesCopy);\n  rejectPoolingOptions(propertiesCopy);\n  JdbcDataSource dataSource=new JdbcDataSource();\n  setupH2DataSource(dataSource,propertiesCopy);\n  return dataSource;\n}", "comment": "creates a pooled xa data source .", "label": "what"}
{"id": "37570", "raw_code": "protected Instance specifier(int i){\n  return m_Specifiers.get(i);\n}", "comment": "get the template at the given position .", "label": "what"}
{"id": "67864", "raw_code": "public void writeTag(String tag,Font value){\n  startTag(tag);\n  writeTag(\"name\",value.getName());\n  int style=value.getStyle();\n  if ((style & Font.BOLD) != 0 && (style & Font.ITALIC) != 0) {\n    writeTag(STYLE,\"BOLDITALIC\");\n  }\n else   if ((style & Font.BOLD) != 0) {\n    writeTag(STYLE,\"BOLD\");\n  }\n else   if ((style & Font.ITALIC) != 0) {\n    writeTag(STYLE,\"ITALIC\");\n  }\n else {\n    writeTag(STYLE,\"PLAIN\");\n  }\n  writeTag(\"size\",value.getSize());\n  closeTag();\n}", "comment": "writes < tag > value < / tag > to output stream", "label": "what"}
{"id": "77767", "raw_code": "private void internalWrite(byte[] b,int off,int len,boolean finish) throws IOException {\n  coder.output=embiggen(coder.output,coder.maxOutputSize(len));\n  if (!coder.process(b,off,len,finish)) {\n    throw new Base64DataException(\"bad base-64\");\n  }\n  out.write(coder.output,0,coder.op);\n}", "comment": "write the given bytes to the encoder / decoder .", "label": "what"}
{"id": "38205", "raw_code": "@Override public boolean batchFinished(){\n  if (getInputFormat() == null) {\n    throw new IllegalStateException(\"No input instance format defined\");\n  }\n  Instances toFilter=getInputFormat();\n  int cutOff=(int)Math.round(toFilter.numInstances() * m_Percentage / 100);\n  if (m_Inverse) {\n    for (int i=0; i < cutOff; i++) {\n      push(toFilter.instance(i));\n    }\n  }\n else {\n    for (int i=cutOff; i < toFilter.numInstances(); i++) {\n      push(toFilter.instance(i));\n    }\n  }\n  flushInput();\n  m_NewBatch=true;\n  m_FirstBatchDone=true;\n  return (numPendingOutput() != 0);\n}", "comment": "signify that this batch of input to the filter is finished .", "label": "what"}
{"id": "7132", "raw_code": "protected OkHttpClient configureHttpClient(){\n  final OkHttpClient.Builder builder=new OkHttpClient.Builder();\n  final CookieManager cookieManager=new CookieManager();\n  cookieManager.setCookiePolicy(CookiePolicy.ACCEPT_ALL);\n  builder.cookieJar(new JavaNetCookieJar(cookieManager));\n  builder.connectTimeout(60,TimeUnit.SECONDS);\n  builder.writeTimeout(60,TimeUnit.SECONDS);\n  builder.readTimeout(90,TimeUnit.SECONDS);\n  return builder.build();\n}", "comment": "configures the http client .", "label": "what"}
{"id": "66054", "raw_code": "public String parseFile(File file){\n  log.config(file.getAbsolutePath());\n  String line=null;\n  try {\n    BufferedReader in=new BufferedReader(new InputStreamReader(new FileInputStream(file),Ini.getCharset()),10240);\n    String errMsg=\"\";\n    int lineNo=1;\n    while ((line=in.readLine()) != null && errMsg.length() == 0) {\n      errMsg=parseLine(line,lineNo);\n      lineNo++;\n    }\n    line=null;\n    in.close();\n    if (errMsg.length() != 0)     return errMsg;\n  }\n catch (  Exception ioe) {\n    String s=ioe.getLocalizedMessage();\n    if (s == null || s.length() == 0)     s=ioe.toString();\n    return \"Parse Error: Line=\" + line + \" - \"+ s;\n  }\n  return \"\";\n}", "comment": "read and parse file", "label": "what"}
{"id": "74468", "raw_code": "public void load(Element element,Object o){\n  log.error(\"load(Element, Object) called unexpectedly\");\n}", "comment": "update static data from xml file", "label": "what"}
{"id": "11233", "raw_code": "public OMRaster(double lt,double ln,int offset_x1,int offset_y1,ImageIcon ii){\n  this(lt,ln,offset_x1,offset_y1,ii.getImage());\n}", "comment": "create an omraster , lat / lon with x / y placement with an imageicon .", "label": "what"}
{"id": "46710", "raw_code": "public void propertyChange(PropertyChangeEvent evt){\n  String name=evt.getPropertyName();\n  if (name == \"width\" || name == \"preferredWidth\") {\n    invalidateWidthCache();\n    fireColumnMarginChanged();\n  }\n}", "comment": "property change listener change method .", "label": "what"}
{"id": "43521", "raw_code": "public static void assertEquals(Object object1,Object object2){\n  checkAssertion(object1.equals(object2),null);\n}", "comment": "asserts that given object1 equals object2 .", "label": "what"}
{"id": "35374", "raw_code": "public void compileProjects(List<File> projects,IssueAcceptor issueAcceptor) throws N4JSCompileException {\n  compileProjects(Arrays.asList(new File(\".\")),projects,Collections.emptyList(),issueAcceptor);\n}", "comment": "compile a list of projects .", "label": "what"}
{"id": "4953", "raw_code": "protected final void print_contact_info(ObjectInfoPanel p_window,java.util.Locale p_locale){\n  Collection<BrdItem> contacts=get_normal_contacts();\n  if (contacts.isEmpty())   return;\n  GuiResources resources=r_board.newGuiResources(\"board.resources.ObjectInfoPanel\");\n  p_window.append(\", \" + resources.getString(\"contacts\") + \" \");\n  Integer contact_count=contacts.size();\n  p_window.append_items(contact_count.toString(),resources.getString(\"contact_info\"),contacts);\n}", "comment": "internal function used in the implementation of print _ info", "label": "what"}
{"id": "85720", "raw_code": "@SuppressWarnings(\"unchecked\") public Promise<Result,Progress> resolve(Result result){\n  List<DoneCallback<Result>> doneCallbacks;\n  List<AlwaysCallback> alwaysCallbacks;\nsynchronized (this) {\n    validateInPendingState();\n    mState=STATE_RESOLVED;\n    printStateChanged(\"RESOLVED\");\n    mResult=result;\n    doneCallbacks=mCallbacks.cloneDoneCallbacks();\n    alwaysCallbacks=mCallbacks.cloneAlwaysCallbacks();\n    clearCallbacks();\n  }\n  if (doneCallbacks.size() > 0 || alwaysCallbacks.size() > 0) {\n    triggerAllDones(doneCallbacks);\n    triggerAllAlways(alwaysCallbacks);\n  }\n  return this;\n}", "comment": "resolves the promise , triggers any done / always callbacks", "label": "what"}
{"id": "21675", "raw_code": "private void createSnapshot(BlockSnapshot snapshot,Snap unitySnap,StorageSystem storage,DbClient dbClient){\n  snapshot.setNativeId(unitySnap.getId());\n  snapshot.setNativeGuid(NativeGUIDGenerator.generateNativeGuid(storage,snapshot));\n  snapshot.setDeviceLabel(unitySnap.getName());\n  snapshot.setIsSyncActive(true);\n  snapshot.setInactive(false);\n  snapshot.setCreationTime(Calendar.getInstance());\n  snapshot.setWWN(unitySnap.getAttachedWWN());\n  snapshot.setAllocatedCapacity(unitySnap.getSize());\n  snapshot.setProvisionedCapacity(unitySnap.getSize());\n  dbClient.createObject(snapshot);\n}", "comment": "create the blocksnapshot in db", "label": "what"}
{"id": "43955", "raw_code": "public void save() throws IOException {\n  if (!props.isEmpty()) {\n    ConfigurationUtil.saveConfigurationProperties(props,propsFile,false);\n  }\n  ConfigurationUtil.saveConfigurationProperties(props,new File(propsFile.getParentFile(),propsFile.getName() + \".default\"),true);\n}", "comment": "saves the currently known settings .", "label": "what"}
{"id": "29929", "raw_code": "public String buildUri(String representationId,int segmentNumber,int bandwidth,long time){\n  StringBuilder builder=new StringBuilder();\n  for (int i=0; i < identifierCount; i++) {\n    builder.append(urlPieces[i]);\n    if (identifiers[i] == REPRESENTATION_ID) {\n      builder.append(representationId);\n    }\n else     if (identifiers[i] == NUMBER_ID) {\n      builder.append(String.format(Locale.US,identifierFormatTags[i],segmentNumber));\n    }\n else     if (identifiers[i] == BANDWIDTH_ID) {\n      builder.append(String.format(Locale.US,identifierFormatTags[i],bandwidth));\n    }\n else     if (identifiers[i] == TIME_ID) {\n      builder.append(String.format(Locale.US,identifierFormatTags[i],time));\n    }\n  }\n  builder.append(urlPieces[identifierCount]);\n  return builder.toString();\n}", "comment": "constructs a uri from the template , substituting in the provided arguments .", "label": "what"}
{"id": "40044", "raw_code": "void renderNormal(){\n  glEnable(GL_DEPTH_TEST);\n  glUseProgram(this.normalProgram);\n  glUniformMatrix4fv(viewMatrixUniform,false,viewMatrix.get(matrixBuffer));\n  glUniformMatrix4fv(projMatrixUniform,false,projMatrix.get(matrixBuffer));\n  glUniformMatrix3fv(normalMatrixUniform,false,normalMatrix.get(matrixBuffer));\n  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT,fbo);\n  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n  glBindBuffer(GL_ARRAY_BUFFER,this.cubeVbo);\n  glEnableVertexAttribArray(0);\n  glVertexAttribPointer(0,3,GL_FLOAT,false,0,0L);\n  glEnableVertexAttribArray(1);\n  glVertexAttribPointer(1,3,GL_FLOAT,false,0,normalsOffset);\n  glDrawArrays(GL_TRIANGLES,0,numVertices);\n  glDisableVertexAttribArray(0);\n  glDisableVertexAttribArray(1);\n  glBindBuffer(GL_ARRAY_BUFFER,0);\n  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT,0);\n  glUseProgram(0);\n}", "comment": "render the normals into a texture .", "label": "what"}
{"id": "20510", "raw_code": "private void calcYValueSum(){\n  mYValueSum=0;\n  for (int i=0; i < mYVals.size(); i++) {\n    Entry e=mYVals.get(i);\n    if (e != null)     mYValueSum+=Math.abs(e.getVal());\n  }\n}", "comment": "calculates the sum of all y - values", "label": "what"}
{"id": "19620", "raw_code": "@Override public boolean release(int decrement){\n  if (isEmpty) {\n    return false;\n  }\n  if (decrement < 1) {\n    throw new IllegalStateException(String.format(\"release(%d) argument is not positive. Buffer Info: %s\",decrement,toVerboseString()));\n  }\n  final int refCnt=ledger.decrement(decrement);\n  if (BaseAllocator.DEBUG) {\n    historicalLog.recordEvent(\"release(%d). original value: %d\",decrement,refCnt + decrement);\n  }\n  if (refCnt < 0) {\n    throw new IllegalStateException(String.format(\"ArrowBuf[%d] refCnt has gone negative. Buffer Info: %s\",id,toVerboseString()));\n  }\n  return refCnt == 0;\n}", "comment": "release the provided number of reference counts .", "label": "what"}
{"id": "3793", "raw_code": "public ConnectionTcp findConnectionByThreadId(long threadId){\n  for (  PortTcp listener : getPorts()) {\n    ConnectionTcp conn=listener.findConnectionByThreadId(threadId);\n    if (conn != null)     return conn;\n  }\n  return null;\n}", "comment": "finds the tcpconnection given the threadid", "label": "what"}
{"id": "53140", "raw_code": "public UniformDistribution estimate(double min,double max,final int count){\n  double grow=(count > 1) ? 0.5 * (max - min) / (count - 1) : 0.;\n  return new UniformDistribution(Math.max(min - grow,-Double.MAX_VALUE),Math.min(max + grow,Double.MAX_VALUE));\n}", "comment": "estimate from simple characteristics .", "label": "what"}
{"id": "56414", "raw_code": "public static RepositoryMetaData readFrom(StreamInput in) throws IOException {\n  String name=in.readString();\n  String type=in.readString();\n  Settings settings=Settings.readSettingsFromStream(in);\n  return new RepositoryMetaData(name,type,settings);\n}", "comment": "reads repository metadata from stream input", "label": "what"}
{"id": "43840", "raw_code": "public static boolean isPrimitiveDatatype(IRI datatype){\n  return datatype.equals(XMLSchema.DURATION) || datatype.equals(XMLSchema.DATETIME) || datatype.equals(XMLSchema.TIME)|| datatype.equals(XMLSchema.DATE)|| datatype.equals(XMLSchema.GYEARMONTH)|| datatype.equals(XMLSchema.GYEAR)|| datatype.equals(XMLSchema.GMONTHDAY)|| datatype.equals(XMLSchema.GDAY)|| datatype.equals(XMLSchema.GMONTH)|| datatype.equals(XMLSchema.STRING)|| datatype.equals(XMLSchema.BOOLEAN)|| datatype.equals(XMLSchema.BASE64BINARY)|| datatype.equals(XMLSchema.HEXBINARY)|| datatype.equals(XMLSchema.FLOAT)|| datatype.equals(XMLSchema.DECIMAL)|| datatype.equals(XMLSchema.DOUBLE)|| datatype.equals(XMLSchema.ANYURI)|| datatype.equals(XMLSchema.QNAME)|| datatype.equals(XMLSchema.NOTATION);\n}", "comment": "checks whether the supplied datatype is a primitive xml schema datatype .", "label": "what"}
{"id": "73787", "raw_code": "protected void appendLine(JComponent c){\n  c.setAlignmentX(0.f);\n  contents.add(c);\n}", "comment": "handle gui layout details during construction .", "label": "what"}
{"id": "5912", "raw_code": "public void postProcess(){\n  if (foreignColumnName != null) {\n    foreignAutoRefresh=true;\n  }\n  if (foreignAutoRefresh && maxForeignAutoRefreshLevel == DatabaseField.NO_MAX_FOREIGN_AUTO_REFRESH_LEVEL_SPECIFIED) {\n    maxForeignAutoRefreshLevel=DatabaseField.DEFAULT_MAX_FOREIGN_AUTO_REFRESH_LEVEL;\n  }\n}", "comment": "process the settings when we are going to consume them .", "label": "what"}
{"id": "18145", "raw_code": "public boolean contains(Node s){\n  runTo(-1);\n  if (null == m_map)   return false;\n  for (int i=0; i < m_firstFree; i++) {\n    Node node=m_map[i];\n    if ((null != node) && node.equals(s))     return true;\n  }\n  return false;\n}", "comment": "tell if the table contains the given node .", "label": "what"}
{"id": "78255", "raw_code": "private void persistNewTemp(File fileCfg){\n  if (hsDeleteOnExit.size() == 0) {\n    logDebug(LogArea.CONFIG,\"No temp file names to persist on exit.\");\n    fileCfg.delete();\n    return;\n  }\n  logDebug(LogArea.CONFIG,\"Persisting %d temp file names into %s\",hsDeleteOnExit.size(),fileCfg.getAbsolutePath());\n  BufferedWriter writer=null;\n  try {\n    writer=new BufferedWriter(new FileWriter(fileCfg));\n    for (    File file : hsDeleteOnExit) {\n      if (!file.delete()) {\n        String f=file.getCanonicalPath();\n        writer.write(f);\n        writer.newLine();\n        logWarn(LogArea.JAR,\"JVM failed to release %s\",f);\n      }\n    }\n  }\n catch (  IOException e) {\n  }\n finally {\n    if (writer != null) {\n      try {\n        writer.close();\n      }\n catch (      IOException e) {\n      }\n    }\n  }\n}", "comment": "creates file with temporary files list .", "label": "what"}
{"id": "78646", "raw_code": "public void addWritten(byte[] value){\n  writeSetLock.lock();\n  writeSet.add(new TimestampValuePair(ets,value));\n  writeSetLock.unlock();\n}", "comment": "add a value that shall be written to the writeset", "label": "what"}
{"id": "70116", "raw_code": "public void load(Entity unit) throws IllegalArgumentException {\n  if (!canLoad(unit)) {\n    throw new IllegalArgumentException(\"Can not load \" + unit.getShortName() + \" into this bay.\");\n  }\n  currentSpace-=1;\n  troops.addElement(unit.getId());\n}", "comment": "load the given unit .", "label": "what"}
{"id": "47311", "raw_code": "public void finish() throws IOException {\n  if (!def.finished()) {\n    def.finish();\n    while (!def.finished()) {\n      int len=def.deflate(buf,0,buf.length);\n      if (def.finished() && len <= buf.length - TRAILER_SIZE) {\n        writeTrailer(buf,len);\n        len=len + TRAILER_SIZE;\n        out.write(buf,0,len);\n        return;\n      }\n      if (len > 0)       out.write(buf,0,len);\n    }\n    byte[] trailer=new byte[TRAILER_SIZE];\n    writeTrailer(trailer,0);\n    out.write(trailer);\n  }\n}", "comment": "finishes writing compressed data to the output stream without closing the underlying stream .", "label": "what"}
{"id": "3959", "raw_code": "public boolean free(T obj){\n  AtomicInteger topRef=_top;\n  while (true) {\n    final int top=topRef.get();\n    if (_capacity <= top) {\n      return false;\n    }\n    boolean isFree=_freeStack.compareAndSet(top,null,obj);\n    topRef.compareAndSet(top,top + 1);\n    if (isFree) {\n      return true;\n    }\n  }\n}", "comment": "frees the object .", "label": "what"}
{"id": "19890", "raw_code": "private OpenReplicatorManagerMBean createInternalService(String serviceName) throws ReplicatorException {\n  logger.info(\"Starting replication service: name=\" + serviceName);\n  try {\n    OpenReplicatorManager orm=new OpenReplicatorManager(serviceName);\n    orm.setRmiHost(managerRMIHost);\n    orm.setRmiPort(managerRMIPort);\n    orm.setHostTimeZone(hostTimeZone);\n    orm.setReplicatorTimeZone(replicatorTimeZone);\n    orm.advertiseInternal();\n    orm.setSecurityInfo(this.securityInfo);\n    return (OpenReplicatorManagerMBean)orm;\n  }\n catch (  Exception e) {\n    throw new ReplicatorException(String.format(\"Unable to instantiate replication service '%s'\",serviceName),e);\n  }\n}", "comment": "creates a replication service that will run as a thread internal to the replicationservicemanager .", "label": "what"}
{"id": "76936", "raw_code": "public static CheckIndex.Status checkIndex(Directory dir) throws IOException {\n  return checkIndex(dir,true);\n}", "comment": "this runs the checkindex tool on the index in .", "label": "what"}
{"id": "54740", "raw_code": "private void startHideAnimations(){\n  animationPlaying=true;\n  lightAnimationLayout();\n  if (buttonType.equals(ButtonType.CIRCLE)) {\n    if (hideOrderType.equals(OrderType.DEFAULT)) {\n      for (int i=0; i < buttonNum; i++) {\n        setHideAnimation(dots[i],circleButtons[i],endLocations[i],startLocations[i],i);\n      }\n    }\n else     if (hideOrderType.equals(OrderType.REVERSE)) {\n      for (int i=0; i < buttonNum; i++) {\n        setHideAnimation(dots[i],circleButtons[i],endLocations[i],startLocations[i],buttonNum - i - 1);\n      }\n    }\n else     if (hideOrderType.equals(OrderType.RANDOM)) {\n      Random random=new Random();\n      boolean[] used=new boolean[buttonNum];\n      for (int i=0; i < buttonNum; i++)       used[i]=false;\n      int count=0;\n      while (true) {\n        int i=random.nextInt(buttonNum);\n        if (!used[i]) {\n          used[i]=true;\n          setHideAnimation(dots[count],circleButtons[count],endLocations[count],startLocations[count],i);\n          count++;\n          if (count == buttonNum)           break;\n        }\n      }\n    }\n  }\n else   if (buttonType.equals(ButtonType.HAM)) {\n    if (hideOrderType.equals(OrderType.DEFAULT)) {\n      for (int i=0; i < buttonNum; i++) {\n        setHideAnimation(bars[i],hamButtons[i],endLocations[i],startLocations[i],i);\n      }\n    }\n else     if (hideOrderType.equals(OrderType.REVERSE)) {\n      for (int i=0; i < buttonNum; i++) {\n        setHideAnimation(bars[i],hamButtons[i],endLocations[i],startLocations[i],buttonNum - i - 1);\n      }\n    }\n else     if (hideOrderType.equals(OrderType.RANDOM)) {\n      Random random=new Random();\n      boolean[] used=new boolean[buttonNum];\n      for (int i=0; i < buttonNum; i++)       used[i]=false;\n      int count=0;\n      while (true) {\n        int i=random.nextInt(buttonNum);\n        if (!used[i]) {\n          used[i]=true;\n          setHideAnimation(bars[count],hamButtons[count],endLocations[count],startLocations[count],i);\n          count++;\n          if (count == buttonNum)           break;\n        }\n      }\n    }\n  }\n}", "comment": "start all animations about dismissing .", "label": "what"}
{"id": "32032", "raw_code": "public static void putShort(long addr,short val){\n  if (UNALIGNED)   UNSAFE.putShort(addr,val);\n else   putShortByByte(addr,val,BIG_ENDIAN);\n}", "comment": "stores given short value .", "label": "what"}
{"id": "12649", "raw_code": "public PronounceableFSM(URL url,boolean scanFromFront) throws IOException {\n  this.scanFromFront=scanFromFront;\n  InputStream is=Utilities.getInputStream(url);\n  loadText(is);\n  is.close();\n}", "comment": "constructs a pronounceablefsm with information in the given url .", "label": "what"}
{"id": "74862", "raw_code": "private char[] applyFloatPadding(final char[] ca4,final boolean noDigits){\n  char[] ca5=ca4;\n  if (fieldWidthSet) {\n    int i;\n    int j;\n    final int nBlanks;\n    if (leftJustify) {\n      nBlanks=fieldWidth - ca4.length;\n      if (nBlanks > 0) {\n        ca5=new char[ca4.length + nBlanks];\n        for (i=0; i < ca4.length; i++) {\n          ca5[i]=ca4[i];\n        }\n        for (j=0; j < nBlanks; j++, i++) {\n          ca5[i]=' ';\n        }\n      }\n    }\n else     if (!leadingZeros || noDigits) {\n      nBlanks=fieldWidth - ca4.length;\n      if (nBlanks > 0) {\n        ca5=new char[ca4.length + nBlanks];\n        for (i=0; i < nBlanks; i++) {\n          ca5[i]=' ';\n        }\n        for (j=0; j < ca4.length; i++, j++) {\n          ca5[i]=ca4[j];\n        }\n      }\n    }\n else     if (leadingZeros) {\n      nBlanks=fieldWidth - ca4.length;\n      if (nBlanks > 0) {\n        ca5=new char[ca4.length + nBlanks];\n        i=0;\n        j=0;\n        if (ca4[0] == '-') {\n          ca5[0]='-';\n          i++;\n          j++;\n        }\n        for (int k=0; k < nBlanks; i++, k++) {\n          ca5[i]='0';\n        }\n        for (; j < ca4.length; i++, j++) {\n          ca5[i]=ca4[j];\n        }\n      }\n    }\n  }\n  return ca5;\n}", "comment": "apply zero or blank , left or right padding .", "label": "what"}
{"id": "14168", "raw_code": "@Override public void makeImmutable(){\n  if (isMutable) {\n    if (authnStatements != null) {\n      int length=authnStatements.size();\n      for (int i=0; i < length; i++) {\n        AuthnStatement authn=(AuthnStatement)authnStatements.get(i);\n        authn.makeImmutable();\n      }\n      authnStatements=Collections.unmodifiableList(authnStatements);\n    }\n    if (authzDecisionStatements != null) {\n      int length=authzDecisionStatements.size();\n      for (int i=0; i < length; i++) {\n        AuthzDecisionStatement authz=(AuthzDecisionStatement)authzDecisionStatements.get(i);\n        authz.makeImmutable();\n      }\n      authzDecisionStatements=Collections.unmodifiableList(authzDecisionStatements);\n    }\n    if (attributeStatements != null) {\n      int length=attributeStatements.size();\n      for (int i=0; i < length; i++) {\n        AttributeStatement attr=(AttributeStatement)attributeStatements.get(i);\n        attr.makeImmutable();\n      }\n      attributeStatements=Collections.unmodifiableList(attributeStatements);\n    }\n    if (statements != null) {\n      statements=Collections.unmodifiableList(statements);\n    }\n    if (conditions != null) {\n      conditions.makeImmutable();\n    }\n    if (issuer != null) {\n      issuer.makeImmutable();\n    }\n    if (subject != null) {\n      subject.makeImmutable();\n    }\n    if (advice != null) {\n      advice.makeImmutable();\n    }\n    isMutable=false;\n  }\n}", "comment": "makes the object immutable", "label": "what"}
{"id": "73521", "raw_code": "public void removeComponentListener(final ComponentUpdateListener listener){\n  componentListeners.remove(listener);\n}", "comment": "removes a component listener from this instance .", "label": "what"}
{"id": "27940", "raw_code": "protected byte[] assertEncodeDecode(final IGangliaMetadataMessage decl,final IGangliaMessage expected){\n  if (expected == null)   throw new IllegalArgumentException();\n  final XDROutputBuffer xdr=new XDROutputBuffer(IGangliaDefaults.BUFFER_SIZE);\n  final GangliaMessageEncoder31 messageEncoder=new GangliaMessageEncoder31();\n  final GangliaMessageDecoder31 messageDecoder=new GangliaMessageDecoder31();\n  if (expected.isMetricRequest()) {\n    messageEncoder.writeRequest(xdr,(IGangliaRequestMessage)expected);\n  }\n else   if (expected.isMetricMetadata()) {\n    messageEncoder.writeMetadata(xdr,(IGangliaMetadataMessage)expected);\n  }\n else   if (expected.isMetricValue()) {\n    if (decl == null)     throw new IllegalArgumentException(\"Declaration required for metric value record\");\n    messageEncoder.writeMetric(xdr,decl,(IGangliaMetricMessage)expected);\n  }\n else {\n    throw new AssertionError();\n  }\n  final IGangliaMessage actual=messageDecoder.decode(xdr.getBuffer(),0,xdr.getLength());\n  assertEquals(\"messages not equal()\",expected,actual);\n  final byte[] actualData=new byte[xdr.getLength()];\n  System.arraycopy(xdr.getBuffer(),0,actualData,0,actualData.length);\n  return actualData;\n}", "comment": "verify that we can encode and decode a record .", "label": "what"}
{"id": "76756", "raw_code": "private boolean isIndexable(String term){\n  return (term.length() < 30) && (term.length() > 2);\n}", "comment": "checks a term if it can be processed indexed .", "label": "what"}
{"id": "55155", "raw_code": "private void sendResponse(String status,String mime,Properties header,InputStream data){\n  try {\n    if (status == null)     throw new Error(\"sendResponse(): Status can't be null.\");\n    OutputStream out=mySocket.getOutputStream();\n    PrintWriter pw=new PrintWriter(out);\n    pw.print(\"HTTP/1.0 \" + status + \" \\r\\n\");\n    if (mime != null)     pw.print(\"Content-Type: \" + mime + \"\\r\\n\");\n    if (header == null || header.getProperty(\"Date\") == null)     pw.print(\"Date: \" + gmtFrmt.format(new Date()) + \"\\r\\n\");\n    if (header != null) {\n      Enumeration e=header.keys();\n      while (e.hasMoreElements()) {\n        String key=(String)e.nextElement();\n        String value=header.getProperty(key);\n        pw.print(key + \": \" + value+ \"\\r\\n\");\n      }\n    }\n    pw.print(\"\\r\\n\");\n    pw.flush();\n    if (data != null) {\n      byte[] buff=new byte[2048];\n      while (true) {\n        int read=data.read(buff,0,2048);\n        if (read <= 0)         break;\n        out.write(buff,0,read);\n      }\n    }\n    out.flush();\n    out.close();\n    if (data != null)     data.close();\n  }\n catch (  IOException ioe) {\n    try {\n      mySocket.close();\n    }\n catch (    Throwable t) {\n    }\n  }\n}", "comment": "sends given response to the socket .", "label": "what"}
{"id": "15309", "raw_code": "public static String decode(String encoded,AMEncryption encr){\n  if (checkCaller()) {\n    try {\n      ISSecurityPermission isp=new ISSecurityPermission(\"access\",\"adminpassword\");\n      if (securityManager != null) {\n        securityManager.checkPermission(isp);\n      }\n    }\n catch (    SecurityException e) {\n      Debug debug=Debug.getInstance(\"amSDK\");\n      debug.error(\"Security Alert: Unauthorized access to \" + \"Encoding/Decoding password utility: Returning NULL\",e);\n      return null;\n    }\n  }\n  if (encoded == null || encoded.length() == 0) {\n    return (null);\n  }\n  byte[] encData=null;\n  encData=Base64.decode(encoded.trim());\n  if (encData == null) {\n    return null;\n  }\n  byte[] rawData=encr.decrypt(encData);\n  if (rawData == null) {\n    return (null);\n  }\n  String answer=null;\n  try {\n    answer=new String(rawData,\"utf-8\");\n  }\n catch (  UnsupportedEncodingException uue) {\n    Debug debug=Debug.getInstance(\"amSDK\");\n    debug.error(\"Crypt:: Unsupported encoding UTF-8\",uue);\n    answer=new String(rawData);\n  }\n  return (answer);\n}", "comment": "decode an encoded string", "label": "what"}
{"id": "25005", "raw_code": "public void addConnection(Connection connection){\n  if (connection == null)   throw new IllegalArgumentException(\"connection cannot be null.\");\nsynchronized (connectionsLock) {\n    Connection[] newConnections=new Connection[connections.length + 1];\n    newConnections[0]=connection;\n    System.arraycopy(connections,0,newConnections,1,connections.length);\n    connections=newConnections;\n  }\n  connection.addListener(invokeListener);\n  if (TRACE)   trace(\"kryonet\",\"Added connection to ObjectSpace: \" + connection);\n}", "comment": "allows the remote end of the specified connection to access objects registered in this objectspace .", "label": "what"}
{"id": "49124", "raw_code": "@Override public void run(){\n  try {\n    for (; ; ) {\n      int n=portGetn(port,bufferAddress,MAX_EVENT_COUNT);\n      assert n > 0;\n      long address=bufferAddress;\n      for (int i=0; i < n; i++) {\n        boolean shutdown=processEvent(address);\n        if (shutdown)         return;\n        address+=SIZEOF_PORT_EVENT;\n      }\n    }\n  }\n catch (  UnixException x) {\n    x.printStackTrace();\n  }\n}", "comment": "poller main loop .", "label": "what"}
{"id": "55942", "raw_code": "@Override public List<String> allKeys(){\n  List<String> nameFiles=new ArrayList<>();\n  File[] files=cacheDirectory.listFiles();\n  if (files == null)   return nameFiles;\n  for (  File file : files) {\n    if (file.isFile()) {\n      nameFiles.add(file.getName());\n    }\n  }\n  return nameFiles;\n}", "comment": "retrieve the names from all files in dir", "label": "what"}
{"id": "56598", "raw_code": "@Override default CompletableFuture<OptionalDouble> minDouble(final ToDoubleFunction<? super T> fn){\n  return CompletableFuture.supplyAsync(null,getExec());\n}", "comment": "perform an asynchronous min operation", "label": "what"}
{"id": "3948", "raw_code": "private boolean toState(LifecycleState newState){\n  LifecycleState state;\nsynchronized (this) {\n    state=_state;\n    _state=newState;\n    _lastChangeTime=CurrentTime.currentTime();\n  }\n  if (_log != null && _log.isLoggable(_lowLevel)) {\n    _log.log(_lowLevel,newState + \" \" + _name);\n  }\n  notifyListeners(state,newState);\n  return true;\n}", "comment": "changes to the next state .", "label": "what"}
{"id": "65890", "raw_code": "public boolean initDialog(){\n  log.config(\"\");\n  gbc.anchor=GridBagConstraints.NORTHWEST;\n  gbc.weightx=0;\n  gbc.weighty=0;\n  gbc.gridy=m_line++;\n  gbc.gridx=0;\n  gbc.gridwidth=1;\n  gbc.insets=nullInset;\n  gbc.fill=GridBagConstraints.HORIZONTAL;\n  centerPanel.add(Box.createVerticalStrut(10),gbc);\n  MClient client=MClient.get(Env.getCtx());\n  String ASPFilter=\"\";\n  if (client.isUseASP())   ASPFilter=\"   AND (   p.AD_Process_Para_ID IN ( \" + \"              SELECT pp.AD_Process_Para_ID \" + \"                FROM ASP_Process_Para pp, ASP_Process p, ASP_Level l, ASP_ClientLevel cl \"+ \"               WHERE p.ASP_Level_ID = l.ASP_Level_ID \"+ \"                 AND cl.AD_Client_ID = \" + client.getAD_Client_ID() + \"                 AND cl.ASP_Level_ID = l.ASP_Level_ID \"+ \"                 AND pp.ASP_Process_ID = p.ASP_Process_ID \"+ \"                 AND pp.IsActive = 'Y' \"+ \"                 AND p.IsActive = 'Y' \"+ \"                 AND l.IsActive = 'Y' \"+ \"                 AND cl.IsActive = 'Y' \"+ \"                 AND pp.ASP_Status = 'S') \"+ \"        OR p.AD_Process_Para_ID IN ( \"+ \"              SELECT AD_Process_Para_ID \"+ \"                FROM ASP_ClientException ce \"+ \"               WHERE ce.AD_Client_ID = \"+ client.getAD_Client_ID()+ \"                 AND ce.IsActive = 'Y' \"+ \"                 AND ce.AD_Process_Para_ID IS NOT NULL \"+ \"                 AND ce.AD_Tab_ID IS NULL \"+ \"                 AND ce.AD_Field_ID IS NULL \"+ \"                 AND ce.ASP_Status = 'S') \"+ \"       ) \"+ \"   AND p.AD_Process_Para_ID NOT IN ( \"+ \"          SELECT AD_Process_Para_ID \"+ \"            FROM ASP_ClientException ce \"+ \"           WHERE ce.AD_Client_ID = \"+ client.getAD_Client_ID()+ \"             AND ce.IsActive = 'Y' \"+ \"             AND ce.AD_Process_Para_ID IS NOT NULL \"+ \"             AND ce.AD_Tab_ID IS NULL \"+ \"             AND ce.AD_Field_ID IS NULL \"+ \"             AND ce.ASP_Status = 'H')\";\n  String sql=null;\n  if (Env.isBaseLanguage(Env.getCtx(),\"AD_Process_Para\"))   sql=\"SELECT p.Name, p.Description, p.Help, \" + \"p.AD_Reference_ID, p.AD_Process_Para_ID, \" + \"p.FieldLength, p.IsMandatory, p.IsRange, p.ColumnName, p.ReadOnlyLogic, p.DisplayLogic, \"+ \"p.DefaultValue, p.DefaultValue2, p.VFormat, p.ValueMin, p.ValueMax, \"+ \"p.SeqNo, p.AD_Reference_Value_ID, vr.Code AS ValidationCode \"+ \"FROM AD_Process_Para p\"+ \" LEFT OUTER JOIN AD_Val_Rule vr ON (p.AD_Val_Rule_ID=vr.AD_Val_Rule_ID) \"+ \"WHERE p.AD_Process_ID=?\"+ \" AND p.IsActive='Y' \" + ASPFilter + \" ORDER BY SeqNo\";\n else   sql=\"SELECT t.Name, t.Description, t.Help, \" + \"p.AD_Reference_ID, p.AD_Process_Para_ID, \" + \"p.FieldLength, p.IsMandatory, p.IsRange, p.ColumnName, p.ReadOnlyLogic, p.DisplayLogic, \"+ \"p.DefaultValue, p.DefaultValue2, p.VFormat, p.ValueMin, p.ValueMax, \"+ \"p.SeqNo, p.AD_Reference_Value_ID, vr.Code AS ValidationCode \"+ \"FROM AD_Process_Para p\"+ \" INNER JOIN AD_Process_Para_Trl t ON (p.AD_Process_Para_ID=t.AD_Process_Para_ID)\"+ \" LEFT OUTER JOIN AD_Val_Rule vr ON (p.AD_Val_Rule_ID=vr.AD_Val_Rule_ID) \"+ \"WHERE p.AD_Process_ID=?\"+ \" AND t.AD_Language='\" + Env.getAD_Language(Env.getCtx()) + \"'\"+ \" AND p.IsActive='Y' \"+ ASPFilter+ \" ORDER BY SeqNo\";\n  boolean hasFields=false;\n  try {\n    PreparedStatement pstmt=DB.prepareStatement(sql,null);\n    pstmt.setInt(1,m_processInfo.getAD_Process_ID());\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      hasFields=true;\n      createField(rs);\n    }\n    rs.close();\n    pstmt.close();\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sql,e);\n  }\n  if (m_mFields.size() != m_mFields2.size() || m_mFields.size() != m_vEditors.size() || m_mFields2.size() != m_vEditors2.size())   log.log(Level.SEVERE,\"View & Model vector size is different\");\n  if (hasFields) {\n    gbc.gridy=m_line++;\n    centerPanel.add(Box.createVerticalStrut(10),gbc);\n    gbc.gridx=3;\n    centerPanel.add(Box.createHorizontalStrut(12),gbc);\n    AEnv.positionCenterWindow(m_frame,this);\n  }\n else   dispose();\n  return hasFields;\n}", "comment": "read fields to display", "label": "what"}
{"id": "83574", "raw_code": "public void swap(int i,int j){\n  x.assertTrue(i < list.size());\n  x.assertTrue(j < list.size());\n  list.set(i,list.set(j,list.get(i)));\n}", "comment": "swaps in place the elements at the specified positions in the specified list .", "label": "what"}
{"id": "14615", "raw_code": "public static boolean isMatch(String actualString,LinkedList patterns,char wildCard){\n  boolean matched=false;\n  for (ListIterator iter=patterns.listIterator(0); iter.hasNext(); ) {\n    if (isMatch(actualString,(String)iter.next(),wildCard)) {\n      matched=true;\n      break;\n    }\n  }\n  return matched;\n}", "comment": "check whether the string matches the pattern .", "label": "what"}
{"id": "74213", "raw_code": "public void addLeaf(CatalogTreeLeaf leaf){\n  _leaves.add(leaf);\n}", "comment": "append leaf to the end of the leaves list", "label": "what"}
{"id": "6023", "raw_code": "public HttpRequest contentLength(final String value){\n  return contentLength(Integer.parseInt(value));\n}", "comment": "set the ' content - length ' request header to the given value", "label": "what"}
{"id": "85801", "raw_code": "public boolean draw(Canvas canvas){\n  update();\n  final float centerX=mBounds.centerX();\n  final float centerY=mBounds.height() - mRadius;\n  canvas.scale(1.f,Math.min(mGlowScaleY,1.f) * mBaseGlowScale,centerX,0);\n  final float displacement=Math.max(0,Math.min(mDisplacement,1.f)) - 0.5f;\n  float translateX=mBounds.width() * displacement / 2;\n  mPaint.setAlpha((int)(0xff * mGlowAlpha));\n  canvas.drawCircle(centerX + translateX,centerY,mRadius,mPaint);\n  boolean oneLastFrame=false;\n  if (mState == STATE_RECEDE && mGlowScaleY == 0) {\n    mState=STATE_IDLE;\n    oneLastFrame=true;\n  }\n  return mState != STATE_IDLE || oneLastFrame;\n}", "comment": "draw into the provided canvas .", "label": "what"}
{"id": "22589", "raw_code": "public VNXeCommandJob modifyLunAsync(LunModifyParam param,String resourceId){\n  StringBuilder urlBld=new StringBuilder(URL_RESOURCE);\n  urlBld.append(resourceId);\n  urlBld.append(URL_LUN_MODIFY_ACTION);\n  _url=urlBld.toString();\n  return postRequestAsync(param);\n}", "comment": "modify lun ( export / unexport / expand etc ) in async mode", "label": "what"}
{"id": "42240", "raw_code": "public String replace(CharSequence target,CharSequence replacement){\n  if (target == null) {\n    throw new NullPointerException(\"target should not be null\");\n  }\n  if (replacement == null) {\n    throw new NullPointerException(\"replacement should not be null\");\n  }\n  String ts=target.toString();\n  int index=indexOf(ts,0);\n  if (index == -1)   return this;\n  String rs=replacement.toString();\n  StringBuilder buffer=new StringBuilder(count);\n  int tl=target.length();\n  int tail=0;\n  do {\n    buffer.append(value,offset + tail,index - tail);\n    buffer.append(rs);\n    tail=index + tl;\n  }\n while ((index=indexOf(ts,tail)) != -1);\n  buffer.append(value,offset + tail,count - tail);\n  return buffer.toString();\n}", "comment": "copies this string replacing occurrences of the specified target sequence with another sequence .", "label": "what"}
{"id": "44668", "raw_code": "public boolean similarTo(Object o){\n  if (o == null) {\n    return false;\n  }\n  if (!(o instanceof SemanticConcept)) {\n    return false;\n  }\n  SemanticConcept otherConcept=(SemanticConcept)o;\n  HashSet<Integer> synset_intersection=new HashSet<Integer>(this.synsets);\n  synset_intersection.retainAll(otherConcept.synsets);\n  if (!synset_intersection.isEmpty()) {\n    return true;\n  }\n  HashSet<String> concept_intersection=new HashSet<String>(this.concepts);\n  concept_intersection.retainAll(otherConcept.concepts);\n  return !concept_intersection.isEmpty();\n}", "comment": "semanticconcepts are similar if they share a synset or a concept", "label": "what"}
{"id": "16632", "raw_code": "public void jGoogleAnalyticsTracker(final String eventType,final String version,final String trackerId){\n  final JGoogleAnalyticsTracker tracker=new JGoogleAnalyticsTracker(\"vdi_calculator\",version,trackerId);\n  final FocusPoint focusPoint=new FocusPoint(eventType.toLowerCase());\n  tracker.trackAsynchronously(focusPoint);\n}", "comment": "google analytics usage tracking", "label": "what"}
{"id": "63656", "raw_code": "protected final Tuple addInternal(Tuple t){\n  if (m_tuples.add(t)) {\n    return t;\n  }\n else {\n    return null;\n  }\n}", "comment": "adds a tuple without firing a notification .", "label": "what"}
{"id": "75684", "raw_code": "@Override public void removeTableModelListener(TableModelListener l){\n  m_Listeners.remove(l);\n}", "comment": "removes a listener from the list that is notified each time a change to the data model occurs", "label": "what"}
{"id": "84111", "raw_code": "public StrBuilder replace(int startIndex,int endIndex,String replaceStr){\n  endIndex=validateRange(startIndex,endIndex);\n  int insertLen=(replaceStr == null ? 0 : replaceStr.length());\n  replaceImpl(startIndex,endIndex,endIndex - startIndex,replaceStr,insertLen);\n  return this;\n}", "comment": "replaces a portion of the string builder with another string .", "label": "what"}
{"id": "62228", "raw_code": "public static void addPermissionRecursive(Path path,PosixFilePermission permission) throws IOException {\n  changePermissionsRecursive(path,PermissionChange.ADD,Collections.singleton(permission));\n}", "comment": "recursively adds a permission to a directory .", "label": "what"}
{"id": "3557", "raw_code": "private void runTimeoutTask(){\n  while (isActive()) {\n    reapTimeouts();\n    try {\n      Thread.sleep(_timeoutReapInterval);\n    }\n catch (    Exception e) {\n    }\n  }\n}", "comment": "running process accepting connections .", "label": "what"}
{"id": "69271", "raw_code": "private static void checkArgReferences(String typeSnippet,int numberOfArgs){\n  Matcher argRefMatcher=ARG_REF_PATTERN.matcher(typeSnippet);\n  while (argRefMatcher.find()) {\n    int index=Integer.parseInt(argRefMatcher.group(1),10) - 1;\n    Preconditions.checkArgument(index >= 0,\"%s not allowed, indices start at 1\",argRefMatcher.group(0));\n    Preconditions.checkArgument(index < numberOfArgs,\"%s too large for number of provided type mirrors\",argRefMatcher.group(0));\n  }\n}", "comment": "check that all % d references in the given type snippet are within bounds .", "label": "what"}
{"id": "73254", "raw_code": "public void randomize(){\n  randomizeIncomingWeights();\n  normalizeIncomingWeights();\n}", "comment": "randomize and normalize weights .", "label": "what"}
{"id": "1516", "raw_code": "public static void saveAsImage(int x,int y,int width,int height,String path,CompressFormat compressFormat,int quality) throws FileNotFoundException {\n  Bitmap bmp=getPixelsFromBuffer(x,y,width,height);\n  try {\n    File file=new File(path);\n    try {\n      file.createNewFile();\n    }\n catch (    IOException e1) {\n      e1.printStackTrace();\n    }\n    FileOutputStream fos=new FileOutputStream(file);\n    bmp.compress(compressFormat,quality,fos);\n    try {\n      fos.flush();\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n    }\n    try {\n      fos.close();\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n    }\n  }\n catch (  FileNotFoundException e) {\n    throw (e);\n  }\n}", "comment": "saves the pixels from the buffer on the sd card .", "label": "what"}
{"id": "22799", "raw_code": "private boolean isFileValid(File file,String methodName){\n  if (file == null) {\n    Log.printConcatLine(name,\".\",methodName,\": Warning - the given file is null.\");\n    return false;\n  }\n  String fileName=file.getName();\n  if (fileName == null || fileName.length() == 0) {\n    Log.printConcatLine(name,\".\" + methodName,\": Warning - invalid file name.\");\n    return false;\n  }\n  return true;\n}", "comment": "check if the file is valid or not .", "label": "what"}
{"id": "66910", "raw_code": "public void removeSrcClass(SootClass clz){\n  srcClasses.remove(clz.getName());\n}", "comment": "remove a class from the list of src classes .", "label": "what"}
{"id": "16289", "raw_code": "private void updateRange(double value){\n  mMinValue=Math.min(mMinValue,value);\n  mMaxValue=Math.max(mMaxValue,value);\n}", "comment": "updates the values range .", "label": "what"}
{"id": "84052", "raw_code": "public static boolean enoughSpaceOnPhone(long updateSize){\n  return getRealSizeOnPhone() > updateSize;\n}", "comment": "checks if there is enough space on phone self", "label": "what"}
{"id": "57668", "raw_code": "public void addAttribute(AttributedCharacterIterator.Attribute attribute,Object value){\n  if (attribute == null) {\n    throw new NullPointerException(\"attribute == null\");\n  }\n  if (text.isEmpty()) {\n    throw new IllegalArgumentException(\"text is empty\");\n  }\n  List<Range> ranges=attributeMap.get(attribute);\n  if (ranges == null) {\n    ranges=new ArrayList<Range>(1);\n    attributeMap.put(attribute,ranges);\n  }\n else {\n    ranges.clear();\n  }\n  ranges.add(new Range(0,text.length(),value));\n}", "comment": "applies a given attribute to this string .", "label": "what"}
{"id": "20186", "raw_code": "public GeoServerWPSClient(GeoServerConnection connection){\n  this.connection=connection;\n}", "comment": "instantiates a new geo server wps client .", "label": "what"}
{"id": "57354", "raw_code": "protected ConnectionStateSSLv3(SSLSessionImpl session){\n  try {\n    CipherSuite cipherSuite=session.cipherSuite;\n    boolean is_exportabe=cipherSuite.isExportable();\n    hash_size=cipherSuite.getMACLength();\n    int key_size=(is_exportabe) ? cipherSuite.keyMaterial : cipherSuite.expandedKeyMaterial;\n    int iv_size=cipherSuite.ivSize;\n    block_size=cipherSuite.getBlockSize();\n    String algName=cipherSuite.getBulkEncryptionAlgorithm();\n    String hashName=cipherSuite.getHashName();\n    if (logger != null) {\n      logger.println(\"ConnectionStateSSLv3.create:\");\n      logger.println(\"  cipher suite name: \" + session.getCipherSuite());\n      logger.println(\"  encryption alg name: \" + algName);\n      logger.println(\"  hash alg name: \" + hashName);\n      logger.println(\"  hash size: \" + hash_size);\n      logger.println(\"  block size: \" + block_size);\n      logger.println(\"  IV size:\" + iv_size);\n      logger.println(\"  key size: \" + key_size);\n    }\n    byte[] clientRandom=session.clientRandom;\n    byte[] serverRandom=session.serverRandom;\n    byte[] key_block=new byte[2 * hash_size + 2 * key_size + 2 * iv_size];\n    byte[] seed=new byte[clientRandom.length + serverRandom.length];\n    System.arraycopy(serverRandom,0,seed,0,serverRandom.length);\n    System.arraycopy(clientRandom,0,seed,serverRandom.length,clientRandom.length);\n    PRF.computePRF_SSLv3(key_block,session.master_secret,seed);\n    byte[] client_mac_secret=new byte[hash_size];\n    byte[] server_mac_secret=new byte[hash_size];\n    byte[] client_key=new byte[key_size];\n    byte[] server_key=new byte[key_size];\n    boolean is_client=!session.isServer;\n    System.arraycopy(key_block,0,client_mac_secret,0,hash_size);\n    System.arraycopy(key_block,hash_size,server_mac_secret,0,hash_size);\n    System.arraycopy(key_block,2 * hash_size,client_key,0,key_size);\n    System.arraycopy(key_block,2 * hash_size + key_size,server_key,0,key_size);\n    IvParameterSpec clientIV=null;\n    IvParameterSpec serverIV=null;\n    if (is_exportabe) {\n      if (logger != null) {\n        logger.println(\"ConnectionStateSSLv3: is_exportable\");\n      }\n      MessageDigest md5=MessageDigest.getInstance(\"MD5\");\n      md5.update(client_key);\n      md5.update(clientRandom);\n      md5.update(serverRandom);\n      client_key=md5.digest();\n      md5.update(server_key);\n      md5.update(serverRandom);\n      md5.update(clientRandom);\n      server_key=md5.digest();\n      key_size=cipherSuite.expandedKeyMaterial;\n      if (block_size != 0) {\n        md5.update(clientRandom);\n        md5.update(serverRandom);\n        clientIV=new IvParameterSpec(md5.digest(),0,iv_size);\n        md5.update(serverRandom);\n        md5.update(clientRandom);\n        serverIV=new IvParameterSpec(md5.digest(),0,iv_size);\n      }\n    }\n else     if (block_size != 0) {\n      clientIV=new IvParameterSpec(key_block,2 * hash_size + 2 * key_size,iv_size);\n      serverIV=new IvParameterSpec(key_block,2 * hash_size + 2 * key_size + iv_size,iv_size);\n    }\n    if (logger != null) {\n      logger.println(\"is exportable: \" + is_exportabe);\n      logger.println(\"master_secret\");\n      logger.print(session.master_secret);\n      logger.println(\"client_random\");\n      logger.print(clientRandom);\n      logger.println(\"server_random\");\n      logger.print(serverRandom);\n      logger.println(\"client_mac_secret\");\n      logger.print(client_mac_secret);\n      logger.println(\"server_mac_secret\");\n      logger.print(server_mac_secret);\n      logger.println(\"client_key\");\n      logger.print(client_key,0,key_size);\n      logger.println(\"server_key\");\n      logger.print(server_key,0,key_size);\n      if (clientIV != null) {\n        logger.println(\"client_iv\");\n        logger.print(clientIV.getIV());\n        logger.println(\"server_iv\");\n        logger.print(serverIV.getIV());\n      }\n else {\n        logger.println(\"no IV.\");\n      }\n    }\n    if (algName == null) {\n      encCipher=new NullCipher();\n      decCipher=new NullCipher();\n    }\n else {\n      encCipher=Cipher.getInstance(algName);\n      decCipher=Cipher.getInstance(algName);\n      if (is_client) {\n        encCipher.init(Cipher.ENCRYPT_MODE,new SecretKeySpec(client_key,0,key_size,algName),clientIV);\n        decCipher.init(Cipher.DECRYPT_MODE,new SecretKeySpec(server_key,0,key_size,algName),serverIV);\n      }\n else {\n        encCipher.init(Cipher.ENCRYPT_MODE,new SecretKeySpec(server_key,0,key_size,algName),serverIV);\n        decCipher.init(Cipher.DECRYPT_MODE,new SecretKeySpec(client_key,0,key_size,algName),clientIV);\n      }\n    }\n    messageDigest=MessageDigest.getInstance(hashName);\n    if (is_client) {\n      mac_write_secret=client_mac_secret;\n      mac_read_secret=server_mac_secret;\n    }\n else {\n      mac_write_secret=server_mac_secret;\n      mac_read_secret=client_mac_secret;\n    }\n    if (hashName.equals(\"MD5\")) {\n      pad_1=SSLv3Constants.MD5pad1;\n      pad_2=SSLv3Constants.MD5pad2;\n    }\n else {\n      pad_1=SSLv3Constants.SHApad1;\n      pad_2=SSLv3Constants.SHApad2;\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    throw new AlertException(AlertProtocol.INTERNAL_ERROR,new SSLProtocolException(\"Error during computation of security parameters\"));\n  }\n}", "comment": "creates the instance of ssl v3 connection state .", "label": "what"}
{"id": "31363", "raw_code": "public boolean compare(Object expected,Object current){\n  if (current != null) {\n    equal=current.equals(expected);\n  }\n else   if (expected != null) {\n    equal=expected.equals(1.0);\n  }\n  return equal;\n}", "comment": "this is used to compare the expected and current versions of the class .", "label": "what"}
{"id": "77743", "raw_code": "private static byte[] generateSeed(){\n  try {\n    ByteArrayOutputStream seedBuffer=new ByteArrayOutputStream();\n    DataOutputStream seedBufferOut=new DataOutputStream(seedBuffer);\n    seedBufferOut.writeLong(System.currentTimeMillis());\n    seedBufferOut.writeLong(System.nanoTime());\n    seedBufferOut.writeInt(Process.myPid());\n    seedBufferOut.writeInt(Process.myUid());\n    seedBufferOut.write(BUILD_FINGERPRINT_AND_DEVICE_SERIAL);\n    seedBufferOut.close();\n    return seedBuffer.toByteArray();\n  }\n catch (  IOException e) {\n    throw new SecurityException(\"Failed to generate seed\",e);\n  }\n}", "comment": "generates a device - and invocation - specific seed to be mixed into the linux prng .", "label": "what"}
{"id": "56800", "raw_code": "private List<UserNamespaceAuthorization> createUserNamespaceAuthorizationsFromEntities(List<UserNamespaceAuthorizationEntity> userNamespaceAuthorizationEntities){\n  List<UserNamespaceAuthorization> userNamespaceAuthorizations=new ArrayList<>();\n  for (  UserNamespaceAuthorizationEntity userNamespaceAuthorizationEntity : userNamespaceAuthorizationEntities) {\n    userNamespaceAuthorizations.add(createUserNamespaceAuthorizationFromEntity(userNamespaceAuthorizationEntity));\n  }\n  return userNamespaceAuthorizations;\n}", "comment": "creates a list of user namespace authorizations from the list of persisted entities .", "label": "what"}
{"id": "25745", "raw_code": "protected void drawText(String text1,String text2,int x,int y,Canvas c){\n  if (textPaint == null) {\n    Paint p=new Paint();\n    p.setTypeface(RobotoLightTypeface.getInstance(context));\n    p.setColor(textColor);\n    p.setTextSize(14 * pixelDensity);\n    this.textPaint=p;\n  }\n  float w=textPaint.measureText(text1,0,text1.length());\n  int offset=(int)w / 2;\n  c.drawText(text1,x - offset,y + (18f * pixelDensity),textPaint);\n  w=textPaint.measureText(text2,0,text2.length());\n  offset=(int)w / 2;\n  c.drawText(text2,x - offset,y + (36f * pixelDensity),textPaint);\n}", "comment": "draw the text under the graphics", "label": "what"}
{"id": "80743", "raw_code": "public boolean isLessThenOrEqualTo(Percent Percent){\n  assertDefined();\n  BigDecimal thisValue=notNull(this);\n  BigDecimal parameter=notNull(Percent);\n  return (thisValue.compareTo(parameter) <= 0);\n}", "comment": "compares two percent objects .", "label": "what"}
{"id": "58103", "raw_code": "public Object clone() throws CloneNotSupportedException {\n  PredicatedNodeTest clone=(PredicatedNodeTest)super.clone();\n  if ((null != this.m_proximityPositions) && (this.m_proximityPositions == clone.m_proximityPositions)) {\n    clone.m_proximityPositions=new int[this.m_proximityPositions.length];\n    System.arraycopy(this.m_proximityPositions,0,clone.m_proximityPositions,0,this.m_proximityPositions.length);\n  }\n  if (clone.m_lpi == this)   clone.m_lpi=(LocPathIterator)clone;\n  return clone;\n}", "comment": "get a cloned prdicatednodetest .", "label": "what"}
{"id": "63102", "raw_code": "public static ServerSocket createServerSocket(int port,InetAddress bindAddress) throws IOException {\n  ServerSocket socket=null;\n  if (SysProperties.ENABLE_ANONYMOUS_TLS) {\n    removeAnonFromLegacyAlgorithms();\n  }\n  setKeystore();\n  ServerSocketFactory f=SSLServerSocketFactory.getDefault();\n  SSLServerSocket secureSocket;\n  if (bindAddress == null) {\n    secureSocket=(SSLServerSocket)f.createServerSocket(port);\n  }\n else {\n    secureSocket=(SSLServerSocket)f.createServerSocket(port,0,bindAddress);\n  }\n  secureSocket.setEnabledProtocols(disableSSL(secureSocket.getEnabledProtocols()));\n  if (SysProperties.ENABLE_ANONYMOUS_TLS) {\n    String[] list=enableAnonymous(secureSocket.getEnabledCipherSuites(),secureSocket.getSupportedCipherSuites());\n    secureSocket.setEnabledCipherSuites(list);\n  }\n  socket=secureSocket;\n  return socket;\n}", "comment": "create a secure server socket .", "label": "what"}
{"id": "84135", "raw_code": "public void printBytes(byte[] data,int offset,int length) throws IOException {\n  int i;\n  for (; length >= 3; length-=3) {\n    int chunk=(((data[offset] & 0xff) << 16) + ((data[offset + 1] & 0xff) << 8) + (data[offset + 2] & 0xff));\n    os.write(base64encode(chunk >> 18));\n    os.write(base64encode(chunk >> 12));\n    os.write(base64encode(chunk >> 6));\n    os.write(base64encode(chunk));\n    offset+=3;\n  }\n  if (length == 2) {\n    int chunk=((data[offset] & 0xff) << 8) + (data[offset + 1] & 0xff);\n    os.write(base64encode(chunk >> 12));\n    os.write(base64encode(chunk >> 6));\n    os.write(base64encode(chunk));\n    os.write('=');\n  }\n else   if (length == 1) {\n    int chunk=data[offset] & 0xff;\n    os.write(base64encode(chunk >> 6));\n    os.write(base64encode(chunk));\n    os.write('=');\n    os.write('=');\n  }\n}", "comment": "prints a byte array to the stream , properly encoded in base64 .", "label": "what"}
{"id": "22518", "raw_code": "public void deleteVVset(String nativeId) throws Exception {\n  _log.info(\"3PARDriver: deleteVVset enter\");\n  ClientResponse clientResp=null;\n  final String path=MessageFormat.format(URI_DELETE_CG,nativeId);\n  _log.info(\"3PARDriver:deleteVVset running delete VV Set \" + path);\n  try {\n    clientResp=delete(path);\n    if (clientResp == null) {\n      _log.error(\"3PARDriver:deleteVVset There is no response from 3PAR\");\n      throw new HP3PARException(\"There is no response from 3PAR\");\n    }\n else     if (clientResp.getStatus() != 200) {\n      String errResp=getResponseDetails(clientResp);\n      throw new HP3PARException(errResp);\n    }\n else {\n      _log.info(\"3PARDriver: deleteVVset success\");\n    }\n  }\n catch (  Exception e) {\n    throw e;\n  }\n finally {\n    if (clientResp != null) {\n      clientResp.close();\n    }\n    _log.info(\"3PARDriver:deleteVVset leave\");\n  }\n}", "comment": "delete a vv set or consistency group", "label": "what"}
{"id": "74227", "raw_code": "private int findKeyCommentIndex(String keyName){\n  for (int i=0; i < keyValComments.size(); i++) {\n    String t=keyValComments.get(i);\n    String targetedKey=\"! \" + keyName + \": \";\n    if (t.startsWith(targetedKey)) {\n      return i;\n    }\n  }\n  if (log.isDebugEnabled()) {\n    log.debug(\"Did not find key \" + keyName);\n  }\n  return -1;\n}", "comment": "finds the index of the specified key within the array containing key / value comments", "label": "what"}
{"id": "49712", "raw_code": "public void persistConnection(Connection connection) throws PersistenceException {\n  MqttConnectOptions conOpts=connection.getConnectionOptions();\n  MqttMessage lastWill=conOpts.getWillMessage();\n  SQLiteDatabase db=getWritableDatabase();\n  ContentValues values=new ContentValues();\n  values.put(COLUMN_HOST,connection.getHostName());\n  values.put(COLUMN_port,connection.getPort());\n  values.put(COLUMN_client_ID,connection.getId());\n  values.put(COLUMN_ssl,connection.isSSL());\n  values.put(COLUMN_KEEP_ALIVE,conOpts.getKeepAliveInterval());\n  values.put(COLUMN_TIME_OUT,conOpts.getConnectionTimeout());\n  values.put(COLUMN_USER_NAME,conOpts.getUserName());\n  values.put(COLUMN_TOPIC,conOpts.getWillDestination());\n  char[] password=conOpts.getPassword();\n  values.put(COLUMN_CLEAN_SESSION,conOpts.isCleanSession() ? 1 : 0);\n  values.put(COLUMN_PASSWORD,password != null ? String.valueOf(password) : null);\n  values.put(COLUMN_MESSAGE,lastWill != null ? new String(lastWill.getPayload()) : null);\n  values.put(COLUMN_QOS,lastWill != null ? lastWill.getQos() : 0);\n  if (lastWill == null) {\n    values.put(COLUMN_RETAINED,0);\n  }\n else {\n    values.put(COLUMN_RETAINED,lastWill.isRetained() ? 1 : 0);\n  }\n  long newRowId=db.insert(TABLE_CONNECTIONS,null,values);\n  db.close();\n  if (newRowId == -1) {\n    throw new PersistenceException(\"Failed to persist connection: \" + connection.handle());\n  }\n else {\n    connection.assignPersistenceId(newRowId);\n  }\n}", "comment": "persist a connection to the database", "label": "what"}
{"id": "67275", "raw_code": "public int next(){\n  return mix(gen.getAndIncrement());\n}", "comment": "produce the next identifier .", "label": "what"}
{"id": "22723", "raw_code": "public InputStream put(final URLConnection connection,final boolean flushCacheOnClose){\n  final String key=getKey(connection);\n  if (key == null)   return null;\n  if (!isCacheable((HttpURLConnection)connection))   try {\n    cache.remove(key);\n    return null;\n  }\n catch (  IOException e) {\n    return null;\n  }\n  String etag=connection.getHeaderField(HEADER_ETAG);\n  if (etag == null || etag.length() == 0)   return null;\n  Editor editor;\n  try {\n    editor=cache.edit(key);\n  }\n catch (  IOException e) {\n    return null;\n  }\n  if (editor == null)   return null;\n  try {\n    editor.set(ETAG,etag);\n  }\n catch (  IOException e) {\n    try {\n      editor.abort();\n    }\n catch (    IOException ignored) {\n    }\n    return null;\n  }\n  InputStream input;\n  try {\n    input=connection.getInputStream();\n    if (!(input instanceof InflaterInputStream) && ENCODING_GZIP.equals(connection.getHeaderField(HEADER_CONTENT_ENCODING)))     input=new GZIPInputStream(input);\n  }\n catch (  IOException e) {\n    return null;\n  }\n  OutputStream output;\n  try {\n    output=editor.newOutputStream(BODY);\n  }\n catch (  IOException e) {\n    return null;\n  }\n  if (output != null)   return new CacheStream(input,output,editor,this,flushCacheOnClose);\n else   return null;\n}", "comment": "create stream that will be cached after it is read", "label": "what"}
{"id": "75417", "raw_code": "public void rootRemoved(ISVNRepositoryLocation root){\n  Iterator it=listeners.iterator();\n  while (it.hasNext()) {\n    IRepositoryListener listener=(IRepositoryListener)it.next();\n    listener.repositoryRemoved(root);\n  }\n}", "comment": "a repository root has been removed .", "label": "what"}
{"id": "42281", "raw_code": "public synchronized void insert(double _priority,Object _data){\n  numElements++;\n  if (numElements == queue.length) {\n    PriorityQueueNode[] tmp=new PriorityQueueNode[(int)(queue.length * 1.5)];\n    System.arraycopy(queue,0,tmp,0,queue.length);\n    for (int i=queue.length; i < tmp.length; i++) {\n      tmp[i]=new PriorityQueueNode();\n    }\n    queue=tmp;\n  }\n  queue[numElements].data=_data;\n  queue[numElements].priority=_priority;\n  reheapify(numElements);\n}", "comment": "insert the object passed with the priority value passed", "label": "what"}
{"id": "33329", "raw_code": "protected String wrapLinuxCommand(String command) throws IOException, InterruptedException {\n  String setGroup=\"export GROUP_NAME=`(getent group \" + getGid() + \" || (groupadd -g \"+ getGid()+ \" user && echo user:x:\"+ getGid()+ \")) | cut -d: -f1`\";\n  String setUser=\"export USER_NAME=`(getent passwd \" + getUid() + \" || (useradd -u \"+ getUid()+ \" -g ${GROUP_NAME} user && echo user:x:\"+ getGid()+ \")) | cut -d: -f1`\";\n  String chownCommand=\"chown --silent -R ${USER_NAME}.${GROUP_NAME} /usr/src/app || true\";\n  return setGroup + \" && \" + setUser+ \" && \"+ chownCommand+ \" && \"+ command+ \" && \"+ chownCommand;\n}", "comment": "wrap the given command into a command with chown .", "label": "what"}
{"id": "14949", "raw_code": "public int size(){\n  return _attrs.size();\n}", "comment": "get the number of attributes in the attribute set", "label": "what"}
{"id": "60049", "raw_code": "public String consumeTagName(){\n  int start=pos;\n  while (!isEmpty() && (matchesWord() || matchesAny(':','_','-')))   pos++;\n  return queue.substring(start,pos);\n}", "comment": "consume an tag name off the queue ( word or : , _ , - )", "label": "what"}
{"id": "12698", "raw_code": "public void deepSort(int[] setFeatureSequence){\n  featureSequence=setFeatureSequence;\n  numberOfLeaves=0;\n  tree=new MaryNode(0,featureVectors.length);\n  sortNode(0,tree);\n}", "comment": "launches a deep sort on the array of feature vectors .", "label": "what"}
{"id": "54075", "raw_code": "public void removeListeners(){\n  listeners.clear();\n}", "comment": "remove all existing listeners .", "label": "what"}
{"id": "1159", "raw_code": "public String decrypt(String sCipherText){\n  int nLen=(sCipherText.length() >> 1) & ~7;\n  if (nLen < BlowfishECB.BLOCKSIZE)   return null;\n  byte[] cbciv=new byte[BlowfishECB.BLOCKSIZE];\n  int nNumOfBytes=BinConverter.binHexToBytes(sCipherText,cbciv,0,0,BlowfishECB.BLOCKSIZE);\n  if (nNumOfBytes < BlowfishECB.BLOCKSIZE)   return null;\n  m_bfish.setCBCIV(cbciv);\n  nLen-=BlowfishECB.BLOCKSIZE;\n  if (nLen == 0)   return \"\";\n  byte[] buf=new byte[nLen];\n  nNumOfBytes=BinConverter.binHexToBytes(sCipherText,buf,BlowfishECB.BLOCKSIZE * 2,0,nLen);\n  if (nNumOfBytes < nLen)   return null;\n  m_bfish.decrypt(buf);\n  int nPadByte=buf[buf.length - 1] & 0x0ff;\n  if ((nPadByte > 8) || (nPadByte < 0))   nPadByte=0;\n  nNumOfBytes-=nPadByte;\n  if (nNumOfBytes < 0)   return \"\";\n  return BinConverter.byteArrayToUNCString(buf,0,nNumOfBytes);\n}", "comment": "decrypts a hexbin string ( handling is case sensitive )", "label": "what"}
{"id": "75786", "raw_code": "public static double L_RankLoss(int y[],int r[]){\n  int L=y.length;\n  ArrayList<Integer> tI=new ArrayList<Integer>();\n  ArrayList<Integer> fI=new ArrayList<Integer>();\n  for (int j=0; j < L; j++) {\n    if (y[j] == 1) {\n      tI.add(j);\n    }\n else {\n      fI.add(j);\n    }\n  }\n  if (!tI.isEmpty() && !fI.isEmpty()) {\n    int c=0;\n    for (    int k : tI) {\n      for (      int l : fI) {\n        if (position(k,r) < position(l,r)) {\n          c++;\n        }\n      }\n    }\n    return (double)c / (double)(tI.size() * fI.size());\n  }\n else {\n    return 0.0;\n  }\n}", "comment": "rank loss - the average fraction of labels which are not correctly ordered .", "label": "what"}
{"id": "53002", "raw_code": "private double addRecursively(ArrayList<double[]> hull,Hierarchy<Cluster<Model>> hier,Cluster<Model> clus){\n  final DBIDs ids=clus.getIDs();\n  double weight=ids.size();\n  for (DBIDIter iter=ids.iter(); iter.valid(); iter.advance()) {\n    double[] projP=proj.fastProjectDataToRenderSpace(rel.get(iter));\n    if (projP[0] != projP[0] || projP[1] != projP[1]) {\n      continue;\n    }\n    hull.add(projP);\n  }\n  for (Iter<Cluster<Model>> iter=hier.iterChildren(clus); iter.valid(); iter.advance()) {\n    weight+=.5 * addRecursively(hull,hier,iter.get());\n  }\n  return weight;\n}", "comment": "recursively add a cluster and its children .", "label": "what"}
{"id": "65962", "raw_code": "public void attributeUpdate(PrintServiceAttributeEvent psae){\n  log.fine(\"attributeUpdate - \" + psae);\n}", "comment": "print service attribute listener .", "label": "what"}
{"id": "73125", "raw_code": "public void evict() throws Exception {\n  assertOpen();\n  boolean isEmpty;\nsynchronized (this) {\n    isEmpty=pool.isEmpty();\n  }\n  if (!isEmpty) {\n    if (softMinEvictableIdleTimeMillis > 0) {\n      int numToEvict=getNumIdle() - getMinIdle();\n      evict(System.currentTimeMillis() - softMinEvictableIdleTimeMillis,numToEvict);\n    }\n    if (minEvictableIdleTimeMillis > 0) {\n      int numToEvict=getNumIdle();\n      evict(System.currentTimeMillis() - minEvictableIdleTimeMillis,numToEvict);\n    }\n  }\n}", "comment": "make one pass of the idle object evictor .", "label": "what"}
{"id": "76236", "raw_code": "protected void generateRandomPopulation(int population_size){\n  logger.debug(\"Creating random population\");\n  for (int i=0; i < population_size; i++) {\n    T individual=chromosomeFactory.getChromosome();\n    for (    FitnessFunction<?> fitnessFunction : this.fitnessFunctions) {\n      individual.addFitness(fitnessFunction);\n    }\n    population.add(individual);\n    if (isFinished())     break;\n  }\n  logger.debug(\"Created \" + population.size() + \" individuals\");\n}", "comment": "generate random population of given size", "label": "what"}
{"id": "43706", "raw_code": "public List<Visitante> listar(){\n  List<Visitante> dados=new ArrayList<>();\n  try {\n    String sql=\"SELECT tb_visitantes.* FROM tb_visitantes \";\n    stm=conector.prepareStatement(sql);\n    rs=stm.executeQuery(sql);\n    while (rs.next()) {\n      dados.add(new Visitante(rs.getInt(1),rs.getString(2),rs.getString(3),rs.getString(4),rs.getString(5),rs.getString(6),Tempo.toDate(rs.getTimestamp(7)),rs.getString(8),rs.getString(9)));\n    }\n    stm.close();\n    rs.close();\n  }\n catch (  SQLException ex) {\n    Mensagem.erro(\"Erro ao consultar visitantes na base de dados! \\n\" + ex);\n  }\n  return dados;\n}", "comment": "consultar todos visitantes cadastrdos na base de dados", "label": "what"}
{"id": "19088", "raw_code": "private void assertAllFromTbl1(Statement stmt,String[] ones,short[] twos) throws SQLException {\n  ResultSet rs=stmt.executeQuery(\"select * from tbl1\");\n  int i=0;\n  for (; rs.next(); i++) {\n    assertTrue(i < ones.length);\n    assertEquals(ones[i],rs.getString(\"one\"));\n    assertEquals(twos[i],rs.getShort(\"two\"));\n  }\n  assertTrue(i == ones.length);\n}", "comment": "asserts that the expected values can be selected from the test table .", "label": "what"}
{"id": "42424", "raw_code": "private void insertBefore(Instruction[] list,Instruction s){\n  for (  Instruction x : list) {\n    s.insertBefore(x);\n  }\n}", "comment": "inserts each instruction in a list before another instruction .", "label": "what"}
{"id": "24750", "raw_code": "public static Builder newBuilder(){\n  return new Builder();\n}", "comment": "creates a new persistent subscription settings builder .", "label": "what"}
{"id": "70099", "raw_code": "public int countArray(String[] array){\n  return array.length;\n}", "comment": "counts the size of an array .", "label": "what"}
{"id": "74669", "raw_code": "private void processUnprocessed(){\n  boolean clean_processings=Boolean.getBoolean(\"Archive.processings.clean\");\n  logger.info(\"Archives processing clean instead of recovery \" + \"(Archive.processings.clean) requested by user (\" + clean_processings + \")\");\n  productService.processUnprocessed(!clean_processings);\n}", "comment": "run recovery of stopped scanners .", "label": "what"}
{"id": "75618", "raw_code": "public double[] popy(double x_[]){\n  return popY(new double[][]{x_})[0];\n}", "comment": "forward pass - given input x _ , get output y _ .", "label": "what"}
{"id": "48341", "raw_code": "public void delete(String name) throws IOException {\n  if (name.equalsIgnoreCase(SUBJECT_NAME)) {\n    names=null;\n  }\n else {\n    throw new IOException(\"Attribute name not recognized by \" + \"CertAttrSet:SubjectAlternativeName.\");\n  }\n  encodeThis();\n}", "comment": "delete the attribute value .", "label": "what"}
{"id": "34668", "raw_code": "private void finishScrollStacks(){\n  cancelAnimation(this,Property.STACK_SNAP);\n  final int currentModelIndex=getTabStackIndex();\n  float delta=Math.abs(currentModelIndex + mRenderedScrollOffset);\n  float target=-currentModelIndex;\n  if (delta != 0) {\n    long duration=FLING_MIN_DURATION + (long)Math.abs(delta * getFullScrollDistance() / mFlingSpeed);\n    addToAnimation(this,Property.STACK_SNAP,mRenderedScrollOffset,target,duration,0);\n  }\n else {\n    setProperty(Property.STACK_SNAP,target);\n    if (mTemporarySelectedStack != null) {\n      mTabModelSelector.selectModel(mTemporarySelectedStack);\n      mTemporarySelectedStack=null;\n    }\n  }\n}", "comment": "animate to the final position of the stack .", "label": "what"}
{"id": "56467", "raw_code": "public GeoDistanceBuilder addUnboundedFrom(String key,double from){\n  ranges.add(new Range(key,from,null));\n  return this;\n}", "comment": "add a new range with no upper bound .", "label": "what"}
{"id": "71975", "raw_code": "private void sendResponse(Document doc,MessageFactory messageFactory,String contentType,HttpServletResponse res) throws IOException, SOAPException {\n  SOAPMessage reply=messageFactory.createMessage();\n  SOAPHeader header=reply.getSOAPHeader();\n  header.detachNode();\n  SOAPBody replyBody=reply.getSOAPBody();\n  res.setHeader(\"Content-Type\",contentType);\n  replyBody.addDocument(doc);\n  reply.saveChanges();\n  OutputStream os=res.getOutputStream();\n  reply.writeTo(os);\n  os.flush();\n}", "comment": "send a response back to the client .", "label": "what"}
{"id": "67683", "raw_code": "public static String replaceChars(String str,String oldchars,char newchar){\n  int pos=indexOfChars(str,oldchars);\n  if (pos == -1) {\n    return str;\n  }\n  StringBuilder buf=new StringBuilder(str);\n  do {\n    buf.setCharAt(pos,newchar);\n    pos=indexOfChars(str,oldchars,pos + 1);\n  }\n while (pos != -1);\n  return buf.toString();\n}", "comment": "like string . replace ( ) except that it accepts any number of old chars .", "label": "what"}
{"id": "6703", "raw_code": "public static void next(){\n  try {\n    if (musicPlaybackService != null) {\n      musicPlaybackService.next();\n    }\n  }\n catch (  final RemoteException ignored) {\n  }\n}", "comment": "changes to the next track", "label": "what"}
{"id": "523", "raw_code": "private void drawBitmapWithStroke(Canvas canvas,Bitmap bitmap,int centerX,int centerY,float radius,Paint drawPaint){\n  drawPaint.setStyle(Paint.Style.FILL);\n  float strokeRadius=radius + mRadiusStrokeWidth;\n  drawPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));\n  canvas.drawCircle(centerX,centerY,strokeRadius,drawPaint);\n  drawPaint.setXfermode(null);\n  final int halfBitmapWidth=bitmap.getWidth() / 2;\n  final int halfBitmapHeight=bitmap.getHeight() / 2;\n  BitmapShader bitmapShader=new BitmapShader(bitmap,Shader.TileMode.REPEAT,Shader.TileMode.REPEAT);\n  Matrix shaderMatrix=new Matrix();\n  float minSize=bitmap.getWidth() > bitmap.getHeight() ? bitmap.getHeight() : bitmap.getWidth();\n  float scale=radius * 2 / minSize;\n  shaderMatrix.setScale(scale,scale);\n  shaderMatrix.postTranslate(centerX - (halfBitmapWidth * scale),centerY - (halfBitmapHeight * scale));\n  bitmapShader.setLocalMatrix(shaderMatrix);\n  drawPaint.setShader(bitmapShader);\n  canvas.drawCircle(centerX,centerY,radius,drawPaint);\n  drawPaint.setShader(null);\n}", "comment": "draw single bitmap with the giving centerx , centery and radius", "label": "what"}
{"id": "69620", "raw_code": "public MqttDevice mqttDevice(){\n  return mqttDevice;\n}", "comment": "get the application ' s mqttdevice", "label": "what"}
{"id": "63172", "raw_code": "public AbbaLockingDetector startCollecting(){\n  thread=new Thread(this,\"AbbaLockingDetector\");\n  thread.setDaemon(true);\n  thread.start();\n  return this;\n}", "comment": "start collecting locking data .", "label": "what"}
{"id": "26256", "raw_code": "public static String searchRemoveFromCategory(HttpServletRequest request,HttpServletResponse response){\n  Delegator delegator=(Delegator)request.getAttribute(\"delegator\");\n  String productCategoryId=request.getParameter(\"SE_SEARCH_CATEGORY_ID\");\n  String errMsg=null;\n  try {\n    boolean beganTransaction=TransactionUtil.begin(DEFAULT_TX_TIMEOUT);\n    try {\n      EntityListIterator eli=getProductSearchResults(request);\n      if (eli == null) {\n        errMsg=UtilProperties.getMessage(resource,\"productsearchevents.no_results_found_probably_error_constraints\",UtilHttp.getLocale(request));\n        request.setAttribute(\"_ERROR_MESSAGE_\",errMsg);\n        return \"error\";\n      }\n      int numRemoved=0;\n      GenericValue searchResultView=null;\n      while ((searchResultView=eli.next()) != null) {\n        String productId=searchResultView.getString(\"mainProductId\");\n        numRemoved+=delegator.removeByAnd(\"ProductCategoryMember\",UtilMisc.toMap(\"productCategoryId\",productCategoryId,\"productId\",productId));\n      }\n      eli.close();\n      Map<String,String> messageMap=UtilMisc.toMap(\"numRemoved\",Integer.toString(numRemoved));\n      errMsg=UtilProperties.getMessage(resource,\"productsearchevents.removed_x_items\",messageMap,UtilHttp.getLocale(request));\n      request.setAttribute(\"_EVENT_MESSAGE_\",errMsg);\n    }\n catch (    GenericEntityException e) {\n      Map<String,String> messageMap=UtilMisc.toMap(\"errSearchResult\",e.toString());\n      errMsg=UtilProperties.getMessage(resource,\"productsearchevents.error_getting_search_results\",messageMap,UtilHttp.getLocale(request));\n      Debug.logError(e,errMsg,module);\n      request.setAttribute(\"_ERROR_MESSAGE_\",errMsg);\n      TransactionUtil.rollback(beganTransaction,errMsg,e);\n      return \"error\";\n    }\n finally {\n      TransactionUtil.commit(beganTransaction);\n    }\n  }\n catch (  GenericTransactionException e) {\n    Map<String,String> messageMap=UtilMisc.toMap(\"errSearchResult\",e.toString());\n    errMsg=UtilProperties.getMessage(resource,\"productsearchevents.error_getting_search_results\",messageMap,UtilHttp.getLocale(request));\n    Debug.logError(e,errMsg,module);\n    request.setAttribute(\"_ERROR_MESSAGE_\",errMsg);\n    return \"error\";\n  }\n  return \"success\";\n}", "comment": "removes the results of a search from the specified category", "label": "what"}
{"id": "79674", "raw_code": "public static double length(double x,double y,double z){\n  return Math.sqrt(x * x + y * y + z * z);\n}", "comment": "computes the length of a vector", "label": "what"}
{"id": "38542", "raw_code": "public AttributeListPanel(){\n  m_Table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n  m_Table.setColumnSelectionAllowed(false);\n  m_Table.setPreferredScrollableViewportSize(new Dimension(250,150));\n  setLayout(new BorderLayout());\n  add(new JScrollPane(m_Table),BorderLayout.CENTER);\n}", "comment": "creates the attribute selection panel with no initial instances .", "label": "what"}
{"id": "78724", "raw_code": "private Environment(){\n  throw ContractUtils.unreachable();\n}", "comment": "make sure nobody can instantiate the class", "label": "what"}
{"id": "40912", "raw_code": "public void removePhoto(PhotoEntity photo){\n  photos.remove(photo);\n}", "comment": "removes the given photo from this user", "label": "what"}
{"id": "56212", "raw_code": "public E[] toArray(E[] a){\n  if (a.length != array.length()) {\n    throw new ElasticsearchGenerationException(\"AtomicArrays can only be copied to arrays of the same size\");\n  }\n  for (int i=0; i < array.length(); i++) {\n    a[i]=array.get(i);\n  }\n  return a;\n}", "comment": "copies the content of the underlying atomic array to a normal one .", "label": "what"}
{"id": "55342", "raw_code": "private static Set<String> createCategoriesSet(Set<String> categories){\n  Set<String> result=new HashSet<>();\n  for (  String cat : categories) {\n    result.add(StringUtil.toLowerCase(cat));\n  }\n  return result;\n}", "comment": "creates a new set with the given categories , making them all lowercase in the process .", "label": "what"}
{"id": "79540", "raw_code": "public void loadListener(String serverKey) throws GenericServiceException {\n  Server server=servers.get(serverKey);\n  if (server == null)   throw new GenericServiceException(\"No listener found with that serverKey.\");\n  loadListener(serverKey,server);\n}", "comment": "load a jms message listener .", "label": "what"}
{"id": "86248", "raw_code": "public void upload(File file,long restartAt,FTPDataTransferListener listener) throws IllegalStateException, FileNotFoundException, IOException, FTPIllegalReplyException, FTPException, FTPDataTransferException, FTPAbortedException {\n  if (!file.exists()) {\n    throw new FileNotFoundException(file.getAbsolutePath());\n  }\n  InputStream inputStream=null;\n  try {\n    inputStream=new FileInputStream(file);\n  }\n catch (  IOException e) {\n    throw new FTPDataTransferException(e);\n  }\n  try {\n    upload(file.getName(),inputStream,restartAt,restartAt,listener);\n  }\n catch (  IllegalStateException e) {\n    throw e;\n  }\ncatch (  IOException e) {\n    throw e;\n  }\ncatch (  FTPIllegalReplyException e) {\n    throw e;\n  }\ncatch (  FTPException e) {\n    throw e;\n  }\ncatch (  FTPDataTransferException e) {\n    throw e;\n  }\ncatch (  FTPAbortedException e) {\n    throw e;\n  }\n finally {\n    if (inputStream != null) {\n      try {\n        inputStream.close();\n      }\n catch (      Throwable t) {\n        ;\n      }\n    }\n  }\n}", "comment": "this method uploads a file to the remote server .", "label": "what"}
{"id": "40265", "raw_code": "public SSLSocket createSSLSocket(Socket socket) throws IOException {\n  SSLSocketFactory sf=((SSLSocketFactory)SSLSocketFactory.getDefault());\n  InetSocketAddress remoteAddress=(InetSocketAddress)socket.getRemoteSocketAddress();\n  SSLSocket s=(SSLSocket)(sf.createSocket(socket,remoteAddress.getHostName(),socket.getPort(),true));\n  s.setUseClientMode(false);\n  s.setEnabledCipherSuites(s.getSupportedCipherSuites());\n  return s;\n}", "comment": "create a ssl socket that wraps the existing socket .", "label": "what"}
{"id": "5509", "raw_code": "private String formatNode(RightThreadedBinaryNode<T> node){\n  RightThreadedBinaryNode<T> n;\n  StringBuilder response=new StringBuilder(\"(\");\n  if ((n=node.getLeftSon()) != null) {\n    response.append(formatNode(n));\n  }\n  response.append(node.toString());\n  if ((n=node.getRightSon()) != null) {\n    response.append(formatNode(n));\n  }\n  response.append(\")\");\n  return response.toString();\n}", "comment": "format the node , recursively .", "label": "what"}
{"id": "101", "raw_code": "public JsonArray add(String value){\n  values.add(Json.value(value));\n  return this;\n}", "comment": "appends the json representation of the specified string to the end of this array .", "label": "what"}
{"id": "27074", "raw_code": "public MagicVariablesArgumentsBundle(@NonNull Map<String,String> arguments,@NonNull Map<String,String> variables,String layerName,@NonNull DisplayMetrics metrics){\n  super(arguments,metrics);\n  mVariables=variables;\n  mLayerNamePrefix='@' + layerName.replace('-','_') + '_';\n}", "comment": "create a new simple arguments bundle implementation from provided key - > value map .", "label": "what"}
{"id": "9951", "raw_code": "public static Document createDOM(InputStream is) throws ParserConfigurationException, SAXException, IOException {\n  DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();\n  dbf.setValidating(false);\n  dbf.setIgnoringComments(false);\n  dbf.setIgnoringElementContentWhitespace(true);\n  dbf.setNamespaceAware(true);\n  dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING,true);\n  dbf.setFeature(DISALLOW_DOCTYPE_DECL,true);\n  dbf.setFeature(EXTERNAL_GENERAL_ENTITIES,false);\n  dbf.setFeature(EXTERNAL_PARAMETER_ENTITIES,false);\n  dbf.setFeature(LOAD_EXTERNAL_DTD,false);\n  DocumentBuilder db=null;\n  db=dbf.newDocumentBuilder();\n  db.setEntityResolver(new NullResolver());\n  db.setErrorHandler(new SamlParserErrorHandler());\n  return db.parse(is);\n}", "comment": "create dom from iostream .", "label": "what"}
{"id": "32445", "raw_code": "public void resetCount(){\n  msgCnt.set(0);\n}", "comment": "resets counter to zero .", "label": "what"}
{"id": "41569", "raw_code": "void decodeAttributeBody(byte[] attributeValue,char offset,char length) throws StunException {\n  realm=new byte[length];\n  System.arraycopy(attributeValue,offset,realm,0,length);\n}", "comment": "copies the value of the realm attribute from the specified attributevalue .", "label": "what"}
{"id": "56146", "raw_code": "public static void copyAssets(Context context,String assetsFilename,File file,String mode) throws IOException, InterruptedException {\n  String abi=Build.CPU_ABI;\n  String libraryName;\n  if (abi.equalsIgnoreCase(\"armeabi\")) {\n    libraryName=\"armeabi\";\n  }\n else   if (abi.equalsIgnoreCase(\"x86\")) {\n    libraryName=\"x86\";\n  }\n else   if (abi.contains(\"armeabi-v7\")) {\n    libraryName=\"armeabi-v7a\";\n  }\n else {\n    return;\n  }\n  AssetManager manager=context.getAssets();\n  final InputStream is=manager.open(libraryName + \"/\" + assetsFilename);\n  copyFile(file,is,mode);\n}", "comment": "copy file in assets into destination file", "label": "what"}
{"id": "41351", "raw_code": "public boolean is_same(Object obj){\n  if (this == obj)   return true;\n  if (obj == null)   return false;\n  if (getClass() != obj.getClass())   return false;\n  HouseNumber other=(HouseNumber)obj;\n  if (number == null) {\n    if (name == null) {\n      if (other.name != null)       return false;\n    }\n else     if (!name.equals(other.name))     return false;\n  }\n else   if (!number.equals(other.number))   return false;\n  if (street == null) {\n    if (other.street != null)     return false;\n  }\n else   if (!street.equals(other.street))   return false;\n  return true;\n}", "comment": "check if address are content identical if number are equals and street ( if number is null , we look at the name )", "label": "what"}
{"id": "18418", "raw_code": "static byte[] discardWhitespace(byte[] data){\n  byte groomedData[]=new byte[data.length];\n  int bytesCopied=0;\n  for (int i=0; i < data.length; i++) {\nswitch (data[i]) {\ncase (byte)' ':\ncase (byte)'\\n':\ncase (byte)'\\r':\ncase (byte)'\\t':\n      break;\ndefault :\n    groomedData[bytesCopied++]=data[i];\n}\n}\nbyte packedData[]=new byte[bytesCopied];\nSystem.arraycopy(groomedData,0,packedData,0,bytesCopied);\nreturn packedData;\n}", "comment": "discards any whitespace from a base - 64 encoded block .", "label": "what"}
{"id": "12060", "raw_code": "public AsyncSelector() throws IOException {\n  this(Selector.open());\n}", "comment": "construct asyncselector with brand new selector", "label": "what"}
{"id": "82252", "raw_code": "public void removeChildAt(int index){\n  if ((index < 0) || (children == null) || (index >= children.size())) {\n    throw new ArrayIndexOutOfBoundsException();\n  }\n  Element child=(Element)children.get(index);\n  child.setParent(null);\n  children.remove(index);\n}", "comment": "removes the child at the given index", "label": "what"}
{"id": "51930", "raw_code": "static void loadDirectory(File file,ModuleCandidate candidate) throws IOException {\n  File[] files=file.listFiles();\n  if (files != null)   for (  File f : files)   loadSubDirectory(file,f,candidate);\n}", "comment": "load a module candidate from a directory .", "label": "what"}
{"id": "31861", "raw_code": "public static boolean hasSuppressed(@Nullable Throwable t,@Nullable Class<? extends Throwable> cls){\n  if (t == null || cls == null)   return false;\n  if (t.getSuppressed() != null) {\n    for (    Throwable th : t.getSuppressed()) {\n      if (cls.isAssignableFrom(th.getClass()))       return true;\n      if (hasSuppressed(th,cls))       return true;\n    }\n  }\n  return false;\n}", "comment": "checks if passed throwable has given class in one of the suppressed exceptions .", "label": "what"}
{"id": "63031", "raw_code": "static int writeVarLong(OutputStream out,long x) throws IOException {\n  int len=0;\n  while ((x & ~0x7f) != 0) {\n    out.write((byte)(0x80 | (x & 0x7f)));\n    x>>>=7;\n    len++;\n  }\n  out.write((byte)x);\n  return ++len;\n}", "comment": "write a variable size long value .", "label": "what"}
{"id": "60788", "raw_code": "private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {\n  final ReentrantLock lock=this.lock;\n  lock.lock();\n  try {\n    s.defaultWriteObject();\n    for (Node<E> p=first; p != null; p=p.next)     s.writeObject(p.item);\n    s.writeObject(null);\n  }\n  finally {\n    lock.unlock();\n  }\n}", "comment": "saves this deque to a stream ( that is , serializes it ) .", "label": "what"}
{"id": "21084", "raw_code": "private boolean checkIfInitiatorForRPBeforeMigration(Initiator initiator){\n  if (initiator == null) {\n    return false;\n  }\n  boolean isRP=true;\n  if (NullColumnValueGetter.isNullValue(initiator.getHostName()) || !NullColumnValueGetter.isNullURI(initiator.getHost())) {\n    isRP=false;\n  }\n  log.debug(\"RP initiator? \" + (isRP ? \"Yes!\" : \"No!\"));\n  return isRP;\n}", "comment": "check if the passed in initiator is for rp", "label": "what"}
{"id": "86497", "raw_code": "@Override public Collection<SerialMessage> initialize(boolean refresh){\n  ArrayList<SerialMessage> result=new ArrayList<SerialMessage>();\n  if (isSupportRequestSupported == true && (refresh == true || initialiseDone == false) && getVersion() > 1) {\n    result.add(getSupportedMessage());\n  }\n  return result;\n}", "comment": "initializes the meter command class .", "label": "what"}
{"id": "60368", "raw_code": "private static boolean isRetina(){\n  if (SystemInfo.isAppleJvm) {\n    return hasAppleRetinaDevice();\n  }\n  if (SystemInfo.isMac) {\n    GraphicsEnvironment e=GraphicsEnvironment.getLocalGraphicsEnvironment();\n    GraphicsDevice[] devices=e.getScreenDevices();\n    for (    GraphicsDevice device : devices) {\n      if (isOracleMacRetinaDevice(device)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "comment": "checks that at least one retina device is present .", "label": "what"}
{"id": "48936", "raw_code": "public void pOln(Object o) throws IOException {\n  pO(o.toString());\n  pln();\n}", "comment": "indent out ; write object ; end current line .", "label": "what"}
{"id": "80271", "raw_code": "private void drawCombat(final Graphics2D g2d,final int x,final int y,final int width,final int height){\n  Rectangle2D wrect=entity.getArea();\n  final Rectangle srect=new Rectangle((int)(wrect.getX() * IGameScreen.SIZE_UNIT_PIXELS),(int)(wrect.getY() * IGameScreen.SIZE_UNIT_PIXELS),(int)(wrect.getWidth() * IGameScreen.SIZE_UNIT_PIXELS),(int)(wrect.getHeight() * IGameScreen.SIZE_UNIT_PIXELS));\n  int circleHeight=(int)((srect.height - 2) / SQRT2);\n  circleHeight=Math.max(circleHeight,srect.height - IGameScreen.SIZE_UNIT_PIXELS / 2);\n  if (entity.isAttacking(User.get())) {\n    g2d.setColor(RING_COLOR_ORANGE);\n    g2d.drawOval(srect.x - 1,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n    g2d.drawOval(srect.x,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n    g2d.drawOval(srect.x + 1,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n    drawShadedOval(g2d,srect.x + 1,srect.y + srect.height - circleHeight + 1,srect.width - 2,circleHeight - 2,RING_COLOR_ORANGE,true,false);\n  }\n  if (entity.isBeingAttacked()) {\n    Color lineColor;\n    g2d.setColor(RING_COLOR_RED);\n    if (entity.isAttacking(User.get())) {\n      lineColor=RING_COLOR_RED;\n      drawShadedOval(g2d,srect.x - 1,srect.y + srect.height - circleHeight - 1,srect.width + 2,circleHeight + 2,RING_COLOR_RED,false,true);\n    }\n else {\n      lineColor=RING_COLOR_DARK_RED;\n      g2d.drawOval(srect.x - 1,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n      g2d.drawOval(srect.x,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n      g2d.drawOval(srect.x + 1,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n      drawShadedOval(g2d,srect.x + 1,srect.y + srect.height - circleHeight + 1,srect.width - 2,circleHeight - 2,RING_COLOR_RED,true,false);\n      drawShadedOval(g2d,srect.x - 1,srect.y + srect.height - circleHeight - 1,srect.width + 2,circleHeight + 2,RING_COLOR_ORANGE,false,false);\n    }\n    EnumSet<Direction> directions=EnumSet.noneOf(Direction.class);\n    for (    Entity attacker : entity.getAttackers()) {\n      directions.add(Direction.getAreaDirectionTowardsArea(entity.getArea(),attacker.getArea()));\n    }\n    drawArrows(g2d,srect.x - 1,srect.y + srect.height - circleHeight - 1,srect.width + 2,circleHeight + 2,directions,lineColor);\n  }\n else   if (entity.isAttacking(User.get())) {\n    drawShadedOval(g2d,srect.x - 1,srect.y + srect.height - circleHeight - 1,srect.width + 2,circleHeight + 2,RING_COLOR_ORANGE,false,false);\n  }\n  drawAttack(g2d,x,y,width,height);\n  if (entity.isDefending()) {\n    final int sx=srect.x + srect.width - ICON_OFFSET;\n    final int sy=y + height - 2 * ICON_OFFSET;\nswitch (entity.getResolution()) {\ncase BLOCKED:\n      blockedSprite.draw(g2d,sx,sy);\n    break;\ncase MISSED:\n  missedSprite.draw(g2d,sx,sy);\nbreak;\ncase HIT:\nhitSprite.draw(g2d,sx,sy);\nbreak;\ndefault :\n}\n}\n}", "comment": "draw the combat indicators .", "label": "what"}
{"id": "28781", "raw_code": "public ActivityResolveInfo(ResolveInfo resolveInfo){\n  this.resolveInfo=resolveInfo;\n}", "comment": "creates a new instance .", "label": "what"}
{"id": "79626", "raw_code": "private void endFormals(){\n  if (hasFormals) {\n    hasFormals=false;\n    buf.append('>');\n  }\n}", "comment": "ends the formal type parameters section of the signature .", "label": "what"}
{"id": "18043", "raw_code": "public boolean nextIsSep(){\n  if (Character.isLetterOrDigit(str.charAt(currentPosition)))   return false;\n else   return true;\n}", "comment": "tells if there is a digit or a letter character ahead .", "label": "what"}
{"id": "81219", "raw_code": "private String extractProjectNameFromUri(@NotNull String uri){\n  int indexFinishProjectName=uri.lastIndexOf(\".\");\n  int indexStartProjectName=uri.lastIndexOf(\"/\") != -1 ? uri.lastIndexOf(\"/\") + 1 : (uri.lastIndexOf(\":\") + 1);\n  if (indexStartProjectName != 0 && indexStartProjectName < indexFinishProjectName) {\n    return uri.substring(indexStartProjectName,indexFinishProjectName);\n  }\n  if (indexStartProjectName != 0) {\n    return uri.substring(indexStartProjectName);\n  }\n  return \"\";\n}", "comment": "gets project name from uri .", "label": "what"}
{"id": "73918", "raw_code": "private void resetNotes2(){\n  if (errorInStatus2) {\n    if (editMode) {\n      statusText1.setText(editStatus2);\n    }\n else {\n      statusText2.setText(stdStatus2);\n    }\n    errorInStatus2=false;\n  }\n}", "comment": "reset the second line of notes area", "label": "what"}
{"id": "76462", "raw_code": "public RequirementsBuilder addRequireProperty(String name,RequirementsBuilder builder){\n  addProperty(name,builder);\n  requiredProperties.add(name);\n  return this;\n}", "comment": "add a required property of type object .", "label": "what"}
{"id": "83858", "raw_code": "@Override public <T>Future<T> submit(Callable<T> task){\nsynchronized (this) {\n    active.incrementAndGet();\n    long timeout=0;\n    while (queue.remainingCapacity() == 0) {\n      try {\n        if (timeout <= giveupTime) {\n          Thread.sleep(DEFAULT_SLEEP);\n          timeout+=DEFAULT_SLEEP;\n        }\n else {\n          throw new RuntimeException(\"Timed out because TPE is too busy...\");\n        }\n      }\n catch (      InterruptedException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return super.submit(task);\n  }\n}", "comment": "this is a thread safe way to avoid rejection exception . . .", "label": "what"}
{"id": "86909", "raw_code": "public static void overwrite(long[] vector,long val,int offset,int len){\n  int idx=offset >> 6;\n  int bitIdx=offset & 63;\n  int truncatedValLen=Math.min(len,64 - bitIdx);\n  vector[idx]&=~(maskBelow(truncatedValLen) << bitIdx);\n  vector[idx]|=val << bitIdx;\n  if (len != truncatedValLen) {\n    long mask=maskBelow(len - truncatedValLen);\n    vector[idx + 1]&=~mask;\n    vector[idx + 1]|=(val >>> truncatedValLen);\n  }\n}", "comment": "overwrites a bit range within the vector .", "label": "what"}
{"id": "30460", "raw_code": "public static boolean isEmpty(String string){\n  if (null == string)   return true;\n  return string.equals(EMPTY);\n}", "comment": "check if the given string is empty or null", "label": "what"}
{"id": "8666", "raw_code": "Callbacks tryGetCallbacks(Callbacks oldCallbacks){\nsynchronized (mLock) {\n    if (mStopped) {\n      return null;\n    }\n    if (mCallbacks == null) {\n      return null;\n    }\n    final Callbacks callbacks=mCallbacks.get();\n    if (callbacks != oldCallbacks) {\n      return null;\n    }\n    if (callbacks == null) {\n      Log.w(TAG,\"no mCallbacks\");\n      return null;\n    }\n    return callbacks;\n  }\n}", "comment": "gets the callbacks object .", "label": "what"}
{"id": "36572", "raw_code": "@Override public Point translateJava2DToScreen(Point2D java2DPoint){\n  Insets insets=getInsets();\n  int x=(int)(java2DPoint.getX() * this.scaleX + insets.left);\n  int y=(int)(java2DPoint.getY() * this.scaleY + insets.top);\n  return new Point(x,y);\n}", "comment": "translates a java2d point on the chart to a screen location .", "label": "what"}
{"id": "15653", "raw_code": "protected FastMap<String> readDeclaredProperties(WidgetCreatorContext context){\n  FastMap<String> declaredProperties=new FastMap<String>();\n  String backColor=context.readWidgetProperty(\"backColor\");\n  if (backColor != null && backColor.length() > 0) {\n    declaredProperties.put(\"backColor\",backColor);\n  }\n  String fontName=context.readWidgetProperty(\"fontName\");\n  if (fontName != null && fontName.length() > 0) {\n    declaredProperties.put(\"fontName\",fontName);\n  }\n  String fontSize=context.readWidgetProperty(\"fontSize\");\n  if (fontSize != null && fontSize.length() > 0) {\n    declaredProperties.put(\"fontSize\",fontSize);\n  }\n  String foreColor=context.readWidgetProperty(\"foreColor\");\n  if (foreColor != null && foreColor.length() > 0) {\n    declaredProperties.put(\"foreColor\",foreColor);\n  }\n  String justification=context.readWidgetProperty(\"justification\");\n  if (justification != null && justification.length() > 0) {\n    declaredProperties.put(\"justification\",justification);\n  }\n  String bold=context.readWidgetProperty(\"bold\");\n  if (bold != null && bold.length() > 0) {\n    declaredProperties.put(\"bold\",bold);\n  }\n  String italic=context.readWidgetProperty(\"italic\");\n  if (italic != null && italic.length() > 0) {\n    declaredProperties.put(\"italic\",italic);\n  }\n  String subscript=context.readWidgetProperty(\"subscript\");\n  if (subscript != null && subscript.length() > 0) {\n    declaredProperties.put(\"subscript\",subscript);\n  }\n  String superscript=context.readWidgetProperty(\"superscript\");\n  if (superscript != null && superscript.length() > 0) {\n    declaredProperties.put(\"superscript\",superscript);\n  }\n  String underline=context.readWidgetProperty(\"underline\");\n  if (underline != null && underline.length() > 0) {\n    declaredProperties.put(\"underline\",underline);\n  }\n  String strikethrough=context.readWidgetProperty(\"strikethrough\");\n  if (strikethrough != null && strikethrough.length() > 0) {\n    declaredProperties.put(\"strikethrough\",strikethrough);\n  }\n  return declaredProperties;\n}", "comment": "reads all declared properties in the component span tag .", "label": "what"}
{"id": "74420", "raw_code": "public void addLayoutEditor(LayoutEditor panel){\n  if (panels.size() > 0) {\n    for (int i=0; i < panels.size(); i++) {\n      LayoutEditor ed=panels.get(i);\n      if (ed == panel) {\n        return;\n      }\n    }\n  }\n  panels.add(panel);\n}", "comment": "keeps track of layouteditor panels that are using this layoutblock", "label": "what"}
{"id": "16249", "raw_code": "protected List<IEditProposal> collectEditProposals(){\n  List<IEditProposal> proposals=new ArrayList<IEditProposal>();\n  View selectedView=getSelectedView();\n  if (selectedView != null) {\n    if (proposalProviders != null) {\n      for (      IEditProposalProvider provider : proposalProviders) {\n        for (        IEditProposal editProposal : provider.getProposals(selectedView)) {\n          if (editProposal.isApplicable())           proposals.add(editProposal);\n        }\n      }\n    }\n  }\n  return proposals;\n}", "comment": "collects all edit proposals from contained poroposal providers .", "label": "what"}
{"id": "84994", "raw_code": "public ExtensionQuery(String pluginId,String extensionPointName,String attributeName){\n  this.pluginId=extensionPointName.contains(\".\") ? null : pluginId;\n  this.extensionPointName=extensionPointName;\n  this.attributeName=attributeName;\n}", "comment": "create a new instance .", "label": "what"}
{"id": "43202", "raw_code": "private void ensureNamespaceExists(Result result){\n  DockerImage image=DockerImage.fromImageName(result.name);\n  if (image.getNamespace() == null) {\n    result.name=String.format(\"%s/%s\",DEFAULT_NAMESPACE,image.getRepository());\n  }\n}", "comment": "ensures that an image name has a namespace prefix .", "label": "what"}
{"id": "74823", "raw_code": "private void checkWidth(final int[] rect){\n  final int x1=rect[0];\n  final int y2=rect[1];\n  final int y1=y2 + rect[3];\n  final int x2=x1 + rect[2];\n  if (x1 < pageX1) {\n    pageX1=x1;\n  }\n  if (x2 > pageX2) {\n    pageX2=x2;\n  }\n  if (y1 > pageY1) {\n    pageY1=y1;\n  }\n  if (y2 < pageY2) {\n    pageY2=y2;\n  }\n}", "comment": "track actual size of shape", "label": "what"}
{"id": "53118", "raw_code": "private int countNonNewline(String str,int off,int len){\n  for (int cnt=0; cnt < len; cnt++) {\n    final int pos=off + cnt;\n    if (str.charAt(pos) == UNIX_NEWLINE) {\n      return cnt;\n    }\n    if (str.charAt(pos) == CARRIAGE_RETURN) {\n      return cnt;\n    }\n  }\n  return len;\n}", "comment": "count the number of non - newline characters before first newline in the string .", "label": "what"}
{"id": "6669", "raw_code": "private static int convertSpanToSparseGrid(int curIx,int span,TreeSet<Integer> indexes){\n  int lastIx=curIx + span;\n  int retSpan=1;\n  for (  Integer ix : indexes) {\n    if (ix <= curIx)     continue;\n    if (ix >= lastIx)     break;\n    retSpan++;\n  }\n  return retSpan;\n}", "comment": "spanning is specified in the uncompressed grid number .", "label": "what"}
{"id": "49380", "raw_code": "@Override public boolean equals(Object otherRules){\n  if (this == otherRules) {\n    return true;\n  }\n  if (otherRules instanceof ZoneRules) {\n    ZoneRules other=(ZoneRules)otherRules;\n    return Arrays.equals(standardTransitions,other.standardTransitions) && Arrays.equals(standardOffsets,other.standardOffsets) && Arrays.equals(savingsInstantTransitions,other.savingsInstantTransitions)&& Arrays.equals(wallOffsets,other.wallOffsets)&& Arrays.equals(lastRules,other.lastRules);\n  }\n  return false;\n}", "comment": "checks if this set of rules equals another .", "label": "what"}
{"id": "34276", "raw_code": "public void addClaimedSignerRole(final String claimedSignerRole){\n  if ((claimedSignerRole == null) || (claimedSignerRole.length() == 0)) {\n    throw new NullPointerException(\"claimedSignerRole\");\n  }\n  if (claimedSignerRoles == null) {\n    claimedSignerRoles=new ArrayList<String>();\n  }\n  claimedSignerRoles.add(claimedSignerRole);\n}", "comment": "adds a claimed signer role", "label": "what"}
{"id": "34861", "raw_code": "@SuppressWarnings(\"nullness\") @GwtIncompatible(\"java.io.ObjectOutputStream\") public static <K extends Object,V extends Object>void writeMap(Map<K,V> map,ObjectOutputStream stream) throws IOException {\n  stream.writeInt(map.size());\n  for (  Map.Entry<K,V> entry : map.entrySet()) {\n    stream.writeObject(entry.getKey());\n    stream.writeObject(entry.getValue());\n  }\n}", "comment": "stores the contents of a map in an output stream , as part of serialization .", "label": "what"}
{"id": "76311", "raw_code": "public static void restorePreviousOutAndErrStream(){\n  if (!alreadyMuted) {\n    return;\n  }\n  System.setOut(latestOut);\n  System.setErr(latestErr);\n  alreadyMuted=false;\n}", "comment": "allow again printing to previous streams that were muted", "label": "what"}
{"id": "34039", "raw_code": "public static BigInteger CRT(List<BigInteger> congs,List<BigInteger> moduli){\n  BigInteger[] cs=ArrayConverter.convertListToArray(congs);\n  BigInteger[] ms=ArrayConverter.convertListToArray(moduli);\n  return CRT(cs,ms);\n}", "comment": "computes chinese reminder theorem : x = = congs [ i ] mod moduli [ i ]", "label": "what"}
{"id": "75374", "raw_code": "private int measureHeight(int measureSpec){\n  int result=0;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  mAscent=(int)mTextPaint.ascent();\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=(int)(-mAscent + mTextPaint.descent()) + getPaddingTop() + getPaddingBottom();\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}", "comment": "determines the height of this view", "label": "what"}
{"id": "79612", "raw_code": "public ByteVector putByteArray(final byte[] b,final int off,final int len){\n  if (length + len > data.length) {\n    enlarge(len);\n  }\n  if (b != null) {\n    System.arraycopy(b,off,data,length,len);\n  }\n  length+=len;\n  return this;\n}", "comment": "puts an array of bytes into this byte vector .", "label": "what"}
{"id": "55698", "raw_code": "public Action(String content,int priority){\n  this.content=content.trim();\n  this.priority=priority;\n}", "comment": "creates a new action object with specified content and line number .", "label": "what"}
{"id": "54532", "raw_code": "void insertFunction2(ByteBuffer bb){\n  int baseSec=(int)(windowId >> 32);\n  bb.putInt(baseSec);\n  Integer operId=operatorId;\n  for (int i=0; i < 3; i++) {\n    byte num=(byte)(operId >> 8 * (2 - i));\n    bb.put(num);\n  }\n  bb.putShort((short)(windowId & 0xffff));\n  for (int i=0; i < 3; i++) {\n    byte num=(byte)(tupleId >> 8 * (2 - i));\n    bb.put(num);\n  }\n}", "comment": "4b basesec | 3b operatorid | 2b windowid | 3b tupleid", "label": "what"}
{"id": "51038", "raw_code": "private static boolean calculateGap(Rectangle a,Rectangle b,Rectangle gap){\n  if (a.intersects(b)) {\n    gap.width=0;\n    return false;\n  }\n  int ax1=a.x;\n  int ax2=a.x + a.width;\n  int ay1=a.y;\n  int ay2=a.y + a.height;\n  int bx1=b.x;\n  int bx2=b.x + b.width;\n  int by1=b.y;\n  int by2=b.y + b.height;\n  int xOverlap=Math.min(ax2,bx2) - Math.max(ax1,bx1);\n  int yOverlap=Math.min(ay2,by2) - Math.max(ay1,by1);\n  if (xOverlap <= 0 && yOverlap <= 0) {\n    gap.width=0;\n    return false;\n  }\n  if (xOverlap > 0) {\n    gap.x=Math.max(ax1,bx1);\n    gap.y=(ay1 > by1) ? by2 : ay2;\n    gap.width=xOverlap;\n    gap.height=-yOverlap;\n  }\n  if (yOverlap > 0) {\n    gap.x=(ax1 > bx1) ? bx2 : ax2;\n    gap.y=Math.max(ay1,by1);\n    gap.width=-xOverlap;\n    gap.height=yOverlap;\n  }\n  return true;\n}", "comment": "calculate the gap rectangle between two rectangles", "label": "what"}
{"id": "15362", "raw_code": "public boolean nextTile() throws ModelControlException {\n  boolean movedToRow=super.nextTile();\n  if (movedToRow) {\n    curTile=getTileIndex();\n    setDisplayFieldValue(TXT_PARENT_INDEX,parentIdx);\n    setDisplayFieldValue(TXT_CHOICE,choices[curTile]);\n    setDisplayFieldValue(TXT_INDEX,Integer.toString(curTile));\n  }\n  return movedToRow;\n}", "comment": "moves the current tile position to the next available tile .", "label": "what"}
{"id": "16213", "raw_code": "public static boolean isIntentAvailable(Context context,String action){\n  final PackageManager packageManager=context.getPackageManager();\n  final Intent intent=new Intent(action);\n  Log.d(MP_TAG,\"Looking for intent \" + action);\n  List<ResolveInfo> list=packageManager.queryIntentServices(intent,PackageManager.MATCH_DEFAULT_ONLY);\n  return list.size() > 0;\n}", "comment": "indicates whether the specified action can be used as an intent .", "label": "what"}
{"id": "26093", "raw_code": "public Set<WordToken> nearestWords(final int distance,final WordToken... start){\n  return nearestWords(distance,null,Arrays.asList(start));\n}", "comment": "find the nearest neighbours within dependency distance links of the provided start dependencies .", "label": "what"}
{"id": "61054", "raw_code": "public DERUTCTime(Date time){\n  SimpleDateFormat dateF=new SimpleDateFormat(\"yyMMddHHmmss'Z'\");\n  dateF.setTimeZone(new SimpleTimeZone(0,\"Z\"));\n  this.time=Strings.toByteArray(dateF.format(time));\n}", "comment": "base constructer from a java . util . date object", "label": "what"}
{"id": "53322", "raw_code": "public void rewind(){\nsynchronized (used) {\n    for (    ParameterPair pair : used) {\n      current.addParameter(pair.option,pair.value);\n    }\n    used.clear();\n  }\n}", "comment": "rewind the configuration to the initial situation", "label": "what"}
{"id": "29331", "raw_code": "public List<Interval> merge(List<Interval> intervals){\n  List<Interval> res=new ArrayList<>();\n  if (intervals == null || intervals.size() == 0) {\n    return res;\n  }\n  Collections.sort(intervals,null);\n  Interval prev=null;\n  for (  Interval i : intervals) {\n    if (prev == null || prev.end < i.start) {\n      res.add(i);\n      prev=i;\n    }\n else     if (i.end > prev.end) {\n      prev.end=i.end;\n    }\n  }\n  return res;\n}", "comment": "sort and merge , o ( nlogn ) time .", "label": "what"}
{"id": "35024", "raw_code": "private String formatType(Object typeRep){\n  StringTokenizer tokenizer=new StringTokenizer(typeRep.toString(),\"()<>[], \",true);\n  StringBuilder sb=new StringBuilder();\n  while (tokenizer.hasMoreTokens()) {\n    String token=tokenizer.nextToken();\n    if (token.length() == 1 || token.lastIndexOf('.') == -1)     sb.append(token);\n else {\n      int index=token.lastIndexOf('.');\n      sb.append(token.substring(index + 1));\n    }\n  }\n  return sb.toString();\n}", "comment": "outputs the simple name of the type", "label": "what"}
{"id": "6471", "raw_code": "private JLabel createIconLabel(JCheckBox checkBox){\n  checkBox.setOpaque(false);\n  checkBox.setSize(checkBox.getMinimumSize());\n  Image image=new BufferedImage(checkBox.getWidth(),checkBox.getHeight(),Transparency.TRANSLUCENT);\n  Graphics g=image.getGraphics();\n  checkBox.paint(g);\n  g.dispose();\n  return new JLabel(new ImageIcon(image));\n}", "comment": "creates an image of the checkbox and puts it in a label .", "label": "what"}
{"id": "62094", "raw_code": "public void closeWindow(){\n  WindowEvent ev=new WindowEvent(frame,WindowEvent.WINDOW_CLOSING);\n  frame.dispatchEvent(ev);\n}", "comment": "closes the window ( and opendial ) .", "label": "what"}
{"id": "21976", "raw_code": "private void populateHostData(Host host,HostParam param){\n  if (param.getName() != null) {\n    host.setLabel(param.getName());\n  }\n  if (param.getHostName() != null) {\n    host.setHostName(param.getHostName());\n  }\n  if (param.getCluster() != null) {\n    host.setCluster(param.getCluster());\n  }\n  if (param.getOsVersion() != null) {\n    host.setOsVersion(param.getOsVersion());\n  }\n  if (param.getUserName() != null) {\n    host.setUsername(param.getUserName());\n  }\n  if (param.getPassword() != null) {\n    host.setPassword(param.getPassword());\n  }\n  if (param.getPortNumber() != null) {\n    host.setPortNumber(param.getPortNumber());\n  }\n  if (param.getUseSsl() != null) {\n    host.setUseSSL(param.getUseSsl());\n  }\n  if (param.getType() != null) {\n    host.setType(param.getType());\n  }\n  if (param.getDiscoverable() != null) {\n    host.setDiscoverable(param.getDiscoverable());\n  }\n  if (param.getVcenterDataCenter() != null) {\n    host.setVcenterDataCenter(NullColumnValueGetter.isNullURI(param.getVcenterDataCenter()) ? NullColumnValueGetter.getNullURI() : param.getVcenterDataCenter());\n  }\n  Cluster cluster=null;\n  if (!NullColumnValueGetter.isNullURI(param.getCluster())) {\n    cluster=queryObject(Cluster.class,param.getCluster(),true);\n    if (!NullColumnValueGetter.isNullURI(cluster.getVcenterDataCenter())) {\n      host.setVcenterDataCenter(cluster.getVcenterDataCenter());\n    }\n    if (!NullColumnValueGetter.isNullURI(cluster.getProject())) {\n      host.setProject(cluster.getProject());\n    }\n  }\n  if (param.getBootVolume() != null) {\n    host.setBootVolumeId(NullColumnValueGetter.isNullURI(param.getBootVolume()) ? NullColumnValueGetter.getNullURI() : param.getBootVolume());\n  }\n}", "comment": "populate an instance of host with the provided host parameter", "label": "what"}
{"id": "50884", "raw_code": "@Nullable public AvdInfo createOrUpdateAvd(@Nullable AvdInfo currentInfo,@NotNull String avdName,@NotNull Device device,@NotNull SystemImageDescription systemImageDescription,@NotNull ScreenOrientation orientation,boolean isCircular,@Nullable String sdCard,@Nullable File skinFolder,@NotNull Map<String,String> hardwareProperties,boolean createSnapshot){\n  if (!initIfNecessary()) {\n    return null;\n  }\n  File avdFolder;\n  try {\n    if (currentInfo != null) {\n      avdFolder=new File(currentInfo.getDataFolderPath());\n    }\n else {\n      avdFolder=AvdInfo.getDefaultAvdFolder(myAvdManager,avdName,myFileOp,true);\n    }\n  }\n catch (  AndroidLocation.AndroidLocationException e) {\n    IJ_LOG.error(\"Could not create AVD \" + avdName,e);\n    return null;\n  }\n  Dimension resolution=device.getScreenSize(orientation);\n  assert resolution != null;\n  String skinName=null;\n  if (skinFolder == null && isCircular) {\n    skinFolder=getRoundSkin(systemImageDescription);\n  }\n  if (FileUtil.filesEqual(skinFolder,AvdWizardUtils.NO_SKIN)) {\n    skinFolder=null;\n  }\n  if (skinFolder == null) {\n    skinName=String.format(\"%dx%d\",Math.round(resolution.getWidth()),Math.round(resolution.getHeight()));\n  }\n  if (orientation == ScreenOrientation.LANDSCAPE) {\n    hardwareProperties.put(HardwareProperties.HW_INITIAL_ORIENTATION,ScreenOrientation.LANDSCAPE.getShortDisplayValue().toLowerCase(Locale.ROOT));\n  }\n  if (currentInfo != null && !avdName.equals(currentInfo.getName())) {\n    boolean success=myAvdManager.moveAvd(currentInfo,avdName,currentInfo.getDataFolderPath(),SDK_LOG);\n    if (!success) {\n      return null;\n    }\n  }\n  return myAvdManager.createAvd(avdFolder,avdName,systemImageDescription.getSystemImage(),skinFolder,skinName,sdCard,hardwareProperties,device.getBootProps(),createSnapshot,false,currentInfo != null,SDK_LOG);\n}", "comment": "update the given avd with the new settings or create one if no avd is specified .", "label": "what"}
{"id": "67033", "raw_code": "public DisjointSets(int numElements){\n  array=new int[numElements];\n  Arrays.fill(array,-1);\n}", "comment": "construct a disjoint sets object .", "label": "what"}
{"id": "9197", "raw_code": "public final void printClusters(PrintWriter out,List<ClusterData> clusterData,int[] matIndexToMsgInternalId) throws AdeException {\n  if (m_finalClusters == null) {\n    updateClusters(clusterData,matIndexToMsgInternalId);\n  }\n  for (  Map.Entry<String,Collection<Integer>> entry : m_finalClusters.entrySet()) {\n    final String n=entry.getKey();\n    final Collection<Integer> c=entry.getValue();\n    out.printf(\"%s\\t\",n);\n    for (    int m : c) {\n      out.printf(\"%d\\t\",matIndexToMsgInternalId[m]);\n    }\n    out.println();\n  }\n}", "comment": "prints out the cluster information .", "label": "what"}
{"id": "16271", "raw_code": "public synchronized void remove(int index){\n  mCategories.remove(index);\n  mValues.remove(index);\n}", "comment": "removes an existing value from the series .", "label": "what"}
{"id": "4941", "raw_code": "public final boolean check_trace(Polyline p_polyline,int p_half_width,int p_layer,NetNosList p_net_no_arr,int p_clearance_class_no,int p_max_recursion_depth,int p_max_via_recursion_depth,int p_max_spring_over_recursion_depth){\n  AwtreeShapeSearch search_tree=search_tree_manager.get_default_tree();\n  int compensated_half_width=p_half_width + search_tree.get_clearance_compensation(p_clearance_class_no,p_layer);\n  ArrayList<ShapeTile> trace_shapes=p_polyline.offset_shapes(compensated_half_width,0,p_polyline.corner_count());\n  for (int index=0; index < trace_shapes.size(); ++index) {\n    ShapeTile curr_trace_shape=trace_shapes.get(index);\n    BrdFromSide from_side=new BrdFromSide(p_polyline,index + 1,curr_trace_shape);\n    boolean check_shove_ok=shove_trace_algo.shove_trace_check(curr_trace_shape,from_side,null,p_layer,p_net_no_arr,p_clearance_class_no,p_max_recursion_depth,p_max_via_recursion_depth,p_max_spring_over_recursion_depth,null);\n    if (!check_shove_ok)     return false;\n  }\n  return true;\n}", "comment": "checks , if a trace polyline with the input parameters can be inserted while shoving aside obstacle traces and vias .", "label": "what"}
{"id": "78807", "raw_code": "protected int encode(double value,double lower,double upper,int nbits){\n  if (value < lower)   return 0;\n  int maxval=(int)(Math.pow(2,nbits) - 1);\n  if (value >= upper)   return maxval;\n  return (int)((value - lower) * ((maxval - 0) / (upper - lower)));\n}", "comment": "encode value as an nbits unsigned integer", "label": "what"}
{"id": "11497", "raw_code": "public long skipBytes(long n) throws IOException {\n  long count=0;\n  long gotsofar=0;\n  if (inputStream == null) {\n    reopen();\n    if (inputStream == null) {\n      reopen();\n      throw new IOException(\"Stream closed, can't be reopened\");\n    }\n  }\n  while (count < n) {\n    gotsofar=inputStream.skip(n - count);\n    if (gotsofar == 0) {\n      Debug.error(\"StreamInputReader can't skip \" + n + \" bytes as instructed\");\n      break;\n    }\n    count+=gotsofar;\n  }\n  count((int)count);\n  return count;\n}", "comment": "skip over n bytes in the input file", "label": "what"}
{"id": "64212", "raw_code": "private void createLock() throws IOException {\nsynchronized (LockableFileWriter.class) {\n    if (!lockFile.createNewFile()) {\n      throw new IOException(\"Can't write file, lock \" + lockFile.getAbsolutePath() + \" exists\");\n    }\n    lockFile.deleteOnExit();\n  }\n}", "comment": "creates the lock file .", "label": "what"}
{"id": "13844", "raw_code": "public void handleTblDSAttributeMapListHrefActionRequest(RequestInvocationEvent event) throws ModelControlException {\n  try {\n    Map values=getValues();\n    onBeforeSaveProfile(values);\n    setPageSessionAttribute(PROPERTY_ATTRIBUTE,(HashMap)values);\n    WSPPServiceDSAttributeMapListEditViewBean vb=(WSPPServiceDSAttributeMapListEditViewBean)getViewBean(WSPPServiceDSAttributeMapListEditViewBean.class);\n    unlockPageTrail();\n    passPgSessionMap(vb);\n    vb.populateValues((String)getDisplayFieldValue(\"tblDSAttributeMapListHrefAction\"));\n    vb.forwardTo(getRequestContext());\n  }\n catch (  AMConsoleException e) {\n    setInlineAlertMessage(CCAlert.TYPE_ERROR,\"message.error\",e.getMessage());\n    forwardTo();\n  }\n}", "comment": "handles edit ldap attribute mapping request .", "label": "what"}
{"id": "62212", "raw_code": "@Override protected synchronized void write(long offset,byte[] b) throws IOException {\n  if (byteBuffer != null) {\n    byteBuffer.position((int)offset);\n    byteBuffer.put(b);\n  }\n else {\n    throw new IOException(\"Write failed, file \" + getPath() + \" not mapped for I/O\");\n  }\n}", "comment": "writes bytes to the underlying rrd file on the disk", "label": "what"}
{"id": "59574", "raw_code": "public boolean hasChanged(){\n  return System.identityHashCode(config) != initialHash;\n}", "comment": "checks if the config has changed since it was loaded .", "label": "what"}
{"id": "62165", "raw_code": "public boolean remove(ImageInfo object){\n  final int location=getLocation(object);\n  final boolean removed=data.remove(object);\n  notifyItemRemoved(location);\n  return removed;\n}", "comment": "removes the first occurrence of the specified object from the data .", "label": "what"}
{"id": "30172", "raw_code": "public T allowedUsers(User... users){\n  List<User> usersList=Arrays.asList(users);\n  this.userPredicate=null;\n  return instance();\n}", "comment": "allow a list of users to use this menu", "label": "what"}
{"id": "22467", "raw_code": "VPlexDistributedDeviceInfo findDistributedDevice(String deviceName) throws VPlexApiException {\n  return findDistributedDevice(deviceName,false);\n}", "comment": "finds the distributed device with the passed name .", "label": "what"}
{"id": "76918", "raw_code": "static CopyState readCopyState(DataInput in) throws IOException {\n  byte[] infosBytes=new byte[in.readVInt()];\n  in.readBytes(infosBytes,0,infosBytes.length);\n  long gen=in.readVLong();\n  long version=in.readVLong();\n  Map<String,FileMetaData> files=readFilesMetaData(in);\n  int count=in.readVInt();\n  Set<String> completedMergeFiles=new HashSet<>();\n  for (int i=0; i < count; i++) {\n    completedMergeFiles.add(in.readString());\n  }\n  long primaryGen=in.readVLong();\n  return new CopyState(files,version,gen,infosBytes,completedMergeFiles,primaryGen,null);\n}", "comment": "pulls copystate off the wire", "label": "what"}
{"id": "19664", "raw_code": "public void notifyTasks(){\n  if (tracker.shouldInterruptTask()) {\n    for (    Thread t : threadMap.values()) {\n      t.interrupt();\n    }\n  }\n}", "comment": "interrupts currently running tasks .", "label": "what"}
{"id": "73453", "raw_code": "public boolean confirmOverwrite(final File file){\n  String message=\"The file \\\"\" + file.getName() + \"\\\" already exists. Overwrite?\";\n  Object[] options={\"OK\",\"Cancel\"};\n  return JOptionPane.YES_OPTION == JOptionPane.showOptionDialog(null,message,\"Warning\",JOptionPane.DEFAULT_OPTION,JOptionPane.WARNING_MESSAGE,null,options,options[0]);\n}", "comment": "ask user whether to overwrite the give existing file .", "label": "what"}
{"id": "73186", "raw_code": "public void clear(){\n  Set<Sensor> oldSelection=new HashSet<Sensor>(selection);\n  selection.clear();\n  if (!oldSelection.isEmpty()) {\n    fireSelectionChanged(oldSelection,selection);\n  }\n}", "comment": "clear this sensor selection model .", "label": "what"}
{"id": "51183", "raw_code": "public void assureProxyOk(){\n  if (socket.isClosed()) {\n    restart();\n  }\n}", "comment": "assure that proxy is in a stable status .", "label": "what"}
{"id": "53946", "raw_code": "public Key(byte[] hash){\n  if (hash.length != SHA1_HASH_LENGTH) {\n    throw new IllegalArgumentException(\"Invalid Hash must be 20bytes, was: \" + hash.length);\n  }\n  System.arraycopy(hash,0,this.hash,0,SHA1_HASH_LENGTH);\n}", "comment": "creates a key with this hash", "label": "what"}
{"id": "1510", "raw_code": "public static int[] concatAllInt(int[]... arrays){\n  int totalLength=0;\n  final int subArrayCount=arrays.length;\n  for (int i=0; i < subArrayCount; ++i) {\n    totalLength+=arrays[i].length;\n  }\n  int[] result=Arrays.copyOf(arrays[0],totalLength);\n  int offset=arrays[0].length;\n  for (int i=1; i < subArrayCount; ++i) {\n    System.arraycopy(arrays[i],0,result,offset,arrays[i].length);\n    offset+=arrays[i].length;\n  }\n  return result;\n}", "comment": "concatenates a list of int arrays into a single array .", "label": "what"}
{"id": "13860", "raw_code": "public void beginDisplay(DisplayEvent event) throws ModelControlException {\n  IdentitySubjectModel subjectModel=getSubjectModel();\n  PolicyModel model=(PolicyModel)getModel();\n  super.beginDisplay(event);\n  if (!canModify) {\n    Map mapValues=getDefaultValues();\n    if ((mapValues != null) && !mapValues.isEmpty()) {\n      Set values=(Set)mapValues.get(AMIdentityMembershipCondition.AM_IDENTITY_NAME);\n      Set identityNames=helper.getAMIdentityNames(model.getUserSSOToken(),values);\n      propertySheetModel.setValue(VALUES_MULTIPLE_CHOICE_VALUE,AMAdminUtils.getString(identityNames,\",\",false));\n    }\n  }\n else {\n    CCDropDownMenu menu=(CCDropDownMenu)getChild(FILTER_TYPE);\n    Map supportedEntityTypes=model.getSupportedEntityTypes(realmName);\n    OptionList entityTypes=createOptionList(supportedEntityTypes);\n    entityTypes.add(0,\"policy.subject.select.identity.type\",\"\");\n    menu.setOptions(entityTypes);\n    menu.setValue(\"\");\n    CCAddRemove child=(CCAddRemove)getChild(VALUES_MULTIPLE_CHOICE_VALUE);\n    child.restoreStateData();\n    if (!submitCycle) {\n      helper.setSelectedIdentities(child,model.getUserSSOToken(),model.getUserLocale(),this,getDefaultValues());\n    }\n else {\n      OptionList possible=helper.createOptionList(model.getUserSSOToken(),model.getUserLocale(),this,getPossibleValues(subjectModel,realmName));\n      OptionList selected=addRemoveModel.getSelectedOptionList();\n      List selectedIds=AMAdminUtils.toList(selected);\n      child.resetStateData();\n      addRemoveModel.setAvailableOptionList(possible);\n      addRemoveModel.setSelectedOptionList(helper.createOptionList(model.getUserSSOToken(),model.getUserLocale(),this,selectedIds));\n    }\n  }\n}", "comment": "sets the values to ui model .", "label": "what"}
{"id": "63367", "raw_code": "public byte[] readBytes() throws IOException {\n  int len=readInt();\n  if (len == -1) {\n    return null;\n  }\n  byte[] b=DataUtils.newBytes(len);\n  in.readFully(b);\n  return b;\n}", "comment": "read a byte array .", "label": "what"}
{"id": "21090", "raw_code": "public Joiner join(Class<? extends DataObject> clazz,String alias,URI... ids){\n  return join(clazz,alias,new ArrayList<URI>(Arrays.asList(ids)));\n}", "comment": "starts a new query not related to a previous class query .", "label": "what"}
{"id": "38590", "raw_code": "public void closeFile(){\n  closeFile(true);\n}", "comment": "closes the current tab", "label": "what"}
{"id": "71236", "raw_code": "public QuadEdge makeEdge(Vertex o,Vertex d){\n  QuadEdge q=QuadEdge.makeEdge(o,d);\n  quadEdges.add(q);\n  return q;\n}", "comment": "creates a new quadedge , recording it in the edges list .", "label": "what"}
{"id": "77477", "raw_code": "public static void sortSeqs(List<String> seqs){\n  Collections.sort(seqs,null);\n}", "comment": "sort n string sequence list .", "label": "what"}
{"id": "54007", "raw_code": "default B with(String key,long value){\n  return with(key,Long.toString(value));\n}", "comment": "associate the given value with the specified key .", "label": "what"}
{"id": "82756", "raw_code": "private Shape decodeEdge(int width,int height){\n  path.reset();\n  path.moveTo(width - 2,0);\n  path.lineTo(width - 2,height - 4);\n  path.lineTo(width - 4,height - 2);\n  path.lineTo(3,height - 2);\n  return path;\n}", "comment": "create the button edge shape .", "label": "what"}
{"id": "6688", "raw_code": "public void dispose() throws IabAsyncInProgressException {\nsynchronized (mAsyncInProgressLock) {\n    if (mAsyncInProgress) {\n      throw new IabAsyncInProgressException(\"Can't dispose because an async operation \" + \"(\" + mAsyncOperation + \") is in progress.\");\n    }\n  }\n  logDebug(\"Disposing.\");\n  mSetupDone=false;\n  if (mServiceConn != null) {\n    logDebug(\"Unbinding from service.\");\n    if (mContext != null)     mContext.unbindService(mServiceConn);\n  }\n  mDisposed=true;\n  mContext=null;\n  mServiceConn=null;\n  mService=null;\n  mPurchaseListener=null;\n}", "comment": "dispose of object , releasing resources .", "label": "what"}
{"id": "5883", "raw_code": "private static File createReserveDiskCacheDir(Context context){\n  File cacheDir=StorageUtils.getCacheDirectory(context,false);\n  File individualDir=new File(cacheDir,\"uil-images\");\n  if (individualDir.exists() || individualDir.mkdir()) {\n    cacheDir=individualDir;\n  }\n  return cacheDir;\n}", "comment": "creates reserve disk cache folder which will be used if primary disk cache folder becomes unavailable", "label": "what"}
{"id": "53473", "raw_code": "@Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n  super.readExternal(in);\n  isLeaf=in.readBoolean();\n  numEntries=in.readInt();\n}", "comment": "reads the id of this node , the numentries and the entries array from the specified stream .", "label": "what"}
{"id": "23689", "raw_code": "public ObjIdMap(){\n  this(11,0.75f);\n}", "comment": "creates a new , empty map with the default initial capacity ( 11 buckets ) and load factor ( 0 . 75 ) .", "label": "what"}
{"id": "72163", "raw_code": "public MessagePropertyKey(String description,Integer ordinal){\n  this.description=description;\n  this.ordinal=ordinal;\n}", "comment": "creates a parameterized instance .", "label": "what"}
{"id": "59056", "raw_code": "private void assertBounded(SortedSet<String> deserialized,boolean bounded){\n  if (bounded) {\n    try {\n      deserialized.add(\"e\");\n      fail();\n    }\n catch (    IllegalArgumentException expected) {\n    }\n  }\n else {\n    assertTrue(deserialized.add(\"e\"));\n    assertTrue(deserialized.remove(\"e\"));\n  }\n}", "comment": "regrettably , serializing a treeset causes it to forget its bounds .", "label": "what"}
{"id": "54503", "raw_code": "@SuppressWarnings({\"unchecked\",\"rawtypes\"}) public static LineByLineFileInputOperator restoreCheckPoint(LineByLineFileInputOperator checkPointOper,ByteArrayOutputStream bos) throws Exception {\n  Kryo kryo=new Kryo();\n  Input lInput=new Input(bos.toByteArray());\n  LineByLineFileInputOperator oper=kryo.readObject(lInput,checkPointOper.getClass());\n  lInput.close();\n  return oper;\n}", "comment": "restores the checkpointed operator .", "label": "what"}
{"id": "24593", "raw_code": "private static byte[] readClass(final InputStream is,boolean close) throws IOException {\n  if (is == null) {\n    throw new IOException(\"Class not found\");\n  }\n  try {\n    byte[] b=new byte[is.available()];\n    int len=0;\n    while (true) {\n      int n=is.read(b,len,b.length - len);\n      if (n == -1) {\n        if (len < b.length) {\n          byte[] c=new byte[len];\n          System.arraycopy(b,0,c,0,len);\n          b=c;\n        }\n        return b;\n      }\n      len+=n;\n      if (len == b.length) {\n        int last=is.read();\n        if (last < 0) {\n          return b;\n        }\n        byte[] c=new byte[b.length + 1000];\n        System.arraycopy(b,0,c,0,len);\n        c[len++]=(byte)last;\n        b=c;\n      }\n    }\n  }\n  finally {\n    if (close) {\n      is.close();\n    }\n  }\n}", "comment": "reads the bytecode of a class .", "label": "what"}
{"id": "48751", "raw_code": "private static synchronized boolean isSupportedImpl(HttpCallerInfo hci){\n  if (supported == null) {\n    supported=new HashMap<String,Boolean>();\n    cache=new HashMap<String,Negotiator>();\n  }\n  String hostname=hci.host;\n  hostname=hostname.toLowerCase();\n  if (supported.containsKey(hostname)) {\n    return supported.get(hostname);\n  }\n  Negotiator neg=Negotiator.getNegotiator(hci);\n  if (neg != null) {\n    supported.put(hostname,true);\n    cache.put(hostname,neg);\n    return true;\n  }\n else {\n    supported.put(hostname,false);\n    return false;\n  }\n}", "comment": "find out if the httpcallerinfo supports negotiate protocol .", "label": "what"}
{"id": "36944", "raw_code": "public CProjectConfiguration(final INaviProject project,final ListenerProvider<IProjectListener> listeners,final SQLProvider provider,final int projectId,final String name,final String description,final Date creationDate,final Date modificationDate,final List<DebuggerTemplate> assignedDebuggers){\n  m_project=project;\n  m_listeners=listeners;\n  m_provider=provider;\n  m_id=projectId;\n  m_name=name;\n  m_description=description;\n  m_creationDate=new Date(creationDate.getTime());\n  m_modificationDate=new Date(modificationDate.getTime());\n  m_assignedDebuggers=new ArrayList<DebuggerTemplate>(assignedDebuggers);\n}", "comment": "creates a new configuration object .", "label": "what"}
{"id": "8570", "raw_code": "public PerformanceLogger(){\n  time1=System.currentTimeMillis();\n}", "comment": "instantiates a new performance logger .", "label": "what"}
{"id": "56682", "raw_code": "public Hash(String hex){\n  if (hex.length() != 64) {\n    throw new IllegalArgumentException(\"Digest length must be 64 hex characters for Hash\");\n  }\n  this.bytes=ByteUtils.reverse(ByteUtils.fromHex(hex));\n}", "comment": "create a hash from a hexadecimal representation of the digest note that this is in the reverse byte order of the internal binary representation .", "label": "what"}
{"id": "42744", "raw_code": "public boolean isNumericalRun(String pin){\n  final int len=pin.length();\n  int prevDigit=Character.digit(pin.charAt(0),10);\n  int prevDiff=Integer.MAX_VALUE;\n  boolean isRun=true;\n  for (int i=1; isRun && i < len; i++) {\n    final int digit=Character.digit(pin.charAt(i),10);\n    final int diff=digit - prevDigit;\n    if (prevDiff != Integer.MAX_VALUE && diff != prevDiff) {\n      isRun=false;\n    }\n    prevDiff=diff;\n    prevDigit=digit;\n  }\n  return isRun;\n}", "comment": "tests the string to see if it contains a numeric run .", "label": "what"}
{"id": "82928", "raw_code": "public boolean leave() throws KeeperException, InterruptedException {\n  zooKeeper.delete(rootPath + \"/\" + name,0);\n  while (true) {\nsynchronized (mutex) {\n      List<String> list=zooKeeper.getChildren(rootPath,true);\n      if (list.size() > 0) {\n        mutex.wait();\n      }\n else {\n        return true;\n      }\n    }\n  }\n}", "comment": "wait until all nodes leave barrier", "label": "what"}
{"id": "10260", "raw_code": "public static String cutFromIndexOf(String string,String substring){\n  int i=string.indexOf(substring);\n  if (i != -1) {\n    string=string.substring(i);\n  }\n  return string;\n}", "comment": "cuts the string from the first index of provided substring to the end .", "label": "what"}
{"id": "10355", "raw_code": "private Response requestHttpGetFromRegistry(String url) throws RegistryException {\n  try {\n    Response resp=http.get(url);\n    if (resp != null && resp.content != null) {\n      return resp;\n    }\n else {\n      throw new RegistryException(TYPE.BAD_RESPONSE,\"Response content is null\");\n    }\n  }\n catch (  ClassCastException e) {\n    throw new RegistryException(TYPE.BAD_RESPONSE,e);\n  }\ncatch (  ConnectException e) {\n    throw new RegistryException(TYPE.PROXY,e);\n  }\ncatch (  UnknownHostException e) {\n    try {\n      http.get(\"http://www.google.com\");\n    }\n catch (    Exception e1) {\n      throw new RegistryException(TYPE.NO_INTERNET,e1);\n    }\n    throw new RegistryException(TYPE.SITE_DOWN,e);\n  }\ncatch (  IOException e) {\n    throw new RegistryException(TYPE.IO_ERROR,e);\n  }\ncatch (  URISyntaxException e) {\n    throw new RegistryException(TYPE.BAD_REQUEST,\"Please check the request URL: \" + ((url != null) ? url : \"empty URL used!\"));\n  }\n}", "comment": "executes an http get request against the gbif registry .", "label": "what"}
{"id": "83449", "raw_code": "public void init(RemoteAuthenticatedUser currentUser){\n  this.currentUser=currentUser;\n}", "comment": "creates a new sharedconnectiondirectory which exposes share keys as connections .", "label": "what"}
{"id": "42193", "raw_code": "public static void invokeFinalize(Object o) throws Throwable {\n  o.finalize();\n}", "comment": "call the object finalize method on the given object", "label": "what"}
{"id": "16796", "raw_code": "private void removeTvShow(TvShow tvShow){\nsynchronized (root) {\n    TvShowTreeNode child=(TvShowTreeNode)nodeMap.get(tvShow);\n    DefaultMutableTreeNode parent=root;\n    if (child != null) {\n      int index=getIndexOfChild(parent,child);\n      nodeMap.remove(tvShow);\n      for (      TvShowEpisode episode : new ArrayList<>(tvShow.getEpisodes())) {\n        nodeMap.remove(episode);\n        episode.removePropertyChangeListener(propertyChangeListener);\n      }\n      tvShow.removePropertyChangeListener(propertyChangeListener);\n      child.removeAllChildren();\n      child.removeFromParent();\n      if (index > -1) {\n        TreeModelEvent event=new TreeModelEvent(this,parent.getPath(),new int[]{index},new Object[]{child});\n        for (        TreeModelListener listener : listeners) {\n          try {\n            listener.treeNodesRemoved(event);\n          }\n catch (          NullPointerException|ArrayIndexOutOfBoundsException npe) {\n          }\n        }\n      }\n    }\n  }\n}", "comment": "removes the tv show .", "label": "what"}
{"id": "41291", "raw_code": "private ComplianceFeature checkEncryptPolicy(org.wso2.emm.agent.beans.Operation operation){\n  boolean encryptStatus=(devicePolicyManager.getStorageEncryptionStatus() != devicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED && devicePolicyManager.getStorageEncryptionStatus() != devicePolicyManager.ENCRYPTION_STATUS_INACTIVE);\n  if ((operation.isEnabled() && encryptStatus) || (!operation.isEnabled() && !encryptStatus)) {\n    policy.setCompliance(true);\n  }\n else {\n    policy.setCompliance(false);\n    policy.setMessage(resources.getString(R.string.error_encrypt_policy));\n  }\n  return policy;\n}", "comment": "checks device encrypt policy on the device ( device external storage encryption ) .", "label": "what"}
{"id": "51343", "raw_code": "@Override public void add(int location,E object){\n  insertElementAt(object,location);\n}", "comment": "adds the specified object into this vector at the specified location .", "label": "what"}
{"id": "64391", "raw_code": "protected Object finish(Map settings) throws WizardException {\n  return provider.finish(settings);\n}", "comment": "instantiate whatever object ( if any ) the wizard creates from its gathered data .", "label": "what"}
{"id": "57221", "raw_code": "public boolean isValidAttachmentPoint(DatapathId switchDPID,OFPort switchPort){\n  if (topology.isAttachmentPointPort(switchDPID,switchPort) == false)   return false;\n  if (suppressAPs.contains(new SwitchPort(switchDPID,switchPort)))   return false;\n  return true;\n}", "comment": "check whether the given attachment point is valid given the current topology", "label": "what"}
{"id": "2001", "raw_code": "protected void fireClusterChange(long timestamp,String type,String message){\n  if (listeners != null && !listeners.isEmpty()) {\n    ClusterEvent event=new ClusterEvent(this,timestamp,type,message);\n    Vector targets;\nsynchronized (this) {\n      targets=(Vector)listeners.clone();\n    }\n    Enumeration e=targets.elements();\n    while (e.hasMoreElements()) {\n      ClusterEventListener l=(ClusterEventListener)e.nextElement();\n      l.changeCluster(event);\n    }\n  }\n}", "comment": "fire a clusterchangeevent to all registered listeners", "label": "what"}
{"id": "34069", "raw_code": "public BatchedImageRequest(Request<?> request,ImageContainer container){\n  mRequest=request;\n  mContainers.add(container);\n}", "comment": "constructs a new batchedimagerequest object", "label": "what"}
{"id": "74861", "raw_code": "private boolean checkForCarry(final char[] ca1,final int icarry){\n  boolean carry=false;\n  if (icarry < ca1.length) {\n    if (ca1[icarry] == '6' || ca1[icarry] == '7' || ca1[icarry] == '8' || ca1[icarry] == '9') {\n      carry=true;\n    }\n else     if (ca1[icarry] == '5') {\n      int ii=icarry + 1;\n      for (; ii < ca1.length; ii++) {\n        if (ca1[ii] != '0') {\n          break;\n        }\n      }\n      carry=ii < ca1.length;\n      if (!carry && icarry > 0) {\n        carry=(ca1[icarry - 1] == '1' || ca1[icarry - 1] == '3' || ca1[icarry - 1] == '5' || ca1[icarry - 1] == '7' || ca1[icarry - 1] == '9');\n      }\n    }\n  }\n  return carry;\n}", "comment": "check to see if the digits that are going to be truncated because of the precision should force a round in the preceding digits .", "label": "what"}
{"id": "52654", "raw_code": "public static boolean deleteDirectoryFiles(Set<String> inputFilePathsAndNames){\n  if ((inputFilePathsAndNames == null)) {\n    return false;\n  }\n  boolean didSuccessfullyDeleteAllFiles=true;\n  try {\n    for (    String filePathAndName : inputFilePathsAndNames) {\n      File file=new File(filePathAndName);\n      if (!file.isDirectory()) {\n        boolean deleteSuccess=deleteFile(filePathAndName);\n        if (!deleteSuccess) {\n          logger.debug(\"Warning - \" + filePathAndName + \" failed to delete\");\n          didSuccessfullyDeleteAllFiles=false;\n        }\n      }\n    }\n  }\n catch (  Exception e) {\n    logger.debug(e.toString() + System.lineSeparator() + StackTrace.getStringFromStackTrace(e));\n    return false;\n  }\n  return didSuccessfullyDeleteAllFiles;\n}", "comment": "this is a quiet method .", "label": "what"}
{"id": "68192", "raw_code": "public static File createTempDir(File dir,boolean cleanup) throws IOException {\n  if (!dir.mkdirs() && !dir.exists()) {\n    throw new IOException(String.format(\"Failed to create directory structure '%s'\",dir.toString()));\n  }\n  if (cleanup) {\n    addCleanupHook(dir.toPath());\n  }\n  return dir;\n}", "comment": "create directory that is automatically cleaned up after the jvm shuts down through use of a runtime shutdown hook .", "label": "what"}
{"id": "29535", "raw_code": "public void add(int pos,Box b){\n  children.add(pos,b);\n  b.parent=this;\n  b.elderParent=elderParent;\n}", "comment": "inserts the given box at the given position in the list of child boxes .", "label": "what"}
{"id": "46626", "raw_code": "public Position createPosition(int offset) throws BadLocationException {\n  while (queue.poll() != null) {\n    unusedMarks++;\n  }\n  if (unusedMarks > Math.max(5,(marks.size() / 10))) {\n    removeUnusedMarks();\n  }\n  int g0=getGapStart();\n  int g1=getGapEnd();\n  int index=(offset < g0) ? offset : offset + (g1 - g0);\n  search.index=index;\n  int sortIndex=findSortIndex(search);\n  MarkData m;\n  StickyPosition position;\n  if (sortIndex < marks.size() && (m=marks.elementAt(sortIndex)).index == index && (position=m.getPosition()) != null) {\n  }\n else {\n    position=new StickyPosition();\n    m=new MarkData(index,position,queue);\n    position.setMark(m);\n    marks.insertElementAt(m,sortIndex);\n  }\n  return position;\n}", "comment": "creates a position within the content that will track change as the content is mutated .", "label": "what"}
{"id": "63167", "raw_code": "public static String pad(String string,int n,String padding,boolean right){\n  if (n < 0) {\n    n=0;\n  }\n  if (n < string.length()) {\n    return string.substring(0,n);\n  }\n else   if (n == string.length()) {\n    return string;\n  }\n  char paddingChar;\n  if (padding == null || padding.length() == 0) {\n    paddingChar=' ';\n  }\n else {\n    paddingChar=padding.charAt(0);\n  }\n  StringBuilder buff=new StringBuilder(n);\n  n-=string.length();\n  if (right) {\n    buff.append(string);\n  }\n  for (int i=0; i < n; i++) {\n    buff.append(paddingChar);\n  }\n  if (!right) {\n    buff.append(string);\n  }\n  return buff.toString();\n}", "comment": "pad a string .", "label": "what"}
{"id": "32607", "raw_code": "public void addMutedUsername(final String username,final Date muteTill){\n  if (isUsernameMuted(username)) {\n    removeMutedUsername(username);\n  }\n  Timestamp muteTillTs=null;\n  if (muteTill != null) {\n    muteTillTs=new Timestamp(muteTill.getTime());\n  }\n  s_logger.fine(\"Muting username:\" + username);\n  final Connection con=Database.getConnection();\n  try {\n    final PreparedStatement ps=con.prepareStatement(\"insert into muted_usernames (username, mute_till) values (?, ?)\");\n    ps.setString(1,username);\n    ps.setTimestamp(2,muteTillTs);\n    ps.execute();\n    ps.close();\n    con.commit();\n  }\n catch (  final SQLException sqle) {\n    if (sqle.getErrorCode() == 30000) {\n      s_logger.info(\"Tried to create duplicate muted username:\" + username + \" error:\"+ sqle.getMessage());\n      return;\n    }\n    s_logger.log(Level.SEVERE,\"Error inserting muted username:\" + username,sqle);\n    throw new IllegalStateException(sqle.getMessage());\n  }\n finally {\n    DbUtil.closeConnection(con);\n  }\n}", "comment": "mute the given username .", "label": "what"}
{"id": "75057", "raw_code": "private Response<Bitmap> doParse(NetworkResponse response){\n  byte[] data=response.data;\n  Log.d(\"Checksum\",\"Decode\");\n  BitmapFactory.Options decodeOptions=new BitmapFactory.Options();\n  Bitmap bitmap=null;\n  Log.d(\"Checksum\",\"Decodess\");\n  decodeOptions.inJustDecodeBounds=true;\n  BitmapFactory.decodeByteArray(data,0,data.length,decodeOptions);\n  int actualWidth=decodeOptions.outWidth;\n  int actualHeight=decodeOptions.outHeight;\n  int desiredWidth=getResizedDimension(mMaxWidth,mMaxHeight,actualWidth,actualHeight,mScaleType);\n  int desiredHeight=getResizedDimension(mMaxHeight,mMaxWidth,actualHeight,actualWidth,mScaleType);\n  decodeOptions.inJustDecodeBounds=false;\n  decodeOptions.inSampleSize=findBestSampleSize(actualWidth,actualHeight,desiredWidth,desiredHeight);\n  Bitmap tempBitmap=BitmapFactory.decodeByteArray(data,0,data.length,decodeOptions);\n  if (tempBitmap != null && (tempBitmap.getWidth() > desiredWidth || tempBitmap.getHeight() > desiredHeight)) {\n    bitmap=Bitmap.createScaledBitmap(tempBitmap,desiredWidth,desiredHeight,true);\n    tempBitmap.recycle();\n  }\n else {\n    bitmap=tempBitmap;\n  }\n  if (bitmap == null) {\n    return Response.error(new ParseError(response));\n  }\n else {\n    return Response.success(bitmap,HttpHeaderParser.parseCacheHeaders(response));\n  }\n}", "comment": "the real guts of parsenetworkresponse .", "label": "what"}
{"id": "51061", "raw_code": "public boolean isEmpty(){\n  return mSelectedWidgets.isEmpty();\n}", "comment": "check if the selection is empty", "label": "what"}
{"id": "7718", "raw_code": "protected void drawLowFarOut(double aRadius,Graphics2D g2,double xx,double m){\n  double side=aRadius * 2;\n  g2.draw(new Line2D.Double(xx - side,m - side,xx + side,m - side));\n  g2.draw(new Line2D.Double(xx - side,m - side,xx,m));\n  g2.draw(new Line2D.Double(xx + side,m - side,xx,m));\n}", "comment": "draws a triangle to indicate the presence of far out values .", "label": "what"}
{"id": "67093", "raw_code": "public boolean isJavaLibraryClass(){\n  if (name.startsWith(\"java.\") || name.startsWith(\"sun.\") || name.startsWith(\"javax.\")|| name.startsWith(\"com.sun.\")|| name.startsWith(\"org.omg.\")|| name.startsWith(\"org.xml.\"))   return true;\n  return false;\n}", "comment": "sometimes we need to know which class is a jdk class .", "label": "what"}
{"id": "46024", "raw_code": "private Set<ObjectName> objectNamesFromFilteredNamedObjects(Set<NamedObject> list,QueryExp query){\n  Set<ObjectName> result=new HashSet<ObjectName>();\n  if (query == null) {\n    for (    NamedObject no : list) {\n      result.add(no.getName());\n    }\n  }\n else {\n    final MBeanServer oldServer=QueryEval.getMBeanServer();\n    query.setMBeanServer(server);\n    try {\n      for (      NamedObject no : list) {\n        boolean res;\n        try {\n          res=query.apply(no.getName());\n        }\n catch (        Exception e) {\n          res=false;\n        }\n        if (res) {\n          result.add(no.getName());\n        }\n      }\n    }\n  finally {\n      query.setMBeanServer(oldServer);\n    }\n  }\n  return result;\n}", "comment": "applies the specified queries to the set of namedobjects .", "label": "what"}
{"id": "67587", "raw_code": "private boolean checkTouchSlop(View child,float dx,float dy){\n  if (child == null) {\n    return false;\n  }\n  final boolean checkHorizontal=mCallback.getViewHorizontalDragRange(child) > 0;\n  final boolean checkVertical=mCallback.getViewVerticalDragRange(child) > 0;\n  if (checkHorizontal && checkVertical) {\n    return dx * dx + dy * dy > mTouchSlop * mTouchSlop;\n  }\n else   if (checkHorizontal) {\n    return Math.abs(dx) > mTouchSlop;\n  }\n else   if (checkVertical) {\n    return Math.abs(dy) > mTouchSlop;\n  }\n  return false;\n}", "comment": "check if we ' ve crossed a reasonable touch slop for the given child view .", "label": "what"}
{"id": "9917", "raw_code": "private Element createEndPoint(String name,String attrBinding,String attrLocation,String attrResponseLocation) throws DOMException {\n  if (name == null) {\n    throw new IllegalArgumentException(\"Null name\");\n  }\n  if (attrBinding == null) {\n    throw new IllegalArgumentException(\"Null binding\");\n  }\n  if (attrLocation == null) {\n    throw new IllegalArgumentException(\"Null location\");\n  }\n  Element endPt=doc.createElement(name);\n  endPt.setAttribute(SAMLNames.BINDING,attrBinding);\n  endPt.setAttribute(SAMLNames.LOCATION,attrLocation);\n  if (attrResponseLocation != null) {\n    endPt.setAttribute(SAMLNames.RESPLOC,attrResponseLocation);\n  }\n  return endPt;\n}", "comment": "create end point element in dom .", "label": "what"}
{"id": "3183", "raw_code": "void putFile(String relativePath,Codebase codebase){\n  try {\n    File dest=new File(rootDirectory.getAbsolutePath(),relativePath);\n    File src=codebase.getFile(relativePath);\n    boolean srcExists=filesystem.exists(src);\n    boolean destExists=filesystem.exists(dest);\n    boolean srcExecutable=filesystem.isExecutable(src);\n    boolean destExecutable=filesystem.isExecutable(dest);\n    if (!srcExists && !destExists) {\n      throw new MoeProblem(\"Neither src nor dests exists. Unreachable code:%n%s%n%s%n%s\",relativePath,src,dest);\n    }\n    if (!srcExists) {\n      util.runSvnCommandWithWorkingDirectory(rootDirectory.getAbsolutePath(),\"rm\",relativePath);\n      return;\n    }\n    try {\n      filesystem.makeDirsForFile(dest);\n      filesystem.copyFile(src,dest);\n    }\n catch (    IOException e) {\n      throw new MoeProblem(e.getMessage());\n    }\n    if (!destExists) {\n      util.runSvnCommandWithWorkingDirectory(rootDirectory.getAbsolutePath(),\"add\",\"--parents\",relativePath);\n    }\n    String mimeType=guessMimeType(relativePath);\n    if (mimeType != null) {\n      try {\n        util.runSvnCommandWithWorkingDirectory(rootDirectory.getAbsolutePath(),\"propset\",\"svn:mime-type\",mimeType,relativePath);\n      }\n catch (      CommandRunner.CommandException e) {\n        ui.message(\"Error setting mime-type for %s\",relativePath);\n      }\n    }\n    if (destExecutable != srcExecutable) {\n      if (srcExecutable) {\n        util.runSvnCommandWithWorkingDirectory(rootDirectory.getAbsolutePath(),\"propset\",\"svn:executable\",\"*\",relativePath);\n      }\n else {\n        util.runSvnCommandWithWorkingDirectory(rootDirectory.getAbsolutePath(),\"propdel\",\"svn:executable\",relativePath);\n      }\n    }\n  }\n catch (  CommandRunner.CommandException e) {\n    throw new MoeProblem(\"problem occurred while running svn: \" + e.stderr);\n  }\n}", "comment": "put file from c into this writer .", "label": "what"}
{"id": "76167", "raw_code": "Calendar toCalendar(String value,String pattern,Locale locale){\n  Calendar calendar=null;\n  try {\n    DateFormat format=(locale == null) ? new SimpleDateFormat(pattern) : new SimpleDateFormat(pattern,locale);\n    format.setLenient(false);\n    format.parse(value);\n    calendar=format.getCalendar();\n  }\n catch (  Exception e) {\n    fail(\"Error creating Calendar value ='\" + value + \", pattern='\"+ pattern+ \"' \"+ e.toString());\n  }\n  return calendar;\n}", "comment": "parse a string value to a calendar", "label": "what"}
{"id": "60446", "raw_code": "private static void saveTemplate(File parentDir,FileTemplateBase template,final String lineSeparator) throws IOException {\n  final File templateFile=new File(parentDir,encodeFileName(template.getName(),template.getExtension()));\n  FileOutputStream fileOutputStream;\n  try {\n    fileOutputStream=new FileOutputStream(templateFile);\n  }\n catch (  FileNotFoundException e) {\n    FileUtil.delete(templateFile);\n    fileOutputStream=new FileOutputStream(templateFile);\n  }\n  OutputStreamWriter outputStreamWriter=new OutputStreamWriter(fileOutputStream,CharsetToolkit.UTF8_CHARSET);\n  String content=template.getText();\n  if (!lineSeparator.equals(\"\\n\")) {\n    content=StringUtil.convertLineSeparators(content,lineSeparator);\n  }\n  outputStreamWriter.write(content);\n  outputStreamWriter.close();\n  fileOutputStream.close();\n}", "comment": "save template to file .", "label": "what"}
{"id": "70108", "raw_code": "protected static void postProcessFlood(IHex[] hexSet,int modifier){\n  int n;\n  IHex field;\n  ITerrainFactory f=Terrains.getTerrainFactory();\n  for (n=0; n < hexSet.length; n++) {\n    field=hexSet[n];\n    int elev=field.getLevel() - modifier;\n    if ((elev == 0) && !(field.containsTerrain(Terrains.WATER)) && !(field.containsTerrain(Terrains.PAVEMENT))) {\n      field.addTerrain(f.createTerrain(Terrains.SWAMP,1));\n    }\n else     if (elev < 0) {\n      if (elev < -4) {\n        elev=-4;\n      }\n      field.removeAllTerrains();\n      field.addTerrain(f.createTerrain(Terrains.WATER,-elev));\n      field.setLevel(modifier);\n    }\n  }\n}", "comment": "flood negative hex levels shoreline / salt marshes effect works best with more elevation", "label": "what"}
{"id": "85057", "raw_code": "public ModuleHandle addModule(String moduleName,String sessionKey){\n  String sanitizedModuleName=generateUniqueNameIfNullOrEmpty(moduleName,\"Module\");\n  ModuleHandle moduleHandle=new ModuleHandle(sanitizedModuleName,sessionKey);\nsynchronized (privateInstanceLock) {\n    modules.add(moduleHandle);\n  }\n  setTerminated(false);\n  return moduleHandle;\n}", "comment": "add a module that was loaded in this browser tab .", "label": "what"}
{"id": "12965", "raw_code": "private static void expand2DigitNumber(String numberString,WordRelation wordRelation,Item tokenItem){\n  if (numberString.charAt(0) == '0') {\n    if (numberString.charAt(1) == '0') {\n    }\n else {\n      String number=digit2num[numberString.charAt(1) - '0'];\n      wordRelation.addWord(tokenItem,number);\n    }\n  }\n else   if (numberString.charAt(1) == '0') {\n    String number=digit2enty[numberString.charAt(0) - '0'];\n    wordRelation.addWord(tokenItem,number);\n  }\n else   if (numberString.charAt(0) == '1') {\n    String number=digit2teen[numberString.charAt(1) - '0'];\n    wordRelation.addWord(tokenItem,number);\n  }\n else {\n    String enty=digit2enty[numberString.charAt(0) - '0'];\n    wordRelation.addWord(tokenItem,enty);\n    expandDigits(numberString.substring(1,numberString.length()),wordRelation,tokenItem);\n  }\n}", "comment": "expands a two - digit string into a list of english words .", "label": "what"}
{"id": "13177", "raw_code": "protected int indexOf(String buffer,int start,int end,char ch){\n  for (int i=start; i < end; i++) {\n    if (buffer.charAt(i) == ch) {\n      return i;\n    }\n  }\n  return -1;\n}", "comment": "computes index of given char within stringbuffer", "label": "what"}
{"id": "85505", "raw_code": "public Factory(JavacMessages messages,String prefix){\n  this.prefix=prefix;\n  this.formatter=new BasicDiagnosticFormatter(messages);\n  defaultErrorFlags=EnumSet.of(DiagnosticFlag.MANDATORY);\n}", "comment": "create a new diagnostic factory .", "label": "what"}
{"id": "20208", "raw_code": "@Override public boolean isEnabled(){\n  if ((attributeSelectionPanel != null) && !isValueOnly()) {\n    return attributeSelectionPanel.isEnabled();\n  }\n else {\n    if (this.crsComboBox != null) {\n      return crsComboBox.isEnabled();\n    }\n  }\n  return false;\n}", "comment": "checks if is enabled .", "label": "what"}
{"id": "84600", "raw_code": "public static double variance(double[] x,double mean){\n  double var=0;\n  int count=x.length;\n  for (  double aX : x) {\n    if (Double.isNaN(aX)) {\n      count--;\n    }\n else {\n      double diff=aX - mean;\n      var+=diff * diff;\n    }\n  }\n  if (count < 2) {\n    count=1;\n  }\n else {\n    count=count - 1;\n  }\n  return var / (double)count;\n}", "comment": "compute variance ( ml estimator )", "label": "what"}
{"id": "61398", "raw_code": "protected void serializeText(Text node) throws SAXException {\n  if (fNextIsRaw) {\n    fNextIsRaw=false;\n    fSerializer.processingInstruction(javax.xml.transform.Result.PI_DISABLE_OUTPUT_ESCAPING,\"\");\n    dispatachChars(node);\n    fSerializer.processingInstruction(javax.xml.transform.Result.PI_ENABLE_OUTPUT_ESCAPING,\"\");\n  }\n else {\n    boolean bDispatch=false;\n    if ((fFeatures & WELLFORMED) != 0) {\n      isTextWellFormed(node);\n    }\n    boolean isElementContentWhitespace=false;\n    if (fIsLevel3DOM) {\n      isElementContentWhitespace=node.isElementContentWhitespace();\n    }\n    if (isElementContentWhitespace) {\n      if ((fFeatures & ELEM_CONTENT_WHITESPACE) != 0) {\n        bDispatch=true;\n      }\n    }\n else {\n      bDispatch=true;\n    }\n    if (!applyFilter(node,NodeFilter.SHOW_TEXT)) {\n      return;\n    }\n    if (bDispatch) {\n      dispatachChars(node);\n    }\n  }\n}", "comment": "serializes an text node .", "label": "what"}
{"id": "60476", "raw_code": "@Override public boolean isInsideSoftWrap(@NotNull VisualPosition visual){\n  return isInsideSoftWrap(visual,false);\n}", "comment": "allows to answer if given visual position points to soft wrap - introduced virtual space .", "label": "what"}
{"id": "30509", "raw_code": "static public InputStream findClusterXML(String _clusterXML){\n  String schemaNameToBeUsed=_clusterXML;\n  InputStream schemaInputStream;\n  String schemaFilePath=Constants.Container.CONTAINER_CONFIG_DIRECTORY + \"/\" + schemaNameToBeUsed+ ClusterXML.CLUSTER_XML_FILE_SUFFIX;\n  schemaInputStream=getResourceStream(schemaFilePath);\n  if (schemaInputStream != null) {\n    if (_logger.isLoggable(Level.INFO)) {\n      _logger.info(\"Loaded the cluster XML < \" + getResourceURL(schemaNameToBeUsed) + \" > for the cluster config setup.\");\n    }\n    return schemaInputStream;\n  }\n else {\n    String defaultSchemaFileName=Constants.Container.CONTAINER_CONFIG_DIRECTORY + \"/\" + Constants.Schemas.DEFAULT_SCHEMA+ ClusterXML.CLUSTER_XML_FILE_SUFFIX;\n    schemaInputStream=getResourceStream(defaultSchemaFileName);\n    if (schemaInputStream != null) {\n      if (_logger.isLoggable(Level.WARNING)) {\n        _logger.warning(\"Could not find the cluster xml file: \" + schemaFilePath + \".\\n Loaded the default cluster xml < \"+ getResourceURL(defaultSchemaFileName)+ \" > for the cluster config setup.\");\n      }\n      return schemaInputStream;\n    }\n else {\n      if (_logger.isLoggable(Level.WARNING)) {\n        _logger.warning(\"The requested cluster xml file does not exist in the following path: \" + defaultSchemaFileName);\n      }\n    }\n  }\n  return schemaInputStream;\n}", "comment": "look for the requested cluster xml file in the resourcebundle ( classpath ) under / config / - cluster . xml .", "label": "what"}
{"id": "729", "raw_code": "public void clear(){\n  Arrays.fill(ritems,0,rsize,null);\n  Arrays.fill(pitems,0,psize,null);\n  rsize=0;\n  psize=0;\n}", "comment": "clear both rendering and picking queues .", "label": "what"}
{"id": "6670", "raw_code": "public final AC growPrio(int p){\n  return growPrio(p,curIx);\n}", "comment": "specifies the current row / column ' s grow priority .", "label": "what"}
{"id": "3380", "raw_code": "private int flush(int offset){\n  try {\n    _os.write(_buffer,0,offset);\n    _offset=0;\n    return 0;\n  }\n catch (  IOException e) {\n    throw new H3ExceptionOut(e);\n  }\n}", "comment": "flush the buffer and set the offset to zero .", "label": "what"}
{"id": "38723", "raw_code": "public synchronized void removeGraphListener(GraphListener cl){\n  m_graphListeners.remove(cl);\n}", "comment": "remove a graph listener", "label": "what"}
{"id": "64344", "raw_code": "public int increment(int offset){\n  CharSequence txt=getText();\n  int i;\n  if (txt != null) {\n    try {\n      i=Integer.parseInt(txt.toString());\n    }\n catch (    NumberFormatException e) {\n      i=0;\n    }\n  }\n else {\n    i=0;\n  }\n  i=i + offset;\n  setText(String.valueOf(i));\n  return i;\n}", "comment": "increment the numeric badge label .", "label": "what"}
{"id": "1868", "raw_code": "public static ServiceConfiguration create(InputStream inStream) throws IOException, IllegalArgumentException {\n  try {\n    checkNotNull(inStream);\n    Properties properties=new Properties();\n    properties.load(inStream);\n    return (create(properties));\n  }\n  finally {\n    if (inStream != null) {\n      inStream.close();\n    }\n  }\n}", "comment": "creates serviceconfiguration and loads it with populated attribute values loaded from provided inputstream property file .", "label": "what"}
{"id": "53586", "raw_code": "public static boolean isFailure(List<Action> actions){\n  return actions.isEmpty();\n}", "comment": "checks whether a list of actions is empty .", "label": "what"}
{"id": "75809", "raw_code": "public static int[][] deep_copy(int M[][]){\n  int[][] C=new int[M.length][];\n  for (int i=0; i < C.length; i++) {\n    C[i]=Arrays.copyOf(M[i],M[i].length);\n  }\n  return C;\n}", "comment": "deep copy - make a deep copy of m [ ] [ ] .", "label": "what"}
{"id": "17458", "raw_code": "public final boolean checkTag(int identifier){\n  return Arrays.binarySearch(identifiers[0],identifier) >= 0;\n}", "comment": "tests whether one of choice alternatives has the same identifier or not .", "label": "what"}
{"id": "32838", "raw_code": "public Date(String date){\n  String[] fields=date.split(\"/\");\n  if (fields.length != 3) {\n    throw new IllegalArgumentException(\"Invalid date\");\n  }\n  month=Integer.parseInt(fields[0]);\n  day=Integer.parseInt(fields[1]);\n  year=Integer.parseInt(fields[2]);\n  if (!isValid(month,day,year))   throw new IllegalArgumentException(\"Invalid date\");\n}", "comment": "initializes new date specified as a string in form mm / dd / yyyy .", "label": "what"}
{"id": "9322", "raw_code": "public static void copy(File src,File dst) throws IOException {\n  if (src.isDirectory()) {\n    ensureDirectoryExists(dst);\n    String[] filesList=src.list();\n    for (    String file : filesList) {\n      File srcFile=new File(src,file);\n      File destFile=new File(dst,file);\n      copy(srcFile,destFile);\n    }\n  }\n else {\n    copyFile(src,dst);\n  }\n}", "comment": "copy file object from one place to another .", "label": "what"}
{"id": "6723", "raw_code": "public MapObjects(PokemonGo api){\n  this.api=api;\n}", "comment": "instantiates a new map objects .", "label": "what"}
{"id": "60615", "raw_code": "@Override public byte[] read(int length) throws IOException {\n  if (length > available()) {\n    throw new EndOfBufferException();\n  }\n  byte[] res=new byte[length];\n  System.arraycopy(buffer,read_pos,res,0,length);\n  read_pos=read_pos + length;\n  return res;\n}", "comment": "reads vector of opaque values", "label": "what"}
{"id": "49011", "raw_code": "static void incrementKeepAliveCount(){\nsynchronized (keepAliveLock) {\n    keepAliveCount++;\n    if (reaper == null) {\n      reaper=AccessController.doPrivileged(new NewThreadAction(new Reaper(),\"Reaper\",false));\n      reaper.start();\n    }\n    if (gcLatencyRequest == null) {\n      gcLatencyRequest=GC.requestLatency(gcInterval);\n    }\n  }\n}", "comment": "increments the \" keep - alive count \" .", "label": "what"}
{"id": "35077", "raw_code": "private static void delete(File f){\n  if (f.isDirectory()) {\n    for (    File c : f.listFiles()) {\n      delete(c);\n    }\n  }\n  if (!f.delete()) {\n    PrintStream err=System.err;\n    err.println(\"Failed to delete file: \" + f);\n  }\n}", "comment": "recursively deletes a file that may represent a directory .", "label": "what"}
{"id": "76429", "raw_code": "protected List<String> prepareSortKeyStatements(List<SortKey> sortKeys){\n  List<String> keys=new ArrayList<String>();\n  for (int i=0; i < sortKeys.size(); i++) {\n    SortKey sortKey=sortKeys.get(i);\n    keys.add(explicitMapping.getDbColumnName(sortKey.getField()) + (sortKey.isAscendingOrder() ? \" ASC\" : \" DESC\"));\n  }\n  return keys;\n}", "comment": "loops through sort keys constructing the key statements .", "label": "what"}
{"id": "26698", "raw_code": "public static void printMagnitudes(){\n  printMagnitudes(System.out);\n}", "comment": "prints the relative magnitudes of the collected timer data to the standard output stream .", "label": "what"}
{"id": "68198", "raw_code": "private Optional<CuratorFramework> createClient(String zookeeperUrl){\n  if (StringUtils.isNotBlank(zookeeperUrl)) {\n    CuratorFramework client=ConfigurationsUtils.getClient(zookeeperUrl);\n    client.start();\n    return Optional.of(client);\n  }\n else {\n    return Optional.empty();\n  }\n}", "comment": "creates a zookeeper client .", "label": "what"}
{"id": "7143", "raw_code": "public final static int readRawUntil(final StringBuilder out,final String in,final int start,final char end){\n  int pos=start;\n  while (pos < in.length()) {\n    final char ch=in.charAt(pos);\n    if (ch == end) {\n      break;\n    }\n    out.append(ch);\n    pos++;\n  }\n  return (pos == in.length()) ? -1 : pos;\n}", "comment": "reads characters until the end character is encountered , ignoring escape sequences .", "label": "what"}
{"id": "29582", "raw_code": "private static SSLSocketFactory trustAllHosts(HttpsURLConnection connection){\n  SSLSocketFactory oldFactory=connection.getSSLSocketFactory();\n  try {\n    SSLContext sc=SSLContext.getInstance(\"TLS\");\n    sc.init(null,trustAllCerts,new java.security.SecureRandom());\n    SSLSocketFactory newFactory=sc.getSocketFactory();\n    connection.setSSLSocketFactory(newFactory);\n  }\n catch (  Exception e) {\n    LOG.e(LOG_TAG,e.getMessage(),e);\n  }\n  return oldFactory;\n}", "comment": "this function will install a trust manager that will blindly trust all ssl certificates .", "label": "what"}
{"id": "66016", "raw_code": "public void updateAmount(){\n  setAmt(getTotalAmount());\n}", "comment": "updates the amount on the document", "label": "what"}
{"id": "38436", "raw_code": "private void updateLegends(){\n  if (m_span == null) {\n    m_span=new JPanel();\n  }\n  JPanel padder=new JPanel();\n  JPanel padd2=new JPanel();\n  m_span.setPreferredSize(new Dimension(m_span.getPreferredSize().width,(m_plots.size() + 1) * 20));\n  m_span.setMaximumSize(new Dimension(m_span.getPreferredSize().width,(m_plots.size() + 1) * 20));\n  LegendEntry tmp;\n  GridBagLayout gb=new GridBagLayout();\n  GridBagLayout gb2=new GridBagLayout();\n  GridBagConstraints constraints=new GridBagConstraints();\n  m_span.removeAll();\n  padder.setLayout(gb);\n  m_span.setLayout(gb2);\n  constraints.anchor=GridBagConstraints.CENTER;\n  constraints.gridx=0;\n  constraints.gridy=0;\n  constraints.weightx=5;\n  constraints.fill=GridBagConstraints.HORIZONTAL;\n  constraints.gridwidth=1;\n  constraints.gridheight=1;\n  constraints.insets=new Insets(0,0,0,0);\n  padder.add(m_span,constraints);\n  constraints.gridx=0;\n  constraints.gridy=1;\n  constraints.weightx=5;\n  constraints.fill=GridBagConstraints.BOTH;\n  constraints.gridwidth=1;\n  constraints.gridheight=1;\n  constraints.weighty=5;\n  constraints.insets=new Insets(0,0,0,0);\n  padder.add(padd2,constraints);\n  constraints.weighty=0;\n  setViewportView(padder);\n  constraints.anchor=GridBagConstraints.CENTER;\n  constraints.gridx=0;\n  constraints.gridy=0;\n  constraints.weightx=5;\n  constraints.fill=GridBagConstraints.HORIZONTAL;\n  constraints.gridwidth=1;\n  constraints.gridheight=1;\n  constraints.weighty=5;\n  constraints.insets=new Insets(2,4,2,4);\n  for (int i=0; i < m_plots.size(); i++) {\n    tmp=new LegendEntry(m_plots.get(i),i);\n    constraints.gridy=i;\n    m_span.add(tmp,constraints);\n  }\n}", "comment": "redraw the panel with the legend entries", "label": "what"}
{"id": "55364", "raw_code": "public void runCommercial(String stream,int length){\n  if (stream == null || stream.isEmpty()) {\n    commercialResult(stream,\"Can't run commercial, not on a channel.\",TwitchApi.RequestResult.FAILED);\n  }\n else {\n    String channel=\"#\" + stream;\n    if (isChannelOpen(channel)) {\n      g.printLine(channel,\"Trying to run \" + length + \"s commercial..\");\n    }\n else {\n      g.printLine(\"Trying to run \" + length + \"s commercial.. (\"+ stream+ \")\");\n    }\n    api.runCommercial(stream,settings.getString(\"token\"),length);\n  }\n}", "comment": "tries to run a commercial on the given stream with the given length .", "label": "what"}
{"id": "33301", "raw_code": "public void addSubTree(int index,List<Node> children){\n  List<NodeDescriptor> nodeDescriptors=convertTreeNodesHelper(children);\n  roots.addChildren(index,nodeDescriptors);\n  List<Node> nodes=new ArrayList<>();\n  for (  NodeDescriptor child : nodeDescriptors) {\n    nodes.add(child.getNode());\n  }\n  if (!nodes.isEmpty()) {\n    fireEvent(new StoreAddEvent(index,nodes));\n  }\n}", "comment": "imports a list of subtrees at the given position in the root of the tree .", "label": "what"}
{"id": "56416", "raw_code": "public static boolean isExplicitAllType(String[] types){\n  return types != null && types.length == 1 && ALL.equals(types[0]);\n}", "comment": "identifies whether the array containing type names given as argument explicitly refers to all types the empty or null array doesn ' t explicitly map to all types", "label": "what"}
{"id": "57797", "raw_code": "private String readUntil(char[] delimiter,boolean returnText) throws IOException, XmlPullParserException {\n  int start=position;\n  StringBuilder result=null;\n  if (returnText && text != null) {\n    result=new StringBuilder();\n    result.append(text);\n  }\n  search:   while (true) {\n    if (position + delimiter.length > limit) {\n      if (start < position && returnText) {\n        if (result == null) {\n          result=new StringBuilder();\n        }\n        result.append(buffer,start,position - start);\n      }\n      if (!fillBuffer(delimiter.length)) {\n        checkRelaxed(UNEXPECTED_EOF);\n        type=COMMENT;\n        return null;\n      }\n      start=position;\n    }\n    for (int i=0; i < delimiter.length; i++) {\n      if (buffer[position + i] != delimiter[i]) {\n        position++;\n        continue search;\n      }\n    }\n    break;\n  }\n  int end=position;\n  position+=delimiter.length;\n  if (!returnText) {\n    return null;\n  }\n else   if (result == null) {\n    return stringPool.get(buffer,start,end - start);\n  }\n else {\n    result.append(buffer,start,end - start);\n    return result.toString();\n  }\n}", "comment": "reads text until the specified delimiter is encountered .", "label": "what"}
{"id": "52886", "raw_code": "public boolean isLeaf(){\n  return children == null || children.isEmpty();\n}", "comment": "true , if the node is a leaf .", "label": "what"}
{"id": "36414", "raw_code": "public static void drawShadow(final Rectangle2D rect,final Graphics2D g2){\n  Graphics2D g2S=(Graphics2D)g2.create();\n  Rectangle2D shadow=new Rectangle2D.Double(rect.getX() + 5,rect.getY() + ProcessDrawer.HEADER_HEIGHT + 5,rect.getWidth(),rect.getHeight() - ProcessDrawer.HEADER_HEIGHT);\n  GeneralPath bottom=new GeneralPath();\n  bottom.moveTo(shadow.getX(),rect.getMaxY());\n  bottom.lineTo(rect.getMaxX(),rect.getMaxY());\n  bottom.lineTo(shadow.getMaxX(),shadow.getMaxY());\n  bottom.lineTo(shadow.getMinX(),shadow.getMaxY());\n  bottom.closePath();\n  g2S.setPaint(new GradientPaint((float)rect.getX(),(float)rect.getMaxY(),Color.gray,(float)rect.getX(),(float)shadow.getMaxY(),TRANSPARENT_GRAY));\n  g2S.fill(bottom);\n  GeneralPath right=new GeneralPath();\n  right.moveTo(rect.getMaxX(),shadow.getMinY());\n  right.lineTo(shadow.getMaxX(),shadow.getMinY());\n  right.lineTo(shadow.getMaxX(),shadow.getMaxY());\n  right.lineTo(rect.getMaxX(),rect.getMaxY());\n  right.closePath();\n  g2S.setPaint(new GradientPaint((float)rect.getMaxX(),(float)shadow.getY(),Color.gray,(float)shadow.getMaxX(),(float)shadow.getY(),TRANSPARENT_GRAY));\n  g2S.fill(right);\n  g2S.dispose();\n}", "comment": "draws a shadow around the given rectangle .", "label": "what"}
{"id": "23956", "raw_code": "public static void interrupt(final Thread thread){\n  if (thread != null) {\n    thread.interrupt();\n  }\n}", "comment": "interrupts the specified thread , guarding against null .", "label": "what"}
{"id": "38608", "raw_code": "public void loadLayout(File oFile,boolean newTab){\n  loadLayout(oFile,newTab,false);\n}", "comment": "load a layout from a file .", "label": "what"}
{"id": "26797", "raw_code": "public static void CF5(double[] x,double[] f,double[] c,int nx){\n  double sum1=0.0;\n  double sum2=0.0;\n  double yj;\n  for (int j=2; j <= nx; j++) {\n    if (j % 2 == 1) {\n      yj=x[j - 1] - 0.8 * x[0] * Math.cos(6.0 * PI * x[0] + j * PI / nx);\n      sum1+=2.0 * yj * yj - Math.cos(4.0 * PI * yj) + 1.0;\n    }\n else {\n      yj=x[j - 1] - 0.8 * x[0] * Math.sin(6.0 * PI * x[0] + j * PI / nx);\n      if (j == 2) {\n        sum2+=yj < 1.5 - 0.75 * Math.sqrt(2.0) ? Math.abs(yj) : (0.125 + (yj - 1) * (yj - 1));\n      }\n else {\n        sum2+=2.0 * yj * yj - Math.cos(4.0 * PI * yj) + 1.0;\n      }\n    }\n  }\n  f[0]=x[0] + sum1;\n  f[1]=1.0 - x[0] + sum2;\n  c[0]=x[1] - 0.8 * x[0] * Math.sin(6.0 * x[0] * PI + 2.0 * PI / nx) - 0.5 * x[0] + 0.25;\n}", "comment": "evaluates the cf5 problem .", "label": "what"}
{"id": "33418", "raw_code": "public boolean hasParameter(String name){\n  return _parameters.hasParameter(name);\n}", "comment": "checks if the extension contains a parameter .", "label": "what"}
{"id": "22186", "raw_code": "public boolean isAppendTaskName(){\n  return appendTaskName;\n}", "comment": "checks if the appendtaskname flag is set .", "label": "what"}
{"id": "28843", "raw_code": "public static Cache.Entry makeRandomCacheEntry(byte[] data,boolean isExpired,boolean needsRefresh){\n  Random random=new Random();\n  Cache.Entry entry=new Cache.Entry();\n  if (data != null) {\n    entry.data=data;\n  }\n else {\n    entry.data=new byte[random.nextInt(1024)];\n  }\n  entry.etag=String.valueOf(random.nextLong());\n  entry.lastModified=random.nextLong();\n  entry.ttl=isExpired ? 0 : Long.MAX_VALUE;\n  entry.softTtl=needsRefresh ? 0 : Long.MAX_VALUE;\n  return entry;\n}", "comment": "makes a random cache entry .", "label": "what"}
{"id": "62088", "raw_code": "private static boolean isStartElement(String line){\n  int first=line.lastIndexOf(\"<\");\n  int last=line.lastIndexOf(\">\");\n  if (last < first) {\n    return true;\n  }\n else {\n    int firstEnd=line.lastIndexOf(\"</\");\n    int lastEnd=line.lastIndexOf(\"/>\");\n    if ((firstEnd != first) && ((lastEnd + 1) != last)) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "tries to find out if the line finishes with an element start", "label": "what"}
{"id": "4115", "raw_code": "long readLong() throws IOException {\n  return (((long)_is.read() << 56) | ((long)_is.read() << 48) | ((long)_is.read() << 40)| ((long)_is.read() << 32)| ((long)_is.read() << 24)| ((long)_is.read() << 16)| ((long)_is.read() << 8)| ((long)_is.read()));\n}", "comment": "parses a 64 - bit int .", "label": "what"}
{"id": "39134", "raw_code": "@Override public Instance remove(int index){\n  return m_Instances.remove(index);\n}", "comment": "removes the instance at the given position .", "label": "what"}
{"id": "54476", "raw_code": "protected static String extractAccessKey(String s3uri){\n  return s3uri.substring(s3uri.indexOf(\"://\") + 3,s3uri.indexOf(':',s3uri.indexOf(\"://\") + 3));\n}", "comment": "extracts the accesskey from the given uri", "label": "what"}
{"id": "61747", "raw_code": "public boolean doTransaction(DB db,Object threadstate) throws WorkloadException {\n  boolean ret=true;\n  long st=System.nanoTime();\n  String op=operationchooser.nextString();\n  if (op.compareTo(\"READ\") == 0) {\n    ret=doTransactionRead(db);\n  }\n else   if (op.compareTo(\"UPDATE\") == 0) {\n    ret=doTransactionUpdate(db);\n  }\n else   if (op.compareTo(\"INSERT\") == 0) {\n    ret=doTransactionInsert(db);\n  }\n else   if (op.compareTo(\"SCAN\") == 0) {\n    ret=doTransactionScan(db);\n  }\n else {\n    ret=doTransactionReadModifyWrite(db);\n  }\n  long en=System.nanoTime();\n  _measurements.measure(_operations.get(op),(int)((en - st) / 1000));\n  if (ret)   _measurements.reportReturnCode(_operations.get(op),-1);\n else {\n    _measurements.reportReturnCode(_operations.get(op),0);\n  }\n  actualopcount.addAndGet(1);\n  return ret;\n}", "comment": "do one transaction operation .", "label": "what"}
{"id": "63230", "raw_code": "public static void copyExcept(Object src,Object dst,int oldSize,int removeIndex){\n  if (removeIndex > 0 && oldSize > 0) {\n    System.arraycopy(src,0,dst,0,removeIndex);\n  }\n  if (removeIndex < oldSize) {\n    System.arraycopy(src,removeIndex + 1,dst,removeIndex,oldSize - removeIndex - 1);\n  }\n}", "comment": "copy the elements of an array , and remove one element .", "label": "what"}
{"id": "14964", "raw_code": "public SiteMonitor(String[] urlList){\n  siteUrlList=urlList;\n}", "comment": "constructs a webtopnaming $ sitemonitor object with the provided site urls .", "label": "what"}
{"id": "61104", "raw_code": "private Set unionIPRange(byte[] ipWithSubmask1,byte[] ipWithSubmask2){\n  Set set=new HashSet();\n  if (Arrays.areEqual(ipWithSubmask1,ipWithSubmask2)) {\n    set.add(ipWithSubmask1);\n  }\n else {\n    set.add(ipWithSubmask1);\n    set.add(ipWithSubmask2);\n  }\n  return set;\n}", "comment": "calculates the union if two ip ranges .", "label": "what"}
{"id": "86568", "raw_code": "public static long addAndGet(AtomicLong current,long toAdd){\n  long u, r;\n  do {\n    r=current.get();\n    if (r == Long.MAX_VALUE) {\n      return Long.MAX_VALUE;\n    }\n    u=addCap(r,toAdd);\n  }\n while (!current.compareAndSet(r,u));\n  return u;\n}", "comment": "concurrent addition bound to long . max _ value .", "label": "what"}
{"id": "84814", "raw_code": "public double norm(){\n  double sum=0;\n  for (int i=0; i < components.length; i++)   sum+=components[i] * components[i];\n  return Math.sqrt(sum);\n}", "comment": "computes the norm of a vector .", "label": "what"}
{"id": "75778", "raw_code": "public static double P_Harmonic(int Y[][],int Ypred[][]){\n  int allMissings=0;\n  int N=Y.length;\n  double loss=0.0;\n  for (int i=0; i < N; i++) {\n    if (allMissing(Y[i])) {\n      allMissings++;\n      continue;\n    }\n    double curLoss=P_Harmonic(Y[i],Ypred[i]);\n    if (Double.isNaN(curLoss)) {\n      allMissings++;\n      continue;\n    }\n    loss+=curLoss;\n  }\n  return loss / (double)(N - allMissings);\n}", "comment": "harmonic accuracy - - average over all labels .", "label": "what"}
{"id": "48410", "raw_code": "public void writeEntry(CCacheOutputStream cos) throws IOException {\n  cos.write16(adType);\n  cos.write32(adData.length);\n  cos.write(adData,0,adData.length);\n}", "comment": "writes the entry ' s data fields in fcc format to an output stream .", "label": "what"}
{"id": "82651", "raw_code": "public CloseableAnimatedBitmap(List<Bitmap> bitmaps,List<Integer> durations,ResourceReleaser<Bitmap> resourceReleaser){\n  Preconditions.checkNotNull(bitmaps);\n  Preconditions.checkState(bitmaps.size() >= 1,\"Need at least 1 frame!\");\n  mBitmaps=new ArrayList<>();\n  mBitmapReferences=new ArrayList<>();\n  for (  Bitmap bitmap : bitmaps) {\n    mBitmapReferences.add(CloseableReference.of(bitmap,resourceReleaser));\n    mBitmaps.add(bitmap);\n  }\n  mDurations=Preconditions.checkNotNull(durations);\n  Preconditions.checkState(mDurations.size() == mBitmaps.size(),\"Arrays length mismatch!\");\n}", "comment": "creates a new instance of a closeablestaticbitmap .", "label": "what"}
{"id": "81495", "raw_code": "private void parse() throws SAXException {\n  XStream xstream=(XStream)properties.get(CONFIGURED_XSTREAM_PROPERTY);\n  if (xstream == null) {\n    xstream=new XStream();\n  }\n  final List<?> source=(List<?>)properties.get(SOURCE_OBJECT_LIST_PROPERTY);\n  if (source == null || source.isEmpty()) {\n    throw new SAXException(\"Missing or empty source object list. Setting property \\\"\" + SOURCE_OBJECT_LIST_PROPERTY + \"\\\" is mandatory\");\n  }\n  try {\n    startDocument(true);\n    for (    final Object name : source) {\n      xstream.marshal(name,this);\n    }\n    endDocument(true);\n  }\n catch (  final StreamException e) {\n    if (e.getCause() instanceof SAXException) {\n      throw (SAXException)e.getCause();\n    }\n else {\n      throw new SAXException(e);\n    }\n  }\n}", "comment": "serializes the java objects of the configured list into a flow of sax events .", "label": "what"}
{"id": "11842", "raw_code": "public void dumpIndex(boolean showBounds) throws IOException {\n  byte ixRecord[]=new byte[SPATIAL_INDEX_RECORD_LENGTH];\n  int recNum=0;\n  if (shpFileName == null) {\n    return;\n  }\n  BinaryBufferedFile ssx=new BinaryBufferedFile(ssx(shpFileName));\n  ssx.seek(100);\n  while (true) {\n    int result=ssx.read(ixRecord,0,SPATIAL_INDEX_RECORD_LENGTH);\n    if (result <= 0) {\n      logger.info(\"Processed \" + recNum + \" records\");\n      break;\n    }\n else {\n      recNum++;\n      int offset=readBEInt(ixRecord,0);\n      int length=readBEInt(ixRecord,4);\n      logger.info(\"Record \" + recNum + \": \"+ offset+ \", \"+ length+ (showBounds ? (\"; \" + readLEDouble(ixRecord,8) + \", \"+ readLEDouble(ixRecord,16)+ \", \"+ readLEDouble(ixRecord,24)+ \", \"+ readLEDouble(ixRecord,32)) : \"\"));\n    }\n  }\n  ssx.close();\n}", "comment": "displays the contents of this index .", "label": "what"}
{"id": "23182", "raw_code": "private static boolean compareParam(String jdiffParam,Type reflectionParamType){\n  if (jdiffParam == null) {\n    return false;\n  }\n  String reflectionParam=typeToString(reflectionParamType);\n  if (jdiffParam.equals(reflectionParam)) {\n    return true;\n  }\n  int jdiffParamEndOffset=jdiffParam.indexOf(\"...\");\n  int reflectionParamEndOffset=reflectionParam.indexOf(\"[]\");\n  if (jdiffParamEndOffset != -1 && reflectionParamEndOffset != -1) {\n    jdiffParam=jdiffParam.substring(0,jdiffParamEndOffset);\n    reflectionParam=reflectionParam.substring(0,reflectionParamEndOffset);\n    return jdiffParam.equals(reflectionParam);\n  }\n  return false;\n}", "comment": "compares the parameter from the api and the parameter from reflection .", "label": "what"}
{"id": "5586", "raw_code": "public static void randomNumber(int[] num,int n){\n  for (int j=0; j < n; j++) {\n    num[j]=(int)(Math.random() * 10);\n  }\n}", "comment": "generate random number of size n directly into num", "label": "what"}
{"id": "83985", "raw_code": "private static String escapeJSON(String text){\n  StringBuilder builder=new StringBuilder();\n  builder.append('\"');\n  for (int index=0; index < text.length(); index++) {\n    char chr=text.charAt(index);\nswitch (chr) {\ncase '\"':\ncase '\\\\':\n      builder.append('\\\\');\n    builder.append(chr);\n  break;\ncase '\\b':\nbuilder.append(\"\\\\b\");\nbreak;\ncase '\\t':\nbuilder.append(\"\\\\t\");\nbreak;\ncase '\\n':\nbuilder.append(\"\\\\n\");\nbreak;\ncase '\\r':\nbuilder.append(\"\\\\r\");\nbreak;\ndefault :\nif (chr < ' ') {\nString t=\"000\" + Integer.toHexString(chr);\nbuilder.append(\"\\\\u\" + t.substring(t.length() - 4));\n}\n else {\nbuilder.append(chr);\n}\nbreak;\n}\n}\nbuilder.append('\"');\nreturn builder.toString();\n}", "comment": "escape a string to create a valid json string", "label": "what"}
{"id": "33748", "raw_code": "public void writeTo(OutputStream out) throws IOException {\n  ByteString[] cachedFlushBuffers;\n  byte[] cachedBuffer;\n  int cachedBufferPos;\nsynchronized (this) {\n    cachedFlushBuffers=flushedBuffers.toArray(new ByteString[flushedBuffers.size()]);\n    cachedBuffer=buffer;\n    cachedBufferPos=bufferPos;\n  }\n  for (  ByteString byteString : cachedFlushBuffers) {\n    byteString.writeTo(out);\n  }\n  out.write(copyArray(cachedBuffer,cachedBufferPos));\n}", "comment": "writes the complete contents of this byte array output stream to the specified output stream argument .", "label": "what"}
{"id": "65120", "raw_code": "public void mouseWheelMoved(MouseWheelEvent e){\n  boolean accepted=checkModifiers(e);\n  if (accepted == true) {\n    VisualizationViewer<?,?> vv=(VisualizationViewer<?,?>)e.getSource();\n    Point2D mouse=e.getPoint();\n    Point2D center=vv.getCenter();\n    int amount=e.getWheelRotation();\n    if (zoomAtMouse) {\n      if (amount > 0) {\n        scaler.scale(vv,in,mouse);\n      }\n else       if (amount < 0) {\n        scaler.scale(vv,out,mouse);\n      }\n    }\n else {\n      if (amount > 0) {\n        scaler.scale(vv,in,center);\n      }\n else       if (amount < 0) {\n        scaler.scale(vv,out,center);\n      }\n    }\n    e.consume();\n    vv.repaint();\n  }\n}", "comment": "zoom the display in or out , depending on the direction of the mouse wheel motion .", "label": "what"}
{"id": "85788", "raw_code": "public static ArrayList<Long> loadWorkspaceScreensDb(Context context){\n  final ContentResolver contentResolver=context.getContentResolver();\n  final Uri screensUri=LauncherSettings.WorkspaceScreens.CONTENT_URI;\n  final Cursor sc=contentResolver.query(screensUri,null,null,null,LauncherSettings.WorkspaceScreens.SCREEN_RANK);\n  ArrayList<Long> screenIds=new ArrayList<Long>();\n  try {\n    final int idIndex=sc.getColumnIndexOrThrow(LauncherSettings.WorkspaceScreens._ID);\n    while (sc.moveToNext()) {\n      try {\n        screenIds.add(sc.getLong(idIndex));\n      }\n catch (      Exception e) {\n        Launcher.addDumpLog(TAG,\"Desktop items loading interrupted\" + \" - invalid screens: \" + e,true);\n      }\n    }\n  }\n  finally {\n    if (sc != null) {\n      sc.close();\n    }\n  }\n  return screenIds;\n}", "comment": "loads the workspace screen ids in an ordered list .", "label": "what"}
{"id": "54955", "raw_code": "private boolean renderOutput(Node node,InternalContextAdapter context,Writer writer) throws IOException, MethodInvocationException, ResourceNotFoundException {\n  String arg=\"\";\n  if (node == null) {\n    rsvc.error(\"#include() error :  null argument\");\n    return false;\n  }\n  Object value=node.value(context);\n  if (value == null) {\n    rsvc.error(\"#include() error :  null argument\");\n    return false;\n  }\n  arg=value.toString();\n  Resource resource=null;\n  try {\n    resource=rsvc.getContent(arg,getInputEncoding(context));\n  }\n catch (  ResourceNotFoundException rnfe) {\n    rsvc.error(\"#include(): cannot find resource '\" + arg + \"', called from template \"+ context.getCurrentTemplateName()+ \" at (\"+ getLine()+ \", \"+ getColumn()+ \")\");\n    throw rnfe;\n  }\ncatch (  Exception e) {\n    rsvc.error(\"#include(): arg = '\" + arg + \"', called from template \"+ context.getCurrentTemplateName()+ \" at (\"+ getLine()+ \", \"+ getColumn()+ \") : \"+ e);\n  }\n  if (resource == null)   return false;\n  writer.write((String)resource.getData());\n  return true;\n}", "comment": "does the actual rendering of the included file", "label": "what"}
{"id": "73462", "raw_code": "public void changeState(){\n  linked=!linked;\n  link=linked ? linkedImIc.getImage() : unlinkedImIc.getImage();\n  repaint();\n}", "comment": "changes the lock icon ' s image to whatever it currently is not .", "label": "what"}
{"id": "17024", "raw_code": "private boolean isAccessibleUserToKibana(Set<String> filters){\n  if (filters.contains(\"/.kibana\")) {\n    return true;\n  }\n  return false;\n}", "comment": "check if an user has auth to kibana", "label": "what"}
{"id": "34443", "raw_code": "public boolean clear(){\n  try {\n    list.clear();\n    fireTableDataChanged();\n  }\n catch (  Exception e) {\n    return false;\n  }\n  return true;\n}", "comment": "remove all entries from the table list .", "label": "what"}
{"id": "74035", "raw_code": "public boolean load(File fi) throws JmriConfigureXmlException {\n  return load(fi,false);\n}", "comment": "load a file .", "label": "what"}
{"id": "53782", "raw_code": "public String parameterToString(Object param){\n  if (param == null) {\n    return \"\";\n  }\n else   if (param instanceof Date) {\n    return formatDate((Date)param);\n  }\n else   if (param instanceof Collection) {\n    StringBuilder b=new StringBuilder();\n    for (    Object o : (Collection)param) {\n      if (b.length() > 0) {\n        b.append(\",\");\n      }\n      b.append(String.valueOf(o));\n    }\n    return b.toString();\n  }\n else {\n    return String.valueOf(param);\n  }\n}", "comment": "format the given parameter object into string .", "label": "what"}
{"id": "81080", "raw_code": "public synchronized void flush() throws IOException {\n  checkNotClosed();\n  trimToSize();\n  trimToFileCount();\n  journalWriter.flush();\n}", "comment": "force buffered operations to the filesystem .", "label": "what"}
{"id": "65352", "raw_code": "ServerMember update(Address clientAddress,Instant time){\n  if (clientAddress != null) {\n    this.clientAddress=clientAddress;\n    if (time.isAfter(updated)) {\n      this.updated=Assert.notNull(time,\"time\");\n    }\n  }\n  return this;\n}", "comment": "updates the member client address .", "label": "what"}
{"id": "7397", "raw_code": "@Override public void actionPerformed(ActionEvent event){\n  String command=event.getActionCommand();\n  if (command.equals(\"BackgroundPaint\")) {\n    attemptModifyBackgroundPaint();\n  }\n}", "comment": "handles user interactions with the panel .", "label": "what"}
{"id": "36084", "raw_code": "public byte[] serializeToBuffer(Object o) throws IOException {\n  ByteArrayOutputStream bufOut=new ByteArrayOutputStream();\n  try {\n    serialize(bufOut,o);\n    bufOut.flush();\n    return bufOut.toByteArray();\n  }\n  finally {\n    bufOut.close();\n  }\n}", "comment": "serializes the object into a byte buffer .", "label": "what"}
{"id": "60593", "raw_code": "protected ConnectionStateTLS(SSLSessionImpl session){\n  try {\n    CipherSuite cipherSuite=session.cipherSuite;\n    hash_size=cipherSuite.getMACLength();\n    boolean is_exportabe=cipherSuite.isExportable();\n    int key_size=(is_exportabe) ? cipherSuite.keyMaterial : cipherSuite.expandedKeyMaterial;\n    int iv_size=cipherSuite.ivSize;\n    block_size=cipherSuite.getBlockSize();\n    String algName=cipherSuite.getBulkEncryptionAlgorithm();\n    String macName=cipherSuite.getHmacName();\n    if (logger != null) {\n      logger.println(\"ConnectionStateTLS.create:\");\n      logger.println(\"  cipher suite name: \" + cipherSuite.getName());\n      logger.println(\"  encryption alg name: \" + algName);\n      logger.println(\"  mac alg name: \" + macName);\n      logger.println(\"  hash size: \" + hash_size);\n      logger.println(\"  block size: \" + block_size);\n      logger.println(\"  IV size:\" + iv_size);\n      logger.println(\"  key size: \" + key_size);\n    }\n    byte[] clientRandom=session.clientRandom;\n    byte[] serverRandom=session.serverRandom;\n    byte[] key_block=new byte[2 * hash_size + 2 * key_size + 2 * iv_size];\n    byte[] seed=new byte[clientRandom.length + serverRandom.length];\n    System.arraycopy(serverRandom,0,seed,0,serverRandom.length);\n    System.arraycopy(clientRandom,0,seed,serverRandom.length,clientRandom.length);\n    PRF.computePRF(key_block,session.master_secret,KEY_EXPANSION_LABEL,seed);\n    byte[] client_mac_secret=new byte[hash_size];\n    byte[] server_mac_secret=new byte[hash_size];\n    byte[] client_key=new byte[key_size];\n    byte[] server_key=new byte[key_size];\n    boolean is_client=!session.isServer;\n    System.arraycopy(key_block,0,client_mac_secret,0,hash_size);\n    System.arraycopy(key_block,hash_size,server_mac_secret,0,hash_size);\n    System.arraycopy(key_block,2 * hash_size,client_key,0,key_size);\n    System.arraycopy(key_block,2 * hash_size + key_size,server_key,0,key_size);\n    IvParameterSpec clientIV=null;\n    IvParameterSpec serverIV=null;\n    if (is_exportabe) {\n      System.arraycopy(clientRandom,0,seed,0,clientRandom.length);\n      System.arraycopy(serverRandom,0,seed,clientRandom.length,serverRandom.length);\n      byte[] final_client_key=new byte[cipherSuite.expandedKeyMaterial];\n      byte[] final_server_key=new byte[cipherSuite.expandedKeyMaterial];\n      PRF.computePRF(final_client_key,client_key,CLIENT_WRITE_KEY_LABEL,seed);\n      PRF.computePRF(final_server_key,server_key,SERVER_WRITE_KEY_LABEL,seed);\n      client_key=final_client_key;\n      server_key=final_server_key;\n      if (block_size != 0) {\n        byte[] iv_block=new byte[2 * iv_size];\n        PRF.computePRF(iv_block,null,IV_BLOCK_LABEL,seed);\n        clientIV=new IvParameterSpec(iv_block,0,iv_size);\n        serverIV=new IvParameterSpec(iv_block,iv_size,iv_size);\n      }\n    }\n else     if (block_size != 0) {\n      clientIV=new IvParameterSpec(key_block,2 * (hash_size + key_size),iv_size);\n      serverIV=new IvParameterSpec(key_block,2 * (hash_size + key_size) + iv_size,iv_size);\n    }\n    if (logger != null) {\n      logger.println(\"is exportable: \" + is_exportabe);\n      logger.println(\"master_secret\");\n      logger.print(session.master_secret);\n      logger.println(\"client_random\");\n      logger.print(clientRandom);\n      logger.println(\"server_random\");\n      logger.print(serverRandom);\n      logger.println(\"client_mac_secret\");\n      logger.print(client_mac_secret);\n      logger.println(\"server_mac_secret\");\n      logger.print(server_mac_secret);\n      logger.println(\"client_key\");\n      logger.print(client_key);\n      logger.println(\"server_key\");\n      logger.print(server_key);\n      if (clientIV == null) {\n        logger.println(\"no IV.\");\n      }\n else {\n        logger.println(\"client_iv\");\n        logger.print(clientIV.getIV());\n        logger.println(\"server_iv\");\n        logger.print(serverIV.getIV());\n      }\n    }\n    if (algName == null) {\n      encCipher=new NullCipher();\n      decCipher=new NullCipher();\n    }\n else {\n      encCipher=Cipher.getInstance(algName);\n      decCipher=Cipher.getInstance(algName);\n      if (is_client) {\n        encCipher.init(Cipher.ENCRYPT_MODE,new SecretKeySpec(client_key,algName),clientIV);\n        decCipher.init(Cipher.DECRYPT_MODE,new SecretKeySpec(server_key,algName),serverIV);\n      }\n else {\n        encCipher.init(Cipher.ENCRYPT_MODE,new SecretKeySpec(server_key,algName),serverIV);\n        decCipher.init(Cipher.DECRYPT_MODE,new SecretKeySpec(client_key,algName),clientIV);\n      }\n    }\n    encMac=Mac.getInstance(macName);\n    decMac=Mac.getInstance(macName);\n    if (is_client) {\n      encMac.init(new SecretKeySpec(client_mac_secret,macName));\n      decMac.init(new SecretKeySpec(server_mac_secret,macName));\n    }\n else {\n      encMac.init(new SecretKeySpec(server_mac_secret,macName));\n      decMac.init(new SecretKeySpec(client_mac_secret,macName));\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    throw new AlertException(AlertProtocol.INTERNAL_ERROR,new SSLProtocolException(\"Error during computation of security parameters\"));\n  }\n}", "comment": "creates the instance of tls v1 connection state .", "label": "what"}
{"id": "18216", "raw_code": "public void startElement(String namespaceURI,String localName,String name,Attributes atts) throws org.xml.sax.SAXException {\n  ElemContext elemContext=m_elemContext;\n  if (elemContext.m_startTagOpen) {\n    closeStartTag();\n    elemContext.m_startTagOpen=false;\n  }\n else   if (m_cdataTagOpen) {\n    closeCDATA();\n    m_cdataTagOpen=false;\n  }\n else   if (m_needToCallStartDocument) {\n    startDocumentInternal();\n    m_needToCallStartDocument=false;\n  }\n  if (m_needToOutputDocTypeDecl) {\n    String n=name;\n    if (n == null || n.length() == 0) {\n      n=localName;\n    }\n    outputDocTypeDecl(n);\n  }\n  if (null != namespaceURI && namespaceURI.length() > 0) {\n    super.startElement(namespaceURI,localName,name,atts);\n    return;\n  }\n  try {\n    ElemDesc elemDesc=getElemDesc2(name);\n    int elemFlags=elemDesc.getFlags();\n    if (m_doIndent) {\n      boolean isBlockElement=(elemFlags & ElemDesc.BLOCK) != 0;\n      if (m_ispreserve)       m_ispreserve=false;\n else       if ((null != elemContext.m_elementName) && (!m_inBlockElem || isBlockElement)) {\n        m_startNewLine=true;\n        indent();\n      }\n      m_inBlockElem=!isBlockElement;\n    }\n    if (atts != null)     addAttributes(atts);\n    m_isprevtext=false;\n    final java.io.Writer writer=m_writer;\n    writer.write('<');\n    writer.write(name);\n    if (m_tracer != null)     firePseudoAttributes();\n    if ((elemFlags & ElemDesc.EMPTY) != 0) {\n      m_elemContext=elemContext.push();\n      m_elemContext.m_elementName=name;\n      m_elemContext.m_elementDesc=elemDesc;\n      return;\n    }\n else {\n      elemContext=elemContext.push(namespaceURI,localName,name);\n      m_elemContext=elemContext;\n      elemContext.m_elementDesc=elemDesc;\n      elemContext.m_isRaw=(elemFlags & ElemDesc.RAW) != 0;\n    }\n    if ((elemFlags & ElemDesc.HEADELEM) != 0) {\n      closeStartTag();\n      elemContext.m_startTagOpen=false;\n      if (!m_omitMetaTag) {\n        if (m_doIndent)         indent();\n        writer.write(\"<META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=\");\n        String encoding=getEncoding();\n        String encode=Encodings.getMimeEncoding(encoding);\n        writer.write(encode);\n        writer.write(\"\\\">\");\n      }\n    }\n  }\n catch (  IOException e) {\n    throw new SAXException(e);\n  }\n}", "comment": "receive notification of the beginning of an element .", "label": "what"}
{"id": "4573", "raw_code": "public NarClassLoader(final File narWorkingDirectory) throws ClassNotFoundException, IOException {\n  super(new URL[0]);\n  this.narWorkingDirectory=narWorkingDirectory;\n  updateClasspath(narWorkingDirectory);\n}", "comment": "construct a nar class loader .", "label": "what"}
{"id": "9059", "raw_code": "private boolean checkIfScrolling(float[] lastPoints,MotionEvent ev){\n  float[] point=new float[2];\n  point[0]=ev.getRawX();\n  point[1]=ev.getRawY();\n  float delta=getDistance(lastPoints,point);\n  return Math.abs(delta) > mSlop;\n}", "comment": "checks to see if the user is currently scrolling the menu .", "label": "what"}
{"id": "55733", "raw_code": "public Edge(S src,Symbol symbol,S dest){\n  this.src=src;\n  this.symbol=symbol;\n  this.dest=dest;\n  this.srcItem=src.getFirstItem();\n  this.hashCache=calcHashCode();\n}", "comment": "edge which leads to another non - accepting state .", "label": "what"}
{"id": "46919", "raw_code": "public void push(final Type value){\n  if (value == null) {\n    mv.visitInsn(Opcodes.ACONST_NULL);\n  }\n else {\nswitch (value.getSort()) {\ncase Type.BOOLEAN:\n      mv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Boolean\",\"TYPE\",CLDESC);\n    break;\ncase Type.CHAR:\n  mv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Character\",\"TYPE\",CLDESC);\nbreak;\ncase Type.BYTE:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Byte\",\"TYPE\",CLDESC);\nbreak;\ncase Type.SHORT:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Short\",\"TYPE\",CLDESC);\nbreak;\ncase Type.INT:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Integer\",\"TYPE\",CLDESC);\nbreak;\ncase Type.FLOAT:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Float\",\"TYPE\",CLDESC);\nbreak;\ncase Type.LONG:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Long\",\"TYPE\",CLDESC);\nbreak;\ncase Type.DOUBLE:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Double\",\"TYPE\",CLDESC);\nbreak;\ndefault :\nmv.visitLdcInsn(value);\n}\n}\n}", "comment": "generates the instruction to push the given value on the stack .", "label": "what"}
{"id": "65276", "raw_code": "public static String rightPad(String s,int minLength,char filling){\n  int ln=s.length();\n  if (minLength <= ln) {\n    return s;\n  }\n  StringBuilder res=new StringBuilder(minLength);\n  res.append(s);\n  int dif=minLength - ln;\n  for (int i=0; i < dif; i++) {\n    res.append(filling);\n  }\n  return res.toString();\n}", "comment": "pads the string at the right with the specified character until it reaches the desired length .", "label": "what"}
{"id": "58270", "raw_code": "public final boolean isSupported(String feature,String version){\n  return implementation.hasFeature(feature,version);\n}", "comment": "ask whether we support a given dom feature .", "label": "what"}
{"id": "27566", "raw_code": "public void clear(){\n  fullyLock();\n  try {\n    for (Node<E> p, h=head; (p=h.next) != null; h=p) {\n      h.next=h;\n      p.item=null;\n    }\n    head=last;\n    if (count.getAndSet(0) == capacity)     notFull.signal();\n  }\n  finally {\n    fullyUnlock();\n  }\n}", "comment": "atomically removes all of the elements from this queue .", "label": "what"}
{"id": "5913", "raw_code": "public Object assignIdValue(Object data,Number val,ObjectCache objectCache) throws SQLException {\n  Object idVal=dataPersister.convertIdNumber(val);\n  if (idVal == null) {\n    throw new SQLException(\"Invalid class \" + dataPersister + \" for sequence-id \"+ this);\n  }\n else {\n    assignField(data,idVal,false,objectCache);\n    return idVal;\n  }\n}", "comment": "assign an id value to this field .", "label": "what"}
{"id": "45446", "raw_code": "public static void writeSwappedInteger(OutputStream output,int value) throws IOException {\n  output.write((byte)((value >> 0) & 0xff));\n  output.write((byte)((value >> 8) & 0xff));\n  output.write((byte)((value >> 16) & 0xff));\n  output.write((byte)((value >> 24) & 0xff));\n}", "comment": "writes a \" int \" value to an outputstream .", "label": "what"}
{"id": "49594", "raw_code": "public static void init(Context context){\n  if (cameraManager == null) {\n    cameraManager=new CameraManager(context);\n  }\n}", "comment": "initializes this static object with the context of the calling activity .", "label": "what"}
{"id": "12798", "raw_code": "@Override public final void writeBoolean(boolean v) throws IOException {\n  dis.writeBoolean(v);\n}", "comment": "write a booleans as one byte .", "label": "what"}
{"id": "72990", "raw_code": "public void train(Set<String> sFileNames){\n  Iterator<String> iFile=sFileNames.iterator();\n  while (iFile.hasNext()) {\n    String sText=utils.loadFileToString(iFile.next());\n    train(sText);\n  }\n}", "comment": "train the statistics of the chunker from a given file set .", "label": "what"}
{"id": "67253", "raw_code": "public static void writeFixInt32(final OutputStream output,final int val) throws IOException {\n  output.write((val >>> 24) & 0xFF);\n  output.write((val >>> 16) & 0xFF);\n  output.write((val >>> 8) & 0xFF);\n  output.write(val & 0xFF);\n}", "comment": "write a fixed - width 32 bit integer in network byte order ( big - endian ) .", "label": "what"}
{"id": "39846", "raw_code": "public static boolean isObjectAvailableNow(final boolean enabled,final Date availableFrom,final Date availableTo,final Date now){\n  if (!enabled) {\n    return false;\n  }\n  if (availableFrom != null && now.before(availableFrom)) {\n    return false;\n  }\n  if (availableTo != null && now.after(availableTo)) {\n    return false;\n  }\n  return true;\n}", "comment": "check availability of an object .", "label": "what"}
{"id": "83696", "raw_code": "private long loadLargestMessageId(){\n  ReleaseMessage releaseMessage=releaseMessageRepository.findTopByOrderByIdDesc();\n  return releaseMessage == null ? 0 : releaseMessage.getId();\n}", "comment": "find largest message id as the current start point", "label": "what"}
{"id": "16787", "raw_code": "public void removeChangeListener(ChangeListener l){\n  if (listeners == null)   return;\n  listeners.remove(l);\n}", "comment": "removes a changelistener from this loader .", "label": "what"}
{"id": "1591", "raw_code": "public void addAll(Collection<? extends T> collection){\n  if (mEventDelegate != null)   mEventDelegate.addData(collection == null ? 0 : collection.size());\n  if (collection != null && collection.size() != 0) {\nsynchronized (mLock) {\n      mObjects.addAll(collection);\n    }\n  }\n  if (mNotifyOnChange)   notifyDataSetChanged();\n}", "comment": "adds the specified collection at the end of the array .", "label": "what"}
{"id": "18032", "raw_code": "void initComposeState(){\n  m_composeState=new ComposeState();\n}", "comment": "initialize a new composestate .", "label": "what"}
{"id": "18377", "raw_code": "public static Date parseDate(String dateValue) throws DateParseException {\n  return parseDate(dateValue,null,null);\n}", "comment": "parses a date value .", "label": "what"}
{"id": "34487", "raw_code": "public RegexFileFilter(String pattern,IOCase caseSensitivity){\n  if (pattern == null) {\n    throw new IllegalArgumentException(\"Pattern is missing\");\n  }\n  int flags=0;\n  if (caseSensitivity != null && !caseSensitivity.isCaseSensitive()) {\n    flags=Pattern.CASE_INSENSITIVE;\n  }\n  this.pattern=Pattern.compile(pattern,flags);\n}", "comment": "construct a new regular expression filter with the specified flags case sensitivity .", "label": "what"}
{"id": "85088", "raw_code": "public void write(byte[] buf) throws IOException {\n  output.write(buf);\n  bytesWritten+=buf.length;\n}", "comment": "counts the written bytes .", "label": "what"}
{"id": "36838", "raw_code": "protected static boolean checkRawModulesTables(final CConnection connection,final String databaseName,final int rawModuleId){\n  Preconditions.checkNotNull(connection,\"IE02261: Connection argument can not be null\");\n  Preconditions.checkNotNull(databaseName,\"IE02262: Database name argument can not be null\");\n  Preconditions.checkArgument(rawModuleId > 0,\"Raw module id %s must be a positive integer\",rawModuleId);\n  final ImmutableSet<String> rawTableNames=ImmutableSet.of(String.format(CTableNames.RAW_ADDRESS_COMMENTS_TABLE,rawModuleId),String.format(CTableNames.RAW_ADDRESS_REFERENCES_TABLE,rawModuleId),String.format(CTableNames.RAW_BASE_TYPES,rawModuleId),String.format(CTableNames.RAW_BASIC_BLOCK_INSTRUCTIONS_TABLE,rawModuleId),String.format(CTableNames.RAW_BASIC_BLOCKS_TABLE,rawModuleId),String.format(CTableNames.RAW_CALLGRAPH_TABLE,rawModuleId),String.format(CTableNames.RAW_CONTROL_FLOW_GRAPHS_TABLE,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_NODES_TABLE,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_SUBSTITUTIONS_TABLE,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_TREE_NODES_TABLE,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_TREES_TABLE,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_TYPES_TABLE,rawModuleId),String.format(CTableNames.RAW_FUNCTIONS_TABLE,rawModuleId),String.format(CTableNames.RAW_INSTRUCTIONS_TABLE,rawModuleId),String.format(CTableNames.RAW_OPERANDS_TABLE,rawModuleId),String.format(CTableNames.RAW_SECTIONS,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_TYPE_INSTANCES,rawModuleId),String.format(CTableNames.RAW_TYPE_INSTACES,rawModuleId),String.format(CTableNames.RAW_TYPES,rawModuleId));\n  final Pair<CConnection,String> cacheKey=new Pair<>(connection,databaseName);\n  if (PostgreSQLDatabaseFunctions.queryCache(cacheKey,rawTableNames)) {\n    return true;\n  }\n else {\n    if (!PostgreSQLDatabaseFunctions.fillCache(cacheKey)) {\n      return false;\n    }\n    return PostgreSQLDatabaseFunctions.queryCache(cacheKey,rawTableNames);\n  }\n}", "comment": "checks the existence of all necessary raw module tables .", "label": "what"}
{"id": "15096", "raw_code": "public Object newInstance(Class javaContentInterface) throws JAXBException {\n  if (javaContentInterface == null) {\n    throw new JAXBException(Messages.format(Messages.CI_NOT_NULL));\n  }\n  try {\n    Class c=gi.getDefaultImplementation(javaContentInterface);\n    if (c == null)     throw new JAXBException(Messages.format(Messages.MISSING_INTERFACE,javaContentInterface));\n    return c.newInstance();\n  }\n catch (  Exception e) {\n    throw new JAXBException(e);\n  }\n}", "comment": "create an instance of the specified java content interface .", "label": "what"}
{"id": "24326", "raw_code": "private void forceOutOfMemory(){\n  ArrayList junk=new ArrayList();\n  for (; ; ) {\n    junk.add(new long[100000]);\n  }\n}", "comment": "allocate objects until death", "label": "what"}
{"id": "79604", "raw_code": "@Override public synchronized void put(String key,Entry entry){\n  pruneIfNeeded(entry.data.length);\n  File file=getFileForKey(key);\n  try {\n    BufferedOutputStream fos=new BufferedOutputStream(new FileOutputStream(file));\n    CacheHeader e=new CacheHeader(key,entry);\n    boolean success=e.writeHeader(fos);\n    if (!success) {\n      fos.close();\n      VolleyLog.d(\"Failed to write header for %s\",file.getAbsolutePath());\n      throw new IOException();\n    }\n    fos.write(entry.data);\n    fos.close();\n    putEntry(key,e);\n    return;\n  }\n catch (  IOException e) {\n  }\n  boolean deleted=file.delete();\n  if (!deleted) {\n    VolleyLog.d(\"Could not clean up file %s\",file.getAbsolutePath());\n  }\n}", "comment": "puts the entry with the specified key into the cache .", "label": "what"}
{"id": "63838", "raw_code": "public void intersection(Rectangle2D r){\n  if (status == INVALID)   return;\n  if (status == EMPTY) {\n    setClip(r);\n    status=INUSE;\n    return;\n  }\n  clip[0]=Math.max(clip[0],r.getMinX());\n  clip[1]=Math.max(clip[1],r.getMinY());\n  clip[6]=Math.min(clip[6],r.getMaxX());\n  clip[7]=Math.min(clip[7],r.getMaxY());\n}", "comment": "intersect this clip with another region .", "label": "what"}
{"id": "36363", "raw_code": "public static void assertLinewiseEquals(String message,String expected,String actual){\n  try (Scanner expectedScanner=new Scanner(expected);Scanner actualScanner=new Scanner(actual)){\n    String expectedLine=null;\n    String actualLine=null;\n    int lineCounter=1;\n    while (expectedScanner.hasNextLine()) {\n      expectedLine=expectedScanner.nextLine();\n      if (actualScanner.hasNextLine()) {\n        actualLine=actualScanner.nextLine();\n      }\n else {\n        fail(\"Line \" + lineCounter + \": actual input has less lines then expected result! Expected: \"+ expectedLine);\n      }\n      assertEquals(\"Line \" + lineCounter + \": \"+ message+ \"\\n\\nExpected:\\n\"+ expected+ \"\\nActual:\\n\"+ actual,expectedLine,actualLine);\n      ++lineCounter;\n    }\n  }\n }", "comment": "compares a string linewise , i . e . ignores different linebreak characters .", "label": "what"}
{"id": "79974", "raw_code": "public String fullForm(final String str,final String lowString){\n  String ret=lowString;\n  PrefixEntry found=prefixMap.get(str);\n  if (found != null) {\n    ret=found.prefixSingular + ret;\n  }\n else {\n    for (    PrefixEntry entry : prefixEndList) {\n      if (str.endsWith(entry.keyword)) {\n        ret=Grammar.addPrefixIfNotAlreadyThere(ret,entry.prefixSingular,entry.prefixPlural);\n        break;\n      }\n    }\n  }\n  return ret;\n}", "comment": "prefix one of the registered nouns with an expression like \" piece of \" .", "label": "what"}
{"id": "71946", "raw_code": "public void clearPasswordExpirationWarnedTime(){\n  operations.add(PasswordPolicyStateOperationType.CLEAR_PASSWORD_EXPIRATION_WARNED_TIME);\n}", "comment": "clears the password expiration warned time .", "label": "what"}
{"id": "86638", "raw_code": "public void showScores(boolean flag){\n  mShowScores=flag;\n  SwingUtilities.invokeLater(null);\n}", "comment": "set whether to show scores on the plot lines", "label": "what"}
{"id": "37974", "raw_code": "protected double kernelHelper(int n,char[] s,int endIndexS,char[] t,int endIndexT){\n  if (n <= 0) {\n    return getReturnValue(n);\n  }\n  if (Math.min(endIndexS + 1,endIndexT + 1) < n) {\n    return getReturnValue(n);\n  }\n  int adr=0;\n  if (m_useRecursionCache) {\n    adr=m_multX * n + m_multY * endIndexS + m_multZ * endIndexT;\n    if (cachekhK[adr % maxCache] == adr + 1) {\n      return cachekh[adr % maxCache];\n    }\n  }\n  double result=0;\n  result=m_lambda * kernelHelper(n,s,endIndexS - 1,t,endIndexT) + kernelHelper2(n,s,endIndexS,t,endIndexT);\n  if (m_useRecursionCache) {\n    cachekhK[adr % maxCache]=adr + 1;\n    cachekh[adr % maxCache]=result;\n  }\n  return result;\n}", "comment": "the kernel helper function , called k ' in [ 1 ] and [ 2 ] .", "label": "what"}
{"id": "31825", "raw_code": "protected Connection openH2Connection(boolean autocommit) throws SQLException {\n  System.setProperty(\"h2.serializeJavaObject\",\"false\");\n  String dbName=\"test\";\n  Connection conn=DriverManager.getConnection(\"jdbc:h2:mem:\" + dbName + \";DB_CLOSE_DELAY=-1\");\n  conn.setAutoCommit(autocommit);\n  return conn;\n}", "comment": "gets connection from a pool .", "label": "what"}
{"id": "62940", "raw_code": "protected void startRecoarding(){\n  coordinates.clear();\n  enabled=true;\n}", "comment": "start recording the gesture", "label": "what"}
{"id": "66185", "raw_code": "public void addInputMethodListener(InputMethodListener l){\n  m_textPane.addInputMethodListener(l);\n}", "comment": "add input method listener", "label": "what"}
{"id": "4594", "raw_code": "protected void putCommand(final Class commandClass,final String[] names){\n  Check.isTrue(names.length > 0,\"names.length > 0\");\n  _commandsToCanonicalNames.put(commandClass,names[0]);\n  for (int i=0; i < names.length; i++) {\n    _aliasesToCommands.put(names[i],commandClass);\n  }\n}", "comment": "add a command in the hash map .", "label": "what"}
{"id": "71621", "raw_code": "protected void writeColumnAutoIncrementStmt(Table table,Column column,StringBuilder ddl){\n  ddl.append(\"IDENTITY\");\n}", "comment": "prints that the column is an auto increment column .", "label": "what"}
{"id": "33609", "raw_code": "private void SaveGCMData(){\n  try {\n    SharedPreferences preferences=getSharedPreferences();\n    SharedPreferences.Editor editor=preferences.edit();\n    editor.putString(PREFS_PUSHER_APP_ID_KEY,mPusherAppId);\n    editor.putString(PREFS_PUSHER_URL_KEY,mPusherUrl);\n    editor.putString(PREFS_PUSHER_FILE_TAG_KEY,mPusherBaseFileTag);\n    editor.commit();\n  }\n catch (  Exception e) {\n    Log.e(LOG_TAG,\"SaveGCMData failed \" + e.getLocalizedMessage());\n  }\n}", "comment": "save the gcm info to the preferences", "label": "what"}
{"id": "60753", "raw_code": "final void runWorker(Worker w){\n  Thread wt=Thread.currentThread();\n  Runnable task=w.firstTask;\n  w.firstTask=null;\n  w.unlock();\n  boolean completedAbruptly=true;\n  try {\n    while (task != null || (task=getTask()) != null) {\n      w.lock();\n      if ((runStateAtLeast(ctl.get(),STOP) || (Thread.interrupted() && runStateAtLeast(ctl.get(),STOP))) && !wt.isInterrupted())       wt.interrupt();\n      try {\n        beforeExecute(wt,task);\n        Throwable thrown=null;\n        try {\n          task.run();\n        }\n catch (        RuntimeException x) {\n          thrown=x;\n          throw x;\n        }\ncatch (        Error x) {\n          thrown=x;\n          throw x;\n        }\ncatch (        Throwable x) {\n          thrown=x;\n          throw new Error(x);\n        }\n finally {\n          afterExecute(task,thrown);\n        }\n      }\n  finally {\n        task=null;\n        w.completedTasks++;\n        w.unlock();\n      }\n    }\n    completedAbruptly=false;\n  }\n  finally {\n    processWorkerExit(w,completedAbruptly);\n  }\n}", "comment": "main worker run loop .", "label": "what"}
{"id": "53799", "raw_code": "public void writeBlockLight(ByteBuf output){\n  output.writeBytes(blockLight.getHandle());\n}", "comment": "write the block light to a buffer", "label": "what"}
{"id": "41364", "raw_code": "public String search() throws Exception {\n  executeQuery();\n  return SUCCESS;\n}", "comment": "execute a fulltextsearch from the request parameters", "label": "what"}
{"id": "82733", "raw_code": "private void paintBackgroundSolid(Graphics2D g,JComponent c,int x,int y,int width,int height){\n  Color color=c.getBackground();\n  if (type == CommonControlState.DISABLED) {\n    color=new Color(color.getRed(),color.getGreen(),color.getBlue(),0x80);\n  }\n  Shape s=shapeGenerator.createRoundRectangle(x - 2,y - 2,width + 4,height + 4,CornerSize.BORDER);\n  g.setPaint(color);\n  g.fill(s);\n  if (isPaintLineSeperators(c)) {\n    paintLineSeparator(g,c,width,height);\n  }\n}", "comment": "paint the background of an uneditable control , e . g . a jlabel .", "label": "what"}
{"id": "85397", "raw_code": "public Options resourceDirs(List<File> value){\n  resourceDirs.clear();\n  resourceDirs.addAll(value);\n  return this;\n}", "comment": "sets the list of directories where the resources come from .", "label": "what"}
{"id": "8083", "raw_code": "private static ClassNode makeType(ClassNode cn,boolean usingClass){\n  if (usingClass) {\n    ClassNode clazzType=CLASS_Type.getPlainNodeReference();\n    clazzType.setGenericsTypes(new GenericsType[]{new GenericsType(cn)});\n    return clazzType;\n  }\n else {\n    return cn;\n  }\n}", "comment": "wrap type in class < > if usingclass = = true", "label": "what"}
{"id": "18097", "raw_code": "void pushImportURL(String hrefUrl){\n  m_importStack.push(hrefUrl);\n}", "comment": "push an import href onto the stylesheet stack .", "label": "what"}
{"id": "55691", "raw_code": "public static String replace(String a,String b,String c){\n  StringBuilder result=new StringBuilder(c.length());\n  int i=0;\n  int j=c.indexOf(a);\n  while (j >= i) {\n    result.append(c.substring(i,j));\n    result.append(b);\n    i=j + a.length();\n    j=c.indexOf(a,i);\n  }\n  result.append(c.substring(i,c.length()));\n  return result.toString();\n}", "comment": "replaces a with b in c .", "label": "what"}
{"id": "12223", "raw_code": "public final void removeAll(){\n  actionList.clear();\n  constraintsList.clear();\n  needSorting=true;\n}", "comment": "removes all children actions ( separators as well ) from the group .", "label": "what"}
{"id": "86297", "raw_code": "private static boolean isWritable(@NonNull final File file){\n  boolean isExisting=file.exists();\n  try {\n    FileOutputStream output=new FileOutputStream(file,true);\n    try {\n      output.close();\n    }\n catch (    IOException e) {\n    }\n  }\n catch (  java.io.FileNotFoundException e) {\n    return false;\n  }\n  boolean result=file.canWrite();\n  if (!isExisting) {\n    file.delete();\n  }\n  return result;\n}", "comment": "check is a file is writable .", "label": "what"}
{"id": "9855", "raw_code": "private RelyingParty validateRelyingParty(HttpServletRequest request,String tenantName){\n  Validate.notNull(request,\"request\");\n  Validate.notEmpty(tenantName,\"tenantName\");\n  DefaultIdmAccessorFactory idmFactory=new DefaultIdmAccessorFactory();\n  Validate.notNull(idmFactory,\"idmFactory\");\n  IdmAccessor idmAccessor=idmFactory.getIdmAccessor();\n  idmAccessor.setTenant(tenantName);\n  String encodedEntityId=request.getParameter(Shared.RELYINGPARTY_ENTITYID);\n  if (encodedEntityId == null || encodedEntityId.isEmpty()) {\n    logger.error(\"No Relying Party's entity ID found. Ignore the request!\");\n    return null;\n  }\n  String rpEntityId=new String(Base64.decode(encodedEntityId));\n  RelyingParty rp=idmAccessor.getRelyingPartyByUrl(rpEntityId);\n  if (rp != null) {\n    return rp;\n  }\n else {\n    logger.error(\"Unknown relying party: \" + rpEntityId);\n    return null;\n  }\n}", "comment": "this method validates the relying party .", "label": "what"}
{"id": "20775", "raw_code": "public void rotateZ(double theta){\n  Matrix3D tmp=new Matrix3D();\n  double c=Math.cos(theta);\n  double s=Math.sin(theta);\n  tmp.set(0,0,c);\n  tmp.set(0,1,-s);\n  tmp.set(1,0,s);\n  tmp.set(1,1,c);\n  preMultiply(tmp);\n}", "comment": "rotate transformation about the z axis", "label": "what"}
{"id": "4013", "raw_code": "void wakeOut(){\n  OnAvailable outFlow=_outFlow;\n  if (outFlow == null) {\n    return;\n  }\n  if (_creditsIn <= _queue.head()) {\n    return;\n  }\n  StateOutPipe stateOld;\n  StateOutPipe stateNew;\n  do {\n    stateOld=_stateOutRef.get();\n    if (!stateOld.isFull()) {\n      return;\n    }\n    stateNew=stateOld.toWake();\n  }\n while (!_stateOutRef.compareAndSet(stateOld,stateNew));\n  try (OutboxAmp outbox=OutboxAmp.currentOrCreate(_outRef.services())){\n    Objects.requireNonNull(outbox);\n    PipeWakeOutMessage<T> msg=new PipeWakeOutMessage<>(outbox,_outRef,this,outFlow);\n    outbox.offer(msg);\n  }\n }", "comment": "notify the reader of available space in the pipe .", "label": "what"}
{"id": "34958", "raw_code": "public ConstraintMap createAssignmentConstraints(final AnnotatedTypeMirror assignedTo,final AnnotatedTypeMirror boxedReturnType,final AnnotatedExecutableType methodType,final Set<AFConstraint> afArgumentConstraints,final Map<TypeVariable,AnnotatedTypeMirror> inferredArgs,final Set<TypeVariable> targets,final AnnotatedTypeFactory typeFactory){\n  final LinkedList<AFConstraint> assignmentAfs=new LinkedList<>();\n  for (  AnnotatedTypeVariable typeParam : methodType.getTypeVariables()) {\n    final TypeVariable target=typeParam.getUnderlyingType();\n    final AnnotatedTypeMirror inferredType=inferredArgs.get(target);\n    if (inferredType != null) {\n      assignmentAfs.add(new A2F(inferredType,typeParam.getUpperBound()));\n      assignmentAfs.add(new F2A(typeParam.getLowerBound(),inferredType));\n    }\n else {\n      assignmentAfs.add(new F2A(typeParam,typeParam.getUpperBound()));\n      assignmentAfs.add(new A2F(typeParam.getLowerBound(),typeParam));\n    }\n  }\n  for (  AFConstraint argConstraint : afArgumentConstraints) {\n    if (argConstraint instanceof F2A) {\n      assignmentAfs.add(argConstraint);\n    }\n  }\n  LinkedList<AFConstraint> substitutedAssignmentConstraints=new LinkedList<>();\n  for (  AFConstraint afConstraint : assignmentAfs) {\n    substitutedAssignmentConstraints.add(afConstraint.substitute(inferredArgs));\n  }\n  final AnnotatedTypeMirror substitutedReturnType=TypeArgInferenceUtil.substitute(inferredArgs,boxedReturnType);\n  substitutedAssignmentConstraints.add(new F2A(substitutedReturnType,assignedTo));\n  final Set<AFConstraint> reducedConstraints=new LinkedHashSet<>();\n  reduceAfConstraints(typeFactory,reducedConstraints,substitutedAssignmentConstraints,targets);\n  final Set<TUConstraint> tuAssignmentConstraints=afToTuConstraints(reducedConstraints,targets);\n  addConstraintsBetweenTargets(tuAssignmentConstraints,targets,true,typeFactory);\n  return constraintMapBuilder.build(targets,tuAssignmentConstraints,typeFactory);\n}", "comment": "the first half of step 6 .", "label": "what"}
{"id": "34902", "raw_code": "private Optional(T value){\n  this.value=Objects.requireNonNull(value);\n}", "comment": "constructs an instance with the value present .", "label": "what"}
{"id": "78914", "raw_code": "public KafkaMessageListenerContainer(ConsumerFactory<K,V> consumerFactory,ContainerProperties containerProperties,TopicPartitionInitialOffset... topicPartitions){\n  super(containerProperties);\n  Assert.notNull(consumerFactory,\"A ConsumerFactory must be provided\");\n  this.consumerFactory=consumerFactory;\n  if (topicPartitions != null) {\n    this.topicPartitions=Arrays.copyOf(topicPartitions,topicPartitions.length);\n  }\n else {\n    this.topicPartitions=containerProperties.getTopicPartitions();\n  }\n}", "comment": "construct an instance with the supplied configuration properties and specific topics / partitions / initialoffsets .", "label": "what"}
{"id": "17914", "raw_code": "public void engineDeleteEntry(String alias) throws KeyStoreException {\n  Key k=(Key)keys.remove(alias);\n  Certificate c=(Certificate)certs.remove(alias);\n  if (c != null) {\n    chainCerts.remove(new CertId(c.getPublicKey()));\n  }\n  if (k != null) {\n    String id=(String)localIds.remove(alias);\n    if (id != null) {\n      c=(Certificate)keyCerts.remove(id);\n    }\n    if (c != null) {\n      chainCerts.remove(new CertId(c.getPublicKey()));\n    }\n  }\n}", "comment": "this is not quite complete - we should follow up on the chain , a bit tricky if a certificate appears in more than one chain . . .", "label": "what"}
{"id": "63304", "raw_code": "protected byte[] generateSalt(){\n  return HEADER.getBytes(Constants.UTF8);\n}", "comment": "generate the random salt bytes if required .", "label": "what"}
{"id": "73443", "raw_code": "public void addListener(final ProjectorListener projectorListener){\n  if (listeners == null) {\n    listeners=new ArrayList<ProjectorListener>();\n  }\n  listeners.add(projectorListener);\n}", "comment": "add a projector listener .", "label": "what"}
{"id": "43869", "raw_code": "protected TupleExpr selectNextTupleExpr(List<TupleExpr> expressions,Map<TupleExpr,Double> cardinalityMap,Map<TupleExpr,List<Var>> varsMap,Map<Var,Integer> varFreqMap,Set<String> boundVars){\n  TupleExpr result=null;\n  if (expressions.size() > 1) {\n    double lowestCardinality=Double.POSITIVE_INFINITY;\n    for (    TupleExpr tupleExpr : expressions) {\n      double cardinality=getTupleExprCardinality(tupleExpr,cardinalityMap,varsMap,varFreqMap,boundVars);\n      if (cardinality < lowestCardinality || result == null) {\n        lowestCardinality=cardinality;\n        result=tupleExpr;\n      }\n    }\n  }\n else {\n    result=expressions.get(0);\n  }\n  return result;\n}", "comment": "selects from a list of tuple expressions the next tuple expression that should be evaluated .", "label": "what"}
{"id": "67983", "raw_code": "public static void writeBcdNumber(OutputStream os,String number) throws IOException {\n  int bcd=0x00;\n  int n=0;\n  for (int i=0; i < number.length(); i++) {\nswitch (number.charAt(i)) {\ncase '0':\n      bcd|=0x00;\n    break;\ncase '1':\n  bcd|=0x10;\nbreak;\ncase '2':\nbcd|=0x20;\nbreak;\ncase '3':\nbcd|=0x30;\nbreak;\ncase '4':\nbcd|=0x40;\nbreak;\ncase '5':\nbcd|=0x50;\nbreak;\ncase '6':\nbcd|=0x60;\nbreak;\ncase '7':\nbcd|=0x70;\nbreak;\ncase '8':\nbcd|=0x80;\nbreak;\ncase '9':\nbcd|=0x90;\nbreak;\ncase '*':\nbcd|=0xA0;\nbreak;\ncase '#':\nbcd|=0xB0;\nbreak;\ncase 'a':\nbcd|=0xC0;\nbreak;\ncase 'b':\nbcd|=0xE0;\nbreak;\n}\nn++;\nif (n == 2) {\nos.write(bcd);\nn=0;\nbcd=0x00;\n}\n else {\nbcd>>=4;\n}\n}\nif (n == 1) {\nbcd|=0xF0;\nos.write(bcd);\n}\n}", "comment": "writes the given phonenumber to the stream ( bcd coded )", "label": "what"}
{"id": "54163", "raw_code": "public void accept(AbstractReporter r){\n  r.testStart(this);\n  r.browserInfoEntry(browserInfoEntry);\n  Iterator<LogEntry> entryIterator=logEntries.iterator();\n  while (entryIterator.hasNext()) {\n    LogEntry entry=entryIterator.next();\n    if (!entryIterator.hasNext()) {\n      entry.setLast(true);\n    }\n    visit(entry,r);\n  }\n  r.testEnd(this);\n}", "comment": "implementation of visitor pattern .", "label": "what"}
{"id": "10334", "raw_code": "private void loadLatestExtensionVersions(){\n  try {\n    List<Extension> all=registryManager.getExtensions();\n    if (!all.isEmpty()) {\n      setLatestExtensionVersions(getLatestVersions(all));\n    }\n  }\n catch (  RegistryException e) {\n    String msg=RegistryException.logRegistryException(e.getType(),this);\n    warnings.addStartupError(msg);\n    LOG.error(msg);\n    msg=getText(\"admin.extensions.couldnt.load\",new String[]{cfg.getRegistryUrl()});\n    warnings.addStartupError(msg);\n    LOG.error(msg);\n  }\n finally {\n    if (getLatestExtensionVersions() == null) {\n      setLatestExtensionVersions(new ArrayList<Extension>());\n    }\n  }\n}", "comment": "reload the list of registered extensions , loading only the latest extension versions .", "label": "what"}
{"id": "58159", "raw_code": "protected void startNode(Node node) throws org.xml.sax.SAXException {\n  if (node instanceof Locator) {\n    Locator loc=(Locator)node;\n    fLocator.setColumnNumber(loc.getColumnNumber());\n    fLocator.setLineNumber(loc.getLineNumber());\n    fLocator.setPublicId(loc.getPublicId());\n    fLocator.setSystemId(loc.getSystemId());\n  }\n else {\n    fLocator.setColumnNumber(0);\n    fLocator.setLineNumber(0);\n  }\nswitch (node.getNodeType()) {\ncase Node.DOCUMENT_TYPE_NODE:\n    serializeDocType((DocumentType)node,true);\n  break;\ncase Node.COMMENT_NODE:\nserializeComment((Comment)node);\nbreak;\ncase Node.DOCUMENT_FRAGMENT_NODE:\nbreak;\ncase Node.DOCUMENT_NODE:\nbreak;\ncase Node.ELEMENT_NODE:\nserializeElement((Element)node,true);\nbreak;\ncase Node.PROCESSING_INSTRUCTION_NODE:\nserializePI((ProcessingInstruction)node);\nbreak;\ncase Node.CDATA_SECTION_NODE:\nserializeCDATASection((CDATASection)node);\nbreak;\ncase Node.TEXT_NODE:\nserializeText((Text)node);\nbreak;\ncase Node.ENTITY_REFERENCE_NODE:\nserializeEntityReference((EntityReference)node,true);\nbreak;\ndefault :\n}\n}", "comment": "start processing given node", "label": "what"}
{"id": "46987", "raw_code": "public int read() throws IOException {\n  int val;\n  if ((val=is.read()) < 0) {\n    return -1;\n  }\n  if (bo == 'b') {\n    val=(char)((val << 8) | (is.read() & 0xff));\n  }\n else {\n    val=(char)((is.read() << 8) | (val & 0xff));\n  }\n  return val;\n}", "comment": "reads a single character .", "label": "what"}
{"id": "75531", "raw_code": "public static void verifySetterMethods(Class<?> clazz,MappedField... fields){\n  String methodName=null;\n  String fieldName=null;\n  Class<?> fieldType=null;\n  try {\n    for (    MappedField field : fields) {\n      fieldName=field.getName();\n      fieldType=field.getType();\n      String customSet=field.setMethod();\n      if (!isNull(customSet) && !customSet.equals(Constants.DEFAULT_ACCESSOR_VALUE))       try {\n        clazz.getMethod(customSet,fieldType);\n        field.setMethod(customSet);\n        continue;\n      }\n catch (      Exception e) {\n        Error.customMethod(\"set\",customSet,clazz);\n      }\n      methodName=mSet(fieldName);\n      clazz.getMethod(methodName,fieldType);\n      field.setMethod(methodName);\n    }\n  }\n catch (  Exception e) {\n    Error.method(methodName,fieldName,clazz);\n  }\n}", "comment": "verifies that the setter methods are compliant with the naming convention .", "label": "what"}
{"id": "57531", "raw_code": "private E dequeue(){\n  final Object[] items=this.items;\n  @SuppressWarnings(\"unchecked\") E x=(E)items[takeIndex];\n  items[takeIndex]=null;\n  takeIndex=inc(takeIndex);\n  count--;\n  if (itrs != null)   itrs.elementDequeued();\n  notFull.signal();\n  return x;\n}", "comment": "extracts element at current take position , advances , and signals .", "label": "what"}
{"id": "44918", "raw_code": "static public String randomPositiveFloat(int whole,int decimal){\n  StringBuilder output=new StringBuilder();\n  output.append(rnd.nextInt(8) + 1);\n  for (int i=0; i < whole - 1; i++) {\n    output.append(rnd.nextInt(9));\n  }\n  output.append(\".\");\n  for (int i=0; i < decimal; i++) {\n    output.append(rnd.nextInt(9));\n  }\n  return output.toString();\n}", "comment": "get a random , positive float", "label": "what"}
{"id": "30246", "raw_code": "public static Variation attemptToGetAsVariant(String part){\n  try {\n    StoneTypes var=StoneTypes.valueOf(part.toUpperCase());\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    WoodTypes var=WoodTypes.valueOf(part.toUpperCase());\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    FlowerTypes var=FlowerTypes.fromValue(part);\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    EntityTypes var=EntityTypes.fromValue(part);\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    MonsterEggTypes var=MonsterEggTypes.fromValue(part);\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    ShapeTypes var=ShapeTypes.fromValue(part);\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    HalfTypes var=HalfTypes.fromValue(part);\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  return null;\n}", "comment": "attempt to parse string as a variation", "label": "what"}
{"id": "84906", "raw_code": "public void resetTextBoxIndexesExcept(Set<Integer> excludedList){\n  Set<Integer> unusedTextBoxIndexes=new HashSet<Integer>(points.getTextBoxIndexes());\n  unusedTextBoxIndexes.removeAll(excludedList);\n  for (  Integer index : unusedTextBoxIndexes) {\n    points.removeTextBox(index);\n  }\n}", "comment": "resets all textbox indexes except those which are contained in the excludedlist", "label": "what"}
{"id": "28713", "raw_code": "public static int countMatches(String string,char c){\n  int n=0;\n  for (  char tc : string.toCharArray()) {\n    if (c == tc)     n++;\n  }\n  return n;\n}", "comment": "counts the amount of times a certain character is part of a string", "label": "what"}
{"id": "363", "raw_code": "protected String searchFor(final String target,String start){\n  return searchFor(target,null,start);\n}", "comment": "searches for the given target directory starting in the \" plugins \" subdirectory of the given location .", "label": "what"}
{"id": "32187", "raw_code": "private int validatePreloadOrder(CacheConfiguration[] cfgs) throws IgniteCheckedException {\n  int maxOrder=0;\n  for (  CacheConfiguration cfg : cfgs) {\n    int rebalanceOrder=cfg.getRebalanceOrder();\n    if (rebalanceOrder > 0) {\n      if (cfg.getCacheMode() == LOCAL)       throw new IgniteCheckedException(\"Rebalance order set for local cache (fix configuration and restart the \" + \"node): \" + U.maskName(cfg.getName()));\n      if (cfg.getRebalanceMode() == CacheRebalanceMode.NONE)       throw new IgniteCheckedException(\"Only caches with SYNC or ASYNC rebalance mode can be set as rebalance \" + \"dependency for other caches [cacheName=\" + U.maskName(cfg.getName()) + \", rebalanceMode=\"+ cfg.getRebalanceMode()+ \", rebalanceOrder=\"+ cfg.getRebalanceOrder()+ ']');\n      maxOrder=Math.max(maxOrder,rebalanceOrder);\n    }\n else     if (rebalanceOrder < 0)     throw new IgniteCheckedException(\"Rebalance order cannot be negative for cache (fix configuration and restart \" + \"the node) [cacheName=\" + U.maskName(cfg.getName()) + \", rebalanceOrder=\"+ rebalanceOrder+ ']');\n  }\n  return maxOrder;\n}", "comment": "checks that preload - order - dependant caches has sync or async preloading mode .", "label": "what"}
{"id": "13425", "raw_code": "public void execute(){\n  mPlayer.setLoopMode(mDoLoop);\n  mThread=new Thread(this,\"Movie Player\");\n  mThread.start();\n}", "comment": "creates a new thread , and starts execution of the player .", "label": "what"}
{"id": "20173", "raw_code": "@Override public void removeEnvVar(EnvVar envVar){\n  if (envVar != null) {\n    envVarList.remove(envVar);\n  }\n}", "comment": "removes the environment variable .", "label": "what"}
{"id": "22433", "raw_code": "public void deleteQuota(String id) throws IsilonException {\n  delete(_baseUrl.resolve(URI_QUOTAS),id,\"quota\");\n}", "comment": "delete a smart quota", "label": "what"}
{"id": "20221", "raw_code": "private void addExtentEntry(){\n  extentModel.addNewEntry();\n  removeExtentButton.setEnabled(false);\n}", "comment": "adds a new extent entry .", "label": "what"}
{"id": "74109", "raw_code": "void readFile(File file) throws org.jdom2.JDOMException, java.io.IOException {\n  XmlFile xf=new XmlFile(){\n  }\n;\n  xf.rootFromFile(file);\n}", "comment": "ask sax to read and verify a file", "label": "what"}
{"id": "6416", "raw_code": "protected void execute(Runnable evt){\n  executor.execute(evt);\n}", "comment": "fires a event on the executor thread", "label": "what"}
{"id": "79729", "raw_code": "public boolean isSessionToken(String token){\nsynchronized (sessionTokens) {\n    return sessionTokens.contains(token);\n  }\n}", "comment": "checks if is session token .", "label": "what"}
{"id": "59629", "raw_code": "public void export(ByteBuffer buf){\n  buf.putInt(seqId);\n  if (info.isRowBlockEnabled())   buf.putInt(nRows);\n  export(primaryKey,buf);\n  for (  ByteArray cb : cellBlocks) {\n    export(cb,buf);\n  }\n}", "comment": "write data to given buffer , like serialize", "label": "what"}
{"id": "30394", "raw_code": "private HashMap<String,Object> createAccDetailmap(String glcode,BigDecimal debitAmount,BigDecimal creditAmount){\n  HashMap<String,Object> accountdetailmap=new HashMap<String,Object>();\n  accountdetailmap.put(VoucherConstant.GLCODE,glcode);\n  accountdetailmap.put(VoucherConstant.DEBITAMOUNT,debitAmount);\n  accountdetailmap.put(VoucherConstant.CREDITAMOUNT,creditAmount);\n  accountdetailmap.put(VoucherConstant.FUNCTIONCODE,getFunctionaryCode());\n  return accountdetailmap;\n}", "comment": "creates account details map", "label": "what"}
{"id": "24840", "raw_code": "private static int byteCompaction(int mode,int[] codewords,Charset encoding,int codeIndex,StringBuilder result){\n  ByteArrayOutputStream decodedBytes=new ByteArrayOutputStream();\n  if (mode == BYTE_COMPACTION_MODE_LATCH) {\n    int count=0;\n    long value=0;\n    int[] byteCompactedCodewords=new int[6];\n    boolean end=false;\n    int nextCode=codewords[codeIndex++];\n    while ((codeIndex < codewords[0]) && !end) {\n      byteCompactedCodewords[count++]=nextCode;\n      value=900 * value + nextCode;\n      nextCode=codewords[codeIndex++];\n      if (nextCode == TEXT_COMPACTION_MODE_LATCH || nextCode == BYTE_COMPACTION_MODE_LATCH || nextCode == NUMERIC_COMPACTION_MODE_LATCH || nextCode == BYTE_COMPACTION_MODE_LATCH_6 || nextCode == BEGIN_MACRO_PDF417_CONTROL_BLOCK || nextCode == BEGIN_MACRO_PDF417_OPTIONAL_FIELD || nextCode == MACRO_PDF417_TERMINATOR) {\n        codeIndex--;\n        end=true;\n      }\n else {\n        if ((count % 5 == 0) && (count > 0)) {\n          for (int j=0; j < 6; ++j) {\n            decodedBytes.write((byte)(value >> (8 * (5 - j))));\n          }\n          value=0;\n          count=0;\n        }\n      }\n    }\n    if (codeIndex == codewords[0] && nextCode < TEXT_COMPACTION_MODE_LATCH) {\n      byteCompactedCodewords[count++]=nextCode;\n    }\n    for (int i=0; i < count; i++) {\n      decodedBytes.write((byte)byteCompactedCodewords[i]);\n    }\n  }\n else   if (mode == BYTE_COMPACTION_MODE_LATCH_6) {\n    int count=0;\n    long value=0;\n    boolean end=false;\n    while (codeIndex < codewords[0] && !end) {\n      int code=codewords[codeIndex++];\n      if (code < TEXT_COMPACTION_MODE_LATCH) {\n        count++;\n        value=900 * value + code;\n      }\n else {\n        if (code == TEXT_COMPACTION_MODE_LATCH || code == BYTE_COMPACTION_MODE_LATCH || code == NUMERIC_COMPACTION_MODE_LATCH || code == BYTE_COMPACTION_MODE_LATCH_6 || code == BEGIN_MACRO_PDF417_CONTROL_BLOCK || code == BEGIN_MACRO_PDF417_OPTIONAL_FIELD || code == MACRO_PDF417_TERMINATOR) {\n          codeIndex--;\n          end=true;\n        }\n      }\n      if ((count % 5 == 0) && (count > 0)) {\n        for (int j=0; j < 6; ++j) {\n          decodedBytes.write((byte)(value >> (8 * (5 - j))));\n        }\n        value=0;\n        count=0;\n      }\n    }\n  }\n  result.append(new String(decodedBytes.toByteArray(),encoding));\n  return codeIndex;\n}", "comment": "byte compaction mode ( see 5 . 4 . 3 ) permits all 256 possible 8 - bit byte values to be encoded .", "label": "what"}
{"id": "38325", "raw_code": "private void updateRadioLinks(){\n  m_advanceDataSetFirst.setEnabled(m_GeneratorPropertyPanel.getEditorActive());\n  m_advanceIteratorFirst.setEnabled(m_GeneratorPropertyPanel.getEditorActive());\n  if (m_Exp != null) {\n    if (!m_GeneratorPropertyPanel.getEditorActive()) {\n      m_Exp.setAdvanceDataSetFirst(true);\n    }\n else {\n      m_Exp.setAdvanceDataSetFirst(m_advanceDataSetFirst.isSelected());\n    }\n  }\n}", "comment": "updates the primary loop iteration control of the experiment", "label": "what"}
{"id": "77423", "raw_code": "public void update(long value){\n  count.incrementAndGet();\n  sample.update(value);\n  setMax(value);\n  setMin(value);\n  sum.getAndAdd(value);\n  updateVariance(value);\n}", "comment": "adds a recorded value .", "label": "what"}
{"id": "81880", "raw_code": "@Override public void drawSeries(Canvas canvas,Paint paint,List<Float> points,XYSeriesRenderer renderer,float yAxisValue,int seriesIndex,int startIndex){\n  paint.setColor(renderer.getColor());\n  paint.setStyle(Style.FILL);\n  int length=points.size();\n  XYValueSeries series=(XYValueSeries)mDataset.getSeriesAt(seriesIndex);\n  double max=series.getMaxValue();\n  double coef=MAX_BUBBLE_SIZE / max;\n  for (int i=0; i < length; i+=2) {\n    double size=series.getValue(startIndex + i / 2) * coef + MIN_BUBBLE_SIZE;\n    drawCircle(canvas,paint,points.get(i),points.get(i + 1),(float)size);\n  }\n}", "comment": "the graphical representation of a series .", "label": "what"}
{"id": "35942", "raw_code": "public static void checkClassSignature(final String signature){\n  int pos=0;\n  if (getChar(signature,0) == '<') {\n    pos=checkFormalTypeParameters(signature,pos);\n  }\n  pos=checkClassTypeSignature(signature,pos);\n  while (getChar(signature,pos) == 'L') {\n    pos=checkClassTypeSignature(signature,pos);\n  }\n  if (pos != signature.length()) {\n    throw new IllegalArgumentException(signature + \": error at index \" + pos);\n  }\n}", "comment": "checks a class signature .", "label": "what"}
{"id": "70746", "raw_code": "public static Source fromURL(URL url,Charset cs) throws IOException {\n  URI uri;\n  try {\n    uri=url.toURI();\n  }\n catch (  URISyntaxException e) {\n    throw new IOException(\"Illegal URI\",e);\n  }\n  try (InputStream is=url.openStream()){\n    return fromStream(is,uri,cs);\n  }\n }", "comment": "creates a new source object from a url", "label": "what"}
{"id": "66838", "raw_code": "public RE extractRE() throws InterruptedException {\n  arden();\n  if (!coeffs.isEmpty()) {\n    throw new RuntimeException(\"production still has free variables\");\n  }\n  return unionREs(terms);\n}", "comment": "extract the regular expression associated with this recursive production .", "label": "what"}
{"id": "61003", "raw_code": "@Deprecated public static void runFinalizersOnExit(boolean run){\n  finalizeOnExit=run;\n}", "comment": "sets the flag that indicates whether all objects are finalized when the vm is about to exit .", "label": "what"}
{"id": "33219", "raw_code": "protected void createFile(ZipEntry entry){\n  IPath pathname=new Path(entry.getName());\n  ZipEntry parent;\n  if (pathname.segmentCount() == 1) {\n    parent=root;\n  }\n else {\n    parent=(ZipEntry)directoryEntryCache.get(pathname.removeLastSegments(1));\n  }\n  addToChildren(parent,entry);\n}", "comment": "creates a new file zip entry with the specified name .", "label": "what"}
{"id": "54986", "raw_code": "public void startDocument(XMLLocator locator,String encoding,NamespaceContext namespaceContext,Augmentations augs) throws XNIException {\n  fNamespaceContext=namespaceContext;\n  try {\n    if (fDocumentHandler != null) {\n      if (locator != null) {\n        fDocumentHandler.setDocumentLocator(new LocatorProxy(locator));\n      }\n      fDocumentHandler.startDocument();\n    }\n    if (fContentHandler != null) {\n      if (locator != null) {\n        fContentHandler.setDocumentLocator(new LocatorProxy(locator));\n      }\n      fContentHandler.startDocument();\n    }\n  }\n catch (  SAXException e) {\n    throw new XNIException(e);\n  }\n}", "comment": "the start of the document .", "label": "what"}
{"id": "3896", "raw_code": "private void sendUpdateHeartbeats(){\n  HeartbeatServiceLocal heartbeat=_bartender.getHeartbeatLocal();\n  if (heartbeat != null) {\n    heartbeat.updateHeartbeats();\n  }\n}", "comment": "send a heartbeat with the updated pods to other servers in the cluster .", "label": "what"}
{"id": "243", "raw_code": "public void serialize(String name,byte[] message,OutputStream out) throws IOException {\n  byte[] header=new byte[4 + COMMAND_LEN + 4+ 4];\n  uint32ToByteArrayBE(params.getPacketMagic(),header,0);\n  for (int i=0; i < name.length() && i < COMMAND_LEN; i++) {\n    header[4 + i]=(byte)(name.codePointAt(i) & 0xFF);\n  }\n  Utils.uint32ToByteArrayLE(message.length,header,4 + COMMAND_LEN);\n  byte[] hash=doubleDigest(message);\n  System.arraycopy(hash,0,header,4 + COMMAND_LEN + 4,4);\n  out.write(header);\n  out.write(message);\n  if (log.isDebugEnabled())   log.debug(\"Sending {} message: {}\",name,bytesToHexString(header) + bytesToHexString(message));\n}", "comment": "writes message to to the output stream .", "label": "what"}
{"id": "70030", "raw_code": "public SSLEngine initSslEngine(boolean client) throws Exception {\n  KeyStore keyStore=loadKeystore(properties.sslKeyStorePath(),properties.sslKeyStorePassword());\n  KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n  keyManagerFactory.init(keyStore,keyStoreKeyPass(properties));\n  KeyStore trustStore;\n  if (properties.sslTrustStorePath() != null) {\n    LOGGER.debug(\"Using separate trust store\");\n    trustStore=loadKeystore(properties.sslTrustStorePath(),properties.sslTrustStorePassword());\n  }\n else {\n    trustStore=keyStore;\n    LOGGER.debug(\"Using key store as trust store\");\n  }\n  TrustManagerFactory trustManagerFactory=TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n  trustManagerFactory.init(trustStore);\n  KeyManager[] keyManagers=keyManagerFactory.getKeyManagers();\n  TrustManager[] trustManagers=trustManagerFactory.getTrustManagers();\n  SSLContext sslContext=SSLContext.getInstance(\"TLS\");\n  sslContext.init(keyManagers,trustManagers,null);\n  SSLEngine sslEngine=sslContext.createSSLEngine();\n  sslEngine.setUseClientMode(client);\n  sslEngine.setWantClientAuth(true);\n  sslEngine.setEnabledProtocols(sslEngine.getSupportedProtocols());\n  sslEngine.setEnabledCipherSuites(sslEngine.getSupportedCipherSuites());\n  sslEngine.setEnableSessionCreation(true);\n  return sslEngine;\n}", "comment": "initializes an ssl engine .", "label": "what"}
{"id": "85251", "raw_code": "public GetBufferedRandomAccessSource(IRandomAccessSource source){\n  this.source=source;\n  this.getBuffer=new byte[(int)Math.min(Math.max(source.length() / 4,1),4096)];\n  this.getBufferStart=-1;\n  this.getBufferEnd=-1;\n}", "comment": "constructs a new offsetrandomaccesssource", "label": "what"}
{"id": "7757", "raw_code": "@Override protected void drawAxisLine(Graphics2D g2,double cursor,Rectangle2D dataArea,RectangleEdge edge){\n  Line2D axisLine=null;\n  double c=cursor;\n  if (edge == RectangleEdge.TOP) {\n    axisLine=new Line2D.Double(dataArea.getX(),c,dataArea.getMaxX(),c);\n  }\n else   if (edge == RectangleEdge.BOTTOM) {\n    axisLine=new Line2D.Double(dataArea.getX(),c,dataArea.getMaxX(),c);\n  }\n else   if (edge == RectangleEdge.LEFT) {\n    axisLine=new Line2D.Double(c,dataArea.getY(),c,dataArea.getMaxY());\n  }\n else   if (edge == RectangleEdge.RIGHT) {\n    axisLine=new Line2D.Double(c,dataArea.getY(),c,dataArea.getMaxY());\n  }\n  g2.setPaint(getAxisLinePaint());\n  g2.setStroke(getAxisLineStroke());\n  Object saved=g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL);\n  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_NORMALIZE);\n  g2.draw(axisLine);\n  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,saved);\n  boolean drawUpOrRight=false;\n  boolean drawDownOrLeft=false;\n  if (this.positiveArrowVisible) {\n    if (this.inverted) {\n      drawDownOrLeft=true;\n    }\n else {\n      drawUpOrRight=true;\n    }\n  }\n  if (this.negativeArrowVisible) {\n    if (this.inverted) {\n      drawUpOrRight=true;\n    }\n else {\n      drawDownOrLeft=true;\n    }\n  }\n  if (drawUpOrRight) {\n    double x=0.0;\n    double y=0.0;\n    Shape arrow=null;\n    if (edge == RectangleEdge.TOP || edge == RectangleEdge.BOTTOM) {\n      x=dataArea.getMaxX();\n      y=cursor;\n      arrow=this.rightArrow;\n    }\n else     if (edge == RectangleEdge.LEFT || edge == RectangleEdge.RIGHT) {\n      x=cursor;\n      y=dataArea.getMinY();\n      arrow=this.upArrow;\n    }\n    AffineTransform transformer=new AffineTransform();\n    transformer.setToTranslation(x,y);\n    Shape shape=transformer.createTransformedShape(arrow);\n    g2.fill(shape);\n    g2.draw(shape);\n  }\n  if (drawDownOrLeft) {\n    double x=0.0;\n    double y=0.0;\n    Shape arrow=null;\n    if (edge == RectangleEdge.TOP || edge == RectangleEdge.BOTTOM) {\n      x=dataArea.getMinX();\n      y=cursor;\n      arrow=this.leftArrow;\n    }\n else     if (edge == RectangleEdge.LEFT || edge == RectangleEdge.RIGHT) {\n      x=cursor;\n      y=dataArea.getMaxY();\n      arrow=this.downArrow;\n    }\n    AffineTransform transformer=new AffineTransform();\n    transformer.setToTranslation(x,y);\n    Shape shape=transformer.createTransformedShape(arrow);\n    g2.fill(shape);\n    g2.draw(shape);\n  }\n}", "comment": "draws an axis line at the current cursor position and edge .", "label": "what"}
{"id": "38671", "raw_code": "public static void saveXStream(File saveTo,Object model,Instances header) throws Exception {\n  Vector<Object> v=new Vector<Object>();\n  v.add(model);\n  if (header != null) {\n    v.add(header);\n  }\n  v.trimToSize();\n  XStream.write(saveTo.getAbsolutePath(),v);\n}", "comment": "save a model in xstream deep object serialized xml form .", "label": "what"}
{"id": "52930", "raw_code": "public int splitRandomly(ArrayModifiableDBIDs ind,int begin,int end,DoubleDataStore tpro,Random rand){\n  final int nele=end - begin;\n  DBIDArrayIter it=ind.iter();\n  double rs=tpro.doubleValue(it.seek(begin + rand.nextInt(nele)));\n  int minInd=begin, maxInd=end - 1;\n  while (minInd < maxInd) {\n    double currEle=tpro.doubleValue(it.seek(minInd));\n    if (currEle > rs) {\n      while (minInd < maxInd && tpro.doubleValue(it.seek(maxInd)) > rs) {\n        maxInd--;\n      }\n      if (minInd == maxInd) {\n        break;\n      }\n      ind.swap(minInd,maxInd);\n      maxInd--;\n    }\n    minInd++;\n  }\n  if (minInd == end - 1) {\n    minInd=(begin + end) >>> 1;\n  }\n  return minInd;\n}", "comment": "split the data set randomly .", "label": "what"}
{"id": "49507", "raw_code": "protected void publish() throws MqttException, IOException {\n  sampleClientPub=new SampleAsyncCallback(url,clientIdPub,cleanSession,quietMode,userName,password);\n  if (sampleClientPub != null) {\n    String topic=\"Sample/Java/v3\";\n    int qos=2;\n    String message=\"Message from async calback MQTTv3 Java client sample\";\n    try {\n      sampleClientPub.publish(topic,qos,message.getBytes());\n    }\n catch (    Throwable e) {\n      e.printStackTrace();\n    }\n  }\n}", "comment": "publish / send a message to an mqtt server", "label": "what"}
{"id": "47329", "raw_code": "public static IntStream concat(IntStream a,IntStream b){\n  Objects.requireNonNull(a);\n  Objects.requireNonNull(b);\n  Spliterator.OfInt split=new Streams.ConcatSpliterator.OfInt(a.spliterator(),b.spliterator());\n  IntStream stream=StreamSupport.intStream(split,a.isParallel() || b.isParallel());\n  return stream.onClose(Streams.composedClose(a,b));\n}", "comment": "creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream .", "label": "what"}
{"id": "18457", "raw_code": "public boolean equals(String expected,String actual){\n  return framework.equals(expected,actual);\n}", "comment": "compares the values of actual and expected .", "label": "what"}
{"id": "15383", "raw_code": "public LoginConfiguration forceAuth(String forceAuthReqParam){\n  forceAuth=Boolean.parseBoolean(forceAuthReqParam);\n  return this;\n}", "comment": "sets the request ' s forceauth parameter .", "label": "what"}
{"id": "19892", "raw_code": "@MethodDesc(description=\"Stops the replicator service\",usage=\"stop\") public void stop() throws Exception {\n  try {\n    handleEventSynchronous(new StopEvent());\n    if (doneLatch != null) {\n      doneLatch.countDown();\n    }\n  }\n catch (  Exception e) {\n    logger.error(\"Stop operation failed\",e);\n    throw new Exception(e.toString());\n  }\n}", "comment": "stop replicator node manager jmx service .", "label": "what"}
{"id": "28559", "raw_code": "public boolean remove(JsonElement element){\n  return elements.remove(element);\n}", "comment": "removes the first occurrence of the specified element from this array , if it is present .", "label": "what"}
{"id": "69604", "raw_code": "public TSink<byte[]> sendBytes(TStream<byte[]> stream){\n  Objects.requireNonNull(stream,\"stream\");\n  return sendBinary(stream,null);\n}", "comment": "send a stream ' s byte [ ] tuples in a websocket binary message .", "label": "what"}
{"id": "31948", "raw_code": "public static boolean p2pLoader(ClassLoader ldr){\n  return ldr instanceof GridDeploymentInfo;\n}", "comment": "checks if class loader is an internal p2p class loader .", "label": "what"}
{"id": "44424", "raw_code": "private static String removeSubTrailers(String decodedSubject){\n  int subStringStart=0;\n  int subStringEnd=decodedSubject.length();\n  int originalSize=decodedSubject.length();\n  int curPos=originalSize - 1;\n  while (true) {\n    char c=decodedSubject.charAt(curPos--);\n    if (c == WS) {\n      subStringEnd--;\n    }\n else {\n      if (subStringEnd > FWD_PARENS.length() && decodedSubject.endsWith(FWD_PARENS)) {\n        subStringEnd-=FWD_PARENS.length();\n      }\n      break;\n    }\n  }\n  decodedSubject=decodedSubject.substring(subStringStart,subStringEnd);\n  return decodedSubject;\n}", "comment": "remove the remove _ subj _ trailers subj - trailer = \" ( fwd ) \" / wsp", "label": "what"}
{"id": "86813", "raw_code": "boolean nextSource() throws IOException {\n  if (mSourceIt.hasNext()) {\n    final InputStream is=mSourceIt.next();\n    if (is == null) {\n      mSource=null;\n      return false;\n    }\n else {\n      mSource=new BufferedInputStream(is,FileUtils.BUFFERED_STREAM_SIZE);\n    }\n    mSourceClosed=false;\n    mInputBufferPosition=0;\n    mInputBufferLength=0;\n    mBufferLength=0;\n    mBufferPosition=0;\n    return true;\n  }\n  if (mSource != null) {\n    mSource.close();\n  }\n  mSource=null;\n  return false;\n}", "comment": "step to the next input stream .", "label": "what"}
{"id": "40065", "raw_code": "public static byte[] bitmapToBytes(Bitmap bm){\n  byte[] bytes=null;\n  if (bm != null) {\n    ByteArrayOutputStream baos=new ByteArrayOutputStream();\n    bm.compress(Bitmap.CompressFormat.PNG,100,baos);\n    bytes=baos.toByteArray();\n  }\n  return bytes;\n}", "comment": "bitmap transfer to bytes", "label": "what"}
{"id": "3404", "raw_code": "public void addPriorityHandler(WarningHandler handler){\n  _priorityHandlers.add(handler);\n}", "comment": "add a warning event handler .", "label": "what"}
{"id": "84174", "raw_code": "public void printLenString(String v) throws IOException {\n  if (v == null) {\n    os.write(0);\n    os.write(0);\n  }\n else {\n    int len=v.length();\n    os.write(len >> 8);\n    os.write(len);\n    printString(v,0,len);\n  }\n}", "comment": "prints a string to the stream , encoded as utf - 8 with preceeding length", "label": "what"}
{"id": "40616", "raw_code": "private void writeAttr(String name,String val) throws IOException {\n  writeAttr(name,val,true);\n}", "comment": "writes the xml attribute name / val .", "label": "what"}
{"id": "3634", "raw_code": "@Override public void write(Buffer buffer,boolean isEnd) throws IOException {\n  if (_s == null) {\n    buffer.free();\n    return;\n  }\n  try {\n    _needsFlush=true;\n    if (buffer.isDirect()) {\n      _totalWriteBytes+=buffer.length();\n      _s.write(buffer.direct());\n      return;\n    }\n    _totalWriteBytes+=buffer.length();\n    while (buffer.length() > 0) {\n      _writeBuffer.clear();\n      buffer.read(_writeBuffer);\n      _writeBuffer.flip();\n      _s.write(_writeBuffer);\n    }\n  }\n catch (  IOException e) {\n    IOException exn=ClientDisconnectException.create(this + \":\" + e,e);\n    try {\n      close();\n    }\n catch (    IOException e1) {\n    }\n    throw exn;\n  }\n finally {\n    buffer.free();\n  }\n}", "comment": "writes an nio buffer to the socket .", "label": "what"}
{"id": "49067", "raw_code": "private static void skipMemberValue(int tag,ByteBuffer buf){\nswitch (tag) {\ncase 'e':\n    buf.getInt();\n  break;\ncase '@':\nskipAnnotation(buf,true);\nbreak;\ncase '[':\nskipArray(buf);\nbreak;\ndefault :\nbuf.getShort();\n}\n}", "comment": "skips the annotation member value at the current position in the specified byte buffer .", "label": "what"}
{"id": "83402", "raw_code": "public String generateMinimalMATSimConfig(){\n  Config config=new Config();\n  ConfigGroup ippcm=config.createModule(MatrixBasedPtRouterConfigGroup.GROUP_NAME);\n  ippcm.addParam(MatrixBasedPtRouterConfigGroup.PT_STOPS,this.ptStops);\n  ippcm.addParam(MatrixBasedPtRouterConfigGroup.USING_PT_STOPS,\"tRue\");\n  ippcm.addParam(MatrixBasedPtRouterConfigGroup.PT_TRAVEL_TIMES_AND_DISTANCES_SWITCH,this.useTravelTimesAndDistances);\n  ChangeModeConfigGroup changeModeConfig=ConfigUtils.addOrGetModule(config,ChangeModeConfigGroup.CONFIG_MODULE,ChangeModeConfigGroup.class);\n  String[] str={\"car\",\"pt\"};\n  changeModeConfig.setModes(str);\n  return writeConfigFile(config);\n}", "comment": "generates the external matsim config file with the specified parameter settings", "label": "what"}
{"id": "80990", "raw_code": "private void registerChildListeners(){\n  Iterator<PropertyChangeListener> iter=fChildListeners.iterator();\n  while (iter.hasNext()) {\n    PropertyChangeListener listener=iter.next();\n    listener.register();\n  }\n}", "comment": "register the child listeners on the child preference stores .", "label": "what"}
{"id": "32110", "raw_code": "protected boolean isLockedLocally(UUID newOwnerID){\n  return thisNode.equals(getOwnerNode()) || thisNode.equals(newOwnerID);\n}", "comment": "checks if latest call to acquire / release was called on this node .", "label": "what"}
{"id": "64033", "raw_code": "private boolean tryToMove(float deltaY){\n  if ((deltaY > 0 && mCurrentPos == 0)) {\n    if (DEBUG) {\n      Log.d(LOG_TAG,String.format(\"has reached the bottom\"));\n    }\n    return false;\n  }\n  if ((deltaY < 0 && mCurrentPos == -mHeaderHeight)) {\n    if (DEBUG) {\n      Log.d(LOG_TAG,String.format(\"has reached the top\"));\n    }\n    return false;\n  }\n  int to=mCurrentPos + (int)deltaY;\n  if (to < -mHeaderHeight) {\n    if (DEBUG) {\n      Log.d(LOG_TAG,String.format(\"over top\"));\n    }\n    to=-mHeaderHeight;\n  }\n  if (to > 0) {\n    if (DEBUG) {\n      Log.d(LOG_TAG,String.format(\"over bottom\"));\n    }\n    to=0;\n  }\n  return moveTo(to);\n}", "comment": "if deltay > 0 , trytomove the content down", "label": "what"}
{"id": "11144", "raw_code": "public void deletePoint(int position){\n  int renderType=poly.getRenderType();\n  Projection proj=getProjection();\n  boolean needToHookUp=false;\n  if (position <= 0 && isEnclosed()) {\n    enclose(false);\n    needToHookUp=true;\n  }\n  if (renderType == OMGraphic.RENDERTYPE_LATLON) {\n    Debug.message(\"eomg\",\"EditableOMPoly: removing point from lat/lon poly\");\n    if (proj != null) {\n      double[] ll=poly.getLatLonArray();\n      double[] newll=new double[ll.length - 2];\n      int actualPosition=(position == Integer.MAX_VALUE ? ll.length : position * 2);\n      if (actualPosition >= ll.length) {\n        System.arraycopy(ll,0,newll,0,ll.length - 2);\n        position=(ll.length - 2) / 2;\n      }\n else       if (actualPosition <= 0) {\n        System.arraycopy(ll,2,newll,0,ll.length - 2);\n        position=0;\n      }\n else {\n        System.arraycopy(ll,0,newll,0,actualPosition);\n        System.arraycopy(ll,actualPosition + 2,newll,actualPosition,ll.length - actualPosition - 2);\n      }\n      poly.setLocation(newll,poly.getUnits());\n    }\n  }\n else {\n    Debug.message(\"eomg\",\"EditableOMPoly: removing point from x/y or offset poly\");\n    int currentLength=poly.xs.length;\n    int[] newxs=new int[currentLength - 1];\n    int[] newys=new int[currentLength - 1];\n    if (position >= currentLength) {\n      System.arraycopy(poly.xs,0,newxs,0,currentLength - 1);\n      System.arraycopy(poly.ys,0,newys,0,currentLength - 1);\n      position=currentLength - 1;\n    }\n else     if (position <= 0) {\n      System.arraycopy(poly.xs,1,newxs,0,currentLength - 1);\n      System.arraycopy(poly.ys,1,newys,0,currentLength - 1);\n      position=0;\n    }\n else {\n      System.arraycopy(poly.xs,0,newxs,0,position);\n      System.arraycopy(poly.xs,position + 1,newxs,position,currentLength - position - 1);\n      System.arraycopy(poly.ys,0,newys,0,position);\n      System.arraycopy(poly.ys,position + 1,newys,position,currentLength - position - 1);\n    }\n    if (poly.getRenderType() == OMGraphic.RENDERTYPE_OFFSET) {\n      poly.setLocation(poly.lat,poly.lon,poly.getUnits(),newxs,newys);\n    }\n else {\n      poly.setLocation(newxs,newys);\n    }\n  }\n  if (proj != null) {\n    poly.regenerate(proj);\n  }\n  GrabPoint gp=(GrabPoint)polyGrabPoints.remove(position);\n  if (gpo != null && gp != null) {\n    gpo.removeGrabPoint(gp);\n  }\n  if (needToHookUp) {\n    enclose(true);\n  }\n}", "comment": "delete a point at a certain point in the polygon coordinate list .", "label": "what"}
{"id": "57315", "raw_code": "@Override public boolean deleteLeftWord(){\n  mInputConnection.beginBatchEdit();\n  if (mInputConnection.getSelectedText(0) != null) {\n    mInputConnection.commitText(\"\",0);\n  }\n else {\n    CharSequence beforeCursor=mInputConnection.getTextBeforeCursor(MAX_DELETABLE_CONTEXT,0);\n    if (beforeCursor != null) {\n      int beforeCursorLength=beforeCursor.length();\n      Matcher m=WHITESPACE_AND_TOKEN.matcher(beforeCursor);\n      int lastIndex=0;\n      while (m.find()) {\n        lastIndex=beforeCursorLength == m.end() ? m.start() : m.end();\n      }\n      if (lastIndex > 0) {\n        mInputConnection.deleteSurroundingText(beforeCursorLength - lastIndex,0);\n      }\n else       if (beforeCursorLength < MAX_DELETABLE_CONTEXT) {\n        mInputConnection.deleteSurroundingText(beforeCursorLength,0);\n      }\n    }\n  }\n  mInputConnection.endBatchEdit();\n  return true;\n}", "comment": "deletes all characters up to the leftmost whitespace from the cursor ( including the whitespace ) .", "label": "what"}
{"id": "53211", "raw_code": "public static double cdf(double val,double rate){\n  if (val < 0.) {\n    return 0.;\n  }\n  return 1 - Math.exp(-rate * val);\n}", "comment": "cumulative density , static version", "label": "what"}
{"id": "52022", "raw_code": "public static DataSet readContinuous(File file,char delimiter) throws IOException {\n  return readInContinuousData(file,delimiter,Collections.singleton(\"MULT\"));\n}", "comment": "read in continuous dataset .", "label": "what"}
{"id": "56270", "raw_code": "public FastStringReader(String s){\n  this.str=s;\n  this.length=s.length();\n}", "comment": "creates a new string reader .", "label": "what"}
{"id": "65171", "raw_code": "@SuppressLint(\"DrawAllocation\") @Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){\n  int widthMode=MeasureSpec.getMode(widthMeasureSpec);\n  int heightMode=MeasureSpec.getMode(heightMeasureSpec);\n  int maxWidth=MeasureSpec.getSize(widthMeasureSpec);\n  int maxHeight=MeasureSpec.getSize(heightMeasureSpec);\n  if (widthMode == MeasureSpec.UNSPECIFIED)   maxWidth=Integer.MAX_VALUE;\n  if (heightMode == MeasureSpec.UNSPECIFIED)   maxHeight=Integer.MAX_VALUE;\n  int paddingLeft=getPaddingLeft();\n  int paddingTop=getPaddingTop();\n  int paddingRight=getPaddingRight();\n  int paddingBottom=getPaddingBottom();\n  int maxRightBound=maxWidth - paddingRight;\n  int maxBottomBound=maxHeight - paddingBottom;\n  int left;\n  int top;\n  int right;\n  int bottom;\n  int rightBound=paddingLeft;\n  int maxRightNoPadding=rightBound;\n  int bottomBound;\n  int lastMaxBottom=paddingTop;\n  int maxBottom=lastMaxBottom;\n  int childWidth;\n  int childHeight;\n  int lineStartIndex=0;\n  int lineEndIndex=0;\n  rectList.clear();\n  int childCount=getChildCount();\n  for (int index=0; index < childCount; index++) {\n    final View child=getChildAt(index);\n    child.measure(MeasureSpec.UNSPECIFIED,MeasureSpec.UNSPECIFIED);\n    if (child.getVisibility() == View.GONE)     continue;\n    final AutoWrapLayout.LayoutParams lp=(AutoWrapLayout.LayoutParams)child.getLayoutParams();\n    childWidth=child.getMeasuredWidth();\n    childHeight=child.getMeasuredHeight();\n    left=rightBound + lp.leftMargin;\n    right=left + childWidth;\n    rightBound=right + lp.rightMargin;\n    if (rightBound > maxRightBound) {\n      lineEndIndex=index;\n      adjustBaseLine(maxBottom - lastMaxBottom,lineStartIndex,lineEndIndex);\n      if (maxBottom >= maxBottomBound)       break;\n      if (lineEndIndex == lineStartIndex) {\n        child.measure(MeasureSpec.makeMeasureSpec(maxWidth - paddingLeft - paddingRight- lp.leftMargin- lp.rightMargin,MeasureSpec.AT_MOST),MeasureSpec.UNSPECIFIED);\n        childWidth=child.getMeasuredWidth();\n        childHeight=child.getMeasuredHeight();\n      }\n      left=paddingLeft + lp.leftMargin;\n      right=left + childWidth;\n      rightBound=right + lp.rightMargin;\n      lastMaxBottom=maxBottom;\n      top=lastMaxBottom + lp.topMargin;\n      bottom=top + childHeight;\n      bottomBound=bottom + lp.bottomMargin;\n      lineStartIndex=index;\n    }\n else {\n      top=lastMaxBottom + lp.topMargin;\n      bottom=top + childHeight;\n      bottomBound=bottom + lp.bottomMargin;\n    }\n    if (rightBound > maxRightNoPadding)     maxRightNoPadding=rightBound;\n    if (bottomBound > maxBottom)     maxBottom=bottomBound;\n    Rect rect=new Rect();\n    rect.left=left;\n    rect.top=top;\n    rect.right=right;\n    rect.bottom=bottom;\n    rectList.add(rect);\n  }\n  adjustBaseLine(maxBottom - lastMaxBottom,lineStartIndex,rectList.size());\n  int measuredWidth;\n  int measuredHeight;\n  if (widthMode == MeasureSpec.EXACTLY)   measuredWidth=maxWidth;\n else   measuredWidth=maxRightNoPadding + paddingRight;\n  if (heightMode == MeasureSpec.EXACTLY)   measuredHeight=maxHeight;\n else {\n    measuredHeight=maxBottom + paddingBottom;\n    if (heightMode == MeasureSpec.AT_MOST)     measuredHeight=measuredHeight > maxHeight ? maxHeight : measuredHeight;\n  }\n  setMeasuredDimension(measuredWidth,measuredHeight);\n}", "comment": "each row or line at least show one child horizontal only show child can show or partly show in parent", "label": "what"}
{"id": "73931", "raw_code": "public void registerSensor(Sensor s,int i){\n  if ((i < 0) || (i > ((numInputCards() * bitsPerCard) - 1)) || (i > MAXSENSORS)) {\n    log.error(\"Unexpected sensor ordinal in registerSensor: \" + Integer.toString(i + 1));\n    return;\n  }\n  hasActiveSensors=true;\n  if (sensorArray[i] == null) {\n    sensorArray[i]=s;\n    if (lastUsedSensor < i) {\n      lastUsedSensor=i;\n    }\n  }\n else {\n    log.warn(\"multiple registration of same sensor: CS\" + Integer.toString((getNodeAddress() * SerialSensorManager.SENSORSPERUA) + i + 1));\n  }\n}", "comment": "the numbers here are 0 to maxsensors , not 1 to maxsensors .", "label": "what"}
{"id": "53997", "raw_code": "public static Number asNumber(String value,Supplier<Number> defaultValueProvider){\n  if (value != null) {\n    try {\n      return Short.valueOf(value);\n    }\n catch (    NumberFormatException e1) {\n      try {\n        return Integer.valueOf(value);\n      }\n catch (      NumberFormatException e2) {\n        try {\n          return Long.valueOf(value);\n        }\n catch (        NumberFormatException e3) {\n          try {\n            return Float.valueOf(value);\n          }\n catch (          NumberFormatException e4) {\n            try {\n              return Double.valueOf(value);\n            }\n catch (            NumberFormatException e5) {\n              try {\n                return new BigInteger(value);\n              }\n catch (              NumberFormatException e6) {\n                try {\n                  return new BigDecimal(value);\n                }\n catch (                NumberFormatException e7) {\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return defaultValueProvider != null ? defaultValueProvider.get() : null;\n}", "comment": "parse the supplied string as a number .", "label": "what"}
{"id": "14344", "raw_code": "private String applyReplacement(final BidiMap replacement,String contents){\n  for (  Object key : replacement.keySet()) {\n    String attributeName=(String)key;\n    String attributeInitials=(String)replacement.get(key);\n    contents=contents.replaceAll(JSONSerialisation.jsonAttributeName(attributeName),JSONSerialisation.jsonAttributeName(attributeInitials));\n  }\n  return contents;\n}", "comment": "perform the keyword substitution .", "label": "what"}
{"id": "46328", "raw_code": "public KeyImpl(KerberosPrincipal principal,char[] password,String algorithm){\n  try {\n    PrincipalName princ=new PrincipalName(principal.getName());\n    EncryptionKey key=new EncryptionKey(password,princ.getSalt(),algorithm);\n    this.keyBytes=key.getBytes();\n    this.keyType=key.getEType();\n  }\n catch (  KrbException e) {\n    throw new IllegalArgumentException(e.getMessage());\n  }\n}", "comment": "constructs a keyimpl from a password .", "label": "what"}
{"id": "80294", "raw_code": "public boolean check(final Direction dir,final boolean facing){\n  if (this.dir != dir) {\n    return false;\n  }\n  if (this.facing != facing) {\n    return false;\n  }\n  final long now=System.currentTimeMillis();\n  if (now >= expiration) {\n    return false;\n  }\n  expiration=now + DELAY;\n  return true;\n}", "comment": "check if a new direction matches the existing one , and if so , reset the expiration point .", "label": "what"}
{"id": "54299", "raw_code": "public void recordVariable(String typeDesc,String varName,int varNo,SymbolTable tbl) throws CompileError {\n  char c;\n  int dim=0;\n  while ((c=typeDesc.charAt(dim)) == '[')   ++dim;\n  int type=MemberResolver.descToType(c);\n  String cname=null;\n  if (type == CLASS) {\n    if (dim == 0)     cname=typeDesc.substring(1,typeDesc.length() - 1);\n else     cname=typeDesc.substring(dim + 1,typeDesc.length() - 1);\n  }\n  Declarator decl=new Declarator(type,cname,dim,varNo,new Symbol(varName));\n  tbl.append(varName,decl);\n}", "comment": "makes the given variable name available .", "label": "what"}
{"id": "11958", "raw_code": "protected synchronized void readDontVerify() throws IOException, FileEncryptionException {\n  if (backingRandomAccessFile.length() < headerSize()) {\n    throw new FileEncryptionException(\"Invalid file header\");\n  }\n  long oldpos=backingRandomAccessFile.getFilePointer();\n  backingRandomAccessFile.seek(0);\n  byte[] header_data=new byte[headerSize() - FileHeader.AUTH_TAG_SIZE];\n  backingRandomAccessFile.read(header_data);\n  backingRandomAccessFile.seek(oldpos);\n  DataInputStream istream=new DataInputStream(new ByteArrayInputStream(header_data));\n  byte[] tmpmagic=new byte[PANBOX_FILE_MAGIC.length];\n  istream.read(tmpmagic);\n  if (!Arrays.equals(tmpmagic,PANBOX_FILE_MAGIC)) {\n    throw new FileEncryptionException(\"Invalid magic number in file header\");\n  }\n  byte[] tmpversion=new byte[PANBOX_FILE_VERSION.length];\n  istream.read(tmpversion);\n  if (!Arrays.equals(tmpversion,PANBOX_FILE_VERSION)) {\n    throw new FileEncryptionException(\"Invalid version in file header. Expected version is \" + PANBOX_FILE_VERSION.toString());\n  }\n  this.shareKeyVersion=istream.readInt();\n  istream.close();\n}", "comment": "reads magic + share key version without verification", "label": "what"}
{"id": "43270", "raw_code": "private void export_dependencies(JCas jcas){\n  dependencies=new LinkedHashMap<Token,List<Dependency>>();\n  List<Token> nonGoverned=new ArrayList<Token>(nodes.keySet());\n  for (  Dependency dependency : select(jcas,Dependency.class)) {\n    Token governor=dependency.getGovernor();\n    Token dependent=dependency.getDependent();\n    List<Dependency> l=dependencies.get(governor);\n    if (l == null) {\n      dependencies.put(governor,new ArrayList<Dependency>());\n      l=dependencies.get(governor);\n    }\n    l.add(dependency);\n    nonGoverned.remove(dependent);\n  }\n  for (  Token t : nonGoverned) {\n    traverseDependents(t,\"\",-1);\n    writeToFile(\"component\",componentId,\"p\",\"dep\",\"dep\");\n    componentId++;\n  }\n}", "comment": "traverse the dependency structure beginning from all \" roots \" , i . e . non - governed tokens .", "label": "what"}
{"id": "56896", "raw_code": "public List<ExpectedPartitionValueEntity> createExpectedPartitionValueEntities(String partitionKeyGroupName,List<String> expectedPartitionValues){\n  PartitionKeyGroupEntity partitionKeyGroupEntity=partitionKeyGroupDao.getPartitionKeyGroupByName(partitionKeyGroupName);\n  if (partitionKeyGroupEntity == null) {\n    partitionKeyGroupEntity=partitionKeyGroupDaoTestHelper.createPartitionKeyGroupEntity(partitionKeyGroupName);\n  }\n  List<ExpectedPartitionValueEntity> expectedPartitionValueEntities=new ArrayList<>();\n  for (  String expectedPartitionValue : expectedPartitionValues) {\n    ExpectedPartitionValueEntity expectedPartitionValueEntity=new ExpectedPartitionValueEntity();\n    expectedPartitionValueEntity.setPartitionKeyGroup(partitionKeyGroupEntity);\n    expectedPartitionValueEntity.setPartitionValue(expectedPartitionValue);\n    expectedPartitionValueEntities.add(expectedPartitionValueDao.saveAndRefresh(expectedPartitionValueEntity));\n  }\n  return expectedPartitionValueEntities;\n}", "comment": "creates and persists specified partition value entities .", "label": "what"}
{"id": "60387", "raw_code": "public static LowMemoryWatcher register(@NotNull Runnable runnable){\n  return new LowMemoryWatcher(runnable);\n}", "comment": "registers a runnable to run on low memory events", "label": "what"}
{"id": "83740", "raw_code": "public void writeData(DataOutput dout) throws IOException {\n  dout.write(getMessage());\n}", "comment": "writedata - - output the completed modbus message to dout", "label": "what"}
{"id": "81564", "raw_code": "public Object extractHardRef(Object o){\n  SoftReference w=(SoftReference)o;\n  if (w != null) {\n    return w.get();\n  }\n  return null;\n}", "comment": "extracts the hard reference from the soft / weak reference given", "label": "what"}
{"id": "24980", "raw_code": "public static String formatLong(long number){\n  return intFormat.format(number);\n}", "comment": "formats a long value .", "label": "what"}
{"id": "82258", "raw_code": "public static void uncontribute(ComponentAddon component){\n  contributedComponents.remove(component);\n  if (currentAddon != null) {\n    component.uninitialize(currentAddon);\n  }\n}", "comment": "removes the contribution of the given addon", "label": "what"}
{"id": "63319", "raw_code": "public synchronized int copyDirect(int pageId,OutputStream out) throws IOException {\n  byte[] buffer=new byte[pageSize];\n  if (pageId >= pageCount) {\n    return -1;\n  }\n  file.seek((long)pageId << pageSizeShift);\n  file.readFullyDirect(buffer,0,pageSize);\n  readCount++;\n  out.write(buffer,0,pageSize);\n  return pageId + 1;\n}", "comment": "copy the next page to the output stream .", "label": "what"}
{"id": "77778", "raw_code": "public void writeRawBytes(final byte[] value,int offset,int length) throws IOException {\n  if (limit - position >= length) {\n    System.arraycopy(value,offset,buffer,position,length);\n    position+=length;\n  }\n else {\n    throw new OutOfSpaceException(position,limit);\n  }\n}", "comment": "write part of an array of bytes .", "label": "what"}
{"id": "9859", "raw_code": "@RequestMapping(value=\"/SAML2/Metadata/{tenant:.*}\") public void metadataError(Locale locale,@PathVariable(value=\"tenant\") String tenant,HttpServletResponse response) throws IOException {\n  logger.info(\"Metadata binding error! The client locale is {}, tenant is {}\",locale.toString(),tenant);\n  metadataDefaultTenantBindingError(locale,response);\n}", "comment": "handle request sent with a wrong binding", "label": "what"}
{"id": "40144", "raw_code": "public synchronized void checkState(State... requiredStates) throws IllegalStateException {\n  for (  State requiredState : requiredStates) {\n    if (requiredState.equals(currentState)) {\n      return;\n    }\n  }\n  throw new IllegalStateException(String.format(Locale.US,\"Expected states %s, but in state %s\",Lists.newArrayList(requiredStates),currentState));\n}", "comment": "checks that the machine is in one of the given states .", "label": "what"}
{"id": "30408", "raw_code": "public KeyValueListParser(String pairDelimiterRegex,String keyValDelimiterRegex){\n  pairDelimiter=Pattern.compile(pairDelimiterRegex);\n  keyValDelimiter=Pattern.compile(keyValDelimiterRegex);\n}", "comment": "create a parser that uses the given regexes to parse a list of key value pairs .", "label": "what"}
{"id": "4241", "raw_code": "private synchronized boolean pollStatsBroker(Destination queue){\n  statsMessageListener.setDestination(queue);\n  Timestamp timestamp=new Timestamp(System.currentTimeMillis());\n  LOGGER.debug(\"Setting the destination to \" + getQueueName(queue) + \" at \"+ timestamp);\n  jmsTemplate.execute(STATS_BROKER_DESTINATION + getQueueName(queue),new ProducerCallbackImpl(statsQueue));\n  try {\n    Thread.sleep(3 * 1000);\n  }\n catch (  InterruptedException e) {\n    e.printStackTrace();\n  }\n  return statsMessageListener.getStats() != null;\n}", "comment": "poll the statistics broker plugin", "label": "what"}
{"id": "8679", "raw_code": "private static int handleDpadVertical(int iconIndex,int cntX,int cntY,int[][] matrix,int increment){\n  int newIconIndex=NOOP;\n  if (matrix == null) {\n    throw new IllegalStateException(\"Dpad navigation requires a matrix.\");\n  }\n  int xPos=-1;\n  int yPos=-1;\n  for (int i=0; i < cntX; i++) {\n    for (int j=0; j < cntY; j++) {\n      if (matrix[i][j] == iconIndex) {\n        xPos=i;\n        yPos=j;\n      }\n    }\n  }\n  if (DEBUG) {\n    Log.v(TAG,String.format(\"\\thandleDpadVertical: \\t[x, y]=[%d, %d] iconIndex=%d\",xPos,yPos,iconIndex));\n  }\n  for (int y=yPos + increment; 0 <= y && y < cntY && 0 <= y; y+=increment) {\n    if ((newIconIndex=inspectMatrix(xPos,y,cntX,cntY,matrix)) != NOOP && newIconIndex != ALL_APPS_COLUMN) {\n      return newIconIndex;\n    }\n  }\n  int nextXPos1;\n  int nextXPos2;\n  boolean haveCrossedAllAppsColumn1=false;\n  boolean haveCrossedAllAppsColumn2=false;\n  int y=-1;\n  for (int coeff=1; coeff < cntX; coeff++) {\n    nextXPos1=xPos + coeff * increment;\n    nextXPos2=xPos - coeff * increment;\n    y=yPos + increment * coeff;\n    if (inspectMatrix(nextXPos1,y,cntX,cntY,matrix) == ALL_APPS_COLUMN) {\n      haveCrossedAllAppsColumn1=true;\n    }\n    if (inspectMatrix(nextXPos2,y,cntX,cntY,matrix) == ALL_APPS_COLUMN) {\n      haveCrossedAllAppsColumn2=true;\n    }\n    for (; 0 <= y && y < cntY; y=y + increment) {\n      int offset1=haveCrossedAllAppsColumn1 && y < cntY - 1 ? increment : 0;\n      newIconIndex=inspectMatrix(nextXPos1 + offset1,y,cntX,cntY,matrix);\n      if (newIconIndex != NOOP) {\n        return newIconIndex;\n      }\n      int offset2=haveCrossedAllAppsColumn2 && y < cntY - 1 ? -increment : 0;\n      newIconIndex=inspectMatrix(nextXPos2 + offset2,y,cntX,cntY,matrix);\n      if (newIconIndex != NOOP) {\n        return newIconIndex;\n      }\n    }\n  }\n  return newIconIndex;\n}", "comment": "calculates icon that is closest to the vertical axis in reference to the current icon .", "label": "what"}
{"id": "9489", "raw_code": "protected void updateOverlayContents(LookAt lookAt,Camera camera){\n  latView.setText(formatLatitude(lookAt.latitude));\n  lonView.setText(formatLongitude(lookAt.longitude));\n  altView.setText(formatAltitude(camera.altitude));\n}", "comment": "displays navigator state information in the status overlay views .", "label": "what"}
{"id": "3474", "raw_code": "public CharBuffer(String string){\n  int length=string.length();\n  int capacity=length + MIN_CAPACITY;\n  init(new char[capacity],0,length);\n  string.getChars(0,length,buffer(),0);\n}", "comment": "constructs a char buffer with the given initial string", "label": "what"}
{"id": "63371", "raw_code": "private ValueGeometry(byte[] bytes,Geometry geometry){\n  this.bytes=bytes;\n  this.geometry=geometry;\n  this.hashCode=Arrays.hashCode(bytes);\n}", "comment": "create a new geometry objects .", "label": "what"}
{"id": "67028", "raw_code": "@Override public void do_after_propagation(){\n  for (  HeapInsIntervalManager im : new_pts.values()) {\n    im.flush();\n  }\n  new_pts=new HashMap<AllocNode,HeapInsIntervalManager>();\n}", "comment": "remember to clean the is _ new flag", "label": "what"}
{"id": "76042", "raw_code": "static boolean isExist(String libName,int version){\n  String file=_targetSoFile(libName,version);\n  File a=new File(file);\n  return a.exists();\n}", "comment": "tell whether the so is extracted .", "label": "what"}
{"id": "35582", "raw_code": "private void finishCommon(){\n  if (!unknownSubjects.isEmpty()) {\n    if (statements.isEmpty() && restoredStatements.isEmpty()) {\n      throw new BadSubjectException(unknownSubjects.keySet(),uris);\n    }\n else {\n      log.info(\"Unrecognized subjects: {}.  Expected only sitelinks and subjects starting with {} and {}\",unknownSubjects.keySet(),uris.entityData(),uris.entity());\n    }\n  }\n  if (revisionId == null) {\n    throw new ContainedException(\"Didn't get a revision id for \" + statements);\n  }\n  if (lastModified == null) {\n    throw new ContainedException(\"Didn't get a last modified date for \" + statements);\n  }\n  for (  Pair<URI,Literal> dataStatement : dataStatements) {\n    statements.add(new StatementImpl(entityUriImpl,dataStatement.getLeft(),dataStatement.getRight()));\n  }\n  statements.addAll(restoredStatements);\n}", "comment": "perform all munge completion tasks that are required no matter the configuration .", "label": "what"}
{"id": "74877", "raw_code": "public static final void showGUIMessage(final String user_message,final BufferedImage image,final String title){\n  if (image == null) {\n    return;\n  }\n  final ImagePanel display=new ImagePanel(image);\n  display.setLayout(new BorderLayout());\n  if (user_message != null) {\n    display.add(new JLabel(user_message),BorderLayout.SOUTH);\n  }\n  final int width=image.getWidth();\n  final int height=image.getHeight();\n  display.setSize(new Dimension(width + 10,height + 10));\n  JOptionPane.showConfirmDialog(contentPane,display,title,JOptionPane.DEFAULT_OPTION,JOptionPane.PLAIN_MESSAGE);\n}", "comment": "display message if in gui mode", "label": "what"}
{"id": "72735", "raw_code": "@Override public Path call() throws Exception {\n  final Set<FileVisitOption> options;\n  if (followLinks) {\n    options=EnumSet.of(FileVisitOption.FOLLOW_LINKS);\n  }\n else {\n    options=EnumSet.noneOf(FileVisitOption.class);\n  }\n  logger.info(String.format(\"Starting scan of: \\\"%s\\\".\",path));\n  try {\n    Files.walkFileTree(path,options,maxDepth,this);\n  }\n catch (  IOException e) {\n    logger.log(Level.SEVERE,String.format(\"Error while scanning path: \\\"%s\\\".\",path),e);\n    throw e;\n  }\n  logger.info(String.format(\"Completed scan of: \\\"%s\\\".\",path));\n  return path;\n}", "comment": "recursively walks the file tree of a directory .", "label": "what"}
{"id": "46357", "raw_code": "private void baselineLayout(int origin,int size){\n  int ascent;\n  int descent;\n  if (baselineAnchoredToTop) {\n    ascent=prefAscent;\n    descent=size - ascent;\n  }\n else {\n    ascent=size - prefDescent;\n    descent=prefDescent;\n  }\n  for (  Spring spring : springs) {\n    Alignment alignment=spring.getAlignment();\n    if (alignment == null || alignment == Alignment.BASELINE) {\n      int baseline=spring.getBaseline();\n      if (baseline >= 0) {\n        int springMax=spring.getMaximumSize(VERTICAL);\n        int springPref=spring.getPreferredSize(VERTICAL);\n        int height=springPref;\n        int y;\nswitch (spring.getBaselineResizeBehavior()) {\ncase CONSTANT_ASCENT:\n          y=origin + ascent - baseline;\n        height=Math.min(descent,springMax - baseline) + baseline;\n      break;\ncase CONSTANT_DESCENT:\n    height=Math.min(ascent,springMax - springPref + baseline) + (springPref - baseline);\n  y=origin + ascent + (springPref - baseline) - height;\nbreak;\ndefault :\ny=origin + ascent - baseline;\nbreak;\n}\nspring.setSize(VERTICAL,y,height);\n}\n else {\nsetChildSize(spring,VERTICAL,origin,size);\n}\n}\n else {\nsetChildSize(spring,VERTICAL,origin,size);\n}\n}\n}", "comment": "lays out springs that have a baseline along the baseline .", "label": "what"}
{"id": "38819", "raw_code": "public void addPropertyChangeListener(PropertyChangeListener pcl){\n  m_pcSupport.addPropertyChangeListener(pcl);\n}", "comment": "add a property change listener", "label": "what"}
{"id": "73642", "raw_code": "private void unregisterDependent(Preference dependent){\n  if (mDependents != null) {\n    mDependents.remove(dependent);\n  }\n}", "comment": "removes a dependent preference on this preference .", "label": "what"}
{"id": "56788", "raw_code": "private void validateStoragePolicySelection(StoragePolicySelection storagePolicySelection){\n  Assert.notNull(storagePolicySelection,\"A storage policy selection must be specified.\");\n  businessObjectDataHelper.validateBusinessObjectDataKey(storagePolicySelection.getBusinessObjectDataKey(),true,true);\n  storagePolicyHelper.validateStoragePolicyKey(storagePolicySelection.getStoragePolicyKey());\n  Assert.notNull(storagePolicySelection.getStoragePolicyVersion(),\"A storage policy version must be specified.\");\n}", "comment": "validates the storage policy selection .", "label": "what"}
{"id": "65084", "raw_code": "public void labelDistances(Hypergraph<V,E> graph,V root){\n  labelDistances(graph,Collections.singleton(root));\n}", "comment": "computes the distances of all the node from the specified root node .", "label": "what"}
{"id": "24489", "raw_code": "public int position(){\n  return lineBuffer == null ? 0 : lineBuffer.length();\n}", "comment": "gets the current column position of this log stream .", "label": "what"}
{"id": "83159", "raw_code": "public void addFrequency(Frequency frequency){\n  frequencies.add(frequency);\n}", "comment": "adds a new frequency", "label": "what"}
{"id": "28805", "raw_code": "public final static HeaderElement parseHeaderElement(final String value,HeaderValueParser parser) throws ParseException {\n  if (value == null) {\n    throw new IllegalArgumentException(\"Value to parse may not be null\");\n  }\n  if (parser == null)   parser=SaveHeaderValueParser.DEFAULT;\n  CharArrayBuffer buffer=new CharArrayBuffer(value.length());\n  buffer.append(value);\n  SaveParserCursor cursor=new SaveParserCursor(0,value.length());\n  return parser.parseHeaderElement(buffer,cursor);\n}", "comment": "parses an element with the given parser .", "label": "what"}
{"id": "52493", "raw_code": "public static List<Interval> sliceIntervals(Interval interval,TimeGrain timeGrain){\n  DateTime intervalEnd=interval.getEnd();\n  DateTime sliceStart=interval.getStart();\n  DateTime periodStart=timeGrain.roundFloor(sliceStart);\n  if (!sliceStart.equals(periodStart)) {\n    LOG.info(\"Interval {} is not aligned to TimeGrain {} starting {}\",interval,timeGrain,periodStart);\n    throw new IllegalArgumentException(\"Interval must be aligned to the TimeGrain starting \" + periodStart);\n  }\n  List<Interval> intervalSlices=new ArrayList<>();\n  while (sliceStart.isBefore(intervalEnd)) {\n    DateTime sliceEnd=DateTimeUtils.addTimeGrain(sliceStart,timeGrain);\n    Interval slicedInterval=new Interval(sliceStart,sliceEnd);\n    if (!interval.contains(slicedInterval)) {\n      LOG.info(\"Interval {} is not a multiple of TimeGrain {}\",interval,timeGrain);\n      throw new IllegalArgumentException(\"Interval must be a multiple of the TimeGrain\");\n    }\n    intervalSlices.add(slicedInterval);\n    sliceStart=sliceEnd;\n  }\n  LOG.debug(\"Sliced interval {} into {} slices of {} grain\",interval,intervalSlices.size(),timeGrain);\n  return intervalSlices;\n}", "comment": "slices the intervals into smaller intervals of the timegrain duration .", "label": "what"}
{"id": "80024", "raw_code": "public boolean isGerund(){\n  return typeString.startsWith(VERB_GERUND);\n}", "comment": "determine if the expression contains a verb in gerund form .", "label": "what"}
{"id": "68908", "raw_code": "private JsonObject createRequest(Map<String,Object> headers,String uri,HttpMethod method,JsonObject payload){\n  JsonObject request=new JsonObject();\n  JsonArray jsonHeaders=new JsonArray();\n  headers.forEach(null);\n  request.put(\"headers\",jsonHeaders);\n  request.put(\"uri\",uri);\n  request.put(\"method\",method.toString());\n  request.put(\"payload\",payload);\n  return request;\n}", "comment": "creates a new request with the given parameters .", "label": "what"}
{"id": "77506", "raw_code": "private long downloadTlogFiles(File tmpTlogDir,long latestGeneration) throws Exception {\n  LOG.info(\"Starting download of tlog files from master: \" + tlogFilesToDownload);\n  tlogFilesDownloaded=Collections.synchronizedList(new ArrayList<>());\n  long bytesDownloaded=0;\n  boolean status=tmpTlogDir.mkdirs();\n  if (!status) {\n    throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\"Failed to create temporary tlog folder: \" + tmpTlogDir.getName());\n  }\n  for (  Map<String,Object> file : tlogFilesToDownload) {\n    String saveAs=(String)(file.get(ALIAS) == null ? file.get(NAME) : file.get(ALIAS));\n    localFileFetcher=new LocalFsFileFetcher(tmpTlogDir,file,saveAs,TLOG_FILE,latestGeneration);\n    currentFile=file;\n    localFileFetcher.fetchFile();\n    bytesDownloaded+=localFileFetcher.getBytesDownloaded();\n    tlogFilesDownloaded.add(new HashMap<>(file));\n  }\n  return bytesDownloaded;\n}", "comment": "download all the tlog files to the temp tlog directory .", "label": "what"}
{"id": "49288", "raw_code": "static WindowsFileAttributes readAttributes(long handle) throws WindowsException {\n  NativeBuffer buffer=NativeBuffers.getNativeBuffer(SIZEOF_FILE_INFORMATION);\n  try {\n    long address=buffer.address();\n    GetFileInformationByHandle(handle,address);\n    int reparseTag=0;\n    int fileAttrs=unsafe.getInt(address + OFFSETOF_FILE_INFORMATION_ATTRIBUTES);\n    if (isReparsePoint(fileAttrs)) {\n      int size=MAXIMUM_REPARSE_DATA_BUFFER_SIZE;\n      NativeBuffer reparseBuffer=NativeBuffers.getNativeBuffer(size);\n      try {\n        DeviceIoControlGetReparsePoint(handle,reparseBuffer.address(),size);\n        reparseTag=(int)unsafe.getLong(reparseBuffer.address());\n      }\n  finally {\n        reparseBuffer.release();\n      }\n    }\n    return fromFileInformation(address,reparseTag);\n  }\n  finally {\n    buffer.release();\n  }\n}", "comment": "reads the attributes of an open file", "label": "what"}
{"id": "11082", "raw_code": "public static JPanel createCheckbox(String boxlabel,String[] buttons,boolean[] checked,ActionListener al){\n  JPanel jp=createPaletteJPanel(boxlabel);\n  for (int j=0; j < buttons.length; j++) {\n    JCheckBox jcb=new JCheckBox(buttons[j]);\n    jcb.setActionCommand(Integer.toString(j));\n    if (al != null)     jcb.addActionListener(al);\n    jcb.setSelected(checked[j]);\n    jp.add(jcb);\n  }\n  return jp;\n}", "comment": "create a panel containing a checkbox .", "label": "what"}
{"id": "54424", "raw_code": "public static void copy(DimensionsEvent aeDest,DimensionsEvent aeSrc){\n  GPOMutable destAggs=aeDest.getAggregates();\n  GPOMutable srcAggs=aeSrc.getAggregates();\n  if (srcAggs.getFieldsBoolean() != null) {\n    System.arraycopy(srcAggs.getFieldsBoolean(),0,destAggs.getFieldsBoolean(),0,srcAggs.getFieldsBoolean().length);\n  }\n  if (srcAggs.getFieldsCharacter() != null) {\n    System.arraycopy(srcAggs.getFieldsCharacter(),0,destAggs.getFieldsCharacter(),0,srcAggs.getFieldsCharacter().length);\n  }\n  if (srcAggs.getFieldsString() != null) {\n    System.arraycopy(srcAggs.getFieldsString(),0,destAggs.getFieldsString(),0,srcAggs.getFieldsString().length);\n  }\n  if (srcAggs.getFieldsShort() != null) {\n    System.arraycopy(srcAggs.getFieldsShort(),0,destAggs.getFieldsShort(),0,srcAggs.getFieldsShort().length);\n  }\n  if (srcAggs.getFieldsInteger() != null) {\n    System.arraycopy(srcAggs.getFieldsInteger(),0,destAggs.getFieldsInteger(),0,srcAggs.getFieldsInteger().length);\n  }\n  if (srcAggs.getFieldsLong() != null) {\n    System.arraycopy(srcAggs.getFieldsLong(),0,destAggs.getFieldsLong(),0,srcAggs.getFieldsLong().length);\n  }\n  if (srcAggs.getFieldsFloat() != null) {\n    System.arraycopy(srcAggs.getFieldsFloat(),0,destAggs.getFieldsFloat(),0,srcAggs.getFieldsFloat().length);\n  }\n  if (srcAggs.getFieldsDouble() != null) {\n    System.arraycopy(srcAggs.getFieldsDouble(),0,destAggs.getFieldsDouble(),0,srcAggs.getFieldsDouble().length);\n  }\n}", "comment": "this is a utility method which copies the given src event to the given destination event .", "label": "what"}
{"id": "28346", "raw_code": "public Kernel(int offset,double[] values){\n  this.values=Arrays.copyOf(values,values.length);\n  this.offset=offset;\n}", "comment": "creates a new kernel object with the specified offset and values .", "label": "what"}
{"id": "42373", "raw_code": "private void initializeWorkList(){\n  for (  GVCongruenceClass c : B) {\n    if (c.size() == 1) {\n      continue;\n    }\n    Iterator<ValueGraphVertex> i=c.iterator();\n    ValueGraphVertex first=i.next();\n    while (i.hasNext()) {\n      ValueGraphVertex v=i.next();\n      if (!checkCongruence(first,v)) {\n        workList.push(c);\n        break;\n      }\n    }\n  }\n}", "comment": "initialize the work list .", "label": "what"}
{"id": "44629", "raw_code": "public boolean hasItem(T object){\nsynchronized (mLock) {\n    return source.contains(object);\n  }\n}", "comment": "determine if the object provide is in this adapter", "label": "what"}
{"id": "48188", "raw_code": "private static boolean versionMatches(Integer v1,int v2){\n  if (v1 == null || v1 == 0 || v2 == 0) {\n    return true;\n  }\n  return v1.equals(v2);\n}", "comment": "determines if a kvno matches another kvno .", "label": "what"}
{"id": "71642", "raw_code": "private void onSchemaComplexType(Element schemaComplexType,DatatypeElementFactory elementFactory){\n  Iterator<Element> iter=schemaComplexType.elementIterator(XSD_ATTRIBUTE);\n  while (iter.hasNext()) {\n    Element xsdAttribute=iter.next();\n    String name=xsdAttribute.attributeValue(\"name\");\n    QName qname=getQName(name);\n    XSDatatype dataType=dataTypeForXsdAttribute(xsdAttribute);\n    if (dataType != null) {\n      elementFactory.setAttributeXSDatatype(qname,dataType);\n    }\n  }\n  Element schemaSequence=schemaComplexType.element(XSD_SEQUENCE);\n  if (schemaSequence != null) {\n    onChildElements(schemaSequence,elementFactory);\n  }\n  Element schemaChoice=schemaComplexType.element(XSD_CHOICE);\n  if (schemaChoice != null) {\n    onChildElements(schemaChoice,elementFactory);\n  }\n  Element schemaAll=schemaComplexType.element(XSD_ALL);\n  if (schemaAll != null) {\n    onChildElements(schemaAll,elementFactory);\n  }\n}", "comment": "processes an xml schema < complextypegt ; tag", "label": "what"}
{"id": "65346", "raw_code": "private void sequenceQuery(QueryEntry entry,ServerSessionContext session,CompletableFuture<QueryResponse> future){\n  if (entry.getSequence() > session.getCommandSequence()) {\n    session.registerSequenceQuery(entry.getSequence(),null);\n  }\n else {\n    indexQuery(entry,future);\n  }\n}", "comment": "sequences the given query .", "label": "what"}
{"id": "73137", "raw_code": "private boolean expungeStaleEntries(){\n  if (size == 0)   return false;\n  Object r;\n  boolean result=false;\n  while ((r=queue.poll()) != null) {\n    result=true;\n    Entry e=(Entry)r;\n    int h=e.hash;\n    int i=indexFor(h,table.length);\n    Entry prev=table[i];\n    Entry p=prev;\n    while (p != null) {\n      Entry next=p.next;\n      if (p == e) {\n        if (prev == e)         table[i]=next;\n else         prev.next=next;\n        e.next=null;\n        size--;\n        break;\n      }\n      prev=p;\n      p=next;\n    }\n  }\n  return result;\n}", "comment": "expunge stale entries from the table .", "label": "what"}
{"id": "24360", "raw_code": "public static List<Integer> createRanges(int... startEnds){\n  assert startEnds.length % 2 == 0;\n  ArrayList<Integer> ret=new ArrayList<Integer>();\n  for (int si=0; si < startEnds.length; si++) {\n    final int start=startEnds[si++];\n    final int end=startEnds[si];\n    assert end >= start;\n    ret.ensureCapacity(ret.size() + ((end - start) + 1));\n    for (int i=start; i <= end; i++) {\n      ret.add(new Integer(i));\n    }\n  }\n  return ret;\n}", "comment": "create a list of integers consisting of the ranges defined by the provided argument e . g . .", "label": "what"}
{"id": "15583", "raw_code": "@After public void tearDown(){\n  webClient.closeAllWindows();\n}", "comment": "tear down after testing .", "label": "what"}
{"id": "26244", "raw_code": "public Timestamp recalculateEstimatedCompletionDate(Long priority,Timestamp startDate){\n  if (exist()) {\n    getProductionRunRoutingTasks();\n    if (quantity == null)     getQuantity();\n    Timestamp endDate=null;\n    for (Iterator<GenericValue> iter=productionRunRoutingTasks.iterator(); iter.hasNext(); ) {\n      GenericValue routingTask=iter.next();\n      if (priority.compareTo(routingTask.getLong(\"priority\")) <= 0) {\n        long totalTime=ProductionRun.getEstimatedTaskTime(routingTask,quantity,dispatcher);\n        endDate=TechDataServices.addForward(TechDataServices.getTechDataCalendar(routingTask),startDate,totalTime);\n        routingTask.set(\"estimatedStartDate\",startDate);\n        routingTask.set(\"estimatedCompletionDate\",endDate);\n        startDate=endDate;\n      }\n    }\n    return endDate;\n  }\n else {\n    return null;\n  }\n}", "comment": "recalculated the estimatedcompletiondate property .", "label": "what"}
{"id": "44505", "raw_code": "public boolean tableExists(DatabaseMetaData dbMetaData,String tableName) throws SQLException {\n  return (tableExistsCaseSensitive(dbMetaData,tableName) || tableExistsCaseSensitive(dbMetaData,tableName.toUpperCase(Locale.US)) || tableExistsCaseSensitive(dbMetaData,tableName.toLowerCase(Locale.US)));\n}", "comment": "checks database metadata to see if a table exists .", "label": "what"}
{"id": "23892", "raw_code": "private void checkIfDirectoriesExist(File[] disk_dirs){\n  DiskStoreFactoryImpl.checkIfDirectoriesExist(disk_dirs);\n}", "comment": "checks if directories exist", "label": "what"}
{"id": "21772", "raw_code": "public void addPortToAlreadyAllocatedContext(StoragePort port,StorageHADomain haDomain,StorageSystem.Type arrayType,String switchName){\n  String engine=getEngine(port,haDomain,arrayType);\n  if (engine != null) {\n    _alreadyAllocatedEngines.add(engine);\n  }\n  String directorType=getDirectorType(arrayType,haDomain);\n  if (directorType != null) {\n    _alreadyAllocatedDirectorTypes.add(directorType);\n  }\n  String director=getDirector(port,haDomain);\n  if (director != null) {\n    _alreadyAllocatedDirectors.add(director);\n  }\n  String cpu=getCpu(port,haDomain,arrayType);\n  if (cpu != null) {\n    _alreadyAllocatedCpus.add(cpu);\n  }\n  if (switchName != null) {\n    _alreadyAllocatedSwitches.add(switchName);\n  }\n}", "comment": "allocates existing ports to the already allocated context ( only ) .", "label": "what"}
{"id": "23592", "raw_code": "public static void writeListOfLongs(List list,boolean hasLongIDs,DataOutput out) throws IOException {\n  if (list == null) {\n    out.writeInt(-1);\n  }\n else {\n    out.writeInt(list.size());\n    out.writeBoolean(hasLongIDs);\n    for (Iterator it=list.iterator(); it.hasNext(); ) {\n      Long l=(Long)it.next();\n      if (hasLongIDs) {\n        out.writeLong(l.longValue());\n      }\n else {\n        out.writeInt((int)l.longValue());\n      }\n    }\n  }\n}", "comment": "write a set of long objects", "label": "what"}
{"id": "46509", "raw_code": "public boolean isDefined(Object attrName){\n  return table.containsKey(attrName);\n}", "comment": "tells whether a given attribute is defined .", "label": "what"}
{"id": "79920", "raw_code": "private void showPreloadingStage(){\n  Stage preloadingStage=new Stage(StageStyle.UNDECORATED);\n  preloadingStage.initOwner(primaryStage);\n  preloadingStage.setScene(new PreloadingScene());\n  preloadingStage.show();\n  primaryStage.setOnShowing(null);\n}", "comment": "shows preloading stage with scene while fxgl is being configured .", "label": "what"}
{"id": "17697", "raw_code": "@Override public void clear(){\n  if (elementCount > 0) {\n    elementCount=0;\n    Arrays.fill(elementData,null);\n    modCount++;\n    while (referenceQueue.poll() != null) {\n    }\n  }\n}", "comment": "removes all mappings from this map , leaving it empty .", "label": "what"}
{"id": "17690", "raw_code": "public V remove(Object key){\n  int hash=hash(key.hashCode());\n  Segment<K,V> s=segmentForHash(hash);\n  return s == null ? null : s.remove(key,hash,null);\n}", "comment": "removes the key ( and its corresponding value ) from this map .", "label": "what"}
{"id": "49699", "raw_code": "private static int ipToBytes(String ip,byte[] bytes,boolean mustHave4) throws IPMatcherException {\n  String[] parts=ip.split(\"\\\\.\");\n  if (parts.length > 4 || mustHave4 && parts.length != 4) {\n    throw new IPMatcherException(\"Malformed IP specification \" + ip);\n  }\n  try {\n    for (int i=0; i < parts.length; i++) {\n      int p=Integer.parseInt(parts[i]);\n      if (p < 0 || p > 255) {\n        throw new IPMatcherException(\"Malformed IP specification \" + ip);\n      }\n      bytes[i]=(byte)(p < 128 ? p : p - 256);\n    }\n  }\n catch (  NumberFormatException nfe) {\n    throw new IPMatcherException(\"Malformed IP specification \" + ip,nfe);\n  }\n  return parts.length;\n}", "comment": "fill out a given four - byte array with the ipv4 address specified in the given string", "label": "what"}
{"id": "43052", "raw_code": "public static void CF2(double[] x,double[] f,double[] c,int nx){\n  int count1=0;\n  int count2=0;\n  double sum1=0.0;\n  double sum2=0.0;\n  double yj;\n  double N=2.0;\n  double a=1.0;\n  double t;\n  for (int j=2; j <= nx; j++) {\n    yj=x[j - 1] - Math.sin(6.0 * PI * x[0] + j * PI / nx);\n    if (j % 2 == 1) {\n      yj=x[j - 1] - Math.sin(6.0 * PI * x[0] + j * PI / nx);\n      sum1+=yj * yj;\n      count1++;\n    }\n else {\n      yj=x[j - 1] - Math.cos(6.0 * PI * x[0] + j * PI / nx);\n      sum2+=yj * yj;\n      count2++;\n    }\n  }\n  f[0]=x[0] + 2.0 * sum1 / (double)count1;\n  f[1]=1.0 - Math.sqrt(x[0]) + 2.0 * sum2 / (double)count2;\n  t=f[1] + Math.sqrt(f[0]) - a * Math.sin(N * PI * (Math.sqrt(f[0]) - f[1] + 1.0)) - 1.0;\n  c[0]=MYSIGN(t) * Math.abs(t) / (1 + Math.exp(4.0 * Math.abs(t)));\n}", "comment": "evaluates the cf2 problem .", "label": "what"}
{"id": "81016", "raw_code": "public void addLongSelectionListener(SelectionListener listener){\n  if (listener == null)   throw new IllegalArgumentException();\n  if (hexEditControl == null) {\n    if (listOfLongListeners == null)     listOfLongListeners=new ArrayList<>();\n    listOfLongListeners.add(listener);\n  }\n else {\n    hexEditControl.addLongSelectionListener(listener);\n  }\n}", "comment": "adds a long selection listener .", "label": "what"}
{"id": "40516", "raw_code": "public void println() throws IOException {\n  out.write(strategy.getPrinterNewline());\n  newLine=true;\n}", "comment": "output a blank line", "label": "what"}
{"id": "36578", "raw_code": "private void drawSelectionRectangle(Graphics2D g2){\n  if (this.selectionRectangle != null) {\n    if (this.fillSelectionRectangle) {\n      g2.setPaint(this.selectionFillPaint);\n      g2.fill(selectionRectangle);\n    }\n else {\n      g2.setPaint(this.selectionOutlinePaint);\n      g2.draw(selectionRectangle);\n    }\n  }\n}", "comment": "draws zoom rectangle ( if present ) .", "label": "what"}
{"id": "25257", "raw_code": "public ConversionException(final Throwable cause){\n  super(cause.getMessage());\n  this.cause=cause;\n}", "comment": "construct a new exception with the specified root cause .", "label": "what"}
{"id": "21922", "raw_code": "private boolean hasConnectivityToAllSystems(Initiator initiator,Collection<URI> storageSystems,ExportGroup exportGroup){\n  return hasConnectivityToAllSystems(initiator,storageSystems,null,exportGroup);\n}", "comment": "checks if an initiator has connectivity to a storage system in a varray .", "label": "what"}
{"id": "78240", "raw_code": "@Override public boolean onTouchEvent(MotionEvent event){\n  if (!isEnabled())   return false;\n  int pointerIndex;\n  final int action=event.getAction();\nswitch (action & MotionEvent.ACTION_MASK) {\ncase MotionEvent.ACTION_DOWN:\n    mActivePointerId=event.getPointerId(event.getPointerCount() - 1);\n  pointerIndex=event.findPointerIndex(mActivePointerId);\nmDownMotionX=event.getX(pointerIndex);\npressedThumb=evalPressedThumb(mDownMotionX);\nif (pressedThumb == null) return super.onTouchEvent(event);\nsetPressed(true);\ninvalidate();\nonStartTrackingTouch();\ntrackTouchEvent(event);\nattemptClaimDrag();\nbreak;\ncase MotionEvent.ACTION_MOVE:\nif (pressedThumb != null) {\nif (mIsDragging) {\ntrackTouchEvent(event);\n}\n else {\npointerIndex=event.findPointerIndex(mActivePointerId);\nfinal float x=event.getX(pointerIndex);\nif (Math.abs(x - mDownMotionX) > mScaledTouchSlop) {\nsetPressed(true);\ninvalidate();\nonStartTrackingTouch();\ntrackTouchEvent(event);\nattemptClaimDrag();\n}\n}\nif (notifyWhileDragging && listener != null) {\nlistener.onRangeSeekBarValuesChanged(this,getSelectedMinValue(),getSelectedMaxValue());\n}\n}\nbreak;\ncase MotionEvent.ACTION_UP:\nif (mIsDragging) {\ntrackTouchEvent(event);\nonStopTrackingTouch();\nsetPressed(false);\n}\n else {\nonStartTrackingTouch();\ntrackTouchEvent(event);\nonStopTrackingTouch();\n}\npressedThumb=null;\ninvalidate();\nif (listener != null) {\nlistener.onRangeSeekBarValuesChanged(this,getSelectedMinValue(),getSelectedMaxValue());\n}\nbreak;\ncase MotionEvent.ACTION_POINTER_DOWN:\n{\nfinal int index=event.getPointerCount() - 1;\nmDownMotionX=event.getX(index);\nmActivePointerId=event.getPointerId(index);\ninvalidate();\nbreak;\n}\ncase MotionEvent.ACTION_POINTER_UP:\nonSecondaryPointerUp(event);\ninvalidate();\nbreak;\ncase MotionEvent.ACTION_CANCEL:\nif (mIsDragging) {\nonStopTrackingTouch();\nsetPressed(false);\n}\ninvalidate();\nbreak;\n}\nreturn true;\n}", "comment": "handles thumb selection and movement .", "label": "what"}
{"id": "43643", "raw_code": "private Derivation<TK,FV> constructDerivation(Derivation<TK,FV> markedNode,int sourceInputId,FeatureExtractor<TK,FV> featurizer,Scorer<FV> scorer,SearchHeuristic<TK,FV> heuristic,OutputSpace<TK,FV> outputSpace){\n  final List<Derivation<TK,FV>> nodes=new LinkedList<>();\n  Derivation<TK,FV> p=markedNode;\n  while (p != null) {\n    nodes.add(0,p);\n    p=p.parent;\n  }\n  p=markedNode.bestChild;\n  while (p != null) {\n    nodes.add(p);\n    p=p.bestChild;\n  }\n  Derivation<TK,FV> goalHyp=null;\n  for (  Derivation<TK,FV> node : nodes) {\n    goalHyp=goalHyp == null ? node : new Derivation<>(sourceInputId,node.rule,goalHyp.length,goalHyp,featurizer,scorer,heuristic,outputSpace);\n  }\n  return goalHyp;\n}", "comment": "construct a new derivation from a node of interest .", "label": "what"}
{"id": "73315", "raw_code": "public JDialog displayPanelInWindow(final JPanel panel,String title){\n  JDialog frame=new GenericJDialog();\n  frame.setContentPane(panel);\n  frame.pack();\n  frame.setTitle(title);\n  frame.setVisible(true);\n  return frame;\n}", "comment": "a copy of displaypanel except returning a subclass of window .", "label": "what"}
{"id": "23400", "raw_code": "public JSONTokener(Reader reader){\n  this.reader=reader.markSupported() ? reader : new BufferedReader(reader);\n  this.eof=false;\n  this.usePrevious=false;\n  this.previous=0;\n  this.index=0;\n  this.character=1;\n  this.line=1;\n}", "comment": "construct a jsontokener from a reader .", "label": "what"}
{"id": "76773", "raw_code": "public Builder withTokenizer(Class<? extends TokenizerFactory> factory,Map<String,String> params) throws IOException {\n  Objects.requireNonNull(factory,\"Tokenizer factory may not be null\");\n  tokenizer.set(applyResourceLoader(newFactoryClassInstance(factory,applyDefaultParams(params))));\n  componentsAdded=true;\n  return this;\n}", "comment": "uses the given tokenizer .", "label": "what"}
{"id": "27029", "raw_code": "protected double computeAzimuthLabelOffset(double radius,double maxRadius){\n  return Math.asin(AZIMUTH_LABEL_OFFSET * maxRadius / radius);\n}", "comment": "compute an angular offset to apply to a azimuth label .", "label": "what"}
{"id": "52536", "raw_code": "private static Stream<Method> extractMethods(Class clazz){\n  try {\n    Method[] methods=clazz.getMethods();\n    if (methods.length > 0) {\n      return Stream.of(methods);\n    }\n  }\n catch (  Exception|Error e) {\n    LOG.warn(\"Problems loading class at startup: {}\",clazz,e);\n  }\n  return Stream.empty();\n}", "comment": "extract a set of methods from a given class .", "label": "what"}
{"id": "43417", "raw_code": "@Override public void updateServerAddress(Application application,String dockerManagerIP,String serverPort,String serverManagerPort){\n  String suffixCloudUnit=application.getSuffixCloudUnitIO();\n  JedisPool pool=null;\n  Jedis jedis=null;\n  try {\n    pool=new JedisPool(new JedisPoolConfig(),redisIp,Integer.parseInt(redisPort),3000);\n    jedis=pool.getResource();\n    String subNameSpace=concatSubNameSpace(application);\n    String key=subNameSpace + suffixCloudUnit;\n    String frontend=\"frontend:\" + key.toLowerCase();\n    jedis.lset(frontend,1,\"http://\" + dockerManagerIP + \":\"+ serverPort);\n    String frontendServerManager=\"frontend:manager-\" + key.toLowerCase();\n    jedis.lset(frontendServerManager,1,\"http://\" + dockerManagerIP + \":\"+ serverManagerPort);\n  }\n catch (  JedisConnectionException|UnsupportedEncodingException e) {\n    logger.error(\"HipacheRedisUtils Exception\",e);\n  }\n finally {\n    if (jedis != null) {\n      pool.destroy();\n    }\n  }\n}", "comment": "update the server address", "label": "what"}
{"id": "42688", "raw_code": "protected void remove(int itemPosition){\n  if (itemPosition >= 0 && itemPosition < getItemCount()) {\n    list.remove(itemPosition);\n  }\n}", "comment": "remove an item from the adapter ' s list .", "label": "what"}
{"id": "6618", "raw_code": "private static boolean isOlderThanLeopard(){\n  String version=System.getProperty(\"os.version\");\n  StringTokenizer tk=new StringTokenizer(version,\".\");\n  int major=Integer.parseInt(tk.nextToken());\n  int minor=Integer.parseInt(tk.nextToken());\n  return major == 10 && minor < 6;\n}", "comment": "determines if this is running a mac osx lower than leopard", "label": "what"}
{"id": "9359", "raw_code": "private void feedForward(Vec input,List<Vec> activations,List<Vec> derivatives){\n  Vec x=input;\n  for (int i=0; i < Ws.size(); i++) {\n    Matrix W_i=Ws.get(i);\n    Vec b_i=bs.get(i);\n    Vec a_i=activations.get(i);\n    a_i.zeroOut();\n    W_i.multiply(x,1,a_i);\n    a_i.mutableAdd(b_i);\n    a_i.applyFunction(f);\n    Vec d_i=derivatives.get(i);\n    a_i.copyTo(d_i);\n    d_i.applyFunction(f.getD());\n    x=a_i;\n  }\n}", "comment": "feeds a vector through the network to get an output", "label": "what"}
{"id": "59117", "raw_code": "private File findFile(File directory,String name) throws FileNotFoundException {\n  File file=new File(directory,name);\n  if (file.exists()) {\n    return file;\n  }\n  for (  String child : directory.list()) {\n    if (child.equalsIgnoreCase(name)) {\n      return new File(directory,child);\n    }\n  }\n  throw new FileNotFoundException(\"Missing file: \" + file);\n}", "comment": "finds the named file in the named directory .", "label": "what"}
{"id": "77351", "raw_code": "public static boolean compareResults(SolrClient controlClient,SolrClient cloudClient) throws SolrServerException, IOException {\n  return compareResults(controlClient,cloudClient,null,null);\n}", "comment": "compares the results of the control and cloud clients .", "label": "what"}
{"id": "8593", "raw_code": "public static CLContext createContextFromCurrentGL(){\n  RuntimeException first=null;\n  for (  CLPlatform platform : listPlatforms()) {\n    try {\n      CLContext ctx=platform.createContextFromCurrentGL();\n      if (ctx != null)       return ctx;\n    }\n catch (    RuntimeException ex) {\n      if (first == null)       first=ex;\n    }\n  }\n  throw new RuntimeException(\"Failed to create an OpenCL context based on the current OpenGL context\",first);\n}", "comment": "creates an opencl context able to share entities with the current opengl context .", "label": "what"}
{"id": "69851", "raw_code": "static void queuePlayerCapeReplacement(AbstractClientPlayer player){\n  final String displayName=player.getDisplayNameString();\n  Logger.info(\"Queueing cape replacement for %s\",displayName);\n  THREAD_POOL.submit(null);\n}", "comment": "queue the replacement of a player ' s cape with the testmod3 cape .", "label": "what"}
{"id": "47827", "raw_code": "public void removeVetoableChangeListener(VetoableChangeListener listener){\n  if (listener != null) {\nsynchronized (this) {\n      if (vetoableSupport != null) {\n        vetoableSupport.removeVetoableChangeListener(listener);\n      }\n    }\n  }\n}", "comment": "removes a vetoablechangelistener from the listener list .", "label": "what"}
{"id": "38903", "raw_code": "public StreamThroughput(String statusMessagePrefix){\n  m_instanceCount=0;\n  m_sampleCount=0;\n  m_numSamples=0;\n  m_cumulativeTime=0;\n  m_startTime=System.currentTimeMillis();\n  m_statusMessagePrefix=statusMessagePrefix;\n}", "comment": "construct a new streamthroughput", "label": "what"}
{"id": "24127", "raw_code": "protected void parseCommand(final String... args){\n  for (  String arg : args) {\n    final Command command=Command.valueOfName(arg);\n    if (command != null) {\n      setCommand(command);\n      break;\n    }\n  }\n}", "comment": "iterates the list of arguments in search of the target locator launcher command .", "label": "what"}
{"id": "51070", "raw_code": "public void createBounds(){\n  if (isEmpty() || hasSingleElement()) {\n    mBounds=null;\n    return;\n  }\n  int l=Integer.MAX_VALUE;\n  int t=Integer.MAX_VALUE;\n  int r=0;\n  int b=0;\n  for (  Selection.Element selection : getElements()) {\n    ConstraintWidget w=selection.widget;\n    l=Math.min(w.getDrawX(),l);\n    t=Math.min(w.getDrawY(),t);\n    r=Math.max(w.getDrawRight(),r);\n    b=Math.max(w.getDrawBottom(),b);\n  }\n  ConstraintWidget bounds=new ConstraintWidget(l,t,r - l,b - t);\n  bounds.setCompanionWidget(WidgetCompanion.create(bounds));\n  mBounds=new Element(bounds);\n  updateOriginFromBounds();\n}", "comment": "if the selection has more than one element , it will create a temporary element object as the bounds of the entire selection .", "label": "what"}
{"id": "28258", "raw_code": "protected static void recordPattern(BitArray row,int start,int[] counters) throws NotFoundException {\n  int numCounters=counters.length;\n  Arrays.fill(counters,0,numCounters,0);\n  int end=row.getSize();\n  if (start >= end) {\n    throw NotFoundException.getNotFoundInstance();\n  }\n  boolean isWhite=!row.get(start);\n  int counterPosition=0;\n  int i=start;\n  while (i < end) {\n    if (row.get(i) ^ isWhite) {\n      counters[counterPosition]++;\n    }\n else {\n      counterPosition++;\n      if (counterPosition == numCounters) {\n        break;\n      }\n else {\n        counters[counterPosition]=1;\n        isWhite=!isWhite;\n      }\n    }\n    i++;\n  }\n  if (!(counterPosition == numCounters || (counterPosition == numCounters - 1 && i == end))) {\n    throw NotFoundException.getNotFoundInstance();\n  }\n}", "comment": "records the size of successive runs of white and black pixels in a row , starting at a given point .", "label": "what"}
{"id": "44472", "raw_code": "private CoderResult decodeByteBufferToCharacterBuffer(boolean endOfInput) throws DecodingException {\n  buffer.flip();\n  return decodeMoreBytesToCharacterBuffer(endOfInput);\n}", "comment": "decodes contents of the byte buffer to the character buffer .", "label": "what"}
{"id": "74493", "raw_code": "protected void newFastClockMinute(){\n  for (int i=delayedTrains.size() - 1; i >= 0; i--) {\n    ActiveTrain at=delayedTrains.get(i);\n    if ((!at.getStarted()) && at.getDelayedStart() != ActiveTrain.NODELAY) {\n      if (at.getDelayedStart() == ActiveTrain.TIMEDDELAY) {\n        if (isFastClockTimeGE(at.getDepartureTimeHr(),at.getDepartureTimeMin())) {\n          at.setStarted();\n          delayedTrains.remove(i);\n          if (_AutoAllocate) {\n            autoAllocate.scanAllocationRequestList(allocationRequests);\n          }\n        }\n      }\n    }\n else     if (at.getStarted() && at.getStatus() == ActiveTrain.READY && at.reachedRestartPoint()) {\n      if (isFastClockTimeGE(at.getRestartDepartHr(),at.getRestartDepartMin())) {\n        at.restart();\n        delayedTrains.remove(i);\n        if (_AutoAllocate) {\n          autoAllocate.scanAllocationRequestList(allocationRequests);\n        }\n      }\n    }\n  }\n}", "comment": "handle activity that is triggered by the fast clock", "label": "what"}
{"id": "66018", "raw_code": "private void loadOrgAccessRole(ArrayList<OrgAccess> list){\n  PreparedStatement pstmt=null;\n  ResultSet rs=null;\n  String sql=\"SELECT * FROM AD_Role_OrgAccess \" + \"WHERE AD_Role_ID=? AND IsActive='Y'\";\n  try {\n    pstmt=DB.prepareStatement(sql,get_TrxName());\n    pstmt.setInt(1,getAD_Role_ID());\n    rs=pstmt.executeQuery();\n    while (rs.next()) {\n      MRoleOrgAccess oa=new MRoleOrgAccess(getCtx(),rs,get_TrxName());\n      loadOrgAccessAdd(list,new OrgAccess(oa.getAD_Client_ID(),oa.getAD_Org_ID(),oa.isReadOnly()));\n    }\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,sql,e);\n  }\n finally {\n    DB.close(rs,pstmt);\n  }\n}", "comment": "load org access role", "label": "what"}
{"id": "17908", "raw_code": "public java.security.cert.Certificate engineGenerateCertificate(InputStream in) throws CertificateException {\n  if (currentStream == null) {\n    currentStream=in;\n    sData=null;\n    sDataObjectCount=0;\n  }\n else   if (currentStream != in) {\n    currentStream=in;\n    sData=null;\n    sDataObjectCount=0;\n  }\n  try {\n    if (sData != null) {\n      if (sDataObjectCount != sData.size()) {\n        return getCertificate();\n      }\n else {\n        sData=null;\n        sDataObjectCount=0;\n        return null;\n      }\n    }\n    PushbackInputStream pis=new PushbackInputStream(in);\n    int tag=pis.read();\n    if (tag == -1) {\n      return null;\n    }\n    pis.unread(tag);\n    if (tag != 0x30) {\n      return readPEMCertificate(pis);\n    }\n else {\n      return readDERCertificate(new ASN1InputStream(pis));\n    }\n  }\n catch (  Exception e) {\n    throw new ExCertificateException(e);\n  }\n}", "comment": "generates a certificate object and initializes it with the data read from the input stream instream .", "label": "what"}
{"id": "4386", "raw_code": "@Override public List<Period> generateRollingPeriods(DateTimeUnit dateTimeUnit){\n  Calendar cal=getCalendar();\n  dateTimeUnit.setDay(1);\n  dateTimeUnit=cal.minusMonths(dateTimeUnit,11);\n  List<Period> periods=Lists.newArrayList();\n  for (int i=0; i < 12; i++) {\n    periods.add(createPeriod(dateTimeUnit,cal));\n    dateTimeUnit=cal.plusMonths(dateTimeUnit,1);\n  }\n  return periods;\n}", "comment": "generates the last 12 months where the last one is the month which the given date is inside .", "label": "what"}
{"id": "66429", "raw_code": "@SuppressWarnings(\"unchecked\") private void expungeStaleEntries(){\nsynchronized (sync) {\n    ListWeakReference r;\n    while ((r=(ListWeakReference)queue.poll()) != null) {\n      ListEntry le=r.getListEntry();\n      int i=list.indexOf(le);\n      if (i != -1) {\n        list.remove(i);\n      }\n    }\n  }\n}", "comment": "expunge stale entries from the list .", "label": "what"}
{"id": "11272", "raw_code": "public void fireVetoableChange(String name,Object oldValue,Object newValue) throws PropertyVetoException {\n  super.fireVetoableChange(name,oldValue,newValue);\n  beanContextChildSupport.fireVetoableChange(name,oldValue,newValue);\n}", "comment": "report a vetoable property update to any registered listeners .", "label": "what"}
{"id": "8769", "raw_code": "@Override public void onFullBackup(FullBackupDataOutput output) throws IOException {\n  if (mVolumes != null) {\n    if (DEBUG)     Slog.i(TAG,\"Backing up \" + mVolumes.length + \" shared volumes\");\n    HashSet<String> externalFilesDirFilter=new HashSet<String>();\n    final File externalAndroidRoot=new File(Environment.getExternalStorageDirectory(),Environment.DIRECTORY_ANDROID);\n    externalFilesDirFilter.add(externalAndroidRoot.getCanonicalPath());\n    for (int i=0; i < mVolumes.length; i++) {\n      StorageVolume v=mVolumes[i];\n      String domain=FullBackup.SHARED_PREFIX + i;\n      fullBackupFileTree(null,domain,v.getPath(),externalFilesDirFilter,output);\n    }\n  }\n}", "comment": "full backup of the shared - storage filesystem", "label": "what"}
{"id": "38634", "raw_code": "public static void removeConnectionList(Integer tab){\n  TABBED_CONNECTIONS.remove(tab.intValue());\n}", "comment": "remove the list of connections at the supplied index", "label": "what"}
{"id": "11291", "raw_code": "protected void paintRangeRings(Point2D originPnt,Point2D dest,Graphics graphics,MapBean theMap){\n  Geo originGeo=new Geo(originPnt.getY(),originPnt.getX(),true);\n  Geo destGeo=new Geo(dest.getY(),dest.getX(),true);\n  double distance=originGeo.distance(destGeo);\n  for (int i=1; i <= Math.max(1,numRings); i++) {\n    double ringDist=distance * (double)i;\n    paintCircle(originGeo,ringDist,graphics,theMap);\n    paintLabel(originGeo,ringDist,graphics,theMap);\n  }\n}", "comment": "paints the circles and their labels on the given graphics .", "label": "what"}
{"id": "56913", "raw_code": "public StorageEntity createStorageEntity(String storageName,StoragePlatformEntity storagePlatformEntity,List<Attribute> attributes){\n  StorageEntity storageEntity=new StorageEntity();\n  storageEntity.setName(storageName);\n  storageEntity.setStoragePlatform(storagePlatformEntity);\n  if (!CollectionUtils.isEmpty(attributes)) {\n    List<StorageAttributeEntity> attributeEntities=new ArrayList<>();\n    storageEntity.setAttributes(attributeEntities);\n    for (    Attribute attribute : attributes) {\n      StorageAttributeEntity attributeEntity=new StorageAttributeEntity();\n      attributeEntities.add(attributeEntity);\n      attributeEntity.setStorage(storageEntity);\n      attributeEntity.setName(attribute.getName());\n      attributeEntity.setValue(attribute.getValue());\n    }\n  }\n  return storageDao.saveAndRefresh(storageEntity);\n}", "comment": "creates and persists a new storage entity .", "label": "what"}
{"id": "11510", "raw_code": "public void displayInfoLine(String infoLine,int labelDesignator){\n  if (infoLineHolder != null) {\n    setLabel((infoLine != null && infoLine.length() > 0) ? infoLine : fudgeString,labelDesignator);\n  }\n}", "comment": "display a line of text in a designated info line .", "label": "what"}
{"id": "857", "raw_code": "public static Object invokeStaticMethod(BshClassManager bcm,Class clas,String methodName,Object[] args) throws ReflectError, UtilEvalError, InvocationTargetException {\n  Interpreter.debug(\"invoke static Method\");\n  Method method=resolveExpectedJavaMethod(bcm,clas,null,methodName,args,true);\n  return invokeMethod(method,null,args);\n}", "comment": "invoke a method known to be static .", "label": "what"}
{"id": "13492", "raw_code": "public static byte[] decode(String encoded){\n  if (encoded == null) {\n    return null;\n  }\n  char[] base64Data=encoded.toCharArray();\n  int len=removeWhiteSpace(base64Data);\n  if (len % FOURBYTE != 0) {\n    return null;\n  }\n  int numberQuadruple=(len / FOURBYTE);\n  if (numberQuadruple == 0) {\n    return new byte[0];\n  }\n  byte decodedData[]=null;\n  byte b1=0, b2=0, b3=0, b4=0;\n  char d1=0, d2=0, d3=0, d4=0;\n  int i=0;\n  int encodedIndex=0;\n  int dataIndex=0;\n  decodedData=new byte[(numberQuadruple) * 3];\n  for (; i < numberQuadruple - 1; i++) {\n    if (!isData((d1=base64Data[dataIndex++])) || !isData((d2=base64Data[dataIndex++])) || !isData((d3=base64Data[dataIndex++]))|| !isData((d4=base64Data[dataIndex++]))) {\n      return null;\n    }\n    b1=base64Alphabet[d1];\n    b2=base64Alphabet[d2];\n    b3=base64Alphabet[d3];\n    b4=base64Alphabet[d4];\n    decodedData[encodedIndex++]=(byte)(b1 << 2 | b2 >> 4);\n    decodedData[encodedIndex++]=(byte)(((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n    decodedData[encodedIndex++]=(byte)(b3 << 6 | b4);\n  }\n  if (!isData((d1=base64Data[dataIndex++])) || !isData((d2=base64Data[dataIndex++]))) {\n    return null;\n  }\n  b1=base64Alphabet[d1];\n  b2=base64Alphabet[d2];\n  d3=base64Data[dataIndex++];\n  d4=base64Data[dataIndex++];\n  if (!isData((d3)) || !isData((d4))) {\n    if (isPad(d3) && isPad(d4)) {\n      if ((b2 & 0xf) != 0) {\n        return null;\n      }\n      byte[] tmp=new byte[i * 3 + 1];\n      System.arraycopy(decodedData,0,tmp,0,i * 3);\n      tmp[encodedIndex]=(byte)(b1 << 2 | b2 >> 4);\n      return tmp;\n    }\n else     if (!isPad(d3) && isPad(d4)) {\n      b3=base64Alphabet[d3];\n      if ((b3 & 0x3) != 0) {\n        return null;\n      }\n      byte[] tmp=new byte[i * 3 + 2];\n      System.arraycopy(decodedData,0,tmp,0,i * 3);\n      tmp[encodedIndex++]=(byte)(b1 << 2 | b2 >> 4);\n      tmp[encodedIndex]=(byte)(((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n      return tmp;\n    }\n else {\n      return null;\n    }\n  }\n else {\n    b3=base64Alphabet[d3];\n    b4=base64Alphabet[d4];\n    decodedData[encodedIndex++]=(byte)(b1 << 2 | b2 >> 4);\n    decodedData[encodedIndex++]=(byte)(((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n    decodedData[encodedIndex++]=(byte)(b3 << 6 | b4);\n  }\n  return decodedData;\n}", "comment": "decodes base64 data into octects", "label": "what"}
{"id": "6574", "raw_code": "public void paint(Graphics g){\n  try {\n    super.paint(g);\n  }\n catch (  Exception e) {\n  }\n  int focusedRow=getFocusedRow(true);\n  if (focusedRow != -1 && focusedRow < getRowCount()) {\n    Border rowBorder=UIManager.getBorder(\"Table.focusRowHighlightBorder\");\n    if (rowBorder != null) {\n      Rectangle rect=getCellRect(focusedRow,0,true);\n      rect.width=getWidth();\n      rowBorder.paintBorder(this,g,rect.x,rect.y,rect.width,rect.height);\n    }\n  }\n}", "comment": "paints the table & a focused row border .", "label": "what"}
{"id": "73180", "raw_code": "private void add(final JLabel label,final JTextField field){\n  panel.add(label);\n  panel.add(field);\n  if (previous == null) {\n    layout.putConstraint(SpringLayout.NORTH,panel,-SPACING,SpringLayout.NORTH,label);\n  }\n else {\n    layout.putConstraint(SpringLayout.NORTH,label,SPACING,SpringLayout.SOUTH,previous);\n  }\n  layout.putConstraint(SpringLayout.WEST,panel,-SPACING,SpringLayout.WEST,label);\n  layout.putConstraint(SpringLayout.SOUTH,panel,SPACING,SpringLayout.SOUTH,label);\n  layout.putConstraint(SpringLayout.EAST,field,-SPACING,SpringLayout.EAST,panel);\n  layout.putConstraint(SpringLayout.WEST,field,-(TEXT_FIELD_WIDTH + SPACING),SpringLayout.EAST,panel);\n  layout.putConstraint(SpringLayout.SOUTH,field,SPACING,SpringLayout.SOUTH,label);\n  previous=label;\n}", "comment": "adds a label and a field combination .", "label": "what"}
{"id": "69343", "raw_code": "private void onTrackPointStart(Attributes attributes){\n  latitude=attributes.getValue(ATTRIBUTE_LAT);\n  longitude=attributes.getValue(ATTRIBUTE_LON);\n  altitude=null;\n  time=null;\n}", "comment": "on track point start .", "label": "what"}
{"id": "75423", "raw_code": "public void commit(IResource[] resources,String comment,boolean keepLocks,IProgressMonitor monitor) throws TeamException {\n  if (monitor == null) {\n    monitor=new NullProgressMonitor();\n  }\n  Map table=getProviderMapping(resources);\n  Set keySet=table.keySet();\n  monitor.beginTask(\"\",keySet.size() * 1000);\n  monitor.setTaskName(Policy.bind(\"RepositoryManager.committing\"));\n  Iterator iterator=keySet.iterator();\n  while (iterator.hasNext()) {\n    IProgressMonitor subMonitor=new SubProgressMonitor(monitor,1000);\n    SVNTeamProvider provider=(SVNTeamProvider)iterator.next();\n    List list=(List)table.get(provider);\n    IResource[] providerResources=(IResource[])list.toArray(new IResource[list.size()]);\n    provider.checkin(providerResources,comment,keepLocks,IResource.DEPTH_INFINITE,subMonitor);\n  }\n}", "comment": "commit the given resources to their associated providers .", "label": "what"}
{"id": "4254", "raw_code": "public boolean canSpawnWorkers(){\n  boolean canSpawnWorker=false;\n  if (verboseLogLevel > 5) {\n    Utilities.verboseLog(\"canSpawnWorkers - gridName: \" + gridName + \" tier : \"+ tier+ \" maxTierDepth: \"+ maxTierDepth+ \" lifeRemaing: \"+ lifeRemaining()+ \" maximumLifeMillis: \"+ maximumLifeMillis);\n  }\n  if (!gridName.equals(\"lsf\")) {\n    return false;\n  }\n  if (clusterState != null) {\n    Long timeSinceClusterLastUpdatedClusterState=System.currentTimeMillis() - clusterState.getLastUpdated();\n    Utilities.verboseLog(\"timeSinceClusterLastUpdatedClusterState: \" + timeSinceClusterLastUpdatedClusterState);\n    if (timeSinceClusterLastUpdatedClusterState > 2 * gridCheckInterval * 1000) {\n      Utilities.verboseLog(\"ClusterState is not uptodate:\" + clusterState.toString());\n      return false;\n    }\n  }\n else {\n    return false;\n  }\n  if (tier == maxTierDepth) {\n    return false;\n  }\n  if (lifeRemaining() < (maximumLifeMillis * 0.25)) {\n    return false;\n  }\nswitch (tier) {\ncase 1:\n    canSpawnWorker=true;\n  break;\ncase 2:\ncanSpawnWorker=true;\nbreak;\ncase 3:\ncanSpawnWorker=true;\nbreak;\ncase 4:\ncanSpawnWorker=true;\nbreak;\ndefault :\nif (gridThrottle) {\ncanSpawnWorker=false;\n}\n else {\ncanSpawnWorker=true;\n}\n}\nreturn canSpawnWorker;\n}", "comment": "check if this worker can spawn any worker", "label": "what"}
{"id": "14846", "raw_code": "public boolean equals(Object object){\n  if (object == null || !(object instanceof SessionID)) {\n    return false;\n  }\n  SessionID another=(SessionID)object;\n  return encryptedString.equals(another.encryptedString);\n}", "comment": "compares this session id to the specified object .", "label": "what"}
{"id": "34505", "raw_code": "Builder addLenient(String name,String value){\n  namesAndValues.add(name);\n  namesAndValues.add(value.trim());\n  return this;\n}", "comment": "add a field with the specified value without any validation .", "label": "what"}
{"id": "44625", "raw_code": "public final <T>void removeInternal(List<T> list,int position){\n  if (hasHeaderView() && position == 0)   return;\n  if (enableLoadMore() && position == getItemCount() - 1)   return;\n  if (list.size() > 0) {\nsynchronized (mLock) {\n      list.remove(hasHeaderView() ? position - 1 : position);\n    }\n    removeNotifyExternal(position);\n    notifyItemRemoved(position);\n  }\n}", "comment": "remove a item of the list of the adapter", "label": "what"}
{"id": "13824", "raw_code": "public AMPrimaryMastHeadViewBean(String name){\n  super(name);\n}", "comment": "creates an instance of base view bean object .", "label": "what"}
{"id": "55974", "raw_code": "void handleSelectionChanged(String selection){\n  if (mDidExpandSelection) {\n    mDidExpandSelection=false;\n    return;\n  }\n  if (selection == null || selection.isEmpty()) {\n    scheduleInvalidTapNotification();\n    if (mSelectionType == SelectionType.TAP) {\n      resetSelectionStates();\n      return;\n    }\n  }\n  if (selection != null && !selection.isEmpty()) {\n    unscheduleInvalidTapNotification();\n  }\n  mSelectedText=selection;\n  if (mWasTapGestureDetected) {\n    mSelectionType=SelectionType.TAP;\n    handleSelection(selection,mSelectionType);\n    mWasTapGestureDetected=false;\n  }\n else {\n    mHandler.handleSelectionModification(selection,mX,mY);\n  }\n}", "comment": "handles a change in the current selection .", "label": "what"}
{"id": "23335", "raw_code": "public TermsAckParser parse() throws ParserConfigurationException, SAXException, ParseFailureException {\n  try {\n    SAXParserFactory factory=SAXParserFactory.newInstance();\n    SAXParser parser=factory.newSAXParser();\n    parser.parse(mInputSource,this);\n    return this;\n  }\n catch (  IOException e) {\n    throw new ParseFailureException(\"Failed to parse input source!\",e);\n  }\n}", "comment": "parse the terms ack information", "label": "what"}
{"id": "26013", "raw_code": "public Builder server(String server){\n  if (server.endsWith(\"/\") == false) {\n    server=server + \"/\";\n  }\n  this.server=server;\n  return this;\n}", "comment": "set the server url to be used by parse .", "label": "what"}
{"id": "37868", "raw_code": "void deriveConfidenceValue(double baseCount){\n  if (Utils.isMissingValue(m_confidence) && !Utils.isMissingValue(baseCount) && baseCount > 0) {\n    m_confidence=m_recordCount / baseCount;\n  }\n}", "comment": "backfit confidence value ( does nothing if the confidence value is already set ) .", "label": "what"}
{"id": "66247", "raw_code": "public ByteArrayDataSource(InputStream is,String type){\n  try {\n    ByteArrayOutputStream os=new ByteArrayOutputStream();\n    int ch;\n    while ((ch=is.read()) != -1) {\n      os.write(ch);\n    }\n    m_data=os.toByteArray();\n  }\n catch (  IOException ioex) {\n    log.log(Level.WARNING,\"\",ioex);\n  }\n  if (type != null && type.length() > 0)   m_type=type;\n}", "comment": "create a datasource from an input stream", "label": "what"}
{"id": "76197", "raw_code": "Object toType(String value,String pattern,Locale locale){\n  Calendar calendar=toCalendar(value,pattern,locale);\n  return toType(calendar);\n}", "comment": "parse a string value to the required type", "label": "what"}
{"id": "83715", "raw_code": "public void readData(DataInput din) throws IOException {\n  function=din.readUnsignedShort();\n  data=(short)(din.readShort() & 0xFFFF);\n}", "comment": "readdata - - read the function code and data value", "label": "what"}
{"id": "3532", "raw_code": "@Override public int read(byte[] buf,int offset,int len) throws IOException {\n  int available=_available;\n  if (available > 0) {\n    len=Math.min(len,available);\n    len=_next.read(buf,offset,len);\n    if (len > 0) {\n      _available-=len;\n    }\n  }\n else   if (available == 0) {\n    _available=readChunkLength();\n    if (_available > 0) {\n      len=Math.min(len,_available);\n      len=_next.read(buf,offset,len);\n      if (len > 0)       _available-=len;\n    }\n else {\n      _available=-1;\n      len=-1;\n    }\n  }\n else {\n    len=-1;\n  }\n  return len;\n}", "comment": "reads more data from the input stream .", "label": "what"}
{"id": "14301", "raw_code": "@Override public void flush(){\n  FlushTask task;\nsynchronized (logRecords) {\n    task=new FlushTask(new ArrayList<String>(logRecords));\n    logRecords.clear();\n  }\n  task.run();\n}", "comment": "flushes the buffered logrecords .", "label": "what"}
{"id": "80742", "raw_code": "public boolean isLessThen(Percent Percent){\n  assertDefined();\n  BigDecimal thisValue=notNull(this);\n  BigDecimal parameter=notNull(Percent);\n  return (thisValue.compareTo(parameter) < 0);\n}", "comment": "compares two percent objects .", "label": "what"}
{"id": "79148", "raw_code": "short readShort() throws IOException {\n  mDexFile.readFully(tmpBuf,0,2);\n  if (isBigEndian) {\n    return (short)((tmpBuf[1] & 0xff) | ((tmpBuf[0] & 0xff) << 8));\n  }\n else {\n    return (short)((tmpBuf[0] & 0xff) | ((tmpBuf[1] & 0xff) << 8));\n  }\n}", "comment": "reads a signed 16 - bit integer , byte - swapping if necessary .", "label": "what"}
{"id": "36841", "raw_code": "public static List<INaviProject> loadProjects(final AbstractSQLProvider provider,final DebuggerTemplateManager debuggerManager) throws CouldntLoadDataException {\n  PostgreSQLDatabaseFunctions.checkArguments(provider,debuggerManager);\n  final CConnection connection=provider.getConnection();\n  final List<INaviProject> projects=new ArrayList<>();\n  if (!PostgreSQLHelpers.hasTable(connection,CTableNames.PROJECTS_TABLE)) {\n    return projects;\n  }\n  String query=\"SELECT id, name, description, creation_date, modification_date, \" + \" (SELECT count(*) FROM \" + CTableNames.ADDRESS_SPACES_TABLE + \" WHERE project_id = \"+ CTableNames.PROJECTS_TABLE+ \".id) \"+ \" AS addressspace_count FROM \"+ CTableNames.PROJECTS_TABLE;\n  try (ResultSet resultSet=connection.executeQuery(query,true)){\n    while (resultSet.next()) {\n      final int projectId=resultSet.getInt(\"id\");\n      final String name=PostgreSQLHelpers.readString(resultSet,\"name\");\n      final String description=PostgreSQLHelpers.readString(resultSet,\"description\");\n      final int addressSpaceCount=resultSet.getInt(\"addressspace_count\");\n      final Timestamp creationDate=resultSet.getTimestamp(\"creation_date\");\n      final Timestamp modificationDate=resultSet.getTimestamp(\"modification_date\");\n      final List<DebuggerTemplate> debuggers=PostgreSQLDatabaseFunctions.getAssignedDebuggers(connection,projectId,debuggerManager);\n      projects.add(new CProject(projectId,name,description == null ? \"\" : description,creationDate,modificationDate,addressSpaceCount,debuggers,provider));\n    }\n  }\n catch (  final SQLException e) {\n    throw new CouldntLoadDataException(e);\n  }\n  return new ArrayList<INaviProject>(projects);\n}", "comment": "loads the projects of a database .", "label": "what"}
{"id": "19947", "raw_code": "public static boolean isFile(String path){\n  File f=new File(path);\n  return f.isFile();\n}", "comment": "checks if the given path is a file", "label": "what"}
{"id": "46824", "raw_code": "public boolean equals(Object object){\n  if (!(object instanceof ObjectInstance)) {\n    return false;\n  }\n  ObjectInstance val=(ObjectInstance)object;\n  if (!name.equals(val.getObjectName()))   return false;\n  if (className == null)   return (val.getClassName() == null);\n  return className.equals(val.getClassName());\n}", "comment": "compares the current object instance with another object instance .", "label": "what"}
{"id": "10377", "raw_code": "public ZookeeperEmbedded(int port){\n  this.port=port;\n  this.logDir=new File(System.getProperty(\"java.io.tmpdir\"),\"zk/logs/zookeeper-test-\" + port);\n}", "comment": "create zookeeper testing server .", "label": "what"}
{"id": "62024", "raw_code": "public BasicCondition(String variable,Value value,Relation relation){\n  this.variable=Template.create(variable);\n  this.templateValue=Template.create(value.toString());\n  this.groundValue=value;\n  this.relation=relation;\n}", "comment": "creates a new basic condition , given a variable label , an expected value , and a relation to hold between the variable and its value", "label": "what"}
{"id": "43315", "raw_code": "public static Set<String> readStopwordsPath(Path path,boolean lowercase) throws IOException {\n  return readStopwordsInputStream(Files.newInputStream(path),lowercase);\n}", "comment": "read a file containing stopwords ( one per line ) .", "label": "what"}
{"id": "57602", "raw_code": "private void breakBarrier(){\n  generation.broken=true;\n  count=parties;\n  trip.signalAll();\n}", "comment": "sets current barrier generation as broken and wakes up everyone .", "label": "what"}
{"id": "56307", "raw_code": "public static <T extends Throwable>T writeStackTraces(T throwable,StreamOutput out) throws IOException {\n  StackTraceElement[] stackTrace=throwable.getStackTrace();\n  out.writeVInt(stackTrace.length);\n  for (  StackTraceElement element : stackTrace) {\n    out.writeString(element.getClassName());\n    out.writeOptionalString(element.getFileName());\n    out.writeString(element.getMethodName());\n    out.writeVInt(element.getLineNumber());\n  }\n  Throwable[] suppressed=throwable.getSuppressed();\n  out.writeVInt(suppressed.length);\n  for (  Throwable t : suppressed) {\n    out.writeThrowable(t);\n  }\n  return throwable;\n}", "comment": "serializes the given exceptions stacktrace elements as well as it ' s suppressed exceptions to the given output stream .", "label": "what"}
{"id": "8053", "raw_code": "public DistributedLogMultiStreamWriter build(){\n  Preconditions.checkArgument((null != _streams && !_streams.isEmpty()),\"No streams provided\");\n  Preconditions.checkNotNull(_client,\"No distributedlog client provided\");\n  Preconditions.checkNotNull(_codec,\"No compression codec provided\");\n  Preconditions.checkArgument(_firstSpeculativeTimeoutMs > 0 && _firstSpeculativeTimeoutMs <= _maxSpeculativeTimeoutMs && _speculativeBackoffMultiplier > 0 && _maxSpeculativeTimeoutMs < _requestTimeoutMs,\"Invalid speculative timeout settings\");\n  return new DistributedLogMultiStreamWriter(_streams,_client,Math.min(_bufferSize,MAX_LOGRECORDSET_SIZE),_flushIntervalMicros,_requestTimeoutMs,_firstSpeculativeTimeoutMs,_maxSpeculativeTimeoutMs,_speculativeBackoffMultiplier,_codec,_ticker,_executorService);\n}", "comment": "build the multi stream writer .", "label": "what"}
{"id": "23513", "raw_code": "public static String numberToString(Number number) throws JSONException {\n  if (number == null) {\n    throw new JSONException(\"Null pointer\");\n  }\n  testValidity(number);\n  String string=number.toString();\n  if (string.indexOf('.') > 0 && string.indexOf('e') < 0 && string.indexOf('E') < 0) {\n    while (string.endsWith(\"0\")) {\n      string=string.substring(0,string.length() - 1);\n    }\n    if (string.endsWith(\".\")) {\n      string=string.substring(0,string.length() - 1);\n    }\n  }\n  return string;\n}", "comment": "produce a string from a number .", "label": "what"}
{"id": "65929", "raw_code": "private ImageElement(int AD_PrintFormatItem_ID){\n  loadAttachment(AD_PrintFormatItem_ID);\n}", "comment": "create image from attachment", "label": "what"}
{"id": "36904", "raw_code": "public ThreadRegisterValues(final ThreadRegisters values){\n  m_tid=values.getTid();\n  for (  final RegisterValue value : values.getRegisters()) {\n    m_values.add(new Register(value));\n  }\n}", "comment": "creates a new thread register values object .", "label": "what"}
{"id": "70384", "raw_code": "public boolean isTriggered(){\n  return checkbox.isSelected();\n}", "comment": "see if this anti - ba pod should be triggered", "label": "what"}
{"id": "10189", "raw_code": "public void addAll(int index,int[] data){\n  int dataLen=data.length;\n  if (dataLen == 0) {\n    return;\n  }\n  int newcap=size + (int)(dataLen * 1.1) + 1;\n  ensureCapacity(newcap);\n  System.arraycopy(array,index,array,index + dataLen,size - index);\n  System.arraycopy(data,0,array,index,dataLen);\n  size+=dataLen;\n}", "comment": "appends all of the elements in the specified array at the specified position in this list .", "label": "what"}
{"id": "35656", "raw_code": "private static float calculateScore(final int[] playCounts){\n  if (playCounts == null) {\n    return 0;\n  }\n  float score=0;\n  for (int i=0; i < Math.min(playCounts.length,NUM_WEEKS); i++) {\n    score+=playCounts[i] * getScoreMultiplierForWeek(i);\n  }\n  return score;\n}", "comment": "calculates the score of the song given the play counts", "label": "what"}
{"id": "76625", "raw_code": "public void removeScanningCallback(OneSheeldScanningCallback scanningCallback){\n  if (scanningCallback != null && scanningCallbacks.contains(scanningCallback))   scanningCallbacks.remove(scanningCallback);\n}", "comment": "remove a scanning callback .", "label": "what"}
{"id": "66223", "raw_code": "public void paintRect(Graphics g,JComponent c,int x,int y,int w,int h){\n  Rectangle bounds=c.getBounds();\n  check(bounds);\n  g.drawImage(m_backImage,x,y,x + w,h + y,x,y,x + w,y + h,c);\n}", "comment": "paint / copy background to component rectangle", "label": "what"}
{"id": "10432", "raw_code": "public ExecutorService shutdown(){\n  pool.shutdown();\n  return pool;\n}", "comment": "shuts down the internal thread pool .", "label": "what"}
{"id": "53559", "raw_code": "public static boolean isPropositionSymbolIdentifierPart(char ch){\n  return Character.isJavaIdentifierPart(ch);\n}", "comment": "determine if the given character is part of a proposition symbol .", "label": "what"}
{"id": "12463", "raw_code": "public static void o(Zdiagmat D){\n  o(D,Parameters.OutputFieldWidth,Parameters.OutputFracPlaces);\n}", "comment": "prints a zdiagmat in default format .", "label": "what"}
{"id": "66430", "raw_code": "public static final String trunc(final String str,final int length){\n  if (str == null) {\n    return str;\n  }\n  if (str.length() <= length) {\n    return str;\n  }\n  return str.substring(0,length);\n}", "comment": "truncate string to a given length .", "label": "what"}
{"id": "232", "raw_code": "public void clearTransactions(int fromHeight){\n  lock.lock();\n  try {\n    if (fromHeight == 0) {\n      unspent.clear();\n      spent.clear();\n      pending.clear();\n      dead.clear();\n      transactions.clear();\n    }\n else {\n      throw new UnsupportedOperationException();\n    }\n  }\n  finally {\n    lock.unlock();\n  }\n}", "comment": "deletes transactions which appeared above the given block height from the wallet , but does not touch the keys .", "label": "what"}
{"id": "80584", "raw_code": "@Override public boolean load(final Player player,final List<String> args){\n  groovyBinding.setVariable(\"player\",player);\n  if (args != null) {\n    groovyBinding.setVariable(\"args\",args.toArray(new String[args.size()]));\n  }\n else {\n    groovyBinding.setVariable(\"args\",new String[0]);\n  }\n  final GroovyShell interp=new GroovyShell(groovyBinding);\n  boolean ret=true;\n  preExecute(player,args);\n  try {\n    final File f=new File(groovyScript);\n    interp.evaluate(f);\n  }\n catch (  final Exception e) {\n    logger.error(\"Exception while sourcing file \" + groovyScript,e);\n    setMessage(e.getMessage());\n    ret=false;\n  }\ncatch (  final Error e) {\n    logger.error(\"Exception while sourcing file \" + groovyScript,e);\n    setMessage(e.getMessage());\n    ret=false;\n  }\n  postExecute(player,args,ret);\n  return (ret);\n}", "comment": "initial load of this script .", "label": "what"}
{"id": "86266", "raw_code": "private void cleanDirtyRegion(float eventX,float eventY){\n  dirtyRect.left=Math.min(lastTouchX,eventX);\n  dirtyRect.right=Math.max(lastTouchX,eventX);\n  dirtyRect.top=Math.min(lastTouchY,eventY);\n  dirtyRect.bottom=Math.max(lastTouchY,eventY);\n}", "comment": "retrieve the region needing to be redrawn", "label": "what"}
{"id": "63674", "raw_code": "public Sort(String[] fields){\n  this(fields,new boolean[fields.length]);\n  Arrays.fill(m_ascend,true);\n}", "comment": "creates a new sort specification that sorts on the given fields , all in ascending order .", "label": "what"}
{"id": "29501", "raw_code": "@Override public boolean wasSuccessful(){\n  return isFinished() && getCurrentPoints() >= successThreashold;\n}", "comment": "the attack is only successful if the xsw message is accepted .", "label": "what"}
{"id": "70702", "raw_code": "void startLocatingPhone(){\n  Intent intent=new Intent(sContext,LocationService.class);\n  intent.setAction(LocationService.START_SERVICE);\n  intent.putExtra(\"to\",this.mAnswerTo);\n  sContext.startService(intent);\n}", "comment": "starts the geolocation service", "label": "what"}
{"id": "20032", "raw_code": "public void deleteResourceConfig(String clusterName,ResourceType resourceType,String dsName) throws ConfigurationException {\n  if (getClusterHome() == null) {\n    throw new ConfigurationException(\"No home directory found from which to configure resources.\");\n  }\n  File resources=getDir(getResourceConfigDirName(getClusterHome(),clusterName,resourceType));\n  String delFileName=resources.getAbsolutePath() + File.separator + dsName+ \".properties\";\n  delFile(delFileName);\n}", "comment": "delete a specific resource configuration .", "label": "what"}
{"id": "55598", "raw_code": "public BusMovement(BusMovement proto){\n  super(proto);\n  this.controlSystem=proto.controlSystem;\n  this.id=nextID++;\n  controlSystem.registerBus(this);\n  startMode=true;\n}", "comment": "create a new instance from a prototype", "label": "what"}
{"id": "45008", "raw_code": "private static char[] zzUnpackCMap(String packed){\n  char[] map=new char[0x10000];\n  int i=0;\n  int j=0;\n  while (i < 158) {\n    int count=packed.charAt(i++);\n    char value=packed.charAt(i++);\n    do     map[j++]=value;\n while (--count > 0);\n  }\n  return map;\n}", "comment": "unpacks the compressed character translation table .", "label": "what"}
{"id": "37134", "raw_code": "private void createGui(){\n  for (  final IResultsPanel panel : m_factory) {\n    m_tabbedPane.addTab(panel.getTitle(),panel.getComponent());\n  }\n  add(m_tabbedPane,BorderLayout.CENTER);\n  m_tabbedPane.setVisible(true);\n}", "comment": "creates the sub - components of the panel .", "label": "what"}
{"id": "53504", "raw_code": "public static float generateRandomFloatBetween(float lowerLimit,float upperLimit){\n  return lowerLimit + ((upperLimit - lowerLimit) * _r.nextFloat());\n}", "comment": "generates a random float between two limits .", "label": "what"}
{"id": "16214", "raw_code": "public SGenItemProviderAdapterFactory(){\n  supportedTypes.add(IEditingDomainItemProvider.class);\n  supportedTypes.add(IStructuredItemContentProvider.class);\n  supportedTypes.add(ITreeItemContentProvider.class);\n  supportedTypes.add(IItemLabelProvider.class);\n  supportedTypes.add(IItemPropertySource.class);\n}", "comment": "this constructs an instance .", "label": "what"}
{"id": "52885", "raw_code": "private void kdRangeSearch(int left,int right,int axis,O query,ModifiableDoubleDBIDList res,DBIDArrayIter iter,double radius){\n  if (right - left <= leafsize) {\n    for (iter.seek(left); iter.getOffset() < right; iter.advance()) {\n      double dist=norm.distance(query,relation.get(iter));\n      countObjectAccess();\n      countDistanceComputation();\n      if (dist <= radius) {\n        res.add(dist,iter);\n      }\n    }\n    return;\n  }\n  final int middle=(left + right) >>> 1;\n  O split=relation.get(iter.seek(middle));\n  countObjectAccess();\n  final double delta=split.doubleValue(axis) - query.doubleValue(axis);\n  final boolean onleft=(delta >= 0);\n  final boolean onright=(delta <= 0);\n  final boolean close=(Math.abs(delta) <= radius);\n  final int next=(axis + 1) % dims;\n  if (close) {\n    double dist=norm.distance(query,split);\n    countDistanceComputation();\n    if (dist <= radius) {\n      assert (iter.getOffset() == middle);\n      res.add(dist,iter);\n    }\n  }\n  if (left < middle && (onleft || close)) {\n    kdRangeSearch(left,middle,next,query,res,iter,radius);\n  }\n  if (middle + 1 < right && (onright || close)) {\n    kdRangeSearch(middle + 1,right,next,query,res,iter,radius);\n  }\n}", "comment": "perform a knn search on the kd - tree .", "label": "what"}
{"id": "49488", "raw_code": "private void connect(){\n  if (!connected) {\n    updateInfo();\n    String connectString=\"tcp://\" + connectAddress + \":\"+ connectPort;\n    if (clientId == null || clientId.length() < 1) {\n      out(getDate() + Messages.MqttClientView_15 + connectString+ Messages.MqttClientView_16);\n      return;\n    }\n    try {\n      if (firstConnect) {\n        mqttClient=new MqttClient(connectString,clientId);\n        mqttClient.setCallback(this);\n        firstConnect=false;\n      }\n    }\n catch (    MqttException e) {\n      out(getDate() + Messages.MqttClientView_17 + e.getMessage());\n      e.printStackTrace();\n    }\n    connOpts=new MqttConnectOptions();\n    connOpts.setCleanSession(cleanStart);\n    connOpts.setConnectionTimeout(30);\n    connOpts.setKeepAliveInterval(keepAlive);\n    if (username.length() > 0 && password.length() > 0) {\n      connOpts.setPassword(password.toCharArray());\n      connOpts.setUserName(username);\n    }\n    if (useWill) {\n      if (willTopic == null || willTopic.equals(\"\")) {\n        out(Messages.MqttClientView_19);\n        return;\n      }\n      connOpts.setWill(mqttClient.getTopic(willTopic),willMessage.getBytes(),willQos,willRetain);\n    }\n    try {\n      out(getDate() + Messages.MqttClientView_20 + connectString);\n      mqttClient.connect(connOpts);\n      connected=true;\n      out(getDate() + Messages.MqttClientView_21 + clientId);\n    }\n catch (    MqttException e) {\n      out(getDate() + Messages.MqttClientView_22 + e.getMessage());\n      e.printStackTrace();\n    }\n  }\n else {\n    out(Messages.MqttClientView_23);\n  }\n}", "comment": "connects to the broker", "label": "what"}
{"id": "51195", "raw_code": "static void checkTypeRefAndPath(int typeRef,TypePath typePath){\n  int mask=0;\nswitch (typeRef >>> 24) {\ncase TypeReference.CLASS_TYPE_PARAMETER:\ncase TypeReference.METHOD_TYPE_PARAMETER:\ncase TypeReference.METHOD_FORMAL_PARAMETER:\n    mask=0xFFFF0000;\n  break;\ncase TypeReference.FIELD:\ncase TypeReference.METHOD_RETURN:\ncase TypeReference.METHOD_RECEIVER:\ncase TypeReference.LOCAL_VARIABLE:\ncase TypeReference.RESOURCE_VARIABLE:\ncase TypeReference.INSTANCEOF:\ncase TypeReference.NEW:\ncase TypeReference.CONSTRUCTOR_REFERENCE:\ncase TypeReference.METHOD_REFERENCE:\nmask=0xFF000000;\nbreak;\ncase TypeReference.CLASS_EXTENDS:\ncase TypeReference.CLASS_TYPE_PARAMETER_BOUND:\ncase TypeReference.METHOD_TYPE_PARAMETER_BOUND:\ncase TypeReference.THROWS:\ncase TypeReference.EXCEPTION_PARAMETER:\nmask=0xFFFFFF00;\nbreak;\ncase TypeReference.CAST:\ncase TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\ncase TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:\ncase TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\ncase TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:\nmask=0xFF0000FF;\nbreak;\ndefault :\nthrow new IllegalArgumentException(\"Invalid type reference sort 0x\" + Integer.toHexString(typeRef >>> 24));\n}\nif ((typeRef & ~mask) != 0) {\nthrow new IllegalArgumentException(\"Invalid type reference 0x\" + Integer.toHexString(typeRef));\n}\nif (typePath != null) {\nfor (int i=0; i < typePath.getLength(); ++i) {\nint step=typePath.getStep(i);\nif (step != TypePath.ARRAY_ELEMENT && step != TypePath.INNER_TYPE && step != TypePath.TYPE_ARGUMENT && step != TypePath.WILDCARD_BOUND) {\nthrow new IllegalArgumentException(\"Invalid type path step \" + i + \" in \"+ typePath);\n}\nif (step != TypePath.TYPE_ARGUMENT && typePath.getStepArgument(i) != 0) {\nthrow new IllegalArgumentException(\"Invalid type path step argument for step \" + i + \" in \"+ typePath);\n}\n}\n}\n}", "comment": "checks the reference to a type in a type annotation .", "label": "what"}
{"id": "78613", "raw_code": "synchronized void addTracer(Tracer tracer){\n  if (curTracers.add(tracer)) {\n    LOG.trace(toString() + \": adding tracer \" + tracer.toString());\n  }\n}", "comment": "add a new tracer .", "label": "what"}
{"id": "32389", "raw_code": "private void grow(){\n  int newCap=(entries.length << 1) + 1;\n  Object[] newEntries=new Object[newCap];\n  System.arraycopy(entries,0,newEntries,0,size);\n  entries=newEntries;\n}", "comment": "expands capacity of internal arrays .", "label": "what"}
{"id": "62051", "raw_code": "public Graph(){\n  roots=new ArrayList<Node>();\n  nodes=new ArrayList<Node>();\n  string=\"\";\n}", "comment": "constructs an empty graph", "label": "what"}
{"id": "39880", "raw_code": "private Inventory queryInventory(boolean querySkuDetails,List<String> moreItemSkus) throws IabException {\n  checkNotDisposed();\n  checkSetupDone(\"queryInventory\");\n  try {\n    Inventory inv=new Inventory();\n    int r=queryPurchases(inv,ITEM_TYPE_INAPP);\n    if (r != BILLING_RESPONSE_RESULT_OK) {\n      throw new IabException(r,\"Error refreshing inventory (querying owned items).\");\n    }\n    if (querySkuDetails) {\n      r=querySkuDetails(ITEM_TYPE_INAPP,inv,moreItemSkus);\n      if (r != BILLING_RESPONSE_RESULT_OK) {\n        throw new IabException(r,\"Error refreshing inventory (querying prices of items).\");\n      }\n    }\n    if (mSubscriptionsSupported) {\n      r=queryPurchases(inv,ITEM_TYPE_SUBS);\n      if (r != BILLING_RESPONSE_RESULT_OK) {\n        throw new IabException(r,\"Error refreshing inventory (querying owned subscriptions).\");\n      }\n      if (querySkuDetails) {\n        r=querySkuDetails(ITEM_TYPE_SUBS,inv,moreItemSkus);\n        if (r != BILLING_RESPONSE_RESULT_OK) {\n          throw new IabException(r,\"Error refreshing inventory (querying prices of subscriptions).\");\n        }\n      }\n    }\n    return inv;\n  }\n catch (  RemoteException e) {\n    throw new IabException(IABHELPER_REMOTE_EXCEPTION,\"Remote exception while refreshing inventory.\",e);\n  }\ncatch (  JSONException e) {\n    throw new IabException(IABHELPER_BAD_RESPONSE,\"Error parsing JSON response while refreshing inventory.\",e);\n  }\n}", "comment": "queries the inventory .", "label": "what"}
{"id": "52215", "raw_code": "public EmBayesEstimatorEditor(EmBayesEstimatorWrapper emBayesEstWrapper){\n  this(emBayesEstWrapper.getEstimateBayesIm(),emBayesEstWrapper.getDataSet());\n}", "comment": "constructs a new bayes im editor from a bayes estimator wrapper .", "label": "what"}
{"id": "49596", "raw_code": "private boolean saveDataToDisk(boolean exit,boolean complete,String updatedSaveName){\n  return saveDataToDisk(exit,complete,updatedSaveName,true);\n}", "comment": "saves data and writes it to disk .", "label": "what"}
{"id": "73610", "raw_code": "public static final void writeMapXml(Map val,String name,XmlSerializer out,WriteMapCallback callback) throws XmlPullParserException, java.io.IOException {\n  if (val == null) {\n    out.startTag(null,\"null\");\n    out.endTag(null,\"null\");\n    return;\n  }\n  out.startTag(null,\"map\");\n  if (name != null) {\n    out.attribute(null,\"name\",name);\n  }\n  writeMapXml(val,out,callback);\n  out.endTag(null,\"map\");\n}", "comment": "flatten a map into an xmlserializer .", "label": "what"}
{"id": "32218", "raw_code": "public boolean needPreloadKey(int idx){\n  return preloadKeys != null && preloadKeys.get(idx);\n}", "comment": "checks whether entry info should be sent to primary node from backup .", "label": "what"}
{"id": "79198", "raw_code": "public int generateChallengeToken(InetSocketAddress address){\n  int token=random.nextInt();\n  challengeTokens.put(address,token);\n  return token;\n}", "comment": "generate a new token .", "label": "what"}
{"id": "42302", "raw_code": "@Override public void perform(IR ir){\n  for (Enumeration<BasicBlock> e=ir.getBasicBlocks(); e.hasMoreElements(); ) {\n    BasicBlock bb=e.nextElement();\n    if (bb.isEmpty())     continue;\n    container.counter2++;\n    if (bb.getInfrequent()) {\n      container.counter1++;\n      if (ir.options.FREQ_FOCUS_EFFORT)       continue;\n    }\n    for (Enumeration<Instruction> ie=bb.forwardInstrEnumerator(); ie.hasMoreElements(); ) {\n      Instruction s=ie.nextElement();\n      if (TypeCheck.conforms(s) && (invertNullAndTypeChecks(s) || pushTypeCheckBelowIf(s,ir))) {\n        ie=bb.forwardInstrEnumerator();\n      }\n    }\n  }\n}", "comment": "main routine : perform the transformation .", "label": "what"}
{"id": "8585", "raw_code": "@SuppressLint(\"NewApi\") @Nullable public static Drawable inflate(boolean forceSystemHandlingWhenPossible,@NonNull Resources resources,@DrawableRes int id){\n  boolean systemHandling=isSystemHandling(forceSystemHandlingWhenPossible);\n  Log.d(LOG_TAG,String.format(\"Inflating resource with id #0x%s (system handling: %s)\",Integer.toHexString(id),systemHandling));\n  if (systemHandling) {\n    return resources.getDrawable(id,null);\n  }\n  try {\n    return VectorDrawable.create(resources,id);\n  }\n catch (  Resources.NotFoundException e) {\n    return null;\n  }\n}", "comment": "inflate a drawable from a vector xml resource .", "label": "what"}
{"id": "52602", "raw_code": "public void addAnnotation(String annotation,double x,double y){\n  mAnnotations.add(annotation);\n  mStringXY.put(x,y);\n}", "comment": "add an string at ( x , y ) coordinates", "label": "what"}
{"id": "67872", "raw_code": "protected synchronized void write(long offset,byte[] b) throws IOException {\n  if (byteBuffer != null) {\n    byteBuffer.position((int)offset);\n    byteBuffer.put(b);\n  }\n else {\n    throw new IOException(\"Write failed, file \" + getPath() + \" not mapped for I/O\");\n  }\n}", "comment": "writes bytes to the underlying rrd file on the disk", "label": "what"}
{"id": "85346", "raw_code": "public MaterialPackage(MaterialPackageBO materialPackageBO,List<GenericTrack> genericTracks){\n  super(materialPackageBO);\n  this.materialPackageBO=materialPackageBO;\n  this.genericTracks=Collections.unmodifiableList(genericTracks);\n}", "comment": "instantiates a new materialpackage object", "label": "what"}
{"id": "49620", "raw_code": "protected final void resolveIssue(HealthIssue healthIssue){\n  EventBus eventBus;\n  boolean wasIssueActive;\nsynchronized (mLock) {\n    if (mHealthEventBus == null) {\n      LOG.w(\"A health issue was resolved even though no event bus was registered to \" + \"handle it: %1$s.\",healthIssue.toString());\n      return;\n    }\n    eventBus=mHealthEventBus;\n    wasIssueActive=mActiveIssues.remove(healthIssue);\n  }\n  if (wasIssueActive) {\n    eventBus.post(healthIssue.resolved);\n  }\n}", "comment": "marks as resolved the specified issue .", "label": "what"}
{"id": "25870", "raw_code": "@Override public void agg(Object newVal){\n  if (newVal instanceof byte[]) {\n    byte[] values=(byte[])newVal;\n    ByteBuffer buffer=ByteBuffer.wrap(values);\n    buffer.rewind();\n    while (buffer.hasRemaining()) {\n      valueSet.add(buffer.getInt());\n    }\n    return;\n  }\n else {\n    double value=new Double(newVal.toString());\n    agg(value);\n  }\n}", "comment": "distinct count aggregate function which update the distinct count", "label": "what"}
{"id": "13136", "raw_code": "public boolean isUnparsedEntity(String entityName){\n  Entity entity=(Entity)fEntities.get(entityName);\n  if (entity == null) {\n    return false;\n  }\n  return entity.isUnparsed();\n}", "comment": "checks whether an entity given by name is unparsed .", "label": "what"}
{"id": "14428", "raw_code": "public void flush() throws IOException {\n  out.flush();\n}", "comment": "flush any buffered messages .", "label": "what"}
{"id": "35689", "raw_code": "private static String urlEncode(final String text) throws UnsupportedEncodingException {\n  return URLEncoder.encode(text,\"UTF-8\");\n}", "comment": "encode text as utf - 8", "label": "what"}
{"id": "6501", "raw_code": "protected void processFocusEvent(FocusEvent evt){\n  super.processFocusEvent(evt);\n  if (evt.getID() == FocusEvent.FOCUS_LOST) {\n    if (popup != null)     hidePopup();\n  }\n}", "comment": "ensures that if we lose focus , the popup goes away .", "label": "what"}
{"id": "12382", "raw_code": "default ByteBuffer serialize(T value){\n  ByteBuffer buffer=ByteBuffer.allocate(size(value));\n  serialize(value,buffer);\n  return buffer;\n}", "comment": "serialize to a byte buffer", "label": "what"}
{"id": "47439", "raw_code": "private void subFormat(int patternCharIndex,int count,FieldDelegate delegate,StringBuffer buffer,boolean useDateFormatSymbols){\n  int maxIntCount=Integer.MAX_VALUE;\n  String current=null;\n  int beginOffset=buffer.length();\n  int field=PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];\n  int value;\n  if (field == CalendarBuilder.WEEK_YEAR) {\n    if (calendar.isWeekDateSupported()) {\n      value=calendar.getWeekYear();\n    }\n else {\n      patternCharIndex=PATTERN_YEAR;\n      field=PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];\n      value=calendar.get(field);\n    }\n  }\n else   if (field == CalendarBuilder.ISO_DAY_OF_WEEK) {\n    value=CalendarBuilder.toISODayOfWeek(calendar.get(Calendar.DAY_OF_WEEK));\n  }\n else {\n    value=calendar.get(field);\n  }\n  int style=(count >= 4) ? Calendar.LONG : Calendar.SHORT;\n  if (!useDateFormatSymbols && field < Calendar.ZONE_OFFSET && patternCharIndex != PATTERN_MONTH_STANDALONE) {\n    current=calendar.getDisplayName(field,style,locale);\n  }\nswitch (patternCharIndex) {\ncase PATTERN_ERA:\n    if (useDateFormatSymbols) {\n      String[] eras=formatData.getEras();\n      if (value < eras.length) {\n        current=eras[value];\n      }\n    }\n  if (current == null) {\n    current=\"\";\n  }\nbreak;\ncase PATTERN_WEEK_YEAR:\ncase PATTERN_YEAR:\nif (calendar instanceof GregorianCalendar) {\nif (count != 2) {\n  zeroPaddingNumber(value,count,maxIntCount,buffer);\n}\n else {\n  zeroPaddingNumber(value,2,2,buffer);\n}\n}\n else {\nif (current == null) {\n  zeroPaddingNumber(value,style == Calendar.LONG ? 1 : count,maxIntCount,buffer);\n}\n}\nbreak;\ncase PATTERN_MONTH:\nif (useDateFormatSymbols) {\nString[] months;\nif (count >= 4) {\nmonths=formatData.getMonths();\ncurrent=months[value];\n}\n else if (count == 3) {\nmonths=formatData.getShortMonths();\ncurrent=months[value];\n}\n}\n else {\nif (count < 3) {\ncurrent=null;\n}\n else if (forceStandaloneForm) {\ncurrent=calendar.getDisplayName(field,style | 0x8000,locale);\nif (current == null) {\ncurrent=calendar.getDisplayName(field,style,locale);\n}\n}\n}\nif (current == null) {\nzeroPaddingNumber(value + 1,count,maxIntCount,buffer);\n}\nbreak;\ncase PATTERN_MONTH_STANDALONE:\nassert current == null;\nif (locale == null) {\nString[] months;\nif (count >= 4) {\nmonths=formatData.getMonths();\ncurrent=months[value];\n}\n else if (count == 3) {\nmonths=formatData.getShortMonths();\ncurrent=months[value];\n}\n}\n else {\nif (count >= 3) {\ncurrent=calendar.getDisplayName(field,style | 0x8000,locale);\n}\n}\nif (current == null) {\nzeroPaddingNumber(value + 1,count,maxIntCount,buffer);\n}\nbreak;\ncase PATTERN_HOUR_OF_DAY1:\nif (current == null) {\nif (value == 0) {\nzeroPaddingNumber(calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1,count,maxIntCount,buffer);\n}\n else {\nzeroPaddingNumber(value,count,maxIntCount,buffer);\n}\n}\nbreak;\ncase PATTERN_DAY_OF_WEEK:\nif (useDateFormatSymbols) {\nString[] weekdays;\nif (count >= 4) {\nweekdays=formatData.getWeekdays();\ncurrent=weekdays[value];\n}\n else {\nweekdays=formatData.getShortWeekdays();\ncurrent=weekdays[value];\n}\n}\nbreak;\ncase PATTERN_AM_PM:\nif (useDateFormatSymbols) {\nString[] ampm=formatData.getAmPmStrings();\ncurrent=ampm[value];\n}\nbreak;\ncase PATTERN_HOUR1:\nif (current == null) {\nif (value == 0) {\nzeroPaddingNumber(calendar.getLeastMaximum(Calendar.HOUR) + 1,count,maxIntCount,buffer);\n}\n else {\nzeroPaddingNumber(value,count,maxIntCount,buffer);\n}\n}\nbreak;\ncase PATTERN_ZONE_NAME:\nif (current == null) {\nif (formatData.locale == null || formatData.isZoneStringsSet) {\nint zoneIndex=formatData.getZoneIndex(calendar.getTimeZone().getID());\nif (zoneIndex == -1) {\nvalue=calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\nbuffer.append(ZoneInfoFile.toCustomID(value));\n}\n else {\nint index=(calendar.get(Calendar.DST_OFFSET) == 0) ? 1 : 3;\nif (count < 4) {\nindex++;\n}\nString[][] zoneStrings=formatData.getZoneStringsWrapper();\nbuffer.append(zoneStrings[zoneIndex][index]);\n}\n}\n else {\nTimeZone tz=calendar.getTimeZone();\nboolean daylight=(calendar.get(Calendar.DST_OFFSET) != 0);\nint tzstyle=(count < 4 ? TimeZone.SHORT : TimeZone.LONG);\nbuffer.append(tz.getDisplayName(daylight,tzstyle,formatData.locale));\n}\n}\nbreak;\ncase PATTERN_ZONE_VALUE:\nvalue=(calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET)) / 60000;\nint width=4;\nif (value >= 0) {\nbuffer.append('+');\n}\n else {\nwidth++;\n}\nint num=(value / 60) * 100 + (value % 60);\nCalendarUtils.sprintf0d(buffer,num,width);\nbreak;\ncase PATTERN_ISO_ZONE:\nvalue=calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\nif (value == 0) {\nbuffer.append('Z');\nbreak;\n}\nvalue/=60000;\nif (value >= 0) {\nbuffer.append('+');\n}\n else {\nbuffer.append('-');\nvalue=-value;\n}\nCalendarUtils.sprintf0d(buffer,value / 60,2);\nif (count == 1) {\nbreak;\n}\nif (count == 3) {\nbuffer.append(':');\n}\nCalendarUtils.sprintf0d(buffer,value % 60,2);\nbreak;\ndefault :\nif (current == null) {\nzeroPaddingNumber(value,count,maxIntCount,buffer);\n}\nbreak;\n}\nif (current != null) {\nbuffer.append(current);\n}\nint fieldID=PATTERN_INDEX_TO_DATE_FORMAT_FIELD[patternCharIndex];\nField f=PATTERN_INDEX_TO_DATE_FORMAT_FIELD_ID[patternCharIndex];\ndelegate.formatted(fieldID,f,f,beginOffset,buffer.length(),buffer);\n}", "comment": "private member function that does the real date / time formatting .", "label": "what"}
{"id": "86222", "raw_code": "@SuppressWarnings(\"unused\") public boolean onTouchEvent(MotionEvent event){\n  try {\n    int pointerCount=multiTouchSupported ? (Integer)m_getPointerCount.invoke(event) : 1;\n    if (DEBUG)     Log.i(\"MultiTouch\",\"Got here 1 - \" + multiTouchSupported + \" \"+ mMode+ \" \"+ handleSingleTouchEvents+ \" \"+ pointerCount);\n    if (mMode == MODE_NOTHING && !handleSingleTouchEvents && pointerCount == 1)     return false;\n    if (DEBUG)     Log.i(\"MultiTouch\",\"Got here 2\");\n    int action=event.getAction();\n    int histLen=event.getHistorySize() / pointerCount;\n    for (int histIdx=0; histIdx <= histLen; histIdx++) {\n      boolean processingHist=histIdx < histLen;\n      if (!multiTouchSupported || pointerCount == 1) {\n        if (DEBUG)         Log.i(\"MultiTouch\",\"Got here 3\");\n        xVals[0]=processingHist ? event.getHistoricalX(histIdx) : event.getX();\n        yVals[0]=processingHist ? event.getHistoricalY(histIdx) : event.getY();\n        pressureVals[0]=processingHist ? event.getHistoricalPressure(histIdx) : event.getPressure();\n      }\n else {\n        if (DEBUG)         Log.i(\"MultiTouch\",\"Got here 4\");\n        int numPointers=Math.min(pointerCount,MAX_TOUCH_POINTS);\n        if (DEBUG && pointerCount > MAX_TOUCH_POINTS)         Log.i(\"MultiTouch\",\"Got more pointers than MAX_TOUCH_POINTS\");\n        for (int ptrIdx=0; ptrIdx < numPointers; ptrIdx++) {\n          int ptrId=(Integer)m_getPointerId.invoke(event,ptrIdx);\n          pointerIds[ptrIdx]=ptrId;\n          xVals[ptrIdx]=(Float)(processingHist ? m_getHistoricalX.invoke(event,ptrIdx,histIdx) : m_getX.invoke(event,ptrIdx));\n          yVals[ptrIdx]=(Float)(processingHist ? m_getHistoricalY.invoke(event,ptrIdx,histIdx) : m_getY.invoke(event,ptrIdx));\n          pressureVals[ptrIdx]=(Float)(processingHist ? m_getHistoricalPressure.invoke(event,ptrIdx,histIdx) : m_getPressure.invoke(event,ptrIdx));\n        }\n      }\n      decodeTouchEvent(pointerCount,xVals,yVals,pressureVals,pointerIds,processingHist ? MotionEvent.ACTION_MOVE : action,processingHist ? true : action != MotionEvent.ACTION_UP && (action & ((1 << ACTION_POINTER_INDEX_SHIFT) - 1)) != ACTION_POINTER_UP && action != MotionEvent.ACTION_CANCEL,processingHist ? event.getHistoricalEventTime(histIdx) : event.getEventTime());\n    }\n    return true;\n  }\n catch (  Exception e) {\n    Log.e(\"MultiTouchController\",\"onTouchEvent() failed\",e);\n    return false;\n  }\n}", "comment": "process incoming touch events", "label": "what"}
{"id": "73069", "raw_code": "public boolean next() throws EOFException {\n  if (limit >= fileSize) {\n    throw new EOFException(\"End of file was reached\");\n  }\n  if (mem.getLongVolatile(Structure.Limit) <= limit) {\n    return false;\n  }\n  byte commit=mem.getByteVolatile(limit);\n  byte rollback=mem.getByteVolatile(limit + Length.Commit);\n  if (rollback == Rollback.Set) {\n    limit+=Length.RecordHeader + recordSize;\n    timeoutCounter=0;\n    timerStart=0;\n    return false;\n  }\n  if (commit == Commit.Set) {\n    timeoutCounter=0;\n    timerStart=0;\n    return true;\n  }\n  timeoutCounter++;\n  if (timeoutCounter >= MAX_TIMEOUT_COUNT) {\n    if (timerStart == 0) {\n      timerStart=System.currentTimeMillis();\n    }\n else {\n      if (System.currentTimeMillis() - timerStart >= maxTimeout) {\n        mem.putByteVolatile(limit + Length.Commit,Rollback.Set);\n        limit+=Length.RecordHeader + recordSize;\n        timeoutCounter=0;\n        timerStart=0;\n        return false;\n      }\n    }\n  }\n  return false;\n}", "comment": "steps forward to the next record if there ' s one available .", "label": "what"}
{"id": "80292", "raw_code": "private int composeComponent(int a,int b){\n  return Math.min(b + b * a / DIMMING_FACTOR,0xff);\n}", "comment": "apply composition to an individual color component of a pixel .", "label": "what"}
{"id": "69453", "raw_code": "public synchronized void writeTo(OutputStream out) throws IOException {\n  int remaining=count;\n  for (  byte[] buf : buffers) {\n    int c=Math.min(buf.length,remaining);\n    out.write(buf,0,c);\n    remaining-=c;\n    if (remaining == 0) {\n      break;\n    }\n  }\n}", "comment": "writes the entire contents of this byte stream to the specified output stream .", "label": "what"}
{"id": "71038", "raw_code": "public void removeTreeModelListener(TreeModelListener l){\n  treeModelListeners.removeElement(l);\n}", "comment": "removes a listener previously added with addtreemodellistener ( ) .", "label": "what"}
{"id": "48214", "raw_code": "public URIName(String name) throws IOException {\n  try {\n    uri=new URI(name);\n  }\n catch (  URISyntaxException use) {\n    throw new IOException(\"invalid URI name:\" + name,use);\n  }\n  if (uri.getScheme() == null) {\n    throw new IOException(\"URI name must include scheme:\" + name);\n  }\n  host=uri.getHost();\n  if (host != null) {\n    if (host.charAt(0) == '[') {\n      String ipV6Host=host.substring(1,host.length() - 1);\n      try {\n        hostIP=new IPAddressName(ipV6Host);\n      }\n catch (      IOException ioe) {\n        throw new IOException(\"invalid URI name (host \" + \"portion is not a valid IPv6 address):\" + name);\n      }\n    }\n else {\n      try {\n        hostDNS=new DNSName(host);\n      }\n catch (      IOException ioe) {\n        try {\n          hostIP=new IPAddressName(host);\n        }\n catch (        Exception ioe2) {\n          throw new IOException(\"invalid URI name (host \" + \"portion is not a valid DNS name, IPv4 address,\" + \" or IPv6 address):\"+ name);\n        }\n      }\n    }\n  }\n}", "comment": "create the uriname object with the specified name .", "label": "what"}
{"id": "49369", "raw_code": "public ZoneRules toRules(String zoneId){\n  Objects.requireNonNull(zoneId,\"zoneId\");\n  if (windowList.isEmpty()) {\n    throw new IllegalStateException(\"No windows have been added to the builder\");\n  }\n  final List<ZoneOffsetTransition> standardTransitionList=new ArrayList<>(4);\n  final List<ZoneOffsetTransition> transitionList=new ArrayList<>(256);\n  final List<ZoneOffsetTransitionRule> lastTransitionRuleList=new ArrayList<>(2);\n  final TZWindow firstWindow=windowList.get(0);\n  ZoneOffset loopStandardOffset=firstWindow.standardOffset;\n  int loopSavings=0;\n  if (firstWindow.fixedSavingAmountSecs != null) {\n    loopSavings=firstWindow.fixedSavingAmountSecs;\n  }\n  final ZoneOffset firstWallOffset=ZoneOffset.ofTotalSeconds(loopStandardOffset.getTotalSeconds() + loopSavings);\n  LocalDateTime loopWindowStart=LocalDateTime.of(YEAR_MIN_VALUE,1,1,0,0);\n  ZoneOffset loopWindowOffset=firstWallOffset;\n  for (  TZWindow window : windowList) {\n    window.tidy(loopWindowStart.getYear());\n    Integer effectiveSavings=window.fixedSavingAmountSecs;\n    if (effectiveSavings == null) {\n      effectiveSavings=0;\n      for (      TZRule rule : window.ruleList) {\n        if (rule.toEpochSecond(loopStandardOffset,loopSavings) > loopWindowStart.toEpochSecond(loopWindowOffset)) {\n          break;\n        }\n        effectiveSavings=rule.savingAmountSecs;\n      }\n    }\n    if (loopStandardOffset.equals(window.standardOffset) == false) {\n      standardTransitionList.add(new ZoneOffsetTransition(LocalDateTime.ofEpochSecond(loopWindowStart.toEpochSecond(loopWindowOffset),0,loopStandardOffset),loopStandardOffset,window.standardOffset));\n      loopStandardOffset=window.standardOffset;\n    }\n    ZoneOffset effectiveWallOffset=ZoneOffset.ofTotalSeconds(loopStandardOffset.getTotalSeconds() + effectiveSavings);\n    if (loopWindowOffset.equals(effectiveWallOffset) == false) {\n      transitionList.add(new ZoneOffsetTransition(loopWindowStart,loopWindowOffset,effectiveWallOffset));\n    }\n    loopSavings=effectiveSavings;\n    for (    TZRule rule : window.ruleList) {\n      if (rule.isTransition(loopSavings)) {\n        ZoneOffsetTransition trans=rule.toTransition(loopStandardOffset,loopSavings);\n        if (trans.toEpochSecond() < loopWindowStart.toEpochSecond(loopWindowOffset) == false && trans.toEpochSecond() < window.createDateTimeEpochSecond(loopSavings)) {\n          transitionList.add(trans);\n          loopSavings=rule.savingAmountSecs;\n        }\n      }\n    }\n    for (    TZRule lastRule : window.lastRuleList) {\n      lastTransitionRuleList.add(lastRule.toTransitionRule(loopStandardOffset,loopSavings));\n      loopSavings=lastRule.savingAmountSecs;\n    }\n    loopWindowOffset=window.createWallOffset(loopSavings);\n    loopWindowStart=LocalDateTime.ofEpochSecond(window.createDateTimeEpochSecond(loopSavings),0,loopWindowOffset);\n  }\n  return new ZoneRules(firstWindow.standardOffset,firstWallOffset,standardTransitionList,transitionList,lastTransitionRuleList);\n}", "comment": "completes the build converting the builder to a set of time - zone rules .", "label": "what"}
{"id": "15730", "raw_code": "public void addParseTemplate(String parseTemplate){\n  parseTemplates.add(parseTemplate);\n}", "comment": "adds a template which should be \" parsed \" while the parsing process .", "label": "what"}
{"id": "438", "raw_code": "static ByteBuffer newByteBuffer(int capacity){\n  ByteBuffer newbb=ByteBuffer.allocate(capacity);\n  newbb.order(ByteOrder.LITTLE_ENDIAN);\n  return newbb;\n}", "comment": "create a ` bytebuffer ` with a given capacity .", "label": "what"}
{"id": "67537", "raw_code": "private void validateCollectionAttribute(CollectionAttribute collection,Set<String> allCollections){\n  if (collection == null || allCollections == null) {\n    return;\n  }\n  for (  RestMethod restMethod : collection.getMethods()) {\n    if (allCollections.contains(restMethod.getRestFullMethodName())) {\n      aspect.warning(SimpleLocation.TOPLEVEL,\"The rpc methods and the associated http paths are not following the guidelines. As a \" + \"result the derived rest collection '%s' contains a sub collection and a \" + \"method with the same name as '%s'. This can cause a failure to generate client \"+ \"library, since these names are used for generating artifacts in generated code.\",collection.getFullName(),restMethod.getRestMethodName());\n    }\n  }\n}", "comment": "validates if the collection does not contain same named elements ( methods and resources ) .", "label": "what"}
{"id": "19994", "raw_code": "public void putStringNoNull(String s){\n  ensureCapacity(s.length() * 2);\n  System.arraycopy(s.getBytes(),0,this.byteBuffer,this.position,s.length());\n  this.position+=s.length();\n}", "comment": "put a string in the buffer .", "label": "what"}
{"id": "54995", "raw_code": "public void externalEntityDecl(String name,XMLResourceIdentifier identifier,Augmentations augs) throws XNIException {\n  try {\n    if (fDeclHandler != null) {\n      String publicId=identifier.getPublicId();\n      String systemId=fResolveDTDURIs ? identifier.getExpandedSystemId() : identifier.getLiteralSystemId();\n      fDeclHandler.externalEntityDecl(name,publicId,systemId);\n    }\n  }\n catch (  SAXException e) {\n    throw new XNIException(e);\n  }\n}", "comment": "an external entity declaration .", "label": "what"}
{"id": "56456", "raw_code": "public HoltWintersModelBuilder alpha(double alpha){\n  this.alpha=alpha;\n  return this;\n}", "comment": "alpha controls the smoothing of the data .", "label": "what"}
{"id": "29120", "raw_code": "public static @CheckForNull ClassDescriptor createClassDescriptorFromFieldSignature(String signature){\n  int start=signature.indexOf('L');\n  if (start < 0) {\n    return null;\n  }\n  int end=signature.indexOf(';',start);\n  if (end < 0) {\n    return null;\n  }\n  return createClassDescriptor(signature.substring(start + 1,end));\n}", "comment": "create a class descriptor from a field signature", "label": "what"}
{"id": "32922", "raw_code": "public void filledEllipse(double x,double y,double semiMajorAxis,double semiMinorAxis){\n  if (semiMajorAxis < 0)   throw new IllegalArgumentException(\"ellipse semimajor axis can't be negative\");\n  if (semiMinorAxis < 0)   throw new IllegalArgumentException(\"ellipse semiminor axis can't be negative\");\n  double xs=scaleX(x);\n  double ys=scaleY(y);\n  double ws=factorX(2 * semiMajorAxis);\n  double hs=factorY(2 * semiMinorAxis);\n  if (ws <= 1 && hs <= 1)   pixel(x,y);\n else   offscreen.fill(new Ellipse2D.Double(xs - ws / 2,ys - hs / 2,ws,hs));\n  draw();\n}", "comment": "draws an ellipse with given semimajor and semiminor axes , centered on ( x , y ) .", "label": "what"}
{"id": "19659", "raw_code": "public static boolean canBeRandomized(Class clazz){\n  return ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.equals(String.class) || clazz.equals(IDiscordClient.class);\n}", "comment": "checks if the class is supported to be randomized without recursion .", "label": "what"}
{"id": "61700", "raw_code": "public static SecretKeys keys(String keysStr) throws InvalidKeyException {\n  String[] keysArr=keysStr.split(\":\");\n  if (keysArr.length != 2) {\n    throw new IllegalArgumentException(\"Cannot parse aesKey:hmacKey\");\n  }\n else {\n    byte[] confidentialityKey=Base64.decode(keysArr[0],BASE64_FLAGS);\n    if (confidentialityKey.length != AES_KEY_LENGTH_BITS / 8) {\n      throw new InvalidKeyException(\"Base64 decoded key is not \" + AES_KEY_LENGTH_BITS + \" bytes\");\n    }\n    byte[] integrityKey=Base64.decode(keysArr[1],BASE64_FLAGS);\n    if (integrityKey.length != HMAC_KEY_LENGTH_BITS / 8) {\n      throw new InvalidKeyException(\"Base64 decoded key is not \" + HMAC_KEY_LENGTH_BITS + \" bytes\");\n    }\n    return new SecretKeys(new SecretKeySpec(confidentialityKey,0,confidentialityKey.length,CIPHER),new SecretKeySpec(integrityKey,HMAC_ALGORITHM));\n  }\n}", "comment": "an aes key derived from a base64 encoded key .", "label": "what"}
{"id": "48815", "raw_code": "public WritableRaster createWritableChild(int x,int y,int width,int height,int x0,int y0,int bandList[]){\n  if (x < this.minX) {\n    throw new RasterFormatException(\"x lies outside raster\");\n  }\n  if (y < this.minY) {\n    throw new RasterFormatException(\"y lies outside raster\");\n  }\n  if ((x + width < x) || (x + width > this.minX + this.width)) {\n    throw new RasterFormatException(\"(x + width) is outside of Raster\");\n  }\n  if ((y + height < y) || (y + height > this.minY + this.height)) {\n    throw new RasterFormatException(\"(y + height) is outside of Raster\");\n  }\n  SampleModel sm;\n  if (bandList != null)   sm=sampleModel.createSubsetSampleModel(bandList);\n else   sm=sampleModel;\n  int deltaX=x0 - x;\n  int deltaY=y0 - y;\n  return new ShortBandedRaster(sm,dataBuffer,new Rectangle(x0,y0,width,height),new Point(sampleModelTranslateX + deltaX,sampleModelTranslateY + deltaY),this);\n}", "comment": "creates a writable subraster given a region of the raster .", "label": "what"}
{"id": "37273", "raw_code": "private void sortChildren(final JCriteriumTreeNode parentNode){\n  final List<JCriteriumTreeNode> operators=new ArrayList<JCriteriumTreeNode>();\n  final List<JCriteriumTreeNode> conditions=new ArrayList<JCriteriumTreeNode>();\n  final List<JCriteriumTreeNode> minus=new ArrayList<JCriteriumTreeNode>();\n  final Enumeration<?> children=parentNode.children();\n  while (children.hasMoreElements()) {\n    final JCriteriumTreeNode child=(JCriteriumTreeNode)children.nextElement();\n    final ICriterium type=child.getCriterium();\n    if (type instanceof CConditionCriterium) {\n      conditions.add(child);\n    }\n else {\n      operators.add(child);\n    }\n  }\n  parentNode.removeAllChildren();\n  for (  final JCriteriumTreeNode child : operators) {\n    parentNode.add(child);\n    child.setParent(parentNode);\n  }\n  for (  final JCriteriumTreeNode child : conditions) {\n    parentNode.add(child);\n    child.setParent(parentNode);\n  }\n  for (  final JCriteriumTreeNode child : minus) {\n    parentNode.add(child);\n    child.setParent(parentNode);\n  }\n}", "comment": "sorts visible tree nodes .", "label": "what"}
{"id": "81863", "raw_code": "public boolean isBuiltinSoundAvailable(String soundIdentifier){\n  return builtinSounds.containsKey(soundIdentifier);\n}", "comment": "indicates whether a user installed or system sound is available", "label": "what"}
{"id": "15697", "raw_code": "public Iterator<String> iterateSerializers(){\n  return serializers.iterator();\n}", "comment": "iterate over view serializers", "label": "what"}
{"id": "46843", "raw_code": "private static void checkKey(String key) throws MalformedObjectNameException {\n  if (key == null)   throw new NullPointerException(\"Invalid key (null)\");\n  final int len=key.length();\n  if (len == 0)   throw new MalformedObjectNameException(\"Invalid key (empty)\");\n  final char[] k=key.toCharArray();\n  final int endKey=parseKey(k,0);\n  if (endKey < len)   throw new MalformedObjectNameException(\"Invalid character in value: `\" + k[endKey] + \"'\");\n}", "comment": "check if the supplied key is a valid key .", "label": "what"}
{"id": "47035", "raw_code": "protected MessageDigest(String algorithm){\n  this.algorithm=algorithm;\n}", "comment": "creates a message digest with the specified algorithm name .", "label": "what"}
{"id": "37179", "raw_code": "private void createGui(){\n  final JPanel topPanel=new JPanel(new BorderLayout());\n  final JPanel innerTopPanel=new JPanel(new BorderLayout());\n  innerTopPanel.add(m_stdEditPanel);\n  topPanel.add(innerTopPanel);\n  final JPanel debuggerChooserPanel=new JPanel(new BorderLayout());\n  debuggerChooserPanel.setBorder(new TitledBorder(\"Project Debuggers\"));\n  m_checkedList=new JCheckedListbox<>(new Vector<DebuggerTemplate>(),false);\n  updateCheckedListPanel();\n  final JScrollPane debuggerScrollPane=new JScrollPane(m_checkedList);\n  m_checkedListPanel.add(debuggerScrollPane);\n  debuggerChooserPanel.add(m_checkedListPanel,BorderLayout.CENTER);\n  debuggerChooserPanel.setMinimumSize(new Dimension(0,128));\n  debuggerChooserPanel.setPreferredSize(new Dimension(0,128));\n  innerTopPanel.add(debuggerChooserPanel,BorderLayout.SOUTH);\n  final JPanel buttonPanel=new JPanel(new GridLayout(1,2));\n  buttonPanel.setBorder(new EmptyBorder(0,0,5,2));\n  buttonPanel.add(new JPanel());\n  buttonPanel.add(m_saveButton);\n  topPanel.add(buttonPanel,BorderLayout.SOUTH);\n  final JPanel bottomPanel=new CAddressSpacesTablePanel(m_table);\n  final JScrollPane scrollPane=new JScrollPane(m_table);\n  bottomPanel.setBorder(m_titledBorder);\n  setBorder(new EmptyBorder(0,0,0,1));\n  bottomPanel.add(scrollPane);\n  final JSplitPane splitPane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,topPanel,bottomPanel);\n  splitPane.setOneTouchExpandable(true);\n  splitPane.setDividerLocation(splitPane.getMinimumDividerLocation());\n  splitPane.setResizeWeight(0.5);\n  add(splitPane);\n}", "comment": "creates the elements of this component .", "label": "what"}
{"id": "57307", "raw_code": "private void handleResponse(AvsResponse response){\n  boolean checkAfter=(avsQueue.size() == 0);\n  if (response != null) {\n    for (int i=response.size() - 1; i >= 0; i--) {\n      if (response.get(i) instanceof AvsReplaceAllItem || response.get(i) instanceof AvsReplaceEnqueuedItem) {\n        avsQueue.clear();\n        response.remove(i);\n      }\n    }\n    Log.i(TAG,\"Adding \" + response.size() + \" items to our queue\");\n    avsQueue.addAll(response);\n  }\n  if (checkAfter) {\n    checkQueue();\n  }\n}", "comment": "handle the response sent back from alexa ' s parsing of the intent , these can be any of the avsitem types ( play , speak , stop , clear , listen )", "label": "what"}
{"id": "65533", "raw_code": "boolean removeViewIfHidden(View view){\n  final int index=mCallback.indexOfChild(view);\n  if (index == -1) {\n    if (mHiddenViews.remove(view) && DEBUG) {\n      throw new IllegalStateException(\"view is in hidden list but not in view group\");\n    }\n    return true;\n  }\n  if (mBucket.get(index)) {\n    mBucket.remove(index);\n    mCallback.removeViewAt(index);\n    if (!mHiddenViews.remove(view) && DEBUG) {\n      throw new IllegalStateException(\"removed a hidden view but it is not in hidden views list\");\n    }\n    return true;\n  }\n  return false;\n}", "comment": "removes a view from the viewgroup if it is hidden .", "label": "what"}
{"id": "45337", "raw_code": "public void serialize(KXmlSerializer serializer) throws IOException {\n  serializer.startTag(ns,TAG);\n  serializeAttribute(serializer,NAME_ATTR,mName);\n  serializeAttribute(serializer,APP_PACKAGE_NAME_ATTR,mAppPackageName);\n  serializeAttribute(serializer,DIGEST_ATTR,getDigest());\n  if (SIGNATURE_TEST_PKG.equals(mName)) {\n    serializer.attribute(ns,\"signatureCheck\",\"true\");\n  }\n  mSuiteRoot.serialize(serializer);\n  serializer.endTag(ns,TAG);\n}", "comment": "serialize this object and all its contents to xml .", "label": "what"}
{"id": "85434", "raw_code": "public void rollback(Throwable t){\n  log.debug(\"  ROLLBACK: deleting \" + tempFile + \" due to \"+ t);\n  try {\n    fileContentStore.delete(tempFile,node);\n  }\n catch (  Exception e) {\n    t.addSuppressed(e);\n  }\n}", "comment": "rollback the download ( delete the temporary file )", "label": "what"}
{"id": "11666", "raw_code": "protected void parseGeometryString(){\n  int i=0;\n  byte[] bytes=geometryString.getBytes();\n  xgrav=new String(bytes,0,1);\n  for (i=2; i < bytes.length; i++) {\n    if ((bytes[i] == '-') || (bytes[i] == '+'))     break;\n  }\n  if (i == bytes.length)   return;\n  ygrav=(bytes[i] == '-') ? \"-\" : \"+\";\n  xpos=Integer.parseInt(new String(bytes,1,i - 1));\n  ++i;\n  ypos=Integer.parseInt(new String(bytes,i,bytes.length - i));\n}", "comment": "parse x - like geometry string .", "label": "what"}
{"id": "82519", "raw_code": "public java.lang.StringBuffer insert(int offset,char c){\n  internal.insert(offset,c);\n  return this;\n}", "comment": "inserts the string representation of the char argument into this string buffer .", "label": "what"}
{"id": "84897", "raw_code": "protected void calculateDestination(IFile uxf,ICompilationUnit referencingCompilationUnit,Destination dest) throws CoreException {\n  IFile uxfDest=calculateImgDestination(uxf,referencingCompilationUnit);\n  if (uxfDest != null) {\n    dest.imgFileDestination=uxfDest;\n  }\n}", "comment": "calculate the destination of the given umlet diagram .", "label": "what"}
{"id": "56022", "raw_code": "public void updateVisibleIds(List<Integer> priority){\n  if (mNativeTabContentManager != 0) {\n    int idsSize=Math.min(mFullResThumbnailsMaxSize,priority.size());\n    if (idsSize != mPriorityTabIds.length) {\n      mPriorityTabIds=new int[idsSize];\n    }\n    for (int i=0; i < idsSize; i++) {\n      mPriorityTabIds[i]=priority.get(i);\n    }\n    nativeUpdateVisibleIds(mNativeTabContentManager,mPriorityTabIds);\n  }\n}", "comment": "update the priority - ordered list of visible tabs .", "label": "what"}
{"id": "32140", "raw_code": "private void requestFragmenting(IgfsEntryInfo fileInfo){\n  IgfsFileMap map=fileInfo.fileMap();\n  assert map != null && !map.ranges().isEmpty();\n  Map<UUID,Collection<IgfsFileAffinityRange>> grpMap=U.newHashMap(map.ranges().size());\n  for (  IgfsFileAffinityRange range : map.ranges()) {\n    UUID nodeId=igfsCtx.data().affinityNode(range.affinityKey()).id();\n    Collection<IgfsFileAffinityRange> nodeRanges=grpMap.get(nodeId);\n    if (nodeRanges == null) {\n      nodeRanges=new LinkedList<>();\n      grpMap.put(nodeId,nodeRanges);\n    }\n    nodeRanges.addAll(range.split(igfsCtx.data().groupBlockSize()));\n  }\n  Collection<UUID> nodeIds=new IdentityHashSet(grpMap.keySet());\n  if (log.isDebugEnabled())   log.debug(\"Calculating fragmentizer groups for file [fileInfo=\" + fileInfo + \", nodeIds=\"+ nodeIds+ ']');\n  Object old=fragmentingFiles.putIfAbsent(fileInfo.id(),nodeIds);\n  assert old == null;\n  for (  Map.Entry<UUID,Collection<IgfsFileAffinityRange>> entry : grpMap.entrySet()) {\n    UUID nodeId=entry.getKey();\n    IgfsFragmentizerRequest msg=new IgfsFragmentizerRequest(fileInfo.id(),entry.getValue());\n    try {\n      if (log.isDebugEnabled())       log.debug(\"Sending fragmentizer request to remote node [nodeId=\" + nodeId + \", fileId=\"+ fileInfo.id()+ \", msg=\"+ msg+ ']');\n      sendWithRetries(nodeId,msg);\n    }\n catch (    IgniteCheckedException e) {\n      if (e.hasCause(ClusterTopologyCheckedException.class)) {\n        if (log.isDebugEnabled())         log.debug(\"Failed to send fragmentizer request to remote node (node left grid): \" + nodeId);\n      }\n else       U.error(log,\"Failed to send fragmentizer request to remote node [nodeId=\" + nodeId + \", msg=\"+ msg+ ']',e);\n      nodeIds.remove(nodeId);\n    }\n  }\n  if (nodeIds.isEmpty()) {\n    if (log.isDebugEnabled())     log.debug(\"Got empty wait set for fragmentized file: \" + fileInfo);\n    fragmentingFiles.remove(fileInfo.id(),nodeIds);\n  }\n}", "comment": "starts file fragmenting .", "label": "what"}
{"id": "6602", "raw_code": "public boolean showPreviousNotification(){\n  int i=getSelectedIndex();\n  if (i != -1 && i > 0) {\n    model.setSelectedItem(model.getElementAt(i - 1));\n    return true;\n  }\n  return false;\n}", "comment": "scrolls to the previous notification .", "label": "what"}
{"id": "37007", "raw_code": "public static void initialize(final CDatabaseConfiguration configuration) throws CouldntLoadDriverException, CouldntConnectException, SQLException {\n  checkDriver(configuration);\n  final String url=POSTGRES_DRIVER + \"//\" + configuration.getHost()+ \"/\"+ POSTGRES_DEFAULT_DB;\n  Connection connection=null;\n  try {\n    connection=DriverManager.getConnection(url,configuration.getUser(),configuration.getPassword());\n  }\n catch (  final SQLException exception) {\n    CUtilityFunctions.logException(exception);\n    throw new CouldntConnectException(exception,exception.getErrorCode(),exception.getSQLState());\n  }\n  final String statement=\"CREATE DATABASE \\\"\" + configuration.getName() + \"\\\"\";\n  final PreparedStatement preparedStatement=connection.prepareStatement(statement);\n  try {\n    preparedStatement.execute();\n  }\n  finally {\n    preparedStatement.close();\n    connection.close();\n  }\n}", "comment": "initializes a new postgresql database", "label": "what"}
{"id": "17820", "raw_code": "private void registerObjectRead(Object obj,int handle,boolean unshared) throws IOException {\n  if (unshared) {\n    obj=UNSHARED_OBJ;\n  }\n  int index=handle - ObjectStreamConstants.baseWireHandle;\n  int size=objectsRead.size();\n  while (index > size) {\n    objectsRead.add(null);\n    ++size;\n  }\n  if (index == size) {\n    objectsRead.add(obj);\n  }\n else {\n    objectsRead.set(index,obj);\n  }\n}", "comment": "associates a read object with the its serialization handle .", "label": "what"}
{"id": "35956", "raw_code": "public boolean merge(final Frame<? extends V> frame,final Interpreter<V> interpreter) throws AnalyzerException {\n  if (top != frame.top) {\n    throw new AnalyzerException(null,\"Incompatible stack heights\");\n  }\n  boolean changes=false;\n  for (int i=0; i < locals + top; ++i) {\n    V v=interpreter.merge(values[i],frame.values[i]);\n    if (!v.equals(values[i])) {\n      values[i]=v;\n      changes=true;\n    }\n  }\n  return changes;\n}", "comment": "merges this frame with the given frame .", "label": "what"}
{"id": "66448", "raw_code": "public static void keytool(String cmd){\n  log.info(\"keytool \" + cmd);\n  ArrayList<String> list=new ArrayList<String>();\n  StringTokenizer st=new StringTokenizer(cmd,\" \");\n  String quoteBuffer=null;\n  while (st.hasMoreTokens()) {\n    String token=st.nextToken();\n    if (quoteBuffer == null) {\n      if (token.startsWith(\"\\\"\"))       quoteBuffer=token.substring(1);\n else       list.add(token);\n    }\n else     quoteBuffer+=\" \" + token;\n    if (token.endsWith(\"\\\"\")) {\n      String str=quoteBuffer.substring(0,quoteBuffer.length() - 1);\n      list.add(str);\n      quoteBuffer=null;\n    }\n  }\n  String[] args=new String[list.size()];\n  list.toArray(args);\n  try {\n    KeyTool.main(args);\n  }\n catch (  Exception e) {\n  }\n}", "comment": "submit command to key tool", "label": "what"}
{"id": "8701", "raw_code": "private void smoothSnapToPosition(int scrollY,int availableScrollHeight,AlphabeticalAppsList.FastScrollSectionInfo info){\n  mRv.removeCallbacks(mSmoothSnapNextFrameRunnable);\n  mRv.removeCallbacks(mFastScrollToTargetSectionRunnable);\n  trackAllChildViews();\n  if (mHasFastScrollTouchSettled) {\n    mCurrentFastScrollSection=info.sectionName;\n    mTargetFastScrollSection=null;\n    updateTrackedViewsFastScrollFocusState();\n  }\n else {\n    mCurrentFastScrollSection=null;\n    mTargetFastScrollSection=info.sectionName;\n    mHasFastScrollTouchSettled=false;\n    updateTrackedViewsFastScrollFocusState();\n    mRv.postDelayed(mFastScrollToTargetSectionRunnable,mHasFastScrollTouchSettledAtLeastOnce ? REPEAT_TOUCH_SETTLING_DURATION : INITIAL_TOUCH_SETTLING_DURATION);\n  }\n  int newScrollY=Math.min(availableScrollHeight,mRv.getPaddingTop() + mRv.getTop(info.fastScrollToItem.rowIndex));\n  int numFrames=mFastScrollFrames.length;\n  for (int i=0; i < numFrames; i++) {\n    mFastScrollFrames[i]=(newScrollY - scrollY) / numFrames;\n  }\n  mFastScrollFrameIndex=0;\n  mRv.postOnAnimation(mSmoothSnapNextFrameRunnable);\n}", "comment": "smoothly snaps to a given position .", "label": "what"}
{"id": "56902", "raw_code": "private void updatePropertyToValue2() throws Exception {\n  properties.put(TEST_KEY,TEST_VALUE_2);\n  updatePropertiesFile();\n}", "comment": "updates the key in the persistent property store to \" value 2 \" .", "label": "what"}
{"id": "13783", "raw_code": "public void unassignServices(String universalId,Set serviceNames) throws AMConsoleException {\n  if ((serviceNames != null) && !serviceNames.isEmpty()) {\n    String[] params=new String[2];\n    params[0]=universalId;\n    String currentSvc=\"\";\n    try {\n      AMIdentity amid=IdUtils.getIdentity(getUserSSOToken(),universalId);\n      for (Iterator iter=serviceNames.iterator(); iter.hasNext(); ) {\n        currentSvc=(String)iter.next();\n        params[1]=currentSvc;\n        logEvent(\"ATTEMPT_IDENTITY_UNASSIGN_SERVICE\",params);\n        amid.unassignService(currentSvc);\n        logEvent(\"SUCCEED_IDENTITY_UNASSIGN_SERVICE\",params);\n      }\n    }\n catch (    SSOException e) {\n      String[] paramsEx={universalId,currentSvc,getErrorString(e)};\n      logEvent(\"SSO_EXCEPTION_IDENTITY_UNASSIGN_SERVICE\",paramsEx);\n      debug.warning(\"EntitiesModelImpl.unassignServices\",e);\n      throw new AMConsoleException(getErrorString(e));\n    }\ncatch (    IdRepoException e) {\n      String[] paramsEx={universalId,currentSvc,getErrorString(e)};\n      logEvent(\"IDM_EXCEPTION_IDENTITY_UNASSIGN_SERVICE\",paramsEx);\n      debug.warning(\"EntitiesModelImpl.unassignServices\",e);\n      throw new AMConsoleException(getErrorString(e));\n    }\n  }\n}", "comment": "unassigns services from an entity .", "label": "what"}
{"id": "72567", "raw_code": "private Cluster<T> expandCluster(final Cluster<T> cluster,final T point,final List<T> neighbors,final Collection<T> points,final Map<Clusterable,PointStatus> visited){\n  cluster.addPoint(point);\n  visited.put(point,PointStatus.PART_OF_CLUSTER);\n  List<T> seeds=new ArrayList<T>(neighbors);\n  int index=0;\n  while (index < seeds.size()) {\n    final T current=seeds.get(index);\n    PointStatus pStatus=visited.get(current);\n    if (pStatus == null) {\n      final List<T> currentNeighbors=getNeighbors(current,points);\n      if (currentNeighbors.size() >= minPts) {\n        seeds=merge(seeds,currentNeighbors);\n      }\n    }\n    if (pStatus != PointStatus.PART_OF_CLUSTER) {\n      visited.put(current,PointStatus.PART_OF_CLUSTER);\n      cluster.addPoint(current);\n    }\n    index++;\n  }\n  return cluster;\n}", "comment": "expands the cluster to include density - reachable items .", "label": "what"}
{"id": "47552", "raw_code": "@Override public int parse(DateTimeParseContext context,CharSequence text,int position){\n  int length=text.length();\n  if (position > length) {\n    throw new IndexOutOfBoundsException();\n  }\n  if (position == length) {\n    return ~position;\n  }\n  char nextChar=text.charAt(position);\n  if (nextChar == '+' || nextChar == '-') {\n    return parseOffsetBased(context,text,position,position,OffsetIdPrinterParser.INSTANCE_ID_Z);\n  }\n else   if (length >= position + 2) {\n    char nextNextChar=text.charAt(position + 1);\n    if (context.charEquals(nextChar,'U') && context.charEquals(nextNextChar,'T')) {\n      if (length >= position + 3 && context.charEquals(text.charAt(position + 2),'C')) {\n        return parseOffsetBased(context,text,position,position + 3,OffsetIdPrinterParser.INSTANCE_ID_ZERO);\n      }\n      return parseOffsetBased(context,text,position,position + 2,OffsetIdPrinterParser.INSTANCE_ID_ZERO);\n    }\n else     if (context.charEquals(nextChar,'G') && length >= position + 3 && context.charEquals(nextNextChar,'M') && context.charEquals(text.charAt(position + 2),'T')) {\n      return parseOffsetBased(context,text,position,position + 3,OffsetIdPrinterParser.INSTANCE_ID_ZERO);\n    }\n  }\n  PrefixTree tree=getTree(context);\n  ParsePosition ppos=new ParsePosition(position);\n  String parsedZoneId=tree.match(text,ppos);\n  if (parsedZoneId == null) {\n    if (context.charEquals(nextChar,'Z')) {\n      context.setParsed(ZoneOffset.UTC);\n      return position + 1;\n    }\n    return ~position;\n  }\n  context.setParsed(ZoneId.of(parsedZoneId));\n  return ppos.getIndex();\n}", "comment": "this implementation looks for the longest matching string .", "label": "what"}
{"id": "61143", "raw_code": "public void registerUnregisteredNamespaces(){\n  for (int i=0; i < m_unregisteredExtensions.size(); i++) {\n    String ns=(String)m_unregisteredExtensions.get(i);\n    ExtensionNamespaceSupport extNsSpt=defineJavaNamespace(ns);\n    if (extNsSpt != null)     m_extensions.add(extNsSpt);\n  }\n}", "comment": "attempt to register any unregistered extension namespaces .", "label": "what"}
{"id": "80090", "raw_code": "private void removeAllObjects(){\n  logger.debug(\"CLEANING screen object list\");\n  texts.clear();\n}", "comment": "remove all map objects .", "label": "what"}
{"id": "40879", "raw_code": "public Builder deleteDisplayName(){\n  deleteFields.add(\"displayName\");\n  return this;\n}", "comment": "deletes the display name of a existing user", "label": "what"}
{"id": "32473", "raw_code": "private void waitForIteratorsCleared(IgniteCache<String,Integer> cache,int secs) throws InterruptedException {\n  for (int i=0; i < secs; i++) {\n    try {\n      cache.size();\n      checkIteratorsCleared();\n    }\n catch (    AssertionFailedError e) {\n      if (i == 9) {\n        for (int j=0; j < gridCount(); j++)         executeOnLocalOrRemoteJvm(j,new PrintIteratorStateTask());\n        throw e;\n      }\n      log.info(\"Iterators not cleared, will wait\");\n      Thread.sleep(1000);\n    }\n  }\n}", "comment": "checks iterators are cleared .", "label": "what"}
{"id": "86312", "raw_code": "private boolean validateCooldownSetting(String appId,AutoScalerPolicyTrigger policyTrigger,String triggerId){\n  AutoScalingDataStore stateStore=AutoScalingDataStoreFactory.getAutoScalingDataStore();\n  AppAutoScaleState appState=null;\n  appState=stateStore.getScalingState(appId);\n  if (appState == null) {\n    return true;\n  }\n else   if ((appState.getInstanceCountState() != ScalingStateManager.SCALING_STATE_COMPLETED) && (appState.getInstanceCountState() != ScalingStateManager.SCALING_STATE_FAILED)) {\n    long lastStartTime=appState.getLastActionStartTime();\n    long currentTime=System.currentTimeMillis();\n    boolean timeExpired=(currentTime - lastStartTime) > this.eventTimeout;\n    if (timeExpired) {\n      logger.debug(\"True: Last scaling action is not completed but it's time expired for application \" + appId + \".\");\n      return true;\n    }\n    logger.debug(\"False: Last scaling action is not completed for application \" + appId + \".\");\n    return false;\n  }\n else {\n    long cooldownEndtime=appState.getLastActionEndTime() + 1000L * getCooldownSecs(policyTrigger,triggerId);\n    if (System.currentTimeMillis() < cooldownEndtime) {\n      logger.debug(\"False: It's cooldown time for application \" + appId + \". No scaling in action.\");\n      return false;\n    }\n  }\n  return true;\n}", "comment": "checks if the app should be scaled in / out according to cooldown settings", "label": "what"}
{"id": "35715", "raw_code": "public void show(Animation anim){\n  mAnim=anim;\n  show();\n}", "comment": "starts the animation given as parameter .", "label": "what"}
{"id": "83", "raw_code": "public static boolean isUriKey(String key){\n  return key.endsWith(\".url\") || key.endsWith(\".uri\");\n}", "comment": "this method determines if the supplied key relates to a uri .", "label": "what"}
{"id": "17408", "raw_code": "public int receive(byte[] buffer,int offset,int count,int timeout){\n  checkArrayBounds(buffer,offset,count);\n  if (count == 0) {\n    return 0;\n  }\n  byte[] data=buffer;\n  if (offset > 0) {\n    data=new byte[count];\n  }\n  IntOut bytesReceivedOut=new IntOut();\n  try {\n    IDevice.checkResult(LibIMobileDevice.idevice_connection_receive_timeout(getRef(),data,count,bytesReceivedOut,timeout));\n    int bytesRead=bytesReceivedOut.getValue();\n    if (bytesRead > 0 && data != buffer) {\n      System.arraycopy(data,0,buffer,offset,bytesRead);\n    }\n    return bytesRead;\n  }\n  finally {\n    bytesReceivedOut.delete();\n  }\n}", "comment": "receives data from the device .", "label": "what"}
{"id": "57168", "raw_code": "public synchronized void addOFChannelHandlerAndSendRole(OFChannelHandler h){\n  connectedChannelHandlers.add(h);\n  h.sendRoleRequest(this.role);\n}", "comment": "add a newly connected ofchannelhandler .", "label": "what"}
{"id": "34299", "raw_code": "public boolean send(byte[] bytes){\n  if (!connected)   return false;\n  try {\n    outputStream.write(bytes);\n    outputStream.flush();\n    return true;\n  }\n catch (  IOException e) {\n    connected=false;\n    Log.e(TAG,\"Fail to send data\");\n    return false;\n  }\n finally {\n    if (!connected) {\n      closeConnection();\n    }\n  }\n}", "comment": "send array of bytes to bluetooth output stream .", "label": "what"}
{"id": "62752", "raw_code": "private byte[] entityToBytes(HttpEntity entity) throws IOException, ServerError {\n  PoolingByteArrayOutputStream bytes=new PoolingByteArrayOutputStream(mPool,(int)entity.getContentLength());\n  byte[] buffer=null;\n  try {\n    InputStream in=entity.getContent();\n    if (in == null) {\n      throw new ServerError();\n    }\n    buffer=mPool.getBuf(1024);\n    int count;\n    while ((count=in.read(buffer)) != -1) {\n      bytes.write(buffer,0,count);\n    }\n    return bytes.toByteArray();\n  }\n  finally {\n    try {\n      entity.consumeContent();\n    }\n catch (    IOException e) {\n      VolleyLog.v(\"Error occured when calling consumingContent\");\n    }\n    mPool.returnBuf(buffer);\n    bytes.close();\n  }\n}", "comment": "reads the contents of httpentity into a byte [ ] .", "label": "what"}
{"id": "3501", "raw_code": "public void addTailArg(String arg){\n  _tailArgs.add(arg);\n}", "comment": "adds an arg after the command and any options .", "label": "what"}
{"id": "48857", "raw_code": "private String translateBytesToString(byte[] bytes,long format,Transferable localeTransferable) throws IOException {\n  Long lFormat=Long.valueOf(format);\n  String charset=getBestCharsetForTextFormat(lFormat,localeTransferable);\n  String eoln=(String)nativeEOLNs.get(lFormat);\n  Integer terminators=(Integer)nativeTerminators.get(lFormat);\n  int count;\n  if (terminators != null) {\n    int numTerminators=terminators.intValue();\n    search:     for (count=0; count < (bytes.length - numTerminators + 1); count+=numTerminators) {\n      for (int i=count; i < count + numTerminators; i++) {\n        if (bytes[i] != 0x0) {\n          continue search;\n        }\n      }\n      break search;\n    }\n  }\n else {\n    count=bytes.length;\n  }\n  String converted=new String(bytes,0,count,charset);\n  if (eoln != null) {\n    char[] buf=converted.toCharArray();\n    char[] eoln_arr=eoln.toCharArray();\n    converted=null;\n    int j=0;\n    boolean match;\n    for (int i=0; i < buf.length; ) {\n      if (i + eoln_arr.length > buf.length) {\n        buf[j++]=buf[i++];\n        continue;\n      }\n      match=true;\n      for (int k=0, l=i; k < eoln_arr.length; k++, l++) {\n        if (eoln_arr[k] != buf[l]) {\n          match=false;\n          break;\n        }\n      }\n      if (match) {\n        buf[j++]='\\n';\n        i+=eoln_arr.length;\n      }\n else {\n        buf[j++]=buf[i++];\n      }\n    }\n    converted=new String(buf,0,j);\n  }\n  return converted;\n}", "comment": "translating either a byte array or an inputstream into an string .", "label": "what"}
{"id": "42683", "raw_code": "public static Object deserialization(String filePath){\n  ObjectInputStream in=null;\n  try {\n    in=new ObjectInputStream(new FileInputStream(filePath));\n    Object o=in.readObject();\n    in.close();\n    return o;\n  }\n catch (  FileNotFoundException e) {\n    throw new RuntimeException(\"FileNotFoundException occurred. \",e);\n  }\ncatch (  ClassNotFoundException e) {\n    throw new RuntimeException(\"ClassNotFoundException occurred. \",e);\n  }\ncatch (  IOException e) {\n    throw new RuntimeException(\"IOException occurred. \",e);\n  }\n finally {\n    IOUtils.close(in);\n  }\n}", "comment": "deserialization object from file .", "label": "what"}
{"id": "25855", "raw_code": "private static boolean isMergedSegment(String segName){\n  if (segName.contains(\".\")) {\n    return true;\n  }\n  return false;\n}", "comment": "to check if the segment is merged or not .", "label": "what"}
{"id": "9063", "raw_code": "public void addEmojiconGroup(List<EaseEmojiconGroupEntity> groupEntitieList){\n  for (int i=0; i < groupEntitieList.size(); i++) {\n    EaseEmojiconGroupEntity groupEntity=groupEntitieList.get(i);\n    emojiconGroupList.add(groupEntity);\n    pagerView.addEmojiconGroup(groupEntity,i == groupEntitieList.size() - 1 ? true : false);\n    tabBar.addTab(groupEntity.getIcon());\n  }\n}", "comment": "add emojicon group list", "label": "what"}
{"id": "38905", "raw_code": "public void updateEnd(Logger log){\n  m_instanceCount++;\n  m_sampleCount++;\n  double end=System.currentTimeMillis();\n  double temp=end - m_updateStart;\n  m_cumulativeTime+=temp;\n  boolean toFastToMeasure=false;\n  if ((end - m_startTime) >= m_sampleTime) {\n    computeUpdate(end);\n    if (log != null) {\n      log.statusMessage(m_statusMessagePrefix + \"Processed \" + m_instanceCount+ \" insts @ \"+ m_avInstsPerSec / m_numSamples + \" insts/sec\" + (toFastToMeasure ? \"*\" : \"\"));\n    }\n    m_sampleCount=0;\n    m_cumulativeTime=0;\n    m_startTime=System.currentTimeMillis();\n  }\n}", "comment": "register a throughput measurement end point .", "label": "what"}
{"id": "72739", "raw_code": "public boolean shouldInclude(final Path path){\n  return includeMatchers.size() == 0 || matches(path,includeMatchers);\n}", "comment": "check whether a path should be included .", "label": "what"}
{"id": "70405", "raw_code": "public ArrayList<MechSummary> generateUnits(int num,UnitFilter filter){\n  ArrayList<MechSummary> retVal=new ArrayList<>();\n  for (int i=0; i < num; i++) {\n    MechSummary ms=generateUnit(filter);\n    if (ms != null) {\n      retVal.add(ms);\n    }\n  }\n  return retVal;\n}", "comment": "selects a number of units from the table with a filter .", "label": "what"}
{"id": "38080", "raw_code": "protected void adjustCanopies(double[] densities){\n  if (m_numClustersRequested < 0) {\n    assignCanopiesToCanopyCenters();\n    m_trainingData=new Instances(m_canopies,0);\n    return;\n  }\n  if (m_canopies.numInstances() > m_numClustersRequested) {\n    int[] sortedIndexes=Utils.stableSort(densities);\n    Instances finalCanopies=new Instances(m_canopies,0);\n    int count=0;\n    for (int i=sortedIndexes.length - 1; count < m_numClustersRequested; i--) {\n      finalCanopies.add(m_canopies.instance(sortedIndexes[i]));\n      count++;\n    }\n    m_canopies=finalCanopies;\n    List<double[][]> tempCanopyCenters=new ArrayList<double[][]>();\n    List<double[]> tempT2Dists=new ArrayList<double[]>();\n    List<double[]> tempMissings=new ArrayList<double[]>();\n    count=0;\n    for (int i=sortedIndexes.length - 1; count < finalCanopies.numInstances(); i--) {\n      tempCanopyCenters.add(m_canopyCenters.get(sortedIndexes[i]));\n      tempT2Dists.add(m_canopyT2Density.get(sortedIndexes[i]));\n      tempMissings.add(m_canopyNumMissingForNumerics.get(sortedIndexes[i]));\n      count++;\n    }\n    m_canopyCenters=tempCanopyCenters;\n    m_canopyT2Density=tempT2Dists;\n    m_canopyNumMissingForNumerics=tempMissings;\n  }\n else   if (m_canopies.numInstances() < m_numClustersRequested && m_trainingData != null && m_trainingData.numInstances() > 0) {\n    Random r=new Random(getSeed());\n    for (int i=0; i < 10; i++) {\n      r.nextInt();\n    }\n    HashMap<DecisionTableHashKey,Integer> initC=new HashMap<DecisionTableHashKey,Integer>();\n    DecisionTableHashKey hk=null;\n    for (int i=0; i < m_canopies.numInstances(); i++) {\n      try {\n        hk=new DecisionTableHashKey(m_canopies.instance(i),m_canopies.numAttributes(),true);\n        initC.put(hk,null);\n      }\n catch (      Exception e) {\n        e.printStackTrace();\n      }\n    }\n    for (int j=m_trainingData.numInstances() - 1; j >= 0; j--) {\n      int instIndex=r.nextInt(j + 1);\n      try {\n        hk=new DecisionTableHashKey(m_trainingData.instance(instIndex),m_trainingData.numAttributes(),true);\n      }\n catch (      Exception e) {\n        e.printStackTrace();\n      }\n      if (!initC.containsKey(hk)) {\n        Instance newInstance=m_trainingData.instance(instIndex);\n        m_canopies.add(newInstance);\n        double[] density=new double[1];\n        density[0]=1.0;\n        m_canopyT2Density.add(density);\n        double[][] center=new double[newInstance.numAttributes()][0];\n        double[] numMissingNumerics=new double[newInstance.numAttributes()];\n        updateCanopyCenter(newInstance,center,numMissingNumerics);\n        m_canopyCenters.add(center);\n        m_canopyNumMissingForNumerics.add(numMissingNumerics);\n        initC.put(hk,null);\n      }\n      m_trainingData.swap(j,instIndex);\n      if (m_canopies.numInstances() == m_numClustersRequested) {\n        break;\n      }\n    }\n  }\n  assignCanopiesToCanopyCenters();\n  m_trainingData=new Instances(m_canopies,0);\n}", "comment": "adjust the final number of canopies to match the user - requested number ( if possible )", "label": "what"}
{"id": "67801", "raw_code": "protected void createFromHValues(int[] hValues,int partitions){\n  Arrays.sort(hValues);\n  this.splits=new int[partitions];\n  int maxH=0x7fffffff;\n  for (int i=0; i < splits.length; i++) {\n    int quantile=(int)((long)(i + 1) * hValues.length / partitions);\n    this.splits[i]=quantile == hValues.length ? maxH : hValues[quantile];\n  }\n}", "comment": "create a hilbertcurvepartitioner from a list of points", "label": "what"}
{"id": "16063", "raw_code": "private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n  iInstant=(LocalDateTime)oos.readObject();\n  DateTimeFieldType type=(DateTimeFieldType)oos.readObject();\n  iField=type.getField(iInstant.getChronology());\n}", "comment": "reads the property from a safe serialization format .", "label": "what"}
{"id": "44642", "raw_code": "public byte readByte() throws IOException {\n  return dis.readByte();\n}", "comment": "read a byte from the input stream .", "label": "what"}
{"id": "55244", "raw_code": "public boolean isEmoteIgnored(Emoticon emote){\n  return ignoredEmotes.contains(emote.code);\n}", "comment": "check if the given emote is on the list of ignored emotes .", "label": "what"}
{"id": "74479", "raw_code": "@SuppressWarnings(\"unchecked\") public void readFile(String fileName) throws JDOMException, IOException {\n  if (checkFile(fileName)) {\n    Element root=rootFromName(fileName);\n    Element roster;\n    if (root == null) {\n      log.warn(\"consist file could not be read\");\n      return;\n    }\n    roster=root.getChild(\"roster\");\n    if (roster == null) {\n      log.debug(\"consist file does not contain a roster entry\");\n      return;\n    }\n    Iterator<Element> consistIterator=root.getDescendants(new ElementFilter(\"consist\"));\n    try {\n      Element consist;\n      do {\n        consist=consistIterator.next();\n        consistFromXml(consist);\n      }\n while (consistIterator.hasNext());\n    }\n catch (    NoSuchElementException nde) {\n      log.debug(\"end of consist list\");\n    }\n  }\n else {\n    log.info(\"Consist file does not exist.  One will be created if necessary.\");\n  }\n}", "comment": "read all consists from a file .", "label": "what"}
{"id": "48714", "raw_code": "private int accept(FileDescriptor ssfd,FileDescriptor newfd,InetSocketAddress[] isaa) throws IOException {\n  return accept0(ssfd,newfd,isaa);\n}", "comment": "accept a connection on a socket .", "label": "what"}
{"id": "64524", "raw_code": "private void reportProgress(State state,InnerState innerState){\n  long now=System.currentTimeMillis();\n  if (innerState.mBytesSoFar - innerState.mBytesNotified > Constants.MIN_PROGRESS_STEP && now - innerState.mTimeLastNotification > Constants.MIN_PROGRESS_TIME) {\n    mInfo.mCurrentBytes=innerState.mBytesSoFar;\n    mDB.updateDownloadCurrentBytes(mInfo);\n    innerState.mBytesNotified=innerState.mBytesSoFar;\n    innerState.mTimeLastNotification=now;\n    long totalBytesSoFar=innerState.mBytesThisSession + mService.mBytesSoFar;\n    if (Constants.LOGVV) {\n      Log.v(Constants.TAG,\"downloaded \" + mInfo.mCurrentBytes + \" out of \"+ mInfo.mTotalBytes);\n      Log.v(Constants.TAG,\"     total \" + totalBytesSoFar + \" out of \"+ mService.mTotalLength);\n    }\n    mService.notifyUpdateBytes(totalBytesSoFar);\n  }\n}", "comment": "report download progress through the database if necessary .", "label": "what"}
{"id": "13897", "raw_code": "public void handleTblRequestHandlerListButtonAddRequest(RequestInvocationEvent event) throws ModelControlException {\n  try {\n    Map values=getValues();\n    onBeforeSaveProfile(values);\n    setPageSessionAttribute(PROPERTY_ATTRIBUTE,(HashMap)values);\n    SCSAML2SOAPBindingRequestHandlerListAddViewBean vb=(SCSAML2SOAPBindingRequestHandlerListAddViewBean)getViewBean(SCSAML2SOAPBindingRequestHandlerListAddViewBean.class);\n    unlockPageTrail();\n    passPgSessionMap(vb);\n    vb.forwardTo(getRequestContext());\n  }\n catch (  AMConsoleException e) {\n    setInlineAlertMessage(CCAlert.TYPE_ERROR,\"message.error\",e.getMessage());\n  }\n}", "comment": "handles add request handler request .", "label": "what"}
{"id": "3161", "raw_code": "static Field findField(Object instance,String name) throws NoSuchFieldException {\n  for (Class<?> clazz=instance.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n    try {\n      Field field=clazz.getDeclaredField(name);\n      if (!field.isAccessible()) {\n        field.setAccessible(true);\n      }\n      return field;\n    }\n catch (    NoSuchFieldException e) {\n    }\n  }\n  throw new NoSuchFieldException(\"Field \" + name + \" not found in \"+ instance.getClass());\n}", "comment": "locates a given field anywhere in the class inheritance hierarchy .", "label": "what"}
{"id": "60608", "raw_code": "SSLSession toSession(byte[] data,String host,int port){\n  ByteArrayInputStream bais=new ByteArrayInputStream(data);\n  DataInputStream dais=new DataInputStream(bais);\n  try {\n    int type=dais.readInt();\n    if (type != OPEN_SSL) {\n      log(new AssertionError(\"Unexpected type ID: \" + type));\n      return null;\n    }\n    int length=dais.readInt();\n    byte[] sessionData=new byte[length];\n    dais.readFully(sessionData);\n    int count=dais.readInt();\n    X509Certificate[] certs=new X509Certificate[count];\n    for (int i=0; i < count; i++) {\n      length=dais.readInt();\n      byte[] certData=new byte[length];\n      dais.readFully(certData);\n      certs[i]=OpenSSLX509Certificate.fromX509Der(certData);\n    }\n    return new OpenSSLSessionImpl(sessionData,host,port,certs,this);\n  }\n catch (  IOException e) {\n    log(e);\n    return null;\n  }\n}", "comment": "creates a session from the given bytes .", "label": "what"}
{"id": "85177", "raw_code": "public boolean isPageInRange(int pageNumber){\n  for (int ind=0; ind < sequenceStarts.size(); ind++) {\n    if (sequenceStarts.get(ind) <= pageNumber && pageNumber <= sequenceEnds.get(ind))     return true;\n  }\n  return false;\n}", "comment": "checks if a given page is present in the range built so far .", "label": "what"}
{"id": "49864", "raw_code": "public void dispose(){\n  logDebug(\"Disposing.\");\n  mSetupDone=false;\n  if (mServiceConn != null) {\n    logDebug(\"Unbinding from service.\");\n    if (mContext != null)     mContext.unbindService(mServiceConn);\n  }\n  mDisposed=true;\n  mContext=null;\n  mServiceConn=null;\n  mService=null;\n  mPurchaseListener=null;\n}", "comment": "dispose of object , releasing resources .", "label": "what"}
{"id": "56332", "raw_code": "public PutIndexTemplateRequest aliases(XContentBuilder source){\n  return aliases(source.bytes());\n}", "comment": "sets the aliases that will be associated with the index when it gets created", "label": "what"}
{"id": "6050", "raw_code": "void reclaimScrapViews(List<View> views){\n  if (mViewTypeCount == 1) {\n    views.addAll(mCurrentScrap);\n  }\n else {\n    final int viewTypeCount=mViewTypeCount;\n    final ArrayList<View>[] scrapViews=mScrapViews;\n    for (int i=0; i < viewTypeCount; ++i) {\n      final ArrayList<View> scrapPile=scrapViews[i];\n      views.addAll(scrapPile);\n    }\n  }\n}", "comment": "puts all views in the scrap heap into the supplied list .", "label": "what"}
{"id": "4024", "raw_code": "public boolean schedule(Runnable task,ClassLoader loader){\n  boolean isPriority=false;\n  boolean isQueue=true;\n  boolean isWake=true;\n  return scheduleImpl(task,loader,MAX_EXPIRE,isPriority,isQueue,isWake);\n}", "comment": "schedules a new task .", "label": "what"}
{"id": "47321", "raw_code": "public static <T>Stream<T> concat(Stream<? extends T> a,Stream<? extends T> b){\n  Objects.requireNonNull(a);\n  Objects.requireNonNull(b);\n  @SuppressWarnings(\"unchecked\") Spliterator<T> split=new Streams.ConcatSpliterator.OfRef<>((Spliterator<T>)a.spliterator(),(Spliterator<T>)b.spliterator());\n  Stream<T> stream=StreamSupport.stream(split,a.isParallel() || b.isParallel());\n  return stream.onClose(Streams.composedClose(a,b));\n}", "comment": "creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream .", "label": "what"}
{"id": "20146", "raw_code": "public static DataSourcePropertiesInterface decodeXML(Document document,String elementName){\n  if ((document == null) || (elementName == null)) {\n    return null;\n  }\n  Map<String,String> map=new LinkedHashMap<String,String>();\n  NodeList nodeList=document.getElementsByTagName(elementName);\n  if (nodeList.getLength() > 0) {\n    Node node=nodeList.item(0);\n    Node child=node.getFirstChild();\n    while (child != null) {\n      if (child.getNodeType() == Node.ELEMENT_NODE) {\n        map.put(child.getNodeName(),child.getTextContent());\n      }\n      child=child.getNextSibling();\n    }\n    return DataSourceConnectorFactory.getDataSourceProperties(map);\n  }\n else {\n    return DataSourceConnectorFactory.getNoDataSource();\n  }\n}", "comment": "decode the data source properties from xml .", "label": "what"}
{"id": "21680", "raw_code": "public List<URI> volumeURIs(List<URI> uris,boolean delete,boolean remediate,ValCk... checks){\n  List<URI> remediatedURIs=new ArrayList<URI>();\n  List<Volume> volumes=dbClient.queryObject(Volume.class,uris);\n  List<Volume> remediatedVolumes=volumes(volumes,delete,remediate,checks);\n  for (  Volume volume : remediatedVolumes) {\n    remediatedURIs.add(volume.getId());\n  }\n  return remediatedURIs;\n}", "comment": "validates a list of volumes", "label": "what"}
{"id": "47041", "raw_code": "private FormatString[] parse(String s){\n  ArrayList<FormatString> al=new ArrayList<>();\n  Matcher m=fsPattern.matcher(s);\n  for (int i=0, len=s.length(); i < len; ) {\n    if (m.find(i)) {\n      if (m.start() != i) {\n        checkText(s,i,m.start());\n        al.add(new FixedString(s.substring(i,m.start())));\n      }\n      al.add(new FormatSpecifier(m));\n      i=m.end();\n    }\n else {\n      checkText(s,i,len);\n      al.add(new FixedString(s.substring(i)));\n      break;\n    }\n  }\n  return al.toArray(new FormatString[al.size()]);\n}", "comment": "finds format specifiers in the format string .", "label": "what"}
{"id": "40929", "raw_code": "private void updateIndexColumnButtons(){\n  indexRemoveButton.setEnabled(false);\n  indexUpButton.setEnabled(false);\n  indexDownButton.setEnabled(false);\n  int index=selectedColumns.getSelectionIndex();\n  if (index >= 0) {\n    indexRemoveButton.setEnabled(true);\n    if (index > 0) {\n      indexUpButton.setEnabled(true);\n    }\n else     if (index < selectedColumns.getItemCount() - 1) {\n      indexDownButton.setEnabled(true);\n    }\n  }\n}", "comment": "updates status of index column up / down buttons .", "label": "what"}
{"id": "74820", "raw_code": "public void waitForDecodingToFinish(){\n  while (isDecoding) {\n    try {\n      Thread.sleep(100);\n    }\n catch (    final InterruptedException e) {\n      LogWriter.writeLog(\"Exception: \" + e.getMessage());\n      isDecoding=false;\n    }\n  }\n}", "comment": "wait for decoding to finish", "label": "what"}
{"id": "80373", "raw_code": "private static String wikiToPlainText(String content){\n  content=content.replaceAll(\"\\\\[\\\\[[iI]mage:[^\\\\]]*\\\\]\\\\]\",\"\");\n  content=content.replaceAll(\"(?s)<!--.*?-->\",\"\");\n  content=content.replaceAll(\"(?s)<ref>.*?</ref>\",\"\");\n  content=content.replaceAll(\"(?s)\\\\{\\\\{([^{}]*?\\\\{\\\\{[^{}]*?\\\\}\\\\})+[^{}].*?\\\\}\\\\}\",\"\");\n  content=content.replaceAll(\"(?s)\\\\{\\\\{.*?\\\\}\\\\}\",\"\");\n  content=content.replaceAll(\"(?s)\\\\{\\\\|.*?\\\\|\\\\}\",\"\");\n  content=content.replaceAll(\"\\\\[\\\\[[^\\\\]]*\\\\|\",\"\");\n  content=content.replaceAll(\"\\\\[\\\\[\",\"\");\n  content=content.replaceAll(\"\\\\]\\\\]\",\"\");\n  content=content.replaceAll(\"(?s)<.*?>\",\"\");\n  content=content.trim();\n  final int size=content.length();\n  int endOfFirstParagraph=content.indexOf(\"\\n\",50);\n  if (endOfFirstParagraph < 0) {\n    endOfFirstParagraph=size;\n  }\n  content=content.substring(0,Math.min(endOfFirstParagraph,1024));\n  return content;\n}", "comment": "extract plain text from wikipedia article content .", "label": "what"}
{"id": "17533", "raw_code": "public final byte[] update(byte[] input){\n  if (mode != ENCRYPT_MODE && mode != DECRYPT_MODE) {\n    throw new IllegalStateException();\n  }\n  if (input == null) {\n    throw new IllegalArgumentException(\"input == null\");\n  }\n  if (input.length == 0) {\n    return null;\n  }\n  return spiImpl.engineUpdate(input,0,input.length);\n}", "comment": "continues a multi - part transformation ( encryption or decryption ) .", "label": "what"}
{"id": "20040", "raw_code": "protected boolean display(File helpFile) throws HelpException {\n  if (helpFile.exists()) {\n    loadAndWrite(helpFile);\n    return true;\n  }\n else {\n    File notFound=new File(helpDir,NOT_FOUND);\n    if (notFound.exists())     loadAndWrite(notFound);\n else     throw new HelpException(\"Topic not found, try 'help' for more information\");\n    return false;\n  }\n}", "comment": "displays the requested help file if it is found .", "label": "what"}
{"id": "61691", "raw_code": "public static void storeLocation(Context context,LatLng location){\n  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);\n  SharedPreferences.Editor editor=prefs.edit();\n  editor.putLong(PREFERENCES_LAT,Double.doubleToRawLongBits(location.latitude));\n  editor.putLong(PREFERENCES_LNG,Double.doubleToRawLongBits(location.longitude));\n  editor.apply();\n}", "comment": "store the location in the app preferences .", "label": "what"}
{"id": "24407", "raw_code": "public static String rowToString(JSONArray ja){\n  StringBuffer sb=new StringBuffer();\n  for (int i=0; i < ja.length(); i+=1) {\n    if (i > 0) {\n      sb.append(',');\n    }\n    Object object=ja.opt(i);\n    if (object != null) {\n      String string=object.toString();\n      if (string.length() > 0 && (string.indexOf(',') >= 0 || string.indexOf('\\n') >= 0 || string.indexOf('\\r') >= 0 || string.indexOf(0) >= 0 || string.charAt(0) == '\"')) {\n        sb.append('\"');\n        int length=string.length();\n        for (int j=0; j < length; j+=1) {\n          char c=string.charAt(j);\n          if (c >= ' ' && c != '\"') {\n            sb.append(c);\n          }\n        }\n        sb.append('\"');\n      }\n else {\n        sb.append(string);\n      }\n    }\n  }\n  sb.append('\\n');\n  return sb.toString();\n}", "comment": "produce a comma delimited text row from a jsonarray .", "label": "what"}
{"id": "1202", "raw_code": "private static void removeTable(Connection conn,String name) throws SQLException {\n  name=name.replace('.','_');\n  Statement stat=conn.createStatement();\n  stat.execute(\"DROP TABLE \" + name);\n  DBUtil.commitEL(conn);\n}", "comment": "remove a table from the memory database", "label": "what"}
{"id": "22046", "raw_code": "public static boolean isVolumeFullCopySource(Volume volume,DbClient dbClient){\n  boolean isFullCopySource=false;\n  StringSet fullCopyIds=volume.getFullCopies();\n  if ((fullCopyIds != null) && (!fullCopyIds.isEmpty())) {\n    Iterator<String> fullCopyIdsIter=fullCopyIds.iterator();\n    while (fullCopyIdsIter.hasNext()) {\n      URI fullCopyURI=URI.create(fullCopyIdsIter.next());\n      Volume fullCopyVolume=dbClient.queryObject(Volume.class,fullCopyURI);\n      if ((fullCopyVolume != null) && (!fullCopyVolume.getInactive())) {\n        isFullCopySource=true;\n      }\n    }\n  }\n  return isFullCopySource;\n}", "comment": "determine if the passed volume is a source volume for any full copies .", "label": "what"}
{"id": "26326", "raw_code": "public static Map<String,Object> entityMaintPermCheck(DispatchContext dctx,Map<String,? extends Object> context){\n  GenericValue userLogin=(GenericValue)context.get(\"userLogin\");\n  Locale locale=(Locale)context.get(\"locale\");\n  Security security=dctx.getSecurity();\n  Map<String,Object> resultMap=null;\n  if (security.hasPermission(\"ENTITY_MAINT\",userLogin)) {\n    resultMap=ServiceUtil.returnSuccess();\n    resultMap.put(\"hasPermission\",true);\n  }\n else {\n    resultMap=ServiceUtil.returnFailure(UtilProperties.getMessage(resource,\"WebtoolsPermissionError\",locale));\n    resultMap.put(\"hasPermission\",false);\n  }\n  return resultMap;\n}", "comment": "performs an entity maintenance security check .", "label": "what"}
{"id": "47605", "raw_code": "public int read(char cbuf[],int offset,int length) throws IOException {\n  return sd.read(cbuf,offset,length);\n}", "comment": "reads characters into a portion of an array .", "label": "what"}
{"id": "46982", "raw_code": "public int read() throws IOException {\n  int val;\n  if ((val=is.read()) < 0) {\n    return -1;\n  }\nswitch (val & 0xf0) {\ncase 0xc0:\ncase 0xd0:\n    val=((val & 0x1f) << 6) | (is.read() & 0x3f);\n  break;\ncase 0xe0:\nval=((val & 0x0f) << 12) | ((is.read() & 0x3f) << 6) | (is.read() & 0x3f);\nbreak;\ncase 0xf0:\nthrow new UnsupportedEncodingException();\ndefault :\nbreak;\n}\nreturn val;\n}", "comment": "reads a single character .", "label": "what"}
{"id": "49936", "raw_code": "private boolean rContainsRMInstruction(ProgramBlock pb,String varName){\n  if (pb instanceof WhileProgramBlock) {\n    WhileProgramBlock tmp=(WhileProgramBlock)pb;\n    for (    ProgramBlock c : tmp.getChildBlocks())     if (rContainsRMInstruction(c,varName))     return true;\n  }\n else   if (pb instanceof IfProgramBlock) {\n    IfProgramBlock tmp=(IfProgramBlock)pb;\n    for (    ProgramBlock c : tmp.getChildBlocksIfBody())     if (rContainsRMInstruction(c,varName))     return true;\n    for (    ProgramBlock c : tmp.getChildBlocksElseBody())     if (rContainsRMInstruction(c,varName))     return true;\n  }\n else   if (pb instanceof ForProgramBlock) {\n    ForProgramBlock tmp=(ForProgramBlock)pb;\n    for (    ProgramBlock c : tmp.getChildBlocks())     if (rContainsRMInstruction(c,varName))     return true;\n  }\n else   if (pb instanceof FunctionProgramBlock) {\n  }\n else {\n    for (    Instruction inst : pb.getInstructions()) {\n      String instStr=inst.toString();\n      if (instStr.contains(\"rmfilevar\" + Lop.OPERAND_DELIMITOR + varName) || instStr.contains(\"rmvar\" + Lop.OPERAND_DELIMITOR + varName)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "comment": "determines if the given program block includes a rmvar or rmfilevar instruction for the given varname .", "label": "what"}
{"id": "23753", "raw_code": "public void waitForOperations(){\n  operator.waitForOperations();\n}", "comment": "wait for the bucket operator to complete any pending asynchronous operations .", "label": "what"}
{"id": "66616", "raw_code": "private static int byteCompaction(int mode,int[] codewords,int codeIndex,StringBuilder result){\n  if (mode == BYTE_COMPACTION_MODE_LATCH) {\n    int count=0;\n    long value=0;\n    char[] decodedData=new char[6];\n    int[] byteCompactedCodewords=new int[6];\n    boolean end=false;\n    int nextCode=codewords[codeIndex++];\n    while ((codeIndex < codewords[0]) && !end) {\n      byteCompactedCodewords[count++]=nextCode;\n      value=900 * value + nextCode;\n      nextCode=codewords[codeIndex++];\n      if (nextCode == TEXT_COMPACTION_MODE_LATCH || nextCode == BYTE_COMPACTION_MODE_LATCH || nextCode == NUMERIC_COMPACTION_MODE_LATCH || nextCode == BYTE_COMPACTION_MODE_LATCH_6 || nextCode == BEGIN_MACRO_PDF417_CONTROL_BLOCK || nextCode == BEGIN_MACRO_PDF417_OPTIONAL_FIELD || nextCode == MACRO_PDF417_TERMINATOR) {\n        codeIndex--;\n        end=true;\n      }\n else {\n        if ((count % 5 == 0) && (count > 0)) {\n          for (int j=0; j < 6; ++j) {\n            decodedData[5 - j]=(char)(value % 256);\n            value>>=8;\n          }\n          result.append(decodedData);\n          count=0;\n        }\n      }\n    }\n    if (codeIndex == codewords[0] && nextCode < TEXT_COMPACTION_MODE_LATCH) {\n      byteCompactedCodewords[count++]=nextCode;\n    }\n    for (int i=0; i < count; i++) {\n      result.append((char)byteCompactedCodewords[i]);\n    }\n  }\n else   if (mode == BYTE_COMPACTION_MODE_LATCH_6) {\n    int count=0;\n    long value=0;\n    boolean end=false;\n    while (codeIndex < codewords[0] && !end) {\n      int code=codewords[codeIndex++];\n      if (code < TEXT_COMPACTION_MODE_LATCH) {\n        count++;\n        value=900 * value + code;\n      }\n else {\n        if (code == TEXT_COMPACTION_MODE_LATCH || code == BYTE_COMPACTION_MODE_LATCH || code == NUMERIC_COMPACTION_MODE_LATCH || code == BYTE_COMPACTION_MODE_LATCH_6 || code == BEGIN_MACRO_PDF417_CONTROL_BLOCK || code == BEGIN_MACRO_PDF417_OPTIONAL_FIELD || code == MACRO_PDF417_TERMINATOR) {\n          codeIndex--;\n          end=true;\n        }\n      }\n      if ((count % 5 == 0) && (count > 0)) {\n        char[] decodedData=new char[6];\n        for (int j=0; j < 6; ++j) {\n          decodedData[5 - j]=(char)(value & 0xFF);\n          value>>=8;\n        }\n        result.append(decodedData);\n        count=0;\n      }\n    }\n  }\n  return codeIndex;\n}", "comment": "byte compaction mode ( see 5 . 4 . 3 ) permits all 256 possible 8 - bit byte values to be encoded .", "label": "what"}
{"id": "39969", "raw_code": "private Object createInner(SimpleObject post,RequestContext context) throws ResponseException {\n  try {\n    String xml=completeXform(convertUuidsToIds(post));\n    File file=File.createTempFile(\"projectbuendia\",null);\n    processor.processXForm(xml,file.getAbsolutePath(),true,context.getRequest());\n  }\n catch (  IOException e) {\n    throw new GenericRestException(\"Error storing xform data\",e);\n  }\ncatch (  ResponseException e) {\n    throw e;\n  }\ncatch (  Exception e) {\n    throw new ConversionException(\"Error processing xform data\",e);\n  }\n  Encounter encounter=guessEncounterFromXformSubmission(post);\n  if (encounter == null) {\n    return post;\n  }\n  SimpleObject returnJson=new SimpleObject();\n  EncounterResource.populateJsonProperties(encounter,returnJson);\n  return returnJson;\n}", "comment": "accepts a submitted form instance .", "label": "what"}
{"id": "12021", "raw_code": "public Endpoint(URI endpointUrl,SecurityMode... modes){\n  if (modes == null || endpointUrl == null)   throw new IllegalArgumentException(\"null arg\");\n  for (  SecurityMode m : modes) {\n    if (m == null)     throw new IllegalArgumentException(\"null arg\");\n    hash=13 * hash + m.hashCode();\n  }\n  this.endpointUrl=endpointUrl.toString();\n  this.modes=modes;\n  this.endpointConfiguration=EndpointConfiguration.defaults();\n  hash=13 * hash + endpointUrl.hashCode();\n}", "comment": "create a new endpoint .", "label": "what"}
{"id": "43977", "raw_code": "protected Value parseValue() throws IOException, RDFParseException, RDFHandlerException {\n  int c=peekCodePoint();\n  if (c == '<') {\n    return parseURI();\n  }\n else   if (c == ':' || TurtleUtil.isPrefixStartChar(c)) {\n    return parseQNameOrBoolean();\n  }\n else   if (c == '_') {\n    return parseNodeID();\n  }\n else   if (c == '\"' || c == '\\'') {\n    return parseQuotedLiteral();\n  }\n else   if (ASCIIUtil.isNumber(c) || c == '.' || c == '+' || c == '-') {\n    return parseNumber();\n  }\n else   if (c == -1) {\n    throwEOFException();\n    return null;\n  }\n else {\n    reportFatalError(\"Expected an RDF value here, found '\" + new String(Character.toChars(c)) + \"'\");\n    return null;\n  }\n}", "comment": "parses an rdf value .", "label": "what"}
{"id": "7913", "raw_code": "public TimeSeriesCollection(){\n  this(null,TimeZone.getDefault());\n}", "comment": "constructs an empty dataset , tied to the default timezone .", "label": "what"}
{"id": "5002", "raw_code": "public void fill_ellipse_arr(PlaEllipse[] p_ellipse_arr,Graphics p_g,Color p_color,double p_translucency_factor){\n  if (p_color == null)   return;\n  if (p_ellipse_arr.length <= 0)   return;\n  GeneralPath draw_path=new GeneralPath(GeneralPath.WIND_EVEN_ODD);\n  for (  PlaEllipse curr_ellipse : p_ellipse_arr) {\n    Point2D center=coordinate_transform.board_to_screen(curr_ellipse.center);\n    double bigger_radius=coordinate_transform.board_to_screen(curr_ellipse.bigger_radius);\n    if (!point_near_rectangle(center.getX(),center.getY(),(Rectangle)p_g.getClip(),bigger_radius)) {\n      continue;\n    }\n    double smaller_radius=coordinate_transform.board_to_screen(curr_ellipse.smaller_radius);\n    Ellipse2D draw_ellipse=new Ellipse2D.Double(center.getX() - bigger_radius,center.getY() - smaller_radius,2 * bigger_radius,2 * smaller_radius);\n    double rotation=coordinate_transform.board_to_screen_angle(curr_ellipse.rotation);\n    AffineTransform affine_transform=new AffineTransform();\n    affine_transform.rotate(rotation,center.getX(),center.getY());\n    Shape rotated_ellipse=affine_transform.createTransformedShape(draw_ellipse);\n    draw_path.append(rotated_ellipse,false);\n  }\n  Graphics2D g2=(Graphics2D)p_g;\n  g2.setColor(p_color);\n  set_translucency(g2,p_translucency_factor);\n  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);\n  g2.fill(draw_path);\n}", "comment": "draws the interiour of an array of ellipses .", "label": "what"}
{"id": "20483", "raw_code": "private void refreshChallengeCounts(){\n  mDueChallengeCounts=mDueChallengeLogic.getDueChallengeCounts(mCategories);\n}", "comment": "reloads the due challenge counts from the database .", "label": "what"}
{"id": "68708", "raw_code": "public Identity(final int dim){\n  this(dim,EnumSet.noneOf(Address.Flags.class));\n}", "comment": "creates an identity matrix", "label": "what"}
{"id": "65738", "raw_code": "public void addTotals(Info_Column[] layout){\n  addTotals((ColumnInfo[])layout);\n}", "comment": "adding a new row with the totals", "label": "what"}
{"id": "5010", "raw_code": "private void fillStackTrace(StringBuffer buffer,StackTraceElement[] elements){\n  for (int index=0; index < elements.length; index++) {\n    buffer.append(elements[index]);\n    buffer.append(\"\\n\");\n  }\n}", "comment": "creates a printing stacktrace from the given elements .", "label": "what"}
{"id": "14127", "raw_code": "public void makeImmutable(){\n  if (isMutable) {\n    isMutable=false;\n  }\n}", "comment": "makes this object immutable .", "label": "what"}
{"id": "14566", "raw_code": "private AMSetupDSConfig(){\n  Map map=ServicesDefaultValues.getDefaultValues();\n  dsManager=(String)map.get(SetupConstants.CONFIG_VAR_DS_MGR_DN);\n  suffix=(String)map.get(SetupConstants.CONFIG_VAR_ROOT_SUFFIX);\n  dsHostName=(String)map.get(SetupConstants.CONFIG_VAR_DIRECTORY_SERVER_HOST);\n  dsPort=(String)map.get(SetupConstants.CONFIG_VAR_DIRECTORY_SERVER_PORT);\n  dsAdminPwd=(String)map.get(SetupConstants.CONFIG_VAR_DS_MGR_PWD);\n  basedir=(String)map.get(SetupConstants.CONFIG_VAR_BASE_DIR);\n  deployuri=(String)map.get(SetupConstants.CONFIG_VAR_SERVER_URI);\n}", "comment": "constructs a new instance .", "label": "what"}
{"id": "47080", "raw_code": "private boolean compareAndIncrementWorkerCount(int expect){\n  return ctl.compareAndSet(expect,expect + 1);\n}", "comment": "attempts to cas - increment the workercount field of ctl .", "label": "what"}
{"id": "61223", "raw_code": "Object processCHAR(StylesheetHandler handler,String uri,String name,String rawName,String value,ElemTemplateElement owner) throws org.xml.sax.SAXException {\n  if (getSupportsAVT()) {\n    try {\n      AVT avt=new AVT(handler,uri,name,rawName,value,owner);\n      if ((avt.isSimple()) && (value.length() != 1)) {\n        handleError(handler,XSLTErrorResources.INVALID_TCHAR,new Object[]{name,value},null);\n        return null;\n      }\n      return avt;\n    }\n catch (    TransformerException te) {\n      throw new org.xml.sax.SAXException(te);\n    }\n  }\n else {\n    if (value.length() != 1) {\n      handleError(handler,XSLTErrorResources.INVALID_TCHAR,new Object[]{name,value},null);\n      return null;\n    }\n    return new Character(value.charAt(0));\n  }\n}", "comment": "process an attribute string of type t _ char into a character value .", "label": "what"}
{"id": "26353", "raw_code": "public static Element addChildElementValue(Element element,String childElementName,String childElementValue,Document document){\n  Element newElement=addChildElement(element,childElementName,document);\n  newElement.appendChild(document.createTextNode(childElementValue));\n  return newElement;\n}", "comment": "creates a child element with the given name and appends it to the element child node list .", "label": "what"}
{"id": "83386", "raw_code": "public static byte[] readBinaryFile(File sourceFile){\n  byte[] result=null;\n  try {\n    BufferedInputStream input;\n    input=new BufferedInputStream(new FileInputStream(sourceFile));\n    int num=input.available();\n    result=new byte[num];\n    input.read(result,0,num);\n    input.close();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    result=null;\n  }\n  return result;\n}", "comment": "reads a binary input file into a byte array", "label": "what"}
{"id": "46353", "raw_code": "public void removeIndexInterval(int index0,int index1){\n  int rmMinIndex=Math.min(index0,index1);\n  int rmMaxIndex=Math.max(index0,index1);\n  int gapLength=(rmMaxIndex - rmMinIndex) + 1;\n  for (int i=rmMinIndex; i <= maxIndex; i++) {\n    setState(i,value.get(i + gapLength));\n  }\n  int leadIndex=this.leadIndex;\n  if (leadIndex == 0 && rmMinIndex == 0) {\n  }\n else   if (leadIndex > rmMaxIndex) {\n    leadIndex=this.leadIndex - gapLength;\n  }\n else   if (leadIndex >= rmMinIndex) {\n    leadIndex=rmMinIndex - 1;\n  }\n  int anchorIndex=this.anchorIndex;\n  if (anchorIndex == 0 && rmMinIndex == 0) {\n  }\n else   if (anchorIndex > rmMaxIndex) {\n    anchorIndex=this.anchorIndex - gapLength;\n  }\n else   if (anchorIndex >= rmMinIndex) {\n    anchorIndex=rmMinIndex - 1;\n  }\n  if (leadIndex != this.leadIndex || anchorIndex != this.anchorIndex) {\n    updateLeadAnchorIndices(anchorIndex,leadIndex);\n  }\n  fireValueChanged();\n}", "comment": "remove the indices in the interval index0 , index1 ( inclusive ) from the selection model .", "label": "what"}
{"id": "11583", "raw_code": "public void rebuildEventList(boolean resetSelected){\n  if (logger.isLoggable(Level.FINE)) {\n    logger.fine(\"rebuilding list\");\n  }\n  allEvents=null;\n  activeEvents=null;\n  hideDetails();\n  initInterface(getActiveEvents(),resetSelected);\n  highlightCurrentEvent(currentTime);\n  firePropertyChange(ActiveEventsProperty,null,getActiveEvents());\n}", "comment": "this is the method that rebuilds the list of visible events .", "label": "what"}
{"id": "23695", "raw_code": "public DiskStoreFactory createDiskStoreFactory(){\n  return new DiskStoreFactoryImpl(this);\n}", "comment": "create diskstore factory with default attributes", "label": "what"}
{"id": "52655", "raw_code": "public static boolean deleteDirectorySubdirectories(String rootDirectory){\n  if ((rootDirectory == null)) {\n    return false;\n  }\n  boolean didSuccessfullyDeleteAllDirectories=true;\n  try {\n    List<File> files=getListOfFilesInADirectory(rootDirectory);\n    for (    File file : files) {\n      if (file.isDirectory()) {\n        boolean deleteSuccess=deleteDirectoryAndContents(file);\n        if (!deleteSuccess) {\n          logger.debug(\"Warning - failed to delete \" + file.getAbsolutePath());\n          didSuccessfullyDeleteAllDirectories=false;\n        }\n      }\n    }\n  }\n catch (  Exception e) {\n    logger.debug(e.toString() + System.lineSeparator() + StackTrace.getStringFromStackTrace(e));\n    return false;\n  }\n  return didSuccessfullyDeleteAllDirectories;\n}", "comment": "this is a quiet method .", "label": "what"}
{"id": "67383", "raw_code": "public void put(byte[] buffer,int offset,int count){\n  if (count > (bytes.length - this.contentLength)) {\n    throw new IllegalArgumentException(\"buffer is too large\");\n  }\n  System.arraycopy(buffer,offset,bytes,this.contentLength,count);\n  this.contentLength+=count;\n}", "comment": "puts content from the specified byte array to this bytearray", "label": "what"}
{"id": "45912", "raw_code": "public static void registerDefaultResolvers(){\nsynchronized (resolverList) {\n    resolverList.add(new ResourceResolver(new ResolverFragment()));\n    resolverList.add(new ResourceResolver(new ResolverLocalFilesystem()));\n    resolverList.add(new ResourceResolver(new ResolverXPointer()));\n    resolverList.add(new ResourceResolver(new ResolverDirectHTTP()));\n  }\n}", "comment": "this method registers the default resolvers .", "label": "what"}
{"id": "79836", "raw_code": "private boolean processAuthenticationResponse(final HttpMethod method){\n  LOG.trace(\"enter HttpMethodBase.processAuthenticationResponse(\" + \"HttpState, HttpConnection)\");\n  try {\nswitch (method.getStatusCode()) {\ncase HttpStatus.SC_UNAUTHORIZED:\n      return processWWWAuthChallenge(method);\ncase HttpStatus.SC_PROXY_AUTHENTICATION_REQUIRED:\n    return processProxyAuthChallenge(method);\ndefault :\n  return false;\n}\n}\n catch (Exception e) {\nif (LOG.isErrorEnabled()) {\nLOG.error(e.getMessage(),e);\n}\nreturn false;\n}\n}", "comment": "processes a response that requires authentication", "label": "what"}
{"id": "67382", "raw_code": "private void release(ByteArray byteArray){\nsynchronized (syncRoot) {\n    if (availableByteArrays.size() >= maxAvailableArraysCount) {\n      return;\n    }\n    if (!availableByteArrays.contains(byteArray)) {\n      availableByteArrays.add(byteArray);\n    }\n  }\n}", "comment": "releases specified byte array", "label": "what"}
{"id": "39767", "raw_code": "private void init(){\n  acceptableMethods=new ArrayList<>();\n  acceptableMethods.add(new NoAuthenticationRequiredMethod());\n  acceptableMethods.add(new GssApiMethod());\n  acceptableMethods.add(new UsernamePasswordMethod());\n}", "comment": "constructs a socks5 instance without any parameter .", "label": "what"}
{"id": "21235", "raw_code": "private boolean lockOrder(Order order){\n  lock.lock();\n  try {\n    return activeOrders.add(order.getId());\n  }\n  finally {\n    lock.unlock();\n  }\n}", "comment": "attempts the lock the order .", "label": "what"}
{"id": "73617", "raw_code": "public static final void writeStringArrayXml(String[] val,String name,XmlSerializer out) throws XmlPullParserException, java.io.IOException {\n  if (val == null) {\n    out.startTag(null,\"null\");\n    out.endTag(null,\"null\");\n    return;\n  }\n  out.startTag(null,\"string-array\");\n  if (name != null) {\n    out.attribute(null,\"name\",name);\n  }\n  final int N=val.length;\n  out.attribute(null,\"num\",Integer.toString(N));\n  for (int i=0; i < N; i++) {\n    out.startTag(null,\"item\");\n    out.attribute(null,\"value\",val[i]);\n    out.endTag(null,\"item\");\n  }\n  out.endTag(null,\"string-array\");\n}", "comment": "flatten a string [ ] into an xmlserializer .", "label": "what"}
{"id": "35647", "raw_code": "private void unifyUsernameByName(Map<String,List<LogCommitInfo>> devNameMap){\n  for (  Entry<String,List<LogCommitInfo>> entry : devNameMap.entrySet()) {\n    List<String> userNames=getUserNamesList(entry.getValue());\n    if (userNames.size() > 1) {\n      String newUserName=getNewUserName(userNames);\n      for (      LogCommitInfo commit : entry.getValue()) {\n        commit.setUserName(newUserName);\n      }\n    }\n  }\n}", "comment": "treat similar name aliases", "label": "what"}
{"id": "86747", "raw_code": "public static byte[] readData(final URL url) throws IOException {\n  try (InputStream input=url.openStream()){\n    return readData(input);\n  }\n }", "comment": "reads all the data from the supplied url into a byte array .", "label": "what"}
{"id": "43467", "raw_code": "public static EnergyNetwork initNetwork(){\n  Random random=new Random(System.currentTimeMillis());\n  int id=random.nextInt();\n  while (usedIds.contains(id)) {\n    id=random.nextInt();\n  }\n  ;\n  EnergyNetwork net=new EnergyNetwork();\n  usedIds.add(id);\n  net.networkID=id;\n  return net;\n}", "comment": "create a new network and get an id", "label": "what"}
{"id": "51957", "raw_code": "private PendingIntent createRequestPendingIntent(@NonNull String pendingIntentClassName){\n  PendingIntent pendingIntent=null;\n  try {\n    Class classOfPendingIntent=Class.forName(pendingIntentClassName);\n    if (classOfPendingIntent != null) {\n      Intent intent=new Intent(mContext,classOfPendingIntent);\n      pendingIntent=PendingIntent.getService(mContext,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);\n    }\n  }\n catch (  ClassNotFoundException e) {\n    e.printStackTrace();\n  }\n  return pendingIntent;\n}", "comment": "create a pending intent from the storable fence", "label": "what"}
{"id": "15155", "raw_code": "protected int checkIPRange(){\n  int retVal=0;\n  String ipVersion;\n  String ipType;\n  Map<String,String> holdDetails;\n  for (  String nextIP : IPRangeRange) {\n    try {\n      holdDetails=checkIPVersion(nextIP);\n    }\n catch (    IllegalArgumentException e) {\n      if (debug.warningEnabled()) {\n        debug.warning(\"{}.checkIPRange: IP type could not be validated. IP={}\",ADAPTIVE,nextIP,e);\n      }\n      continue;\n    }\n    ipVersion=holdDetails.get(IP_Version);\n    ipType=holdDetails.get(IP_TYPE);\n    if (ipVersion.equalsIgnoreCase(IP_V6) && ValidateIPaddress.isIPv6(clientIP)) {\n      if (debug.messageEnabled()) {\n        debug.message(\"{}.checkIPRange: {} --> {}\",ADAPTIVE,clientIP,nextIP);\n        debug.message(\"IP version is: {}\",IP_V6);\n        debug.message(\"Client IP is: {}\",IPv6Address.fromString(clientIP));\n      }\n      if (ipType.equalsIgnoreCase(\"Range\")) {\n        String first=holdDetails.get(IP_START);\n        String last=holdDetails.get(IP_END);\n        IPv6AddressRange iPv6AddressRange=IPv6AddressRange.fromFirstAndLast(IPv6Address.fromString(first),IPv6Address.fromString(last));\n        if (iPv6AddressRange.contains(IPv6Address.fromString(clientIP))) {\n          retVal=IPRangeScore;\n          break;\n        }\n      }\n else       if (ipType.equalsIgnoreCase(\"CIDR\")) {\n        IPv6Network iPv6Network=IPv6Network.fromString(nextIP);\n        if (iPv6Network.contains(IPv6Address.fromString(clientIP))) {\n          retVal=IPRangeScore;\n          break;\n        }\n      }\n else {\n        IPv6Address iPv6AddressNextIP=IPv6Address.fromString(nextIP);\n        if (iPv6AddressNextIP.compareTo(IPv6Address.fromString(clientIP)) == 0) {\n          retVal=IPRangeScore;\n          break;\n        }\n      }\n    }\n else     if (ipVersion.equalsIgnoreCase(IP_V4) && ValidateIPaddress.isIPv4(clientIP)) {\n      if (debug.messageEnabled()) {\n        debug.message(\"{}.checkIPRange: {} --> {}\",ADAPTIVE,clientIP,nextIP);\n        debug.message(\"IP version is: {}\",IP_V4);\n        debug.message(\"Client IP is: {}\",clientIP);\n      }\n      IPRange theRange=new IPRange(nextIP);\n      if (theRange.inRange(clientIP)) {\n        retVal=IPRangeScore;\n        break;\n      }\n    }\n  }\n  if (!IPRangeInvert) {\n    retVal=IPRangeScore - retVal;\n  }\n  return retVal;\n}", "comment": "check to see if the ip address is within the ranges specified range can be in the form of : x . x . x . x / yy or x . x . x . x - y . y . y . y .", "label": "what"}
{"id": "19568", "raw_code": "private static Field findField(Object instance,String name) throws NoSuchFieldException {\n  for (Class<?> clazz=instance.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n    try {\n      Field field=clazz.getDeclaredField(name);\n      if (!field.isAccessible()) {\n        field.setAccessible(true);\n      }\n      return field;\n    }\n catch (    NoSuchFieldException e) {\n    }\n  }\n  throw new NoSuchFieldException(\"Field \" + name + \" not found in \"+ instance.getClass());\n}", "comment": "locates a given field anywhere in the class inheritance hierarchy .", "label": "what"}
{"id": "15402", "raw_code": "private void injectContent(Inject injectContent) throws IOException, MojoExecutionException {\n  Map<Pattern,File> contents=getContentsMap(injectContent.getContents());\n  File tmpFile=ioFactory.createTemporaryFile(injectContent.getDestinationFile());\n  BufferedReader reader=null;\n  BufferedWriter writer=null;\n  try {\n    reader=ioFactory.newReader(injectContent.getDestinationFile());\n    writer=ioFactory.newWriter(tmpFile);\n    String line;\n    while ((line=reader.readLine()) != null) {\n      File content=doesLineMatchId(contents,line);\n      if (content != null) {\n        ioFactory.writeContent(writer,content,getContentConverter(injectContent));\n      }\n else {\n        ioFactory.writeLine(writer,line);\n      }\n    }\n  }\n  finally {\n    if (reader != null) {\n      reader.close();\n    }\n    if (writer != null) {\n      writer.flush();\n      writer.close();\n    }\n  }\n  ioFactory.moveTo(tmpFile,injectContent.getDestinationFile());\n}", "comment": "injects the configured content files into the destination file .", "label": "what"}
{"id": "79412", "raw_code": "public static <E>boolean isEmpty(CharSequence c){\n  return (c == null) || c.length() == 0;\n}", "comment": "check whether charsequence c is empty .", "label": "what"}
{"id": "30853", "raw_code": "private MarshalledWrapper lookupDo(Template tmpl){\n  if (isEmpty(tmpl.serviceTypes) || tmpl.serviceID != null) {\n    ItemIter iter=matchingItems(tmpl);\n    if (iter.hasNext())     return iter.next().service;\n    return null;\n  }\n  List services=matchingServices(tmpl.serviceTypes);\n  long now=System.currentTimeMillis();\n  int slen=services.size();\n  if (slen == 0)   return null;\n  int srand=Math.abs(random.nextInt() % slen);\n  for (int i=0; i < slen; i++) {\n    SvcReg reg=(SvcReg)services.get((i + srand) % slen);\n    if (reg.leaseExpiration > now && matchAttributes(tmpl,reg.item))     return reg.item.service;\n  }\n  return null;\n}", "comment": "the code that does the real work of lookup .", "label": "what"}
{"id": "52392", "raw_code": "String generateKey() throws OracleException {\n  byte[] data=null;\n  try {\n    data=HashFuncs.getRandom();\n  }\n catch (  Exception e) {\n    if (OracleLog.isLoggingEnabled())     log.warning(e.toString());\n  }\n  if (data == null) {\n    data=fetchGuid();\n  }\n  if (data == null) {\n    throw SODAUtils.makeException(SODAMessage.EX_UNABLE_TO_CREATE_UUID);\n  }\n  return (ByteArray.rawToHex(data));\n}", "comment": "generate a uuid key string", "label": "what"}
{"id": "9371", "raw_code": "public double[] arrayCopy(){\n  double[] array=new double[length()];\n  for (  IndexValue iv : this)   array[iv.getIndex()]=iv.getValue();\n  return array;\n}", "comment": "creates a new array that contains all the values of this vector in the appropriate indices", "label": "what"}
{"id": "85491", "raw_code": "private static boolean parse(Class<?> service,URL u) throws ServiceConfigurationError {\n  InputStream in=null;\n  BufferedReader r=null;\n  try {\n    in=u.openStream();\n    r=new BufferedReader(new InputStreamReader(in,\"utf-8\"));\n    int lc=1;\n    String ln;\n    while ((ln=r.readLine()) != null) {\n      int ci=ln.indexOf('#');\n      if (ci >= 0)       ln=ln.substring(0,ci);\n      ln=ln.trim();\n      int n=ln.length();\n      if (n != 0) {\n        if ((ln.indexOf(' ') >= 0) || (ln.indexOf('\\t') >= 0))         fail(service,u,lc,\"Illegal configuration-file syntax\");\n        int cp=ln.codePointAt(0);\n        if (!Character.isJavaIdentifierStart(cp))         fail(service,u,lc,\"Illegal provider-class name: \" + ln);\n        for (int i=Character.charCount(cp); i < n; i+=Character.charCount(cp)) {\n          cp=ln.codePointAt(i);\n          if (!Character.isJavaIdentifierPart(cp) && (cp != '.'))           fail(service,u,lc,\"Illegal provider-class name: \" + ln);\n        }\n        return true;\n      }\n    }\n  }\n catch (  FileNotFoundException x) {\n    return false;\n  }\ncatch (  IOException x) {\n    fail(service,\": \" + x);\n  }\n finally {\n    try {\n      if (r != null)       r.close();\n    }\n catch (    IOException y) {\n      fail(service,\": \" + y);\n    }\n    try {\n      if (in != null)       in.close();\n    }\n catch (    IOException y) {\n      fail(service,\": \" + y);\n    }\n  }\n  return false;\n}", "comment": "parse the content of the given url as a provider - configuration file .", "label": "what"}
{"id": "51825", "raw_code": "private void initPattern(){\n  StringBuffer patternTemplateRegex=new StringBuffer();\n  logger.debug(\"Get placeholder matcher\");\n  Matcher placeholderMatcher=getPlaceholderMatcher();\n  logger.debug(\"Replace all placeholder with regex group capture\");\n  while (placeholderMatcher.find()) {\n    String group=placeholderMatcher.group(1);\n    if (!groups.contains(group)) {\n      logger.trace(\"New group found, add it, replace with a capture group\");\n      groups.add(group);\n      String groupRegex=getGroupRegex(group);\n      placeholderMatcher.appendReplacement(patternTemplateRegex,Matcher.quoteReplacement(\"(?<\" + group + \">\"+ groupRegex+ \")\"));\n    }\n else {\n      logger.trace(\"Existing group found, replace with a back reference\");\n      placeholderMatcher.appendReplacement(patternTemplateRegex,Matcher.quoteReplacement(\"\\\\k<\" + group + \">\"));\n    }\n  }\n  placeholderMatcher.appendTail(patternTemplateRegex);\n  String patternRegex=patternTemplateRegex.toString();\n  logger.debug(\"pattern:\" + patternRegex);\n  pattern=Pattern.compile(patternRegex);\n}", "comment": "initialize the pattern to match files .", "label": "what"}
{"id": "74326", "raw_code": "protected void newLine(PrintWriter file,String string,boolean isManifest){\n  String[] lines=string.split(NEW_LINE);\n  for (  String line : lines) {\n    String[] words=line.split(SPACE);\n    StringBuffer sb=new StringBuffer();\n    for (    String word : words) {\n      if (checkStringLength(sb.toString() + word,isManifest)) {\n        sb.append(word + SPACE);\n      }\n else {\n        sb.setLength(sb.length() - 1);\n        addLine(file,sb.toString());\n        sb=new StringBuffer(word + SPACE);\n      }\n    }\n    if (sb.length() > 0) {\n      sb.setLength(sb.length() - 1);\n    }\n    addLine(file,sb.toString());\n  }\n}", "comment": "writes a string to a file .", "label": "what"}
{"id": "57130", "raw_code": "protected boolean updateAttachmentPoint(){\n  boolean moved=false;\n  this.oldAPs=attachmentPoints;\n  if (attachmentPoints == null || attachmentPoints.isEmpty())   return false;\n  List<AttachmentPoint> apList=new ArrayList<AttachmentPoint>();\n  if (attachmentPoints != null)   apList.addAll(attachmentPoints);\n  Map<Long,AttachmentPoint> newMap=getAPMap(apList);\n  if (newMap == null || newMap.size() != apList.size()) {\n    moved=true;\n  }\n  if (moved) {\n    log.info(\"updateAttachmentPoint: ap {}  newmap {} \",attachmentPoints,newMap);\n    List<AttachmentPoint> newAPList=new ArrayList<AttachmentPoint>();\n    if (newMap != null)     newAPList.addAll(newMap.values());\n    this.attachmentPoints=newAPList;\n  }\n  return moved;\n}", "comment": "update the known attachment points .", "label": "what"}
{"id": "60471", "raw_code": "public List<SoftWrapImpl> removeStartingFrom(int offset){\n  int startIndex=getSoftWrapIndex(offset);\n  if (startIndex < 0) {\n    startIndex=-startIndex - 1;\n  }\n  if (startIndex >= myWraps.size()) {\n    return Collections.emptyList();\n  }\n  List<SoftWrapImpl> tail=myWraps.subList(startIndex,myWraps.size());\n  List<SoftWrapImpl> result=new ArrayList<SoftWrapImpl>(tail);\n  tail.clear();\n  return result;\n}", "comment": "removes soft wraps with offsets equal or larger than a given offset from storage .", "label": "what"}
{"id": "43146", "raw_code": "public static String formatDps(final double dps){\n  return \"(\" + String.format(\"%.2f\",dps) + \" dps)\";\n}", "comment": "formats given dps ( = damage per second ) to a readable string .", "label": "what"}
{"id": "10218", "raw_code": "public static String truncate(String string,int length){\n  if (string.length() > length) {\n    string=string.substring(0,length);\n  }\n  return string;\n}", "comment": "sets the maximum length of the string .", "label": "what"}
{"id": "64300", "raw_code": "private boolean checkDisband(Legion legion){\n  if (legion.isDisbanding()) {\n    if ((System.currentTimeMillis() / 1000) > legion.getDisbandTime()) {\n      disbandLegion(legion);\n      return true;\n    }\n  }\n  return false;\n}", "comment": "method that checks if a legion is disbanding", "label": "what"}
{"id": "63719", "raw_code": "public void index(Tuple t,String field){\n  String s;\n  if ((s=t.getString(field)) == null)   return;\n  StringTokenizer st=new StringTokenizer(s,m_delim);\n  while (st.hasMoreTokens()) {\n    String tok=st.nextToken();\n    addString(tok,t);\n  }\n}", "comment": "indexes the given field of the provided tuple instance .", "label": "what"}
{"id": "44215", "raw_code": "protected int readFully(InputStream in,byte buffer[]) throws java.io.IOException {\n  for (int i=0; i < buffer.length; i++) {\n    int q=in.read();\n    if (q == -1)     return i;\n    buffer[i]=(byte)q;\n  }\n  return buffer.length;\n}", "comment": "this method works around the bizarre semantics of bufferedinputstream ' s read method .", "label": "what"}
{"id": "56086", "raw_code": "@CalledByNative private static void insertFullscreenInfoIntoList(ArrayList<FullscreenInfo> list,String origin,String embedder){\n  list.add(new FullscreenInfo(origin,embedder,false));\n}", "comment": "inserts fullscreen information into a list .", "label": "what"}
{"id": "747", "raw_code": "public static InputStream streamFromString(String location) throws IOException {\n  InputStream is=null;\n  URL url=urlFromString(location,null,false);\n  if (url != null) {\n    is=url.openStream();\n  }\n else {\n    File f=new File(location);\n    if (f.exists())     is=new FileInputStream(f);\n  }\n  if (is == null) {\n    return null;\n  }\n else   if (isGZipFile(location)) {\n    return new GZIPInputStream(is);\n  }\n else {\n    return is;\n  }\n}", "comment": "get an input string corresponding to the given location string .", "label": "what"}
{"id": "85926", "raw_code": "public void add(T item){\nsynchronized (lock) {\n    items.add(identifiedItemFactory.create(item));\n  }\n  notifyDataSetChanged();\n}", "comment": "adds the specified item at the end of the array .", "label": "what"}
{"id": "21907", "raw_code": "private void copyACLs(List<UnManagedCifsShareACL> origACLList,List<CifsShareACL> shareACLList,FileShare fileshare){\n  CifsShareACL shareACL=null;\n  for (  UnManagedCifsShareACL origACL : origACLList) {\n    shareACL=new CifsShareACL();\n    shareACL.setId(URIUtil.createId(CifsShareACL.class));\n    shareACL.setUser(origACL.getUser());\n    shareACL.setPermission(origACL.getPermission());\n    shareACL.setShareName(origACL.getShareName());\n    shareACL.setFileSystemId(fileshare.getId());\n    shareACLList.add(shareACL);\n    _logger.info(\"share ACLs details {}\",shareACL.toString());\n  }\n}", "comment": "copy unmanaged cifs share into new cifs share acls", "label": "what"}
{"id": "23292", "raw_code": "public ResourceListParser parse() throws ParserConfigurationException, SAXException, ParseFailureException {\n  try {\n    SAXParserFactory factory=SAXParserFactory.newInstance();\n    SAXParser parser=factory.newSAXParser();\n    parser.parse(mInputSource,this);\n    return this;\n  }\n catch (  IOException e) {\n    throw new ParseFailureException(\"Failed to parse input source!\",e);\n  }\n}", "comment": "parse the resource list", "label": "what"}
{"id": "40891", "raw_code": "public Builder deleteEntitlements(){\n  deleteFields.add(\"entitlements\");\n  return this;\n}", "comment": "deletes all entitlements of a existing user", "label": "what"}
{"id": "34226", "raw_code": "protected void incorporateSignedProperties() throws DSSException {\n  signedPropertiesDom=DSSXMLUtils.addElement(documentDom,qualifyingPropertiesDom,XAdES,XADES_SIGNED_PROPERTIES);\n  signedPropertiesDom.setAttribute(ID,\"xades-\" + deterministicId);\n  incorporateSignedSignatureProperties();\n}", "comment": "creates the signedproperties dom object element .", "label": "what"}
{"id": "20298", "raw_code": "private ChannelSelection createChannelSelection(StyleFactoryImpl styleFactory,ContrastMethod contrastMethod){\n  ContrastEnhancement contrastEnhancement=(ContrastEnhancement)styleFactory.contrastEnhancement(null,contrastMethod.name());\n  FilterFactory ff=CommonFactoryFinder.getFilterFactory();\n  Map<String,Expression> options=contrastEnhancement.getOptions();\n  options.put(\"algorithm\",ff.literal(\"StretchToMinimumMaximum\"));\n  options.put(\"minValue\",ff.literal(\"1\"));\n  options.put(\"maxValue\",ff.literal(\"5\"));\n  SelectedChannelType channelType=styleFactory.createSelectedChannelType(\"channel name\",contrastEnhancement);\n  SelectedChannelType[] channels=new SelectedChannelType[3];\n  channels[0]=channelType;\n  channels[1]=channelType;\n  channels[2]=channelType;\n  ChannelSelection channelSelection=styleFactory.createChannelSelection(channels);\n  return channelSelection;\n}", "comment": "creates the channel selection object", "label": "what"}
{"id": "12816", "raw_code": "public static float mean(float[] data,int[] inds){\n  float mean=0;\n  for (int i=0; i < inds.length; i++) {\n    if (Float.isNaN(data[inds[i]]))     throw new IllegalArgumentException(\"NaN not allowed in mean calculation\");\n    mean+=data[inds[i]];\n  }\n  mean/=inds.length;\n  return mean;\n}", "comment": "compute the mean of all elements in the array with given indices .", "label": "what"}
{"id": "81491", "raw_code": "public int depth(){\n  return pointer;\n}", "comment": "get the depth of the stack .", "label": "what"}
{"id": "65764", "raw_code": "private void cmd_import(){\n  JFileChooser jc=new JFileChooser();\n  jc.setDialogTitle(Msg.getMsg(Env.getCtx(),\"Import\"));\n  jc.setDialogType(JFileChooser.OPEN_DIALOG);\n  jc.setFileSelectionMode(JFileChooser.FILES_ONLY);\n  if (jc.showOpenDialog(this) != JFileChooser.APPROVE_OPTION)   return;\n  StringBuffer sb=new StringBuffer();\n  try {\n    InputStreamReader in=new InputStreamReader(new FileInputStream(jc.getSelectedFile()));\n    char[] cbuf=new char[1024];\n    int count;\n    while ((count=in.read(cbuf)) > 0)     sb.append(cbuf,0,count);\n    in.close();\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,\"HTMLEditor.import\" + e.getMessage());\n    return;\n  }\n  setHtmlText(sb.toString());\n}", "comment": "import text from file", "label": "what"}
{"id": "75524", "raw_code": "private static void writeFile(File file,List<String> lines) throws IOException {\n  if (!file.exists())   file.createNewFile();\n  FileWriter fw=new FileWriter(file);\n  BufferedWriter Bw=new BufferedWriter(fw);\n  PrintWriter pw=new PrintWriter(Bw);\n  for (  String line : lines)   pw.println(line);\n  Bw.close();\n  fw.close();\n  pw.close();\n}", "comment": "writes the lines given in input in file .", "label": "what"}
{"id": "11954", "raw_code": "public synchronized boolean verifyChunkAuthTag(int chunkIdx,byte[] chunkAuthTag) throws FileEncryptionException {\n  if ((chunkIdx < 0) || (chunkAuthTag == null) || (chunkAuthTag.length != backEncRandomAccessFile.CHUNK_TLEN)) {\n    throw new FileEncryptionException(\"Invalid auth tag parameter given!\");\n  }\n else {\n    byte[] storedAuthTag=atagList.get(chunkIdx);\n    if (storedAuthTag == null || !Arrays.equals(chunkAuthTag,storedAuthTag)) {\n      return false;\n    }\n else {\n      return true;\n    }\n  }\n}", "comment": "verifies if the given chunk authentication tag equals the one in the authentication tag list , but does not verify if the complete list of all authentication tags is valid w . r . t .", "label": "what"}
{"id": "313", "raw_code": "public <AnnotationType extends Annotation>void register(MethodBinder<AnnotationType> methodBinder){\n  Set<AnnotatedMethod<AnnotationType>> annotatedMethods=AnnotatedMethods.get(methodBinder.getAnnotationClass(),annotatedType);\n  if (!annotatedMethods.isEmpty()) {\n    objectBinders.add(new AnnotatedMethodBinder<>(methodBinder,annotatedMethods));\n  }\n}", "comment": "update the cache with this binder", "label": "what"}
{"id": "55710", "raw_code": "protected void read_lookahead() throws java.lang.Exception {\n  lookahead=new Symbol[error_sync_size()];\n  for (int i=0; i < error_sync_size(); i++) {\n    lookahead[i]=cur_token;\n    cur_token=scan();\n  }\n  lookahead_pos=0;\n}", "comment": "read from input to establish our buffer of \" parse ahead \" lookahead symbols .", "label": "what"}
{"id": "45955", "raw_code": "private Vector<SnmpVarBind> splitFrom(Vector<SnmpVarBind> original,int limit){\n  int max=original.size();\n  Vector<SnmpVarBind> result=new Vector<>(max - limit);\n  int i=limit;\n  for (Enumeration<SnmpVarBind> e=original.elements(); e.hasMoreElements(); --i) {\n    SnmpVarBind var=e.nextElement();\n    if (i > 0)     continue;\n    result.addElement(new SnmpVarBind(var.oid,var.value));\n  }\n  return result;\n}", "comment": "this method creates a new vector which does not contain the first element up to the specified limit .", "label": "what"}
{"id": "42738", "raw_code": "public TextEditor replaceAll(String regex,String replacement){\n  if (text.length() > 0) {\n    final String r=replacement;\n    Pattern p=Pattern.compile(regex,Pattern.MULTILINE);\n    Matcher m=p.matcher(text);\n    StringBuffer sb=new StringBuffer();\n    while (m.find()) {\n      m.appendReplacement(sb,r);\n    }\n    m.appendTail(sb);\n    text=new StringBuilder(sb.toString());\n  }\n  return this;\n}", "comment": "replace all occurrences of the regular expression with the replacement .", "label": "what"}
{"id": "33308", "raw_code": "private static <T>int migrateAll(Migration<T> migration) throws Exception {\n  int migrated=0;\n  for (  T entity : migration.getAllEntities()) {\n    try {\n      if (migration.isMigrated(entity))       continue;\n    }\n catch (    Exception x) {\n      LOG.error(\"Couldn't check if the entity '{}' is migrated due to occurred error\",entity);\n      throw x;\n    }\n    try {\n      migration.migrate(entity);\n    }\n catch (    Exception x) {\n      LOG.error(\"Error migrating the entity '{}\",entity);\n      throw x;\n    }\n    migrated++;\n  }\n  return migrated;\n}", "comment": "migrates entities and skips those which are already migrated .", "label": "what"}
{"id": "83846", "raw_code": "@Override protected void drawXLabels(List<Double> xLabels,Double[] xTextLabelLocations,Canvas canvas,Paint paint,int left,int top,int bottom,double xPixelsPerUnit,double minX,double maxX){\n  int length=xLabels.size();\n  if (length > 0) {\n    boolean showLabels=mRenderer.isShowLabels();\n    boolean showGridY=mRenderer.isShowGridY();\n    DateFormat format=getDateFormat(xLabels.get(0),xLabels.get(length - 1));\n    for (int i=0; i < length; i++) {\n      long label=Math.round(xLabels.get(i));\n      float xLabel=(float)(left + xPixelsPerUnit * (label - minX));\n      if (showLabels) {\n        paint.setColor(mRenderer.getXLabelsColor());\n        canvas.drawLine(xLabel,bottom,xLabel,bottom + mRenderer.getLabelsTextSize() / 3,paint);\n        drawText(canvas,format.format(new Date(label)),xLabel,bottom + mRenderer.getLabelsTextSize() * 4 / 3,paint,mRenderer.getXLabelsAngle());\n      }\n      if (showGridY) {\n        paint.setColor(mRenderer.getGridColor());\n        canvas.drawLine(xLabel,bottom,xLabel,top,paint);\n      }\n    }\n  }\n  drawXTextLabels(xTextLabelLocations,canvas,paint,true,left,top,bottom,xPixelsPerUnit,minX,maxX);\n}", "comment": "the graphical representation of the labels on the x axis .", "label": "what"}
{"id": "50407", "raw_code": "public static String encodeToString(byte[] src){\n  if (src == null) {\n    return null;\n  }\n  if (src.length == 0) {\n    return \"\";\n  }\n  String result;\n  try {\n    result=new String(delegate.encode(src),DEFAULT_CHARSET.displayName());\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new IllegalStateException(e);\n  }\n  return result;\n}", "comment": "base64 - encode the given byte array to a string .", "label": "what"}
{"id": "9011", "raw_code": "public ElsaSerializerPojo make(){\n  return new ElsaSerializerPojo(objectStack,singletons,registeredSers,registeredSerHeaders,registeredDeser,unknownClassNotification,new ElsaClassInfoResolver.ArrayBased(classes.toArray(new Class[0])));\n}", "comment": "creates new serializer with configuration from this builder", "label": "what"}
{"id": "12613", "raw_code": "private void loadBinary(InputStream is) throws IOException {\n  if (is instanceof FileInputStream) {\n    FileInputStream fis=(FileInputStream)is;\n    FileChannel fc=fis.getChannel();\n    MappedByteBuffer bb=fc.map(FileChannel.MapMode.READ_ONLY,0,(int)fc.size());\n    bb.load();\n    loadBinary(bb);\n    is.close();\n  }\n else {\n    loadBinary(new DataInputStream(is));\n  }\n}", "comment": "loads a binary file from the input stream .", "label": "what"}
{"id": "44466", "raw_code": "private void consumeCRLF() throws DecodingException {\n  char next=nextChar();\n  if (next != '\\n') {\n    consumeChar('\\r');\n  }\n  consumeChar('\\n');\n}", "comment": "consumes a crlf from the request .", "label": "what"}
{"id": "10862", "raw_code": "public boolean equals(Object o){\n  if (o instanceof CoverageIntVdt) {\n    CoverageIntVdt civ=(CoverageIntVdt)o;\n    return ((attribute == civ.attribute) && (value == civ.value));\n  }\n else {\n    return false;\n  }\n}", "comment": "override the equals method .", "label": "what"}
{"id": "72725", "raw_code": "public void accept(final Path file) throws InterruptedException {\n  logger.info(String.format(\"Sending to thread pool; will queue if full: \\\"%s\\\".\",file));\n  permits.acquire();\n  executor.execute(new ConsumerTask(file));\n}", "comment": "consume a file .", "label": "what"}
{"id": "7390", "raw_code": "private Activity checkActivity(){\n  Activity activity=mActivity.get();\n  if (activity == null) {\n    throw new IllegalStateException(\"No activity set. Either subclass PermisoActivity or call Permiso.setActivity() in onCreate() and onResume() of your Activity.\");\n  }\n  return activity;\n}", "comment": "ensures that our weakreference to the activity is still valid .", "label": "what"}
{"id": "68529", "raw_code": "@Override public synchronized void start(){\n  LOGGER.info(\"Starting the C2MON alive timer mechanism.\");\n  timer=new Timer(\"C2MON-alive-timer\");\n  timer.schedule(this,INITIAL_SCAN_DELAY,SCAN_INTERVAL);\n  running=true;\n}", "comment": "starts the timer .", "label": "what"}
{"id": "77400", "raw_code": "public boolean isLandingPage(URL url){\n  if (url.getQuery() != null) {\n    return false;\n  }\n else {\n    return landingPageSuffix(url) != \"\";\n  }\n}", "comment": "calculates whether the url is a landing page or not", "label": "what"}
{"id": "62288", "raw_code": "protected static void writeRowCountDefinitions(TableCreator creator,ByteBuffer buffer){\n  writeRowCountDefinitions(creator,buffer,creator.getIndexCount());\n}", "comment": "writes the index row count definitions into a table definition buffer .", "label": "what"}
{"id": "25211", "raw_code": "private static String doGetPath(String filename,int separatorAdd){\n  if (filename == null) {\n    return null;\n  }\n  int prefix=getPrefixLength(filename);\n  if (prefix < 0) {\n    return null;\n  }\n  int index=indexOfLastSeparator(filename);\n  int endIndex=index + separatorAdd;\n  if (prefix >= filename.length() || index < 0 || prefix >= endIndex) {\n    return \"\";\n  }\n  return filename.substring(prefix,endIndex);\n}", "comment": "does the work of getting the path .", "label": "what"}
{"id": "29594", "raw_code": "private void sign(final byte[] contentBytes,final ByteArrayOutputStream mimeContent) throws Exception {\n  String algId=conf.getSignatureAlgorithmId();\n  String keyId=conf.getActiveSigningKey();\n  log.debug(\"Signing directory with signing key '{}' \" + \"and signing algorithm '{}'\",keyId,algId);\n  String signature=signHelper(keyId,algId,contentBytes);\n  mimeContent.write(envelopeHeader.getBytes());\n  try (MultipartEncoder encoder=new MultipartEncoder(mimeContent,envelopeBoundary)){\n    encoder.startPart(mpMixedContentType(dataBoundary));\n    encoder.write(contentBytes);\n    String algURI=CryptoUtils.getSignatureAlgorithmURI(algId);\n    String hashURI=hashCalculator.getAlgoURI();\n    Path verificatioCertPath=conf.getCertPath(keyId);\n    encoder.startPart(MimeTypes.BINARY,new String[]{HEADER_CONTENT_TRANSFER_ENCODING + \": base64\",HEADER_SIG_ALGO_ID + \": \" + algURI,HEADER_VERIFICATION_CERT_HASH + \": \" + getVerificationCertHash(verificatioCertPath)+ \"; \"+ HEADER_HASH_ALGORITHM_ID+ \"=\"+ hashURI});\n    encoder.write(signature.getBytes());\n  }\n   log.debug(\"Generated signed directory:\\n{}\\n\",mimeContent.toString());\n  Files.write(tempConfPath,mimeContent.toByteArray());\n  log.debug(\"Written signed directory to '{}'\",tempConfPath);\n}", "comment": "signs the global configuration directory content .", "label": "what"}
{"id": "68777", "raw_code": "private boolean nextItemIs(String match) throws IOException {\n  int c;\n  while (isWhiteSpace(c=buf.get())) {\n  }\n  for (int i=0; i < match.length(); i++) {\n    if (i > 0) {\n      c=buf.get();\n    }\n    if (c != match.charAt(i)) {\n      return false;\n    }\n  }\n  return true;\n}", "comment": "requires the next few characters ( after whitespace ) to match the argument .", "label": "what"}
{"id": "9201", "raw_code": "public IntervalImpl(int serialNum,long startIntervalDateTime,double coverageFactor,FramingFlowType intervalDataType,ISource source,IIntervalClassification intervalClassification,Version adeVersion) throws AdeInternalException {\n  a_adeVersion=adeVersion;\n  if (startIntervalDateTime < 0) {\n    throw new IllegalArgumentException(String.format(\"Interval start time must be \" + \"greater than 0! Failed creating new interval with parameters: serialNum=%d, \" + \"startIntervalDateTime=%d, coverageFactor=%s, intervalDataType=%s, source=%s, \"+ \"intervalClassification=%s, adeVersion=%s\",serialNum,startIntervalDateTime,coverageFactor,intervalDataType,source,intervalClassification,adeVersion));\n  }\n  m_startIntervalTime=startIntervalDateTime;\n  m_framingFlowType=intervalDataType;\n  m_serialNum=serialNum;\n  m_intervalClassification=intervalClassification;\n  if (m_intervalClassification == null) {\n    m_intervalClassification=IntervalClassificationEnum.REGULAR;\n  }\n  m_messageSummaryMap=new TreeMap<Integer,IMessageSummary>();\n  m_endIntervalTime=m_startIntervalTime + m_framingFlowType.getDuration();\n  m_source=source;\n  if (coverageFactor <= 0 || coverageFactor > 1) {\n    throw new AdeInternalException(\"Interval coverage factor must be between 0 (exclusive) and 1 (inclusive), but currently is: \" + coverageFactor);\n  }\n  m_coverageFactor=coverageFactor;\n}", "comment": "this is used to build partial intervals .", "label": "what"}
{"id": "64219", "raw_code": "public OutputStream bindStream(OutputStream output){\n  OutputStream stream=m_streams.get();\n  m_streams.set(output);\n  return stream;\n}", "comment": "bind the specified stream to the current thread .", "label": "what"}
{"id": "72802", "raw_code": "private void initMapLayer(){\n  float zoom=getInitZoom(mapView.getWidth(),mapView.getHeight(),image.getWidth(),image.getHeight());\n  Log.i(TAG,Float.toString(zoom));\n  mapView.setCurrentZoom(zoom,0,0);\n  float width=mapView.getWidth() - zoom * image.getWidth();\n  float height=mapView.getHeight() - zoom * image.getHeight();\n  mapView.translate(width / 2,height / 2);\n}", "comment": "init map image layer", "label": "what"}
{"id": "84577", "raw_code": "public void finished(long chainLength){\n  currentState=chainLength;\n  if (loggers != null) {\n    for (    Logger logger : loggers) {\n      logger.log(currentState);\n      logger.stopLogging();\n    }\n  }\n  if (showOperatorAnalysis) {\n    showOperatorAnalysis(System.out);\n  }\n  if (operatorAnalysisFile != null) {\n    try {\n      PrintStream out=new PrintStream(new FileOutputStream(operatorAnalysisFile));\n      showOperatorAnalysis(out);\n      out.flush();\n      out.close();\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n    }\n  }\n}", "comment": "cleans up when the chain finishes ( possibly early ) .", "label": "what"}
{"id": "82406", "raw_code": "public InputStreamReader(java.io.InputStream is,java.lang.String enc) throws java.io.UnsupportedEncodingException {\n  internal=is;\n  this.enc=enc.intern();\n}", "comment": "create an inputstreamreader that uses the named character encoding .", "label": "what"}
{"id": "1838", "raw_code": "public int serverDelivery(Object message,Object consumer,int deliveryCount) throws Exception {\n  ProtonServerSenderContext protonSender=serverSenders.get(consumer);\n  if (protonSender != null) {\n    return protonSender.deliverMessage(message,deliveryCount);\n  }\n  return 0;\n}", "comment": "the consumer object from the broker or the key used to store the sender", "label": "what"}
{"id": "38944", "raw_code": "private Instance votedReclassifyExample(Instance example) throws Exception {\n  int classVotes[]=new int[getNumClasses()];\n  for (int i=0; i < classVotes.length; i++) {\n    classVotes[i]=0;\n  }\n  for (Enumeration<RuleList> e=new WekaEnumeration<RuleList>(m_DecisionList); e.hasMoreElements(); ) {\n    RuleList rl=e.nextElement();\n    int classValue=(int)rl.classifyInstance(example);\n    if (classValue >= 0) {\n      classVotes[classValue]++;\n    }\n  }\n  int maxVote=0;\n  int vote=-1;\n  for (int i=0; i < classVotes.length; i++) {\n    if (classVotes[i] > maxVote) {\n      maxVote=classVotes[i];\n      vote=i;\n    }\n  }\n  if (vote >= 0) {\n    example.setClassValue(vote);\n  }\n else {\n    throw new Exception(\"Error in instance classification.\");\n  }\n  return example;\n}", "comment": "classify example with maximum vote the following way .", "label": "what"}
{"id": "42926", "raw_code": "public RotationMatrixBuilder withThetas(double theta){\n  for (  Plane plane : planes) {\n    plane.setTheta(theta);\n  }\n  return this;\n}", "comment": "sets the rotation angle , in radians , of all 2d rotation planes added to this builder .", "label": "what"}
{"id": "5339", "raw_code": "private void writeUserRegistry(LocalContainer container,File configDir,Map<String,String> users,Map<String,List<String>> groups) throws IOException {\n  File usersXML=new File(configDir,\"cargo-users.xml\");\n  PrintStream writer=ServerConfigUtils.open(usersXML);\n  writer.println(\"  <basicRegistry id=\\\"basic\\\">\");\n  for (  Map.Entry<String,String> user : users.entrySet()) {\n    writer.print(\"    <user name=\\\"\");\n    writer.print(user.getKey());\n    writer.print(\"\\\" password=\\\"\");\n    writer.print(user.getValue());\n    writer.println(\"\\\"/>\");\n  }\n  for (  Map.Entry<String,List<String>> group : groups.entrySet()) {\n    writer.print(\"    <group name=\\\"\");\n    writer.print(group.getKey());\n    writer.println(\"\\\">\");\n    for (    String member : group.getValue()) {\n      writer.print(\"      <member name=\\\"\");\n      writer.print(member);\n      writer.println(\"\\\"/>\");\n    }\n    writer.println(\"    </group>\");\n  }\n  writer.println(\"  </basicRegistry>\");\n  ServerConfigUtils.close(writer);\n}", "comment": "this method writes a user registry xml", "label": "what"}
{"id": "32739", "raw_code": "public StopwatchCPU(){\n  threadTimer=ManagementFactory.getThreadMXBean();\n  start=threadTimer.getCurrentThreadCpuTime();\n}", "comment": "initializes a new stopwatch .", "label": "what"}
{"id": "42095", "raw_code": "public void addCondition(final Condition condition){\n  conditions.add(condition);\n  condition.setId(conditionIdCounter++);\n}", "comment": "will add the condition to the list .", "label": "what"}
{"id": "30058", "raw_code": "public static byte[] readBytesFromByteBuffer(ByteBuffer byteBuffer){\n  byte[] buffer=new byte[byteBuffer.remaining()];\n  byteBuffer.get(buffer);\n  return buffer;\n}", "comment": "reads the remaining bytes in a bytebuffer into a byte [ ] .", "label": "what"}
{"id": "55693", "raw_code": "public void findPackageAndClass() throws IOException {\n  packageName=null;\n  className=null;\n  LineNumberReader reader=new LineNumberReader(new FileReader(inputFile));\n  try {\n    while (className == null || packageName == null) {\n      String line=reader.readLine();\n      if (line == null)       break;\n      if (packageName == null) {\n        Matcher matcher=PACKAGE_PATTERN.matcher(line);\n        if (matcher.find()) {\n          packageName=matcher.group(1);\n        }\n      }\n      if (className == null) {\n        Matcher matcher=CLASS_PATTERN.matcher(line);\n        if (matcher.find()) {\n          className=matcher.group(1);\n        }\n      }\n    }\n    if (className == null) {\n      className=\"Yylex\";\n    }\n  }\n  finally {\n    reader.close();\n  }\n}", "comment": "peek into . flex file to get package and class name", "label": "what"}
{"id": "78353", "raw_code": "public static void log(final String msg,final Throwable t){\n  if (DEBUG) {\n    log(msg);\n    t.printStackTrace(System.out);\n  }\n}", "comment": "prints msg and exception to system . out .", "label": "what"}
{"id": "21381", "raw_code": "public static Set<URI> fetchRPTargetVirtualPools(DbClient dbClient){\n  Set<URI> rpProtectedTargetVPools=new HashSet<URI>();\n  try {\n    List<URI> vpoolProtectionSettingsURIs=dbClient.queryByType(VpoolProtectionVarraySettings.class,true);\n    Iterator<VpoolProtectionVarraySettings> vPoolProtectionSettingsItr=dbClient.queryIterativeObjects(VpoolProtectionVarraySettings.class,vpoolProtectionSettingsURIs,true);\n    while (vPoolProtectionSettingsItr.hasNext()) {\n      VpoolProtectionVarraySettings rSetting=vPoolProtectionSettingsItr.next();\n      if (null != rSetting && !NullColumnValueGetter.isNullURI(rSetting.getVirtualPool())) {\n        rpProtectedTargetVPools.add(rSetting.getVirtualPool());\n      }\n    }\n  }\n catch (  Exception ex) {\n    _log.error(\"Exception occurred while fetching RP enabled virtualpools\",ex);\n  }\n  return rpProtectedTargetVPools;\n}", "comment": "fetch the rp protected target virtual pool uris .", "label": "what"}
{"id": "69640", "raw_code": "public NSData(File file) throws IOException {\n  bytes=new byte[(int)file.length()];\n  RandomAccessFile raf=new RandomAccessFile(file,\"r\");\n  raf.read(bytes);\n  raf.close();\n}", "comment": "creates a nsdata object from a file .", "label": "what"}
{"id": "64407", "raw_code": "public int cardinality(){\n  int sum=0;\n  for (  long l : this.data)   sum+=Long.bitCount(l);\n  return sum;\n}", "comment": "compute the number of bits set to 1", "label": "what"}
{"id": "67507", "raw_code": "private String deEscapeLiteral(String lit){\n  return lit.replaceAll(\"\\\\\\\\\\\"\",\"\\\"\");\n}", "comment": "de - escapes a literal .", "label": "what"}
{"id": "67962", "raw_code": "public static void i(String msg,Object... args){\n  if (!allowI)   return;\n  StackTraceElement caller=getCallerStackTraceElement();\n  String tag=generateTag(caller);\n  if (sLevel > LEVEL_INFO) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.i(tag,msg);\n}", "comment": "send an info log message", "label": "what"}
{"id": "9693", "raw_code": "public DNewKeyStoreType(JFrame parent){\n  super(parent,Dialog.ModalityType.DOCUMENT_MODAL);\n  setTitle(res.getString(\"DNewKeyStoreType.Title\"));\n  initComponents();\n}", "comment": "creates a new dnewkeystoretype dialog .", "label": "what"}
{"id": "84511", "raw_code": "public void removeListener(final L listener){\n  Validate.notNull(listener,\"Listener object cannot be null.\");\n  listeners.remove(listener);\n}", "comment": "unregisters an event listener .", "label": "what"}
{"id": "41093", "raw_code": "public int predBlockIndexForSourcesIndex(int sourcesIndex){\n  return operands.get(sourcesIndex).blockIndex;\n}", "comment": "gets the index of the pred block associated with the registerspec at the particular getsources ( ) index .", "label": "what"}
{"id": "64210", "raw_code": "public LockableFileWriter(File file,Charset encoding,boolean append,String lockDir) throws IOException {\n  super();\n  file=file.getAbsoluteFile();\n  if (file.getParentFile() != null) {\n    FileUtils.forceMkdir(file.getParentFile());\n  }\n  if (file.isDirectory()) {\n    throw new IOException(\"File specified is a directory\");\n  }\n  if (lockDir == null) {\n    lockDir=System.getProperty(\"java.io.tmpdir\");\n  }\n  File lockDirFile=new File(lockDir);\n  FileUtils.forceMkdir(lockDirFile);\n  testLockDir(lockDirFile);\n  lockFile=new File(lockDirFile,file.getName() + LCK);\n  createLock();\n  out=initWriter(file,encoding,append);\n}", "comment": "constructs a lockablefilewriter with a file encoding .", "label": "what"}
{"id": "6590", "raw_code": "@SuppressWarnings(\"deprecation\") private static final URL toURL(String location,boolean file){\n  if (file) {\n    File f=new File(location);\n    if (f.exists()) {\n      try {\n        return f.toURL();\n      }\n catch (      MalformedURLException murl) {\n        return null;\n      }\n    }\n else {\n      return null;\n    }\n  }\n else {\n    return getURL(location);\n  }\n}", "comment": "makes a url out of a location , as either a file or a resource .", "label": "what"}
{"id": "12582", "raw_code": "protected Object parseValue(String string){\n  int openParen=string.indexOf(\"(\");\n  String type=string.substring(0,openParen);\n  String value=string.substring(openParen + 1,string.length() - 1);\n  if (type.equals(\"String\")) {\n    return value;\n  }\n else   if (type.equals(\"Float\")) {\n    return new Float(Float.parseFloat(value));\n  }\n else   if (type.equals(\"Integer\")) {\n    return new Integer(Integer.parseInt(value));\n  }\n else   if (type.equals(\"List\")) {\n    StringTokenizer tok=new StringTokenizer(value,\",\");\n    int size=tok.countTokens();\n    int[] values=new int[size];\n    for (int i=0; i < size; i++) {\n      float fval=Float.parseFloat(tok.nextToken());\n      values[i]=Math.round(fval);\n    }\n    return values;\n  }\n else {\n    throw new Error(\"Unknown type: \" + type);\n  }\n}", "comment": "coerces a string into a value .", "label": "what"}
{"id": "15931", "raw_code": "public static String toUpperCase(String string){\n  boolean changed=false;\n  char[] chars=string.toCharArray();\n  for (int i=0; i != chars.length; i++) {\n    char ch=chars[i];\n    if ('a' <= ch && 'z' >= ch) {\n      changed=true;\n      chars[i]=(char)(ch - 'a' + 'A');\n    }\n  }\n  if (changed) {\n    return new String(chars);\n  }\n  return string;\n}", "comment": "a locale independent version of touppercase .", "label": "what"}
{"id": "20174", "raw_code": "@Override public void update(List<EnvVar> dataList){\n  envVarList.clear();\n  if (dataList == null) {\n    for (    EnvVar envVar : builtInEnvVarMap.values()) {\n      envVarList.add(envVar);\n    }\n  }\n else {\n    for (    EnvVar envVar : dataList) {\n      if (builtInEnvVarMap.containsKey(envVar.getName())) {\n        envVarList.add(new EnvVar(envVar,true));\n      }\n else {\n        envVarList.add(new EnvVar(envVar,false));\n      }\n    }\n  }\n  setEnvironmentVariableValues();\n}", "comment": "update the environment variables .", "label": "what"}
{"id": "23835", "raw_code": "protected void notifyTimestampsToGateways(EntryEventImpl event){\n  VersionTagHolder updateTimeStampEvent=new VersionTagHolder(event.getVersionTag());\n  updateTimeStampEvent.setOperation(Operation.UPDATE_VERSION_STAMP);\n  updateTimeStampEvent.setKeyInfo(event.getKeyInfo());\n  updateTimeStampEvent.setGenerateCallbacks(false);\n  updateTimeStampEvent.distributedMember=event.getDistributedMember();\n  updateTimeStampEvent.setNewEventId(getSystem());\n  if (event.getRegion() instanceof BucketRegion) {\n    BucketRegion br=(BucketRegion)event.getRegion();\n    PartitionedRegion pr=br.getPartitionedRegion();\n    updateTimeStampEvent.setRegion(pr);\n    if (pr.isParallelWanEnabled()) {\n      br.handleWANEvent(updateTimeStampEvent);\n    }\n    if (pr.isInitialized()) {\n      pr.notifyGatewaySender(EnumListenerEvent.TIMESTAMP_UPDATE,updateTimeStampEvent);\n    }\n  }\n else {\n    updateTimeStampEvent.setRegion(event.getRegion());\n    notifyGatewaySender(EnumListenerEvent.TIMESTAMP_UPDATE,updateTimeStampEvent);\n  }\n}", "comment": "this notifies all wan sites about updated timestamp on local site .", "label": "what"}
{"id": "57247", "raw_code": "public boolean removeNode(ServiceNode node){\n  try {\n    return nodes.remove(node);\n  }\n catch (  Exception e) {\n    return false;\n  }\n}", "comment": "remove a service node from the node list", "label": "what"}
{"id": "49572", "raw_code": "public void execute() throws IOException {\n  String key=\"mqtt-\" + (System.currentTimeMillis() / 1000);\n  String b64Key=Base64.encode(key);\n  sendHandshakeRequest(b64Key);\n  receiveHandshakeResponse(b64Key);\n}", "comment": "executes a websocket handshake .", "label": "what"}
{"id": "24988", "raw_code": "public void calculateMin(double min){\n  if (this.min == -1) {\n    this.min=min;\n  }\n else {\n    this.min=Math.min(this.min,min);\n  }\n}", "comment": "sets the minimum and deals with the - 1 initialization ! .", "label": "what"}
{"id": "84004", "raw_code": "private void emitUntil(@Nonnegative int taskCountAllowed) throws IOException {\n  try {\n    while (emitQueue.size() > taskCountAllowed) {\n      Future<byte[]> future=emitQueue.remove();\n      byte[] toWrite=future.get();\n      blockSizes.add(toWrite.length);\n      out.write(toWrite);\n    }\n    tryEmit();\n  }\n catch (  ExecutionException e) {\n    throw new IOException(e);\n  }\ncatch (  InterruptedException e) {\n    throw new InterruptedIOException();\n  }\n}", "comment": "emits any opportunistically available blocks .", "label": "what"}
{"id": "45814", "raw_code": "void xrot(double theta){\n  theta*=(pi / 180);\n  double ct=Math.cos(theta);\n  double st=Math.sin(theta);\n  float Nyx=(float)(yx * ct + zx * st);\n  float Nyy=(float)(yy * ct + zy * st);\n  float Nyz=(float)(yz * ct + zz * st);\n  float Nyo=(float)(yo * ct + zo * st);\n  float Nzx=(float)(zx * ct - yx * st);\n  float Nzy=(float)(zy * ct - yy * st);\n  float Nzz=(float)(zz * ct - yz * st);\n  float Nzo=(float)(zo * ct - yo * st);\n  yo=Nyo;\n  yx=Nyx;\n  yy=Nyy;\n  yz=Nyz;\n  zo=Nzo;\n  zx=Nzx;\n  zy=Nzy;\n  zz=Nzz;\n}", "comment": "rotate theta degrees about the x axis", "label": "what"}
{"id": "17160", "raw_code": "public static void scaleRectAboutCenter(Rect r,float scale){\n  if (scale != 1.0f) {\n    int cx=r.centerX();\n    int cy=r.centerY();\n    r.offset(-cx,-cy);\n    r.left=(int)(r.left * scale + 0.5f);\n    r.top=(int)(r.top * scale + 0.5f);\n    r.right=(int)(r.right * scale + 0.5f);\n    r.bottom=(int)(r.bottom * scale + 0.5f);\n    r.offset(cx,cy);\n  }\n}", "comment": "scales a rect about its centroid", "label": "what"}
{"id": "12389", "raw_code": "private int measureHeight(int measureSpec){\n  float result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=mPaintSelected.getStrokeWidth() + getPaddingTop() + getPaddingBottom();\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return (int)Math.ceil(result);\n}", "comment": "determines the height of this view", "label": "what"}
{"id": "21310", "raw_code": "public static boolean isNull(URI id){\n  return (id == null) || NULL_URI.equals(id);\n}", "comment": "checks if the id is null ( or matches the null _ uri ) .", "label": "what"}
{"id": "29561", "raw_code": "@SuppressWarnings(\"unused\") public static float valueRangeLimit(float value,float startValue,float endValue){\n  if (value < Math.min(startValue,endValue))   return Math.min(startValue,endValue);\n  if (value > Math.max(startValue,endValue))   return Math.max(startValue,endValue);\n  return value;\n}", "comment": "limit number within a values range .", "label": "what"}
{"id": "38565", "raw_code": "protected void createTitle(String title){\n  String newTitle;\n  newTitle=\"Weka \" + new Version();\n  if (title.length() != 0) {\n    newTitle+=\" - \" + title;\n  }\n  setTitle(newTitle);\n}", "comment": "creates and displays the title .", "label": "what"}
{"id": "44574", "raw_code": "public static boolean isConnected(NetType netType,NetworkInfo networkInfo){\n  if (netType == NetType.Any && networkInfo != null && isConnected(networkInfo))   return true;\n else   if (netType == NetType.Wifi && networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_WIFI && isConnected(networkInfo))   return true;\n else   if (netType == NetType.Mobile && networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_MOBILE && isConnected(networkInfo))   return true;\n  return false;\n}", "comment": "according to the different type of network to determine whether the network connection .", "label": "what"}
{"id": "33847", "raw_code": "private void applyImageMatrix(float width,float height,boolean center,boolean animate){\n  if (mBitmap != null && width > 0 && height > 0) {\n    mImageMatrix.reset();\n    mImageMatrix.postTranslate((width - mBitmap.getWidth()) / 2,(height - mBitmap.getHeight()) / 2);\n    mapImagePointsByImageMatrix();\n    if (mDegreesRotated > 0) {\n      mImageMatrix.postRotate(mDegreesRotated,BitmapUtils.getRectCenterX(mImagePoints),BitmapUtils.getRectCenterY(mImagePoints));\n      mapImagePointsByImageMatrix();\n    }\n    float scale=Math.min(width / BitmapUtils.getRectWidth(mImagePoints),height / BitmapUtils.getRectHeight(mImagePoints));\n    if (mScaleType == ScaleType.FIT_CENTER || (mScaleType == ScaleType.CENTER_INSIDE && scale < 1) || (scale > 1 && mAutoZoomEnabled)) {\n      mImageMatrix.postScale(scale,scale,BitmapUtils.getRectCenterX(mImagePoints),BitmapUtils.getRectCenterY(mImagePoints));\n      mapImagePointsByImageMatrix();\n    }\n    mImageMatrix.postScale(mZoom,mZoom,BitmapUtils.getRectCenterX(mImagePoints),BitmapUtils.getRectCenterY(mImagePoints));\n    mapImagePointsByImageMatrix();\n    RectF cropRect=mCropOverlayView.getCropWindowRect();\n    cropRect.offset(-mZoomOffsetX * mZoom,-mZoomOffsetY * mZoom);\n    if (center) {\n      mZoomOffsetX=width > BitmapUtils.getRectWidth(mImagePoints) ? 0 : Math.max(Math.min(width / 2 - cropRect.centerX(),-BitmapUtils.getRectLeft(mImagePoints)),getWidth() - BitmapUtils.getRectRight(mImagePoints)) / mZoom;\n      mZoomOffsetY=height > BitmapUtils.getRectHeight(mImagePoints) ? 0 : Math.max(Math.min(height / 2 - cropRect.centerY(),-BitmapUtils.getRectTop(mImagePoints)),getHeight() - BitmapUtils.getRectBottom(mImagePoints)) / mZoom;\n    }\n else {\n      mZoomOffsetX=Math.min(Math.max(mZoomOffsetX * mZoom,-cropRect.left),-cropRect.right + width) / mZoom;\n      mZoomOffsetY=Math.min(Math.max(mZoomOffsetY * mZoom,-cropRect.top),-cropRect.bottom + height) / mZoom;\n    }\n    mImageMatrix.postTranslate(mZoomOffsetX * mZoom,mZoomOffsetY * mZoom);\n    cropRect.offset(mZoomOffsetX * mZoom,mZoomOffsetY * mZoom);\n    mCropOverlayView.setCropWindowRect(cropRect);\n    mapImagePointsByImageMatrix();\n    if (animate) {\n      mAnimation.setEndState(mImagePoints,mImageMatrix);\n      mImageView.startAnimation(mAnimation);\n    }\n else {\n      mImageView.setImageMatrix(mImageMatrix);\n    }\n    updateImageBounds(false);\n  }\n}", "comment": "apply matrix to handle the image inside the image view .", "label": "what"}
{"id": "31921", "raw_code": "public static void closeQuiet(@Nullable SelectionKey rsrc){\n  if (rsrc != null)   closeQuiet(rsrc.channel());\n}", "comment": "quietly closes given resource ignoring possible checked exceptions .", "label": "what"}
{"id": "83938", "raw_code": "public CompletableFuture<NewFile> run(){\n  LOG.log(Level.FINE,\"starting optimized file creation for {0} files\",files.size());\n  CompletableFuture<NewFile> fileCreation=new CompletableFuture<>();\n  final List<TSData> fjpFiles=this.files;\n  TASK_POOL.execute(null);\nsynchronized (OUTSTANDING) {\n    OUTSTANDING.add(fileCreation);\n  }\n  this.files=new LinkedList<>();\n  return fileCreation;\n}", "comment": "start creating the optimized file .", "label": "what"}
{"id": "2907", "raw_code": "private static Key createDESKey(byte[] bytes,int offset){\n  byte[] keyBytes=new byte[7];\n  System.arraycopy(bytes,offset,keyBytes,0,7);\n  byte[] material=new byte[8];\n  material[0]=keyBytes[0];\n  material[1]=(byte)(keyBytes[0] << 7 | (keyBytes[1] & 0xff) >>> 1);\n  material[2]=(byte)(keyBytes[1] << 6 | (keyBytes[2] & 0xff) >>> 2);\n  material[3]=(byte)(keyBytes[2] << 5 | (keyBytes[3] & 0xff) >>> 3);\n  material[4]=(byte)(keyBytes[3] << 4 | (keyBytes[4] & 0xff) >>> 4);\n  material[5]=(byte)(keyBytes[4] << 3 | (keyBytes[5] & 0xff) >>> 5);\n  material[6]=(byte)(keyBytes[5] << 2 | (keyBytes[6] & 0xff) >>> 6);\n  material[7]=(byte)(keyBytes[6] << 1);\n  oddParity(material);\n  return new SecretKeySpec(material,\"DES\");\n}", "comment": "creates a des encryption key from the given key material .", "label": "what"}
{"id": "45528", "raw_code": "static void checkDesc(final String desc,final boolean canBeVoid){\n  int end=checkDesc(desc,0,canBeVoid);\n  if (end != desc.length()) {\n    throw new IllegalArgumentException(\"Invalid descriptor: \" + desc);\n  }\n}", "comment": "checks that the given string is a valid type descriptor .", "label": "what"}
{"id": "10289", "raw_code": "public String text(){\n  StringBuilder sb=new StringBuilder();\n  for (  Node node : nodes) {\n    sb.append(node.getTextContent());\n  }\n  return sb.toString();\n}", "comment": "gets the combined text contents of each element in the set of matched elements , including their descendants .", "label": "what"}
{"id": "13298", "raw_code": "private boolean scanExpr(SymbolTable symbolTable,Tokens tokens,String data,int currentOffset,int endOffset) throws XNIException {\n  int ch;\n  int openParen=0;\n  int closeParen=0;\n  int nameOffset, dataOffset;\n  boolean isQName=false;\n  String name=null;\n  String prefix=null;\n  String schemeData=null;\n  StringBuffer schemeDataBuff=new StringBuffer();\n  while (true) {\n    if (currentOffset == endOffset) {\n      break;\n    }\n    ch=data.charAt(currentOffset);\n    while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n      if (++currentOffset == endOffset) {\n        break;\n      }\n      ch=data.charAt(currentOffset);\n    }\n    if (currentOffset == endOffset) {\n      break;\n    }\n    byte chartype=(ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\nswitch (chartype) {\ncase CHARTYPE_OPEN_PAREN:\n      addToken(tokens,Tokens.XPTRTOKEN_OPEN_PAREN);\n    openParen++;\n  ++currentOffset;\nbreak;\ncase CHARTYPE_CLOSE_PAREN:\naddToken(tokens,Tokens.XPTRTOKEN_CLOSE_PAREN);\ncloseParen++;\n++currentOffset;\nbreak;\ncase CHARTYPE_CARRET:\ncase CHARTYPE_COLON:\ncase CHARTYPE_DIGIT:\ncase CHARTYPE_EQUAL:\ncase CHARTYPE_LETTER:\ncase CHARTYPE_MINUS:\ncase CHARTYPE_NONASCII:\ncase CHARTYPE_OTHER:\ncase CHARTYPE_PERIOD:\ncase CHARTYPE_SLASH:\ncase CHARTYPE_UNDERSCORE:\ncase CHARTYPE_WHITESPACE:\nif (openParen == 0) {\nnameOffset=currentOffset;\ncurrentOffset=scanNCName(data,endOffset,currentOffset);\nif (currentOffset == nameOffset) {\nreportError(\"InvalidShortHandPointer\",new Object[]{data});\nreturn false;\n}\nif (currentOffset < endOffset) {\nch=data.charAt(currentOffset);\n}\n else {\nch=-1;\n}\nname=symbolTable.addSymbol(data.substring(nameOffset,currentOffset));\nprefix=XMLSymbols.EMPTY_STRING;\nif (ch == ':') {\nif (++currentOffset == endOffset) {\nreturn false;\n}\nch=data.charAt(currentOffset);\nprefix=name;\nnameOffset=currentOffset;\ncurrentOffset=scanNCName(data,endOffset,currentOffset);\nif (currentOffset == nameOffset) {\nreturn false;\n}\nif (currentOffset < endOffset) {\nch=data.charAt(currentOffset);\n}\n else {\nch=-1;\n}\nisQName=true;\nname=symbolTable.addSymbol(data.substring(nameOffset,currentOffset));\n}\nif (currentOffset != endOffset) {\naddToken(tokens,Tokens.XPTRTOKEN_SCHEMENAME);\ntokens.addToken(prefix);\ntokens.addToken(name);\nisQName=false;\n}\n else if (currentOffset == endOffset) {\naddToken(tokens,Tokens.XPTRTOKEN_SHORTHAND);\ntokens.addToken(name);\nisQName=false;\n}\ncloseParen=0;\nbreak;\n}\n else if (openParen > 0 && closeParen == 0 && name != null) {\ndataOffset=currentOffset;\ncurrentOffset=scanData(data,schemeDataBuff,endOffset,currentOffset);\nif (currentOffset == dataOffset) {\nreportError(\"InvalidSchemeDataInXPointer\",new Object[]{data});\nreturn false;\n}\nif (currentOffset < endOffset) {\nch=data.charAt(currentOffset);\n}\n else {\nch=-1;\n}\nschemeData=symbolTable.addSymbol(schemeDataBuff.toString());\naddToken(tokens,Tokens.XPTRTOKEN_SCHEMEDATA);\ntokens.addToken(schemeData);\nopenParen=0;\nschemeDataBuff.delete(0,schemeDataBuff.length());\n}\n else {\nreturn false;\n}\n}\n}\nreturn true;\n}", "comment": "scans the xpointer expression", "label": "what"}
{"id": "3866", "raw_code": "public void addLine(int startLine,String sourceFile,int repeatCount,int outputLine,int outputIncrement){\n  _lines.add(new Line(startLine,sourceFile,repeatCount,outputLine,outputIncrement));\n}", "comment": "adds a line from the smap", "label": "what"}
{"id": "42234", "raw_code": "public String(StringBuffer stringbuffer){\n  offset=0;\nsynchronized (stringbuffer) {\n    value=stringbuffer.shareValue();\n    count=stringbuffer.length();\n  }\n}", "comment": "creates a string from the contents of a stringbuffer .", "label": "what"}
{"id": "15034", "raw_code": "private void checkComplianceAttributes(AttrSet attrSet,boolean ignoreCompliance) throws AMException {\n  if (!ignoreCompliance && ComplianceServicesImpl.isComplianceUserDeletionEnabled()) {\n    complianceImpl.verifyAttributes(attrSet);\n  }\n}", "comment": "checks for compliance related attributes if applicable .", "label": "what"}
{"id": "21671", "raw_code": "private void updateZoningMap(UnManagedExportMask mask,List<Initiator> initiators,List<StoragePort> storagePorts){\n  ZoneInfoMap zoningMap=networkDeviceController.getInitiatorsZoneInfoMap(initiators,storagePorts);\n  for (  ZoneInfo zoneInfo : zoningMap.values()) {\n    log.info(\"Found zone: {} for initiator {} and port {}\",new Object[]{zoneInfo.getZoneName(),zoneInfo.getInitiatorWwn(),zoneInfo.getPortWwn()});\n  }\n  mask.setZoningMap(zoningMap);\n}", "comment": "set mask zoning map", "label": "what"}
{"id": "23320", "raw_code": "public InvitationStatus waitInvitationAnswer(){\n  return waitInvitationAnswer(mRingingPeriod);\n}", "comment": "wait session invitation answer", "label": "what"}
{"id": "52155", "raw_code": "private double[][] xPrime(int t){\n  double[][] x=new double[1][getNumLags() * numVars];\n  for (int i=0; i < getNumLags(); i++) {\n    double[][] yPrime=yPrime(t - i - 1);\n    System.arraycopy(yPrime[0],0,x[0],i * numVars,numVars);\n  }\n  return x;\n}", "comment": "constructs the x ( t ) vector .", "label": "what"}
{"id": "28727", "raw_code": "public void omitLessFreq(){\n  if (name == null)   return;\n  int threshold=n_words[0] / LESS_FREQ_RATIO;\n  if (threshold < MINIMUM_FREQ)   threshold=MINIMUM_FREQ;\n  Set<String> keys=freq.keySet();\n  int roman=0;\n  for (Iterator<String> i=keys.iterator(); i.hasNext(); ) {\n    String key=i.next();\n    int count=freq.get(key);\n    if (count <= threshold) {\n      n_words[key.length() - 1]-=count;\n      i.remove();\n    }\n else {\n      if (key.matches(\"^[A-Za-z]$\")) {\n        roman+=count;\n      }\n    }\n  }\n  if (roman < n_words[0] / 3) {\n    Set<String> keys2=freq.keySet();\n    for (Iterator<String> i=keys2.iterator(); i.hasNext(); ) {\n      String key=i.next();\n      if (key.matches(\".*[A-Za-z].*\")) {\n        n_words[key.length() - 1]-=freq.get(key);\n        i.remove();\n      }\n    }\n  }\n}", "comment": "eliminate below less frequency n - grams and noise latin alphabets", "label": "what"}
{"id": "11209", "raw_code": "public static void describeShapeDetail(Shape shape,double flattening){\n  PathIterator pi2=shape.getPathIterator(null);\n  FlatteningPathIterator pi=new FlatteningPathIterator(pi2,flattening);\n  double[] coords=new double[6];\n  int pointCount=0;\n  Debug.output(\" -- start describeShapeDetail with flattening[\" + flattening + \"]\");\n  while (!pi.isDone()) {\n    int type=pi.currentSegment(coords);\n    Debug.output(\" Shape point [\" + type + \"] (\"+ (pointCount++)+ \") \"+ coords[0]+ \", \"+ coords[1]);\n    pi.next();\n  }\n  Debug.output(\" -- end (\" + pointCount + \")\");\n}", "comment": "utility method that iterates over a shape object and prints out the points .", "label": "what"}
{"id": "53065", "raw_code": "protected static String shortenClassname(String nam,char c){\n  final int lastdot=nam.lastIndexOf(c);\n  if (lastdot >= 0) {\n    nam=nam.substring(lastdot + 1);\n  }\n  return nam;\n}", "comment": "shorten the class name .", "label": "what"}
{"id": "31189", "raw_code": "public ServiceID(DataInput in) throws IOException {\n  this.mostSig=in.readLong();\n  this.leastSig=in.readLong();\n}", "comment": "reads in 16 bytes in standard network byte order .", "label": "what"}
{"id": "17007", "raw_code": "protected int[] readColorTable(final int ncolors){\n  final int nbytes=3 * ncolors;\n  int[] tab=null;\n  final byte[] c=new byte[nbytes];\n  try {\n    rawData.get(c);\n    tab=new int[256];\n    int i=0;\n    int j=0;\n    while (i < ncolors) {\n      final int r=(c[j++]) & 0xff;\n      final int g=(c[j++]) & 0xff;\n      final int b=(c[j++]) & 0xff;\n      tab[i++]=0xff000000 | (r << 16) | (g << 8)| b;\n    }\n  }\n catch (  final BufferUnderflowException e) {\n    Log.w(TAG,\"Format Error Reading Color Table\",e);\n    status=STATUS_FORMAT_ERROR;\n  }\n  return tab;\n}", "comment": "reads color table as 256 rgb integer values", "label": "what"}
{"id": "63289", "raw_code": "void touch(boolean openReadOnly) throws IOException {\n  if (isReadOnly || openReadOnly) {\n    throw new IOException(\"Read only\");\n  }\n  lastModified=System.currentTimeMillis();\n}", "comment": "update the last modified time .", "label": "what"}
{"id": "81883", "raw_code": "protected int drawLegend(Canvas canvas,DefaultRenderer renderer,String[] titles,int left,int right,int y,int width,int height,int legendSize,Paint paint,boolean calculate){\n  float size=32;\n  if (renderer.isShowLegend()) {\n    float currentX=left;\n    float currentY=y + height - legendSize + size;\n    paint.setTextAlign(Component.LEFT);\n    paint.setTextSize(renderer.getLegendTextSize());\n    int sLength=Math.min(titles.length,renderer.getSeriesRendererCount());\n    for (int i=0; i < sLength; i++) {\n      SimpleSeriesRenderer r=renderer.getSeriesRendererAt(i);\n      final float lineSize=getLegendShapeWidth(i);\n      if (r.isShowLegendItem()) {\n        String text=titles[i];\n        if (titles.length == renderer.getSeriesRendererCount()) {\n          paint.setColor(r.getColor());\n        }\n else {\n          paint.setColor(ColorUtil.LTGRAY);\n        }\n        float[] widths=new float[text.length()];\n        paint.getTextWidths(text,widths);\n        float sum=0;\n        for (        float value : widths) {\n          sum+=value;\n        }\n        float extraSize=lineSize + 10 + sum;\n        float currentWidth=currentX + extraSize;\n        if (i > 0 && getExceed(currentWidth,renderer,right,width)) {\n          currentX=left;\n          currentY+=renderer.getLegendTextSize();\n          size+=renderer.getLegendTextSize();\n          currentWidth=currentX + extraSize;\n        }\n        if (getExceed(currentWidth,renderer,right,width)) {\n          float maxWidth=right - currentX - lineSize- 10;\n          if (isVertical(renderer)) {\n            maxWidth=width - currentX - lineSize- 10;\n          }\n          int nr=paint.breakText(text,true,maxWidth,widths);\n          text=text.substring(0,nr) + \"...\";\n        }\n        if (!calculate) {\n          drawLegendShape(canvas,r,currentX,currentY,i,paint);\n          drawString(canvas,text,currentX + lineSize + 5,currentY + 5,paint);\n        }\n        currentX+=extraSize;\n      }\n    }\n  }\n  return Math.round(size + renderer.getLegendTextSize());\n}", "comment": "draws the chart legend .", "label": "what"}
{"id": "56341", "raw_code": "public PutRepositoryRequest source(byte[] repositoryDefinition){\n  return source(repositoryDefinition,0,repositoryDefinition.length);\n}", "comment": "parses repository definition .", "label": "what"}
{"id": "70377", "raw_code": "private void disableButtons(){\n  setFireEnabled(false);\n  setSkipEnabled(false);\n  setTwistEnabled(false);\n  setNextEnabled(false);\n  butDone.setEnabled(false);\n  setFlipArmsEnabled(false);\n  setFireModeEnabled(false);\n  setNextTargetEnabled(false);\n}", "comment": "disables all buttons in the interface", "label": "what"}
{"id": "35988", "raw_code": "@Override public void write(String str){\n  int start=0;\n  while (start < str.length()) {\n    int end=Math.min(start + MAX_MESSAGE_LENGTH,str.length());\n    Log.i(TAG,str.substring(start,end));\n    start=end;\n  }\n}", "comment": "writes the given string to android logcat .", "label": "what"}
{"id": "79069", "raw_code": "private CarbonDictionarySortInfo createColumnSortInfo(CarbonDictionarySortModel[] dictionarySortModels){\n  int[] sortIndex;\n  int[] sortIndexInverted;\n  Arrays.sort(dictionarySortModels);\n  sortIndex=new int[dictionarySortModels.length];\n  sortIndexInverted=new int[dictionarySortModels.length];\n  for (int i=0; i < dictionarySortModels.length; i++) {\n    CarbonDictionarySortModel dictionarySortModel=dictionarySortModels[i];\n    sortIndex[i]=dictionarySortModel.getKey();\n    sortIndexInverted[dictionarySortModel.getKey() - 1]=i + 1;\n  }\n  dictionarySortModels=null;\n  List<Integer> sortIndexList=convertToList(sortIndex);\n  List<Integer> sortIndexInvertedList=convertToList(sortIndexInverted);\n  return new CarbonDictionarySortInfo(sortIndexList,sortIndexInvertedList);\n}", "comment": "the method prepares the sort _ index and sort _ index _ inverted data", "label": "what"}
{"id": "74992", "raw_code": "public BitString(final String value){\n  this(value.length());\n  for (int i=0; i < value.length(); i++) {\n    if (value.charAt(i) == '1') {\n      setBit(value.length() - (i + 1),true);\n    }\n else     if (value.charAt(i) != '0') {\n      throw new IllegalArgumentException(\"Illegal character at position \" + i);\n    }\n  }\n}", "comment": "initialises the bit string from a character string of 1s and 0s in big - endian order .", "label": "what"}
{"id": "39396", "raw_code": "public void write(Writer writer) throws Exception {\n  writer.write(toString());\n  writer.flush();\n}", "comment": "writes the current dom document into the given writer .", "label": "what"}
{"id": "72601", "raw_code": "public static boolean isCglibRenamedMethod(Method renamedMethod){\n  String name=renamedMethod.getName();\n  if (name.startsWith(CGLIB_RENAMED_METHOD_PREFIX)) {\n    int i=name.length() - 1;\n    while (i >= 0 && Character.isDigit(name.charAt(i))) {\n      i--;\n    }\n    return ((i > CGLIB_RENAMED_METHOD_PREFIX.length()) && (i < name.length() - 1) && (name.charAt(i) == '$'));\n  }\n  return false;\n}", "comment": "determine whether the given method is a cglib ' renamed ' method , following the pattern \" cglib $ methodname $ 0 \" .", "label": "what"}
{"id": "14366", "raw_code": "public PWResetException(String bundleName,String errCode,Object[] args){\n  super(bundleName,errCode,args);\n  errList=new ArrayList(1);\n  errList.add(getMessage());\n}", "comment": "creates a password reset exception object with localizable error message .", "label": "what"}
{"id": "49217", "raw_code": "boolean isStateChange(XDecoratedPeer window,XPropertyEvent e){\n  if (!window.isShowing()) {\n    stateLog.finer(\"Window is not showing\");\n    return false;\n  }\n  int wm_state=window.getWMState();\n  if (wm_state == XUtilConstants.WithdrawnState) {\n    stateLog.finer(\"WithdrawnState\");\n    return false;\n  }\n else {\n    if (stateLog.isLoggable(PlatformLogger.Level.FINER)) {\n      stateLog.finer(\"Window WM_STATE is \" + wm_state);\n    }\n  }\n  boolean is_state_change=false;\n  if (e.get_atom() == XA_WM_STATE.getAtom()) {\n    is_state_change=true;\n  }\n  for (  XStateProtocol proto : getProtocols(XStateProtocol.class)) {\n    is_state_change|=proto.isStateChange(e);\n    if (stateLog.isLoggable(PlatformLogger.Level.FINEST)) {\n      stateLog.finest(proto + \": is state changed = \" + is_state_change);\n    }\n  }\n  return is_state_change;\n}", "comment": "\\ notice window state change when wm changes a property on the window . . .", "label": "what"}
{"id": "66885", "raw_code": "public static String grabClass(String signature){\n  Matcher matcher=sigRE.matcher(signature);\n  boolean b=matcher.matches();\n  if (!b && matcher.groupCount() != 4)   logger.error(\"Bad method signature: {}\",signature);\n  return matcher.group(1);\n}", "comment": "grab the class from the signature", "label": "what"}
{"id": "72936", "raw_code": "public InputBuilder<T> repeatAll(int times){\n  List<T> toAppend=new ArrayList<>();\n  for (int i=0; i < times; i++) {\n    toAppend.addAll(input);\n  }\n  input.addAll(toAppend);\n  return this;\n}", "comment": "repeat the current input list", "label": "what"}
{"id": "54309", "raw_code": "public final void renameClass(Map classnames){\n  String jvmNewThisName=(String)classnames.get(Descriptor.toJvmName(thisclassname));\n  if (jvmNewThisName != null)   thisclassname=Descriptor.toJavaName(jvmNewThisName);\n  constPool.renameClass(classnames);\n  AttributeInfo.renameClass(attributes,classnames);\n  ArrayList list=methods;\n  int n=list.size();\n  for (int i=0; i < n; ++i) {\n    MethodInfo minfo=(MethodInfo)list.get(i);\n    String desc=minfo.getDescriptor();\n    minfo.setDescriptor(Descriptor.rename(desc,classnames));\n    AttributeInfo.renameClass(minfo.getAttributes(),classnames);\n  }\n  list=fields;\n  n=list.size();\n  for (int i=0; i < n; ++i) {\n    FieldInfo finfo=(FieldInfo)list.get(i);\n    String desc=finfo.getDescriptor();\n    finfo.setDescriptor(Descriptor.rename(desc,classnames));\n    AttributeInfo.renameClass(finfo.getAttributes(),classnames);\n  }\n}", "comment": "replaces all occurrences of several class names in the class file .", "label": "what"}
{"id": "5032", "raw_code": "public final double distance(){\n  return Math.sqrt(distance_square());\n}", "comment": "the \" size \" of the line from 0 , 0 to x , y", "label": "what"}
{"id": "72434", "raw_code": "public MersenneTwister(){\n  mt=new int[N];\n  setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n}", "comment": "creates a new random number generator .", "label": "what"}
{"id": "85684", "raw_code": "public static String array2hex(final byte[] array){\n  return byteArray2String(array,\"0x\",\", \",true,16);\n}", "comment": "a byte array into its hex string representation", "label": "what"}
{"id": "68821", "raw_code": "public static int findName(String name,int[] table){\n  for (int i=0; i < table.length; i++) {\n    if (name.equals(getName(table[i]))) {\n      return i;\n    }\n  }\n  return -1;\n}", "comment": "get the encoding value of a glyph given its name and a charset .", "label": "what"}
{"id": "69322", "raw_code": "private void scoreTrackResults(Collection<Track> tracks,SearchQuery query,Collection<ScoredResult> output){\n  for (  Track track : tracks) {\n    double score=scoreTrackResult(query,track);\n    output.add(new ScoredResult(track,score));\n  }\n}", "comment": "scores a collection of track results .", "label": "what"}
{"id": "76680", "raw_code": "private static byte[] encode(double latitude,double longitude){\n  byte[] bytes=new byte[2 * Integer.BYTES];\n  NumericUtils.intToSortableBytes(encodeLatitude(latitude),bytes,0);\n  NumericUtils.intToSortableBytes(encodeLongitude(longitude),bytes,Integer.BYTES);\n  return bytes;\n}", "comment": "sugar encodes a single point as a byte array", "label": "what"}
{"id": "32052", "raw_code": "public static void putLongVolatile(Object obj,long off,long val){\n  UNSAFE.putLongVolatile(obj,off,val);\n}", "comment": "stores long value with volatile semantic .", "label": "what"}
{"id": "32919", "raw_code": "public void circle(double x,double y,double r){\n  if (r < 0)   throw new IllegalArgumentException(\"circle radius can't be negative\");\n  double xs=scaleX(x);\n  double ys=scaleY(y);\n  double ws=factorX(2 * r);\n  double hs=factorY(2 * r);\n  if (ws <= 1 && hs <= 1)   pixel(x,y);\n else   offscreen.draw(new Ellipse2D.Double(xs - ws / 2,ys - hs / 2,ws,hs));\n  draw();\n}", "comment": "draws a circle of radius r , centered on ( x , y ) .", "label": "what"}
{"id": "3661", "raw_code": "final public void println(double v){\n  Writer out=this.out;\n  if (out == null)   return;\n  print(v);\n  try {\n    out.write(_newline,0,_newline.length);\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}", "comment": "prints a double followed by a newline .", "label": "what"}
{"id": "41631", "raw_code": "public void writeSI32(int value) throws IOException {\n  flushBits();\n  out.write(value & 0xff);\n  out.write(value >> 8);\n  out.write(value >> 16);\n  out.write(value >> 24);\n  bytesWritten+=4;\n}", "comment": "write a 32 bit signed value", "label": "what"}
{"id": "20239", "raw_code": "public void addButtonPressedListener(FieldConfigStringButtonInterface listener){\n  if (buttonPressedListenerList == null) {\n    buttonPressedListenerList=new ArrayList<FieldConfigStringButtonInterface>();\n  }\n  buttonPressedListenerList.add(listener);\n}", "comment": "adds the button pressed listener .", "label": "what"}
{"id": "64567", "raw_code": "public void dispose(){\n  logDebug(\"Disposing.\");\n  mSetupDone=false;\n  if (mServiceConn != null) {\n    logDebug(\"Unbinding from service.\");\n    if (mContext != null)     mContext.unbindService(mServiceConn);\n    mServiceConn=null;\n    mService=null;\n    mPurchaseListener=null;\n  }\n}", "comment": "dispose of object , releasing resources .", "label": "what"}
{"id": "64161", "raw_code": "private void walk(File directory,int depth,Collection<T> results) throws IOException {\n  checkIfCancelled(directory,depth,results);\n  if (handleDirectory(directory,depth,results)) {\n    handleDirectoryStart(directory,depth,results);\n    int childDepth=depth + 1;\n    if (depthLimit < 0 || childDepth <= depthLimit) {\n      checkIfCancelled(directory,depth,results);\n      File[] childFiles=filter == null ? directory.listFiles() : directory.listFiles(filter);\n      childFiles=filterDirectoryContents(directory,depth,childFiles);\n      if (childFiles == null) {\n        handleRestricted(directory,childDepth,results);\n      }\n else {\n        for (        File childFile : childFiles) {\n          if (childFile.isDirectory()) {\n            walk(childFile,childDepth,results);\n          }\n else {\n            checkIfCancelled(childFile,childDepth,results);\n            handleFile(childFile,childDepth,results);\n            checkIfCancelled(childFile,childDepth,results);\n          }\n        }\n      }\n    }\n    handleDirectoryEnd(directory,depth,results);\n  }\n  checkIfCancelled(directory,depth,results);\n}", "comment": "main recursive method to examine the directory hierarchy .", "label": "why"}
{"id": "63817", "raw_code": "public static Object[] ordinalArray(TupleSet tuples,String field){\n  return ordinalArray(tuples,field,DefaultLiteralComparator.getInstance());\n}", "comment": "get a sorted array containing all column values for a given tuple iterator and field .", "label": "why"}
{"id": "25383", "raw_code": "public TcpMatcher(final NetworkConfig config){\n  super(config);\n}", "comment": "creates a new matcher for running coap over tcp .", "label": "why"}
{"id": "49452", "raw_code": "protected void requestPassCodeConfirmation(){\n  clearBoxes();\n  mPassCodeHdr.setText(R.string.pass_code_reenter_your_pass_code);\n  mPassCodeHdrExplanation.setVisibility(View.INVISIBLE);\n  mConfirmingPassCode=true;\n}", "comment": "ask to the user for retyping the pass code just entered before saving it as the current pass code .", "label": "why"}
{"id": "74215", "raw_code": "public void deleteLeaves(String name){\n  for (int i=0; i < _leaves.size(); i++) {\n    CatalogTreeLeaf leaf=_leaves.get(i);\n    if (name.equals(leaf.getName())) {\n      _leaves.remove(i);\n    }\n  }\n}", "comment": "leaves can be used for many - to - many relations", "label": "why"}
{"id": "76092", "raw_code": "private float calcAngle(float value){\n  return value / mData.getYValueSum() * 360f;\n}", "comment": "calculates the needed angle for a given value", "label": "why"}
{"id": "48956", "raw_code": "private long computeInterfaceHash(){\n  long hash=0;\n  ByteArrayOutputStream sink=new ByteArrayOutputStream(512);\n  try {\n    MessageDigest md=MessageDigest.getInstance(\"SHA\");\n    DataOutputStream out=new DataOutputStream(new DigestOutputStream(sink,md));\n    out.writeInt(INTERFACE_HASH_STUB_VERSION);\n    for (    Method method : remoteMethods) {\n      MethodDoc methodDoc=method.methodDoc();\n      out.writeUTF(methodDoc.name());\n      out.writeUTF(Util.methodDescriptorOf(methodDoc));\n      ClassDoc exceptions[]=methodDoc.thrownExceptions();\n      Arrays.sort(exceptions,new ClassDocComparator());\n      for (      ClassDoc ex : exceptions) {\n        out.writeUTF(Util.binaryNameOf(ex));\n      }\n    }\n    out.flush();\n    byte hashArray[]=md.digest();\n    for (int i=0; i < Math.min(8,hashArray.length); i++) {\n      hash+=((long)(hashArray[i] & 0xFF)) << (i * 8);\n    }\n  }\n catch (  IOException e) {\n    throw new AssertionError(e);\n  }\ncatch (  NoSuchAlgorithmException e) {\n    throw new AssertionError(e);\n  }\n  return hash;\n}", "comment": "computes the \" interface hash \" of the stub / skeleton pair for this remote implementation class .", "label": "why"}
{"id": "79089", "raw_code": "protected void prepareDataSet(){\n  dataSet1=Arrays.asList(new String[]{\"a\",\"b\",\"c\"});\n  dataSet2=Arrays.asList(new String[]{\"d\",\"e\",\"f\"});\n  dataSet3=Arrays.asList(new String[]{\"b\",\"c\",\"a\",\"d\"});\n}", "comment": "prepare the dataset required for running test cases", "label": "why"}
{"id": "50528", "raw_code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}", "comment": "used to communicate a progress update between a plugin tool and the main whitebox user interface .", "label": "why"}
{"id": "61741", "raw_code": "public static ClassProperties loadProperties(Class[] cls,Properties properties,boolean inherit){\n  ClassProperties cp=new ClassProperties(properties);\n  for (  Class c : cls) {\n    cp.load(c,inherit);\n  }\n  return cp;\n}", "comment": "for all the classes , loads all properties from each class annotations for the given platform .", "label": "why"}
{"id": "26272", "raw_code": "public static Map<String,Object> createElectronicText(DispatchContext dctx,Map<String,? extends Object> context){\n  Map<String,Object> result=createElectronicTextMethod(dctx,context);\n  return result;\n}", "comment": "a service wrapper for the createelectronictextmethod method .", "label": "why"}
{"id": "7228", "raw_code": "public PatternGuardExpr(String namespace,String name,Expression[] parameters,PatternExpr guarded){\n  this(namespace,name,Arrays.asList(parameters),guarded);\n}", "comment": "ctor - for use to create a pattern expression tree , without pattern child expression .", "label": "why"}
{"id": "86992", "raw_code": "private String local_number() throws ParseException {\n  StringBuilder s=new StringBuilder();\n  if (debug)   dbg_enter(\"local_number\");\n  try {\n    int lc=0;\n    while (lexer.hasMoreChars()) {\n      char la=lexer.lookAhead(0);\n      if (la == '*' || la == '#' || la == '-' || la == '.' || la == '(' || la == ')' || Lexer.isHexDigit(la)) {\n        lexer.consume(1);\n        s.append(la);\n        lc++;\n      }\n else       if (lc > 0)       break;\n else       throw createParseException(\"unexepcted \" + la);\n    }\n    return s.toString();\n  }\n  finally {\n    if (debug)     dbg_leave(\"local_number\");\n  }\n}", "comment": "parser for the local phone # .", "label": "why"}
{"id": "14771", "raw_code": "public void registerCallbackHandler(SMSObjectListener changeListener) throws SMSException {\n  objectListener=changeListener;\n  if (!notificationInitialized) {\n    String notificationFlag=SystemProperties.get(NOTIFICATION_PROPERTY,\"true\");\n    if (notificationFlag.equalsIgnoreCase(\"true\")) {\n      try {\n        URL url=WebtopNaming.getNotificationURL();\n        PLLClient.addNotificationHandler(JAXRPCUtil.SMS_SERVICE,new SMSNotificationHandler());\n        client.send(\"registerNotificationURL\",url.toString(),null,null);\n        if (debug.messageEnabled()) {\n          debug.message(\"SMSJAXRPCObject: Using \" + \"notification mechanism for cache updates: \" + url);\n        }\n      }\n catch (      Exception e) {\n        if (debug.warningEnabled()) {\n          debug.warning(\"SMSJAXRPCObject: Registering for \" + \"notification via URL failed: \" + e.getMessage() + \"\\nUsing polling mechanism for updates\");\n        }\n        startPollingThreadIfEnabled(getCachePollingInterval());\n      }\n    }\n else {\n      startPollingThreadIfEnabled(getCachePollingInterval());\n    }\n    notificationInitialized=true;\n  }\n}", "comment": "registration for event change notifications .", "label": "why"}
{"id": "48550", "raw_code": "public Class<?> loadClass(String name,boolean resolve) throws ClassNotFoundException {\n  int i=name.lastIndexOf('.');\n  if (i != -1) {\n    SecurityManager sm=System.getSecurityManager();\n    if (sm != null) {\n      sm.checkPackageAccess(name.substring(0,i));\n    }\n  }\n  if (ucp.knownToNotExist(name)) {\n    Class<?> c=findLoadedClass(name);\n    if (c != null) {\n      if (resolve) {\n        resolveClass(c);\n      }\n      return c;\n    }\n    throw new ClassNotFoundException(name);\n  }\n  return (super.loadClass(name,resolve));\n}", "comment": "override loadclass so we can checkpackageaccess .", "label": "why"}
{"id": "33124", "raw_code": "Rules(Workspace workspace){\n  this.root=workspace.getRoot();\n  this.teamHook=workspace.getTeamHook();\n}", "comment": "creates a new scheduling rule factory for the given workspace", "label": "why"}
{"id": "650", "raw_code": "private static int indexOf(Object o,Object[] elements,int index,int fence){\n  if (o == null) {\n    for (int i=index; i < fence; i++)     if (elements[i] == null)     return i;\n  }\n else {\n    for (int i=index; i < fence; i++)     if (o.equals(elements[i]))     return i;\n  }\n  return -1;\n}", "comment": "static version of indexof , to allow repeated calls without needing to re - acquire array each time .", "label": "why"}
{"id": "3003", "raw_code": "private void startItemList(StringBuilder result,String rootId){\n  result.append(\"<div class=\\\"container\\\"\" + \"><div class=\\\"alone fakealone\\\" id=\\\"alone_ef_\" + rootId + \"\\\"></div><div class=\\\"justchildren fakejustchildren\\\">\");\n}", "comment": "called to start an item list .", "label": "why"}
{"id": "71226", "raw_code": "private void checkInteriorIntersections(){\n  for (Iterator i=segStrings.iterator(); i.hasNext(); ) {\n    SegmentString ss0=(SegmentString)i.next();\n    for (Iterator j=segStrings.iterator(); j.hasNext(); ) {\n      SegmentString ss1=(SegmentString)j.next();\n      checkInteriorIntersections(ss0,ss1);\n    }\n  }\n}", "comment": "checks all pairs of segments for intersections at an interior point of a segment", "label": "why"}
{"id": "50875", "raw_code": "public static String convertToJavaFieldName(String name){\n  int dotIndex=name.indexOf('.');\n  if (dotIndex >= 0) {\n    name=name.substring(0,dotIndex);\n  }\n  String[] split=name.split(\"[_-]\");\n  StringBuilder out=new StringBuilder();\n  boolean first=true;\n  for (  String section : split) {\n    if (first) {\n      first=false;\n      out.append(section);\n    }\n else {\n      out.append(StringUtil.capitalize(section));\n    }\n  }\n  return out.toString();\n}", "comment": "utility method to convert a variable name into java field name .", "label": "why"}
{"id": "59688", "raw_code": "protected void execute(String[] sqls,SQLiteDatabase db){\n  String throwSQL=\"\";\n  try {\n    if (sqls != null) {\n      for (      String sql : sqls) {\n        throwSQL=sql;\n        db.execSQL(BaseUtility.changeCase(sql));\n      }\n    }\n  }\n catch (  SQLException e) {\n    throw new DatabaseGenerateException(DatabaseGenerateException.SQL_ERROR + throwSQL);\n  }\n}", "comment": "use the parameter sqlitedatabase to execute the passing sqls .", "label": "why"}
{"id": "28835", "raw_code": "private void expand(int i){\n  if (count + i <= buf.length) {\n    return;\n  }\n  byte[] newbuf=mPool.getBuf((count + i) * 2);\n  System.arraycopy(buf,0,newbuf,0,count);\n  mPool.returnBuf(buf);\n  buf=newbuf;\n}", "comment": "ensures there is enough space in the buffer for the given number of additional bytes .", "label": "why"}
{"id": "79608", "raw_code": "private void clipViewOnTheRight(Rect curViewBound,float curViewWidth,int right){\n  curViewBound.right=(int)(right - mClipPadding);\n  curViewBound.left=(int)(curViewBound.right - curViewWidth);\n}", "comment": "set bounds for the right textview including clip padding .", "label": "why"}
{"id": "62286", "raw_code": "public ContentImpl createCompoundPackageContent(OleBlobImpl blob,String prettyName,String className,String typeName,ByteBuffer blobBb,int dataBlockLen){\n  return new CompoundContentImpl(blob,prettyName,className,typeName,blobBb.position(),dataBlockLen);\n}", "comment": "creates a nes compoundcontent for the given blob information .", "label": "why"}
{"id": "67750", "raw_code": "@Deprecated public void append(final String name,final String value){\n  List<String> l=map.get(name);\n  if (l != null) {\n    l.add(value);\n  }\n else {\n    l=Lists.newArrayList(value);\n    map.put(name,l);\n  }\n}", "comment": "add a new value for name", "label": "why"}
{"id": "5744", "raw_code": "public static Map<Object,Long> valueHistogram(GeoTimeSerie gts){\n  Map<Object,Long> occurrences=new HashMap<Object,Long>();\n  for (int i=0; i < gts.values; i++) {\n    Object value=GTSHelper.valueAtIndex(gts,i);\n    if (!occurrences.containsKey(value)) {\n      occurrences.put(value,1L);\n    }\n else {\n      occurrences.put(value,1L + occurrences.get(value));\n    }\n  }\n  if (GTSHelper.isBucketized(gts) && gts.bucketcount != gts.values) {\n    occurrences.put(null,(long)(gts.bucketcount - gts.values));\n  }\n  return occurrences;\n}", "comment": "build an occurrence count by value for the given time serie .", "label": "why"}
{"id": "5900", "raw_code": "protected void appendShortType(StringBuilder sb,FieldType fieldType,int fieldWidth){\n  sb.append(\"SMALLINT\");\n}", "comment": "output the sql type for a java short .", "label": "why"}
{"id": "30969", "raw_code": "public void initializeOwnerReferencesForField(StateManager sm,FieldMetaData fmd){\n  if (fmd.getAssociationType() == FieldMetaData.ONE_TO_MANY) {\n    Collection<?> collection=(Collection<?>)sm.fetch(fmd.getIndex());\n    if (collection != null) {\n      for (      Object item : collection) {\n        if (item != null) {\n          _relationsManager.setOwnerStateManagerForPersistentInstance(item,sm,fmd);\n        }\n      }\n    }\n  }\n else   if (fmd.getAssociationType() == FieldMetaData.ONE_TO_ONE || fmd.isEmbeddedPC()) {\n    Object value=sm.fetch(fmd.getIndex());\n    if (value != null) {\n      _relationsManager.setOwnerStateManagerForPersistentInstance(value,sm,fmd);\n    }\n  }\n}", "comment": "sets the provided state manager as the owner for the provided field value .", "label": "why"}
{"id": "60001", "raw_code": "public static String generateHostName(String vmName,String hostId){\n  String hostname=vmName + '-' + hostId;\n  Preconditions.checkState(hostname.equals(hostname.toLowerCase()),\"hostname should not contain upper case characters\");\n  return hostname;\n}", "comment": "generates the hostname for a node .", "label": "why"}
{"id": "53695", "raw_code": "public static void overScrollBy(final PullToRefreshBase<?> view,final int deltaX,final int scrollX,final int deltaY,final int scrollY,final int scrollRange,final int fuzzyThreshold,final float scaleFactor,final boolean isTouchEvent){\n  final int deltaValue, currentScrollValue, scrollValue;\nswitch (view.getPullToRefreshScrollDirection()) {\ncase HORIZONTAL:\n    deltaValue=deltaX;\n  scrollValue=scrollX;\ncurrentScrollValue=view.getScrollX();\nbreak;\ncase VERTICAL:\ndefault :\ndeltaValue=deltaY;\nscrollValue=scrollY;\ncurrentScrollValue=view.getScrollY();\nbreak;\n}\nif (view.isPullToRefreshOverScrollEnabled() && !view.isRefreshing()) {\nfinal Mode mode=view.getMode();\nif (mode.permitsPullToRefresh() && !isTouchEvent && deltaValue != 0) {\nfinal int newScrollValue=(deltaValue + scrollValue);\nif (PullToRefreshBase.DEBUG) {\nLog.d(LOG_TAG,\"OverScroll. DeltaX: \" + deltaX + \", ScrollX: \"+ scrollX+ \", DeltaY: \"+ deltaY+ \", ScrollY: \"+ scrollY+ \", NewY: \"+ newScrollValue+ \", ScrollRange: \"+ scrollRange+ \", CurrentScroll: \"+ currentScrollValue);\n}\nif (newScrollValue < (0 - fuzzyThreshold)) {\nif (mode.showHeaderLoadingLayout()) {\nif (currentScrollValue == 0) {\nview.setState(State.OVERSCROLLING);\n}\nview.setHeaderScroll((int)(scaleFactor * (currentScrollValue + newScrollValue)));\n}\n}\n else if (newScrollValue > (scrollRange + fuzzyThreshold)) {\nif (mode.showFooterLoadingLayout()) {\nif (currentScrollValue == 0) {\nview.setState(State.OVERSCROLLING);\n}\nview.setHeaderScroll((int)(scaleFactor * (currentScrollValue + newScrollValue - scrollRange)));\n}\n}\n else if (Math.abs(newScrollValue) <= fuzzyThreshold || Math.abs(newScrollValue - scrollRange) <= fuzzyThreshold) {\nview.setState(State.RESET);\n}\n}\n else if (isTouchEvent && State.OVERSCROLLING == view.getState()) {\nview.setState(State.RESET);\n}\n}\n}", "comment": "helper method for overscrolling that encapsulates all of the necessary function .", "label": "why"}
{"id": "33186", "raw_code": "private int createLines(String text,int insertPosition,int offset){\n  int count=0;\n  int start=0;\n  DelimiterInfo delimiterInfo=nextDelimiterInfo(text,0);\n  while (delimiterInfo != null && delimiterInfo.delimiterIndex > -1) {\n    int index=delimiterInfo.delimiterIndex + (delimiterInfo.delimiterLength - 1);\n    if (insertPosition + count >= fLines.size())     fLines.add(new Line(offset + start,offset + index,delimiterInfo.delimiter));\n else     fLines.add(insertPosition + count,new Line(offset + start,offset + index,delimiterInfo.delimiter));\n    ++count;\n    start=index + 1;\n    delimiterInfo=nextDelimiterInfo(text,start);\n  }\n  if (start < text.length()) {\n    if (insertPosition + count < fLines.size()) {\n      Line l=(Line)fLines.get(insertPosition + count);\n      int delta=text.length() - start;\n      l.offset-=delta;\n      l.length+=delta;\n    }\n else {\n      fLines.add(new Line(offset + start,offset + text.length() - 1,null));\n      ++count;\n    }\n  }\n  return count;\n}", "comment": "creates the line structure for the given text .", "label": "why"}
{"id": "78759", "raw_code": "void deregisterSpring(Spring spring){\n  if (spring == null) {\n    throw new IllegalArgumentException(\"spring is required\");\n  }\n  mActiveSprings.remove(spring);\n  mSpringRegistry.remove(spring.getId());\n}", "comment": "deregisters a spring from this basespringsystem , so it won ' t be iterated anymore .", "label": "why"}
{"id": "51812", "raw_code": "private void stretchViewVertically(View view,int crossSize){\n  LayoutParams lp=(LayoutParams)view.getLayoutParams();\n  int newHeight=crossSize - lp.topMargin - lp.bottomMargin;\n  newHeight=Math.max(newHeight,0);\n  view.measure(MeasureSpec.makeMeasureSpec(view.getMeasuredWidth(),MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(newHeight,MeasureSpec.EXACTLY));\n}", "comment": "expand the view vertically to the size of the crosssize ( considering the view margins )", "label": "why"}
{"id": "36283", "raw_code": "protected Date compute(double value){\n  if (Double.isNaN(value)) {\n    return null;\n  }\n  long dateLong=(long)value;\n  Date date=new Date(dateLong);\n  Calendar cal=Calendar.getInstance();\n  cal.setTime(date);\n  return cal.getTime();\n}", "comment": "computes the result for one input double value .", "label": "why"}
{"id": "31039", "raw_code": "public static String arrayToDelimitedString(Object[] arr,String delim){\n  if (arr == null) {\n    return \"\";\n  }\n  StringBuffer sb=new StringBuffer();\n  for (int i=0; i < arr.length; i++) {\n    if (i > 0) {\n      sb.append(delim);\n    }\n    sb.append(arr[i]);\n  }\n  return sb.toString();\n}", "comment": "convenience method to return a string array as a delimited ( e . g . csv ) string .", "label": "why"}
{"id": "59762", "raw_code": "private void fitImageToView(){\n  Drawable drawable=getDrawable();\n  if (drawable == null || drawable.getIntrinsicWidth() == 0 || drawable.getIntrinsicHeight() == 0) {\n    return;\n  }\n  if (matrix == null || prevMatrix == null) {\n    return;\n  }\n  int drawableWidth=drawable.getIntrinsicWidth();\n  int drawableHeight=drawable.getIntrinsicHeight();\n  float scaleX=(float)viewWidth / drawableWidth;\n  float scaleY=(float)viewHeight / drawableHeight;\nswitch (mScaleType) {\ncase CENTER:\n    scaleX=scaleY=1;\n  break;\ncase CENTER_CROP:\nscaleX=scaleY=Math.max(scaleX,scaleY);\nbreak;\ncase CENTER_INSIDE:\nscaleX=scaleY=Math.min(1,Math.min(scaleX,scaleY));\ncase FIT_CENTER:\nscaleX=scaleY=Math.min(scaleX,scaleY);\nbreak;\ncase FIT_XY:\nbreak;\ndefault :\nthrow new UnsupportedOperationException(\"TouchImageView does not support FIT_START or FIT_END\");\n}\nfloat redundantXSpace=viewWidth - (scaleX * drawableWidth);\nfloat redundantYSpace=viewHeight - (scaleY * drawableHeight);\nmatchViewWidth=viewWidth - redundantXSpace;\nmatchViewHeight=viewHeight - redundantYSpace;\nif (!isZoomed() && !imageRenderedAtLeastOnce) {\nmatrix.setScale(scaleX,scaleY);\nmatrix.postTranslate(redundantXSpace / 2,redundantYSpace / 2);\nnormalizedScale=1;\n}\n else {\nif (prevMatchViewWidth == 0 || prevMatchViewHeight == 0) {\nsavePreviousImageValues();\n}\nprevMatrix.getValues(m);\nm[Matrix.MSCALE_X]=matchViewWidth / drawableWidth * normalizedScale;\nm[Matrix.MSCALE_Y]=matchViewHeight / drawableHeight * normalizedScale;\nfloat transX=m[Matrix.MTRANS_X];\nfloat transY=m[Matrix.MTRANS_Y];\nfloat prevActualWidth=prevMatchViewWidth * normalizedScale;\nfloat actualWidth=getImageWidth();\ntranslateMatrixAfterRotate(Matrix.MTRANS_X,transX,prevActualWidth,actualWidth,prevViewWidth,viewWidth,drawableWidth);\nfloat prevActualHeight=prevMatchViewHeight * normalizedScale;\nfloat actualHeight=getImageHeight();\ntranslateMatrixAfterRotate(Matrix.MTRANS_Y,transY,prevActualHeight,actualHeight,prevViewHeight,viewHeight,drawableHeight);\nmatrix.setValues(m);\n}\nfixTrans();\nsetImageMatrix(matrix);\n}", "comment": "if the normalizedscale is equal to 1 , then the image is made to fit the screen .", "label": "why"}
{"id": "720", "raw_code": "public void limit(double x1,double y1,double x2,double y2){\n  clip[0]=Math.max(clip[0],x1);\n  clip[1]=Math.max(clip[1],y1);\n  clip[6]=Math.min(clip[6],x2);\n  clip[7]=Math.min(clip[7],y2);\n}", "comment": "limit the clip such that it fits within the specified region .", "label": "why"}
{"id": "78109", "raw_code": "void calculateCounters(){\n  if (!isDBAvailable())   return;\n  long time=System.currentTimeMillis();\n  int total=0;\n  write.lock();\n  try {\n    countResetFeedsAndCategories();\n    total+=countFeedsWithUnread();\n    countCategoriesWithUnread();\n    countSpecialCategories(total);\n  }\n  finally {\n    write.unlock();\n  }\n  Log.i(TAG,String.format(\"Recalculated counters, total unread: %s (took %sms)\",total,(System.currentTimeMillis() - time)));\n}", "comment": "set unread counters for feeds and categories according to real amount of unread articles .", "label": "why"}
{"id": "21798", "raw_code": "protected Workflow.Method createRemoveVolumesFromCGMethod(URI vplexURI,URI cgURI,List<URI> vplexVolumeURIs){\n  return new Workflow.Method(REMOVE_VOLUMES_FROM_CG_STEP,vplexURI,cgURI,vplexVolumeURIs);\n}", "comment": "a method that creates the workflow method for removing vplex volumes from a consistency group .", "label": "why"}
{"id": "23902", "raw_code": "public void unlockForClear(InternalDistributedMember locker){\nsynchronized (this.clearLockSync) {\n    InternalDistributedSystem instance=InternalDistributedSystem.getAnyInstance();\n    if (instance != null && logger.isDebugEnabled()) {\n      logger.debug(\"Unlocking for clear, from member {} RVV {}\",locker,System.identityHashCode(this));\n    }\n    if (this.lockOwner != null && !locker.equals(this.lockOwner)) {\n      if (instance != null && logger.isDebugEnabled()) {\n        logger.debug(\"current clear lock owner was {} not unlocking\",lockOwner);\n      }\n      return;\n    }\n    unlockVersionGeneration(locker);\n  }\n}", "comment": "unlocks version generation for clear ( ) operations", "label": "why"}
{"id": "11145", "raw_code": "public void move(MouseEvent e){\n  Point2D pnt=getProjectionPoint(e);\n  int x=(int)pnt.getX();\n  int y=(int)pnt.getY();\n  if (poly.getRenderType() == OMGraphic.RENDERTYPE_OFFSET) {\n    gpm=new OffsetGrabPoint(x,y);\n    gpm.clear();\n  }\n else {\n    gpm=gpo;\n    gpm.clear();\n    gpm.set(x,y);\n  }\n  addPolyGrabPointsToOGP(gpm);\n  movingPoint=gpm;\n}", "comment": "called to set the offsetgrabpoint to the current mouse location , and update the offsetgrabpoint with all the other grabpoint locations , so everything can shift smoothly .", "label": "why"}
{"id": "10164", "raw_code": "public static String gensalt(int log_rounds,SecureRandom random){\n  StringBuffer rs=new StringBuffer();\n  byte rnd[]=new byte[BCRYPT_SALT_LEN];\n  random.nextBytes(rnd);\n  rs.append(\"$2a$\");\n  if (log_rounds < 10) {\n    rs.append(\"0\");\n  }\n  if (log_rounds > 30) {\n    throw new IllegalArgumentException(\"log_rounds exceeds maximum (30)\");\n  }\n  rs.append(Integer.toString(log_rounds));\n  rs.append(\"$\");\n  rs.append(encode_base64(rnd,rnd.length));\n  return rs.toString();\n}", "comment": "generate a salt for use with the bcrypt . hashpw ( ) method .", "label": "why"}
{"id": "45390", "raw_code": "private static String doNormalize(String filename,char separator,boolean keepSeparator){\n  if (filename == null) {\n    return null;\n  }\n  int size=filename.length();\n  if (size == 0) {\n    return filename;\n  }\n  int prefix=getPrefixLength(filename);\n  if (prefix < 0) {\n    return null;\n  }\n  char[] array=new char[size + 2];\n  filename.getChars(0,filename.length(),array,0);\n  char otherSeparator=separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR;\n  for (int i=0; i < array.length; i++) {\n    if (array[i] == otherSeparator) {\n      array[i]=separator;\n    }\n  }\n  boolean lastIsDirectory=true;\n  if (array[size - 1] != separator) {\n    array[size++]=separator;\n    lastIsDirectory=false;\n  }\n  for (int i=prefix + 1; i < size; i++) {\n    if (array[i] == separator && array[i - 1] == separator) {\n      System.arraycopy(array,i,array,i - 1,size - i);\n      size--;\n      i--;\n    }\n  }\n  for (int i=prefix + 1; i < size; i++) {\n    if (array[i] == separator && array[i - 1] == '.' && (i == prefix + 1 || array[i - 2] == separator)) {\n      if (i == size - 1) {\n        lastIsDirectory=true;\n      }\n      System.arraycopy(array,i + 1,array,i - 1,size - i);\n      size-=2;\n      i--;\n    }\n  }\n  outer:   for (int i=prefix + 2; i < size; i++) {\n    if (array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' && (i == prefix + 2 || array[i - 3] == separator)) {\n      if (i == prefix + 2) {\n        return null;\n      }\n      if (i == size - 1) {\n        lastIsDirectory=true;\n      }\n      int j;\n      for (j=i - 4; j >= prefix; j--) {\n        if (array[j] == separator) {\n          System.arraycopy(array,i + 1,array,j + 1,size - i);\n          size-=i - j;\n          i=j + 1;\n          continue outer;\n        }\n      }\n      System.arraycopy(array,i + 1,array,prefix,size - i);\n      size-=i + 1 - prefix;\n      i=prefix + 1;\n    }\n  }\n  if (size <= 0) {\n    return \"\";\n  }\n  if (size <= prefix) {\n    return new String(array,0,size);\n  }\n  if (lastIsDirectory && keepSeparator) {\n    return new String(array,0,size);\n  }\n  return new String(array,0,size - 1);\n}", "comment": "internal method to perform the normalization .", "label": "why"}
{"id": "43987", "raw_code": "private void insertUsedContextPrefixes(){\n  int unknownPrefixesCount=unknownPrefixesInXMLLiteral.size();\n  if (unknownPrefixesCount > 0) {\n    StringBuilder contextPrefixes=new StringBuilder(1024);\n    ElementInfo topElement=peekStack();\n    for (int i=0; i < unknownPrefixesCount; i++) {\n      String prefix=unknownPrefixesInXMLLiteral.get(i);\n      String namespace=topElement.getNamespace(prefix);\n      if (namespace != null) {\n        appendNamespaceDecl(contextPrefixes,prefix,namespace);\n      }\n    }\n    int endOfFirstStartTag=charBuf.indexOf(\">\");\n    charBuf.insert(endOfFirstStartTag,contextPrefixes.toString());\n  }\n  unknownPrefixesInXMLLiteral.clear();\n}", "comment": "inserts prefix mappings from an xml literal ' s context for all prefixes that are used in the xml literal and that are not defined in the xml literal itself .", "label": "why"}
{"id": "83784", "raw_code": "public static List<Integer> precomputeHashes(byte[] data,long tweak){\n  ArrayList<Integer> list=new ArrayList<>(MAX_HASH_FUNCS);\n  for (int i=0; i < MAX_HASH_FUNCS; ++i) {\n    list.add(murmurhash3bit(i,data,tweak));\n  }\n  return list;\n}", "comment": "precompute hashes used to set mask bits for a data .", "label": "why"}
{"id": "46877", "raw_code": "ObservedObject createObservedObject(ObjectName object){\n  return new ObservedObject(object);\n}", "comment": "factory method for observedobject creation .", "label": "why"}
{"id": "15505", "raw_code": "private void saveInitialChildState(FacesContext facesContext,UIComponent component){\n  if (component instanceof EditableValueHolder && !component.isTransient()) {\n    String clientId=component.getClientId(facesContext);\n    SavedState state=new SavedState();\n    initialChildState.put(clientId,state);\n    state.populate((EditableValueHolder)component);\n  }\n  Iterator<UIComponent> iterator=component.getFacetsAndChildren();\n  while (iterator.hasNext()) {\n    saveChildState(facesContext,iterator.next());\n  }\n}", "comment": "recursively create the initial state for the given component .", "label": "why"}
{"id": "73165", "raw_code": "public void addPreferencesButton(){\n  JButton prefsButton=new JButton(\"Prefs\");\n  prefsButton.setHideActionText(true);\n  prefsButton.setAction(RasterPlotActions.getPropertiesDialogAction(this));\n  buttonPanel.add(prefsButton);\n}", "comment": "add button for showing preferences .", "label": "why"}
{"id": "75708", "raw_code": "public static GenericObjectEditorDialog createDialog(Container parent){\n  return createDialog(parent,null);\n}", "comment": "creates a modal dialog for the parent .", "label": "why"}
{"id": "42266", "raw_code": "public static void runFinalization(){\n  RUNTIME.runFinalization();\n}", "comment": "provides a hint to the virtual machine that it would be useful to attempt to perform any outstanding object finalizations .", "label": "why"}
{"id": "74050", "raw_code": "@Override public void clearRouteSensors(){\n  _controlSensorList=new ArrayList<>();\n}", "comment": "method to delete all control sensors from this route", "label": "why"}
{"id": "48133", "raw_code": "@Override public boolean equals(Object obj){\n  if (this == obj)   return true;\n  if (!(obj instanceof PrincipalEntry))   return false;\n  PrincipalEntry that=(PrincipalEntry)obj;\n  return (principalClass.equals(that.principalClass) && principalName.equals(that.principalName));\n}", "comment": "test for equality between the specified object and this object .", "label": "why"}
{"id": "76602", "raw_code": "public boolean isValidLockdownProfile(){\n  try {\n    return true;\n  }\n catch (  IllegalArgumentException e) {\n    Log.w(TAG,\"Invalid address\",e);\n    return false;\n  }\n}", "comment": "test if profile is valid for lockdown , which requires ipv4 address for both server and dns .", "label": "why"}
{"id": "7238", "raw_code": "public FromClause(Stream streamOne,OuterJoinQualifier outerJoinQualifier,Stream streamTwo){\n  this(streamOne);\n  add(streamTwo);\n  outerJoinQualifiers.add(outerJoinQualifier);\n}", "comment": "ctor for an outer join between two streams .", "label": "why"}
{"id": "34941", "raw_code": "private static InputStream nullInputStream() throws NullPointerException {\n  if (currentTimeMillis() > 0) {\n    return null;\n  }\n  throw new NullPointerException();\n}", "comment": "the following two methods exist because in , out , and err must be initialized to null .", "label": "why"}
{"id": "9092", "raw_code": "private static void deleteRules(List<String> batchList,List<Rule> rulesToDelete){\n  String deleteStatement=\"DELETE FROM \" + RULES_TABLE + \" WHERE RULE_INTERNAL_ID=%d\";\n  for (  Rule rule : rulesToDelete) {\n    batchList.add(String.format(deleteStatement,rule.getUid()));\n  }\n}", "comment": "the sql commands to be added to the batchlist for deleting the rules in rulestodelete .", "label": "why"}
{"id": "16666", "raw_code": "public List<StructuredTranslation> KbestExtractOnHG(HyperGraph hg,int topN){\n  resetState();\n  if (hg == null || hg.goalNode == null) {\n    return emptyList();\n  }\n  final List<StructuredTranslation> kbest=new ArrayList<>(topN);\n  for (int k=1; k <= topN; k++) {\n    StructuredTranslation translation=getKthStructuredTranslation(hg.goalNode,k);\n    if (translation == null) {\n      break;\n    }\n    kbest.add(translation);\n  }\n  return kbest;\n}", "comment": "this is an entry point for extracting k - best hypotheses as structuredtranslation objects .", "label": "why"}
{"id": "53170", "raw_code": "public static double quantile(double p,double alpha,double beta){\n  if (Double.isNaN(alpha) || Double.isNaN(beta) || Double.isNaN(p)|| alpha < 0. || beta < 0.) {\n    return Double.NaN;\n  }\n  if (p < 0 || p > 1) {\n    return Double.NaN;\n  }\n  if (p == 0) {\n    return 0.0;\n  }\n  if (p == 1) {\n    return 1.0;\n  }\n  if (p > 0.5) {\n    return 1 - rawQuantile(1 - p,beta,alpha,logBeta(beta,alpha));\n  }\n else {\n    return rawQuantile(p,alpha,beta,logBeta(alpha,beta));\n  }\n}", "comment": "compute quantile ( inverse cdf ) for beta distributions .", "label": "why"}
{"id": "50240", "raw_code": "private List<Header> defaultHeaders(){\n  DateFormat dateFormat=new SimpleDateFormat(\"EEE, dd mmm yyyy HH:mm:ss zzz\");\n  List<Header> headers=new ArrayList<>();\n  headers.add(new BasicHeader(\"Date\",dateFormat.format(new Date())));\n  return headers;\n}", "comment": "create default headers for server response .", "label": "why"}
{"id": "1666", "raw_code": "@Override protected void before() throws Throwable {\n  previousThreads=Thread.getAllStackTraces();\n}", "comment": "override to set up your specific external resource .", "label": "why"}
{"id": "81978", "raw_code": "public static String encodeUrl(final String str){\n  return encode(str,\"%20\");\n}", "comment": "encode a string for html requests", "label": "why"}
{"id": "44772", "raw_code": "private boolean processKeyUp(int keyCode){\n  if (keyCode == KeyEvent.KEYCODE_ESCAPE || keyCode == KeyEvent.KEYCODE_BACK) {\n    dismiss();\n    return true;\n  }\n else   if (keyCode == KeyEvent.KEYCODE_TAB) {\n    if (mInKbMode) {\n      if (isTypedTimeFullyLegal()) {\n        finishKbMode(true);\n      }\n      return true;\n    }\n  }\n else   if (keyCode == KeyEvent.KEYCODE_ENTER) {\n    if (mInKbMode) {\n      if (!isTypedTimeFullyLegal()) {\n        return true;\n      }\n      finishKbMode(false);\n    }\n    if (mCallback != null) {\n      mCallback.onTimeSet(mTimePicker,mTimePicker.getHours(),mTimePicker.getMinutes());\n    }\n    dismiss();\n    return true;\n  }\n else   if (keyCode == KeyEvent.KEYCODE_DEL) {\n    if (mInKbMode) {\n      if (!mTypedTimes.isEmpty()) {\n        int deleted=deleteLastTypedKey();\n        String deletedKeyStr;\n        if (deleted == getAmOrPmKeyCode(AM)) {\n          deletedKeyStr=mAmText;\n        }\n else         if (deleted == getAmOrPmKeyCode(PM)) {\n          deletedKeyStr=mPmText;\n        }\n else {\n          deletedKeyStr=String.format(\"%d\",getValFromKeyCode(deleted));\n        }\n        Utils.tryAccessibilityAnnounce(mTimePicker,String.format(mDeletedKeyFormat,deletedKeyStr));\n        updateDisplay(true);\n      }\n    }\n  }\n else   if (keyCode == KeyEvent.KEYCODE_0 || keyCode == KeyEvent.KEYCODE_1 || keyCode == KeyEvent.KEYCODE_2 || keyCode == KeyEvent.KEYCODE_3 || keyCode == KeyEvent.KEYCODE_4 || keyCode == KeyEvent.KEYCODE_5 || keyCode == KeyEvent.KEYCODE_6 || keyCode == KeyEvent.KEYCODE_7 || keyCode == KeyEvent.KEYCODE_8 || keyCode == KeyEvent.KEYCODE_9 || (!mIs24HourMode && (keyCode == getAmOrPmKeyCode(AM) || keyCode == getAmOrPmKeyCode(PM)))) {\n    if (!mInKbMode) {\n      if (mTimePicker == null) {\n        Log.e(TAG,\"Unable to initiate keyboard mode, TimePicker was null.\");\n        return true;\n      }\n      mTypedTimes.clear();\n      tryStartingKbMode(keyCode);\n      return true;\n    }\n    if (addKeyIfLegal(keyCode)) {\n      updateDisplay(false);\n    }\n    return true;\n  }\n  return false;\n}", "comment": "for keyboard mode , processes key events .", "label": "why"}
{"id": "71005", "raw_code": "private Parameters(){\n  for (Iterator i=arguments.iterator(); i.hasNext(); ) {\n    String arg=(String)i.next();\n    arg=arg.toLowerCase();\n    if (!arg.startsWith(\"-\"))     throw new IllegalArgumentException(\"Command-line argument does not start with '-': \" + arg);\n    int colonIndex=arg.indexOf(\":\");\n    String key;\n    String value;\n    if (colonIndex >= 0) {\n      key=arg.substring(1,colonIndex);\n      value=arg.substring(colonIndex + 1);\n    }\n else {\n      key=arg.substring(1);\n      value=\"\";\n    }\n    if (!allowedKeys.contains(key))     throw new IllegalArgumentException(\"Unrecognized command-line argument: \" + arg.substring(1) + \". Valid arguments are: \"+ StringUtil.toCommaDelimitedString(allowedKeys));\n    hashtable.put(key,value);\n  }\n  for (Iterator i=requiredKeys.iterator(); i.hasNext(); ) {\n    String requiredKey=(String)i.next();\n    if (!hashtable.containsKey(requiredKey))     throw new IllegalArgumentException(\"Required command-line argument is missing: \" + requiredKey);\n  }\n}", "comment": "creates a parameters object for the given main - method arguments .", "label": "why"}
{"id": "22337", "raw_code": "private void writeAttribute(java.lang.String prefix,java.lang.String namespace,java.lang.String attName,java.lang.String attValue,javax.xml.stream.XMLStreamWriter xmlWriter) throws javax.xml.stream.XMLStreamException {\n  if (xmlWriter.getPrefix(namespace) == null) {\n    xmlWriter.writeNamespace(prefix,namespace);\n    xmlWriter.setPrefix(prefix,namespace);\n  }\n  xmlWriter.writeAttribute(namespace,attName,attValue);\n}", "comment": "util method to write an attribute with the ns prefix", "label": "why"}
{"id": "83748", "raw_code": "public ModbusTransaction createTransaction(){\n  ModbusSerialTransaction transaction=new ModbusSerialTransaction();\n  transaction.setTransport(this);\n  return transaction;\n}", "comment": "creates a new transaction suitable for the serial port", "label": "why"}
{"id": "6625", "raw_code": "public void updateUI(){\n  super.updateUI();\n  setBackground(new Color(255,255,255,0));\n  setWrapStyleWord(true);\n  setHighlighter(null);\n  setEditable(false);\n  LookAndFeel.installBorder(this,\"Label.border\");\n  LookAndFeel.installColorsAndFont(this,\"Label.background\",\"Label.foreground\",\"Label.font\");\n  if (resizeHandler != null) {\n    resizeHandler.componentResized(null);\n  }\n  SizePolicy policy=(SizePolicy)getClientProperty(SizePolicy.class);\n  if (policy != null) {\n    GUIUtils.restrictSize(this,policy);\n  }\n}", "comment": "tells the look and feel to reset some of the values for this component so that it doesn ' t use jtextarea ' s default values .", "label": "why"}
{"id": "19958", "raw_code": "public synchronized Future<V> submit(Callable<V> task) throws RejectedExecutionException {\n  return pool.submit(task);\n}", "comment": "submits a task for execution .", "label": "why"}
{"id": "31396", "raw_code": "private void copyAction(File srcFile,File destFile) throws FileNotFoundException, IOException {\n  FileInputStream istream=new FileInputStream(srcFile);\n  FileOutputStream ostream=new FileOutputStream(destFile);\n  FileChannel input=istream.getChannel();\n  FileChannel output=ostream.getChannel();\n  try {\n    input.transferTo(0,input.size(),output);\n  }\n  finally {\n    istream.close();\n    ostream.close();\n    input.close();\n    output.close();\n  }\n}", "comment": "moved this code into it ' s own method so moveto could use it when the move is across file systems", "label": "why"}
{"id": "36443", "raw_code": "public void addProcessInteractionListener(final ProcessInteractionListener l){\n  if (l == null) {\n    throw new IllegalArgumentException(\"l must not be null!\");\n  }\n  processInteractionListeners.add(l);\n}", "comment": "adds a listener that will be informed when the user right - clicks an operator or a port .", "label": "why"}
{"id": "74464", "raw_code": "public CommonTurnoutOperationConfig(TurnoutOperation op){\n  super(op);\n  myOp=(CommonTurnoutOperation)op;\n  maxTriesSpinner=new JSpinner();\n  intervalSpinner=new JSpinner();\n  Box vbox=Box.createVerticalBox();\n  Box hbox1=Box.createHorizontalBox();\n  Box hbox2=Box.createHorizontalBox();\n  vbox.add(hbox2);\n  vbox.add(hbox1);\n  vbox.add(Box.createVerticalGlue());\n  hbox1.add(new JLabel(Bundle.getMessage(\"Interval\")));\n  hbox1.add(Box.createHorizontalGlue());\n  intervalSpinner.setMinimumSize(new Dimension(100,20));\n  intervalSpinner.setModel(new SpinnerNumberModel(myOp.getInterval(),CommonTurnoutOperation.minInterval,CommonTurnoutOperation.maxInterval,CommonTurnoutOperation.intervalStepSize));\n  hbox1.add(intervalSpinner);\n  hbox2.add(new JLabel(Bundle.getMessage(\"TimesToTry\")));\n  hbox2.add(Box.createHorizontalGlue());\n  maxTriesSpinner.setMinimumSize(new Dimension(100,20));\n  maxTriesSpinner.setModel(new SpinnerNumberModel(myOp.getMaxTries(),CommonTurnoutOperation.minMaxTries,CommonTurnoutOperation.maxMaxTries,1));\n  hbox2.add(maxTriesSpinner);\n  Box hbox3=Box.createHorizontalBox();\n  hbox3.add(Box.createHorizontalStrut(150));\n  vbox.add(hbox3);\n  add(vbox);\n}", "comment": "create the config jpanel , if there is one , to configure this operation type", "label": "why"}
{"id": "18", "raw_code": "public static String gensalt(int log_rounds,SecureRandom random){\n  if (log_rounds < 4 || log_rounds > 31) {\n    throw new IllegalArgumentException(\"Bad number of rounds\");\n  }\n  StringBuilder rs=new StringBuilder();\n  byte rnd[]=new byte[BCRYPT_SALT_LEN];\n  random.nextBytes(rnd);\n  rs.append(\"$2a$\");\n  if (log_rounds < 10) {\n    rs.append(\"0\");\n  }\n  rs.append(log_rounds);\n  rs.append(\"$\");\n  encode_base64(rnd,rnd.length,rs);\n  return rs.toString();\n}", "comment": "generate a salt for use with the bcrypt . hashpw ( ) method", "label": "why"}
{"id": "69621", "raw_code": "public Channel chan(final String topic,final JsonNode payload){\n  LOG.log(Level.FINE,\"chan: {0}, {1}\",new Object[]{topic,payload});\n  final Channel channel=new Channel(topic,payload,Socket.this);\nsynchronized (channels) {\n    channels.add(channel);\n  }\n  return channel;\n}", "comment": "retrieve a channel instance for the specified topic", "label": "why"}
{"id": "31779", "raw_code": "private void addDefaultUri() throws IgniteSpiException {\n  assert uriEncodedList != null;\n  URI uri;\n  try {\n    uri=U.resolveWorkDirectory(DFLT_DEPLOY_DIR,false).toURI();\n  }\n catch (  IgniteCheckedException e) {\n    throw new IgniteSpiException(\"Failed to initialize default file scanner\",e);\n  }\n  uriEncodedList.add(uri);\n}", "comment": "add configuration for file scanner .", "label": "why"}
{"id": "52074", "raw_code": "public PartialCorrelationPdf(int n,int k){\n  this.n=n;\n  this.k=k;\n  double gammaRatio=gammaRatio(n,k);\n  this.constant=(1 / Math.pow(Math.PI,0.5)) * gammaRatio;\n  this.outsideExp=(double)(n - k - 2) / 2.0;\n}", "comment": "constructs a new zero partial correlation distribution function with the given values for n and k .", "label": "why"}
{"id": "52340", "raw_code": "protected void load_raw_characters(StringBuilder sb) throws IOException {\n  int c=read_char();\n  for (; ; ) {\n    c=read_char();\nswitch (c) {\ncase CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:\ncase CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:\ncase CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:\n      continue;\ncase -1:\n    return;\ndefault :\n  if (!IonTokenConstsX.is7bitValue(c)) {\n    c=read_large_char_sequence(c);\n  }\n}\nif (IonUTF8.needsSurrogateEncoding(c)) {\nsb.append(IonUTF8.highSurrogate(c));\nc=IonUTF8.lowSurrogate(c);\n}\nsb.append((char)c);\n}\n}", "comment": "this is used to load a previously marked set of bytes into the stringbuilder without escaping .", "label": "why"}
{"id": "22358", "raw_code": "private void writeAttribute(java.lang.String namespace,java.lang.String attName,java.lang.String attValue,javax.xml.stream.XMLStreamWriter xmlWriter) throws javax.xml.stream.XMLStreamException {\n  if (namespace.equals(\"\")) {\n    xmlWriter.writeAttribute(attName,attValue);\n  }\n else {\n    registerPrefix(xmlWriter,namespace);\n    xmlWriter.writeAttribute(namespace,attName,attValue);\n  }\n}", "comment": "util method to write an attribute without the ns prefix", "label": "why"}
{"id": "11337", "raw_code": "public void removeVetoableChangeListener(String propertyName,VetoableChangeListener in_vcl){\n  beanContextChildSupport.removeVetoableChangeListener(propertyName,in_vcl);\n}", "comment": "method for beancontextchild interface .", "label": "why"}
{"id": "36711", "raw_code": "protected void drawCylinder(int x,int y,int w,int h,Color fillColor,Paint fillPaint,Color penColor,boolean isShadow){\n  int h4=h / 4;\n  int r=w - 1;\n  if (fillColor != null || fillPaint != null) {\n    Area area=new Area(new Rectangle(x,y + h4 / 2,r,h - h4));\n    area.add(new Area(new Rectangle(x,y + h4 / 2,r,h - h4)));\n    area.add(new Area(new Ellipse2D.Double(x,y,r,h4)));\n    area.add(new Area(new Ellipse2D.Double(x,y + h - h4,r,h4)));\n    if (isShadow) {\n      g.setColor(mxConstants.SHADOW_COLOR);\n      g.translate(mxConstants.SHADOW_OFFSETX,mxConstants.SHADOW_OFFSETY);\n      g.fill(area);\n      g.translate(-mxConstants.SHADOW_OFFSETX,-mxConstants.SHADOW_OFFSETY);\n    }\n    if (fillPaint != null) {\n      g.setPaint(fillPaint);\n    }\n else {\n      g.setColor(fillColor);\n    }\n    g.fill(area);\n  }\n  if (penColor != null) {\n    g.setColor(penColor);\n    int h2=h4 / 2;\n    g.drawOval(x,y,r,h4);\n    g.drawLine(x,y + h2,x,y + h - h2);\n    g.drawLine(x + w - 1,y + h2,x + w - 1,y + h - h2);\n    g.drawArc(x,y + h - h4,r,h4,0,-180);\n  }\n}", "comment": "draws a cylinder for the given parameters .", "label": "why"}
{"id": "60326", "raw_code": "private static boolean eq(Object o1,Object o2){\n  return o1 == null ? o2 == null : o1.equals(o2);\n}", "comment": "test for equality , coping with nulls .", "label": "why"}
{"id": "75785", "raw_code": "public static double P_AveragePrecision(int y[],int r[]){\n  double avg_prec=0;\n  int L=y.length;\n  List<Integer> ones=new ArrayList<Integer>();\n  for (int j=0; j < L; j++) {\n    if (y[j] == 1) {\n      ones.add(j);\n    }\n  }\n  if (ones.size() <= 0)   return 1.0;\n  for (  int j : ones) {\n    double s=0.0;\n    for (    int k : ones) {\n      if (r[k] <= r[j]) {\n        s++;\n      }\n    }\n    avg_prec+=(s / (1. + r[j]));\n  }\n  avg_prec/=ones.size();\n  return avg_prec;\n}", "comment": "average precision - computes for each relevant label the percentage of relevant labels among all labels that are ranked before it .", "label": "why"}
{"id": "5776", "raw_code": "public void resetPolicy(){\n  mPreferences.putString(PREF_LAST_RESPONSE,Integer.toString(Policy.RETRY));\n  setRetryUntil(DEFAULT_RETRY_UNTIL);\n  setMaxRetries(DEFAULT_MAX_RETRIES);\n  setRetryCount(Long.parseLong(DEFAULT_RETRY_COUNT));\n  setValidityTimestamp(DEFAULT_VALIDITY_TIMESTAMP);\n  mPreferences.commit();\n}", "comment": "we call this to guarantee that we fetch a fresh policy from the server .", "label": "why"}
{"id": "42390", "raw_code": "public void insertTwin(Instruction inst,Instruction twin){\n  ListIterator<GCIRMapElement> iter=list.listIterator();\n  while (iter.hasNext()) {\n    GCIRMapElement newPtr=iter.next();\n    if (newPtr.getInstruction() == inst) {\n      iter.add(newPtr.createTwin(twin));\n      return;\n    }\n  }\n  throw new OptimizingCompilerException(\"GCIRMap.createTwin: \" + inst + \" not found\");\n}", "comment": "this method inserts an entry for a \" twin \" instruction immediately after the original entry .", "label": "why"}
{"id": "57481", "raw_code": "FormatSpecifierParser(String format){\n  this.format=format;\n  this.length=format.length();\n}", "comment": "constructs a new parser for the given format string .", "label": "why"}
{"id": "30370", "raw_code": "@Override public List<WorkOrder> searchWOForBilling(final Map<String,Object> criteriaMap){\n  logger.debug(\"-------------------------Inside searchWOForBilling-----------------------\");\n  final List<WorkOrder> filteredList=new ArrayList<WorkOrder>();\n  criteriaMap.put(ACTION_FLAG,\"searchWOForBilling\");\n  for (  final WorkOrder workorder : searchWO(criteriaMap))   if (!isWOValidforBill(workorder.getId()))   filteredList.add(workorder);\n  return filteredList;\n}", "comment": "this method will search list of wo ' s for the given criteria and eligible for mb .", "label": "why"}
{"id": "27402", "raw_code": "public ResourceQueue(final NonBlockingLockManagerWithNewDesign<R> lockService,final R resource){\n  if (lockService == null)   throw new IllegalArgumentException();\n  if (resource == null)   throw new IllegalArgumentException();\n  this.lockService=lockService;\n  this.resource=resource;\n  this.queue=new LinkedBlockingQueue<T>();\n  this.statisticsTask=new QueueSizeMovingAverageTask(resource.toString(),queue);\n}", "comment": "create a queue of lock requests for a resource .", "label": "why"}
{"id": "10529", "raw_code": "private void nukeSymbols(){\n  _count=0;\n  _longestCollisionList=0;\n  Arrays.fill(_mainHash,0);\n  Arrays.fill(_mainNames,null);\n  Arrays.fill(_collList,null);\n  _collCount=0;\n  _collEnd=0;\n}", "comment": "helper method called to empty all shared symbols , but to leave arrays allocated", "label": "why"}
{"id": "32661", "raw_code": "private static float determineEnemyBlitzStrength(final Territory blitzHere,final List<Route> blitzTerrRoutes,final List<Territory> blockTerr,final GameData data,final PlayerID ePlayer){\n  final HashSet<Integer> ignore=new HashSet<>();\n  ignore.add(1);\n  final CompositeMatch<Unit> blitzUnit=new CompositeMatchAnd<>(Matches.unitIsOwnedBy(ePlayer),Matches.UnitCanBlitz,Matches.UnitCanMove);\n  final CompositeMatch<Territory> validBlitzRoute=new CompositeMatchAnd<>(Matches.territoryHasNoEnemyUnits(ePlayer,data),Matches.TerritoryIsNotImpassableToLandUnits(ePlayer,data));\n  final List<Route> routes=new ArrayList<>();\n  final List<Unit> blitzUnits=findAttackers(blitzHere,2,ignore,ePlayer,data,blitzUnit,validBlitzRoute,blockTerr,routes,false);\n  for (  final Route r : routes) {\n    if (r.numberOfSteps() == 2) {\n      blitzTerrRoutes.add(r);\n    }\n  }\n  return strength(blitzUnits,true,false,true);\n}", "comment": "determine the enemy potential for blitzing a territory - all enemies are combined", "label": "why"}
{"id": "78698", "raw_code": "public Builder addListenUrls(List<String> urls){\n  List<String> needAdd=new ArrayList<String>();\n  for (  String url : urls) {\n    if (!UrlUtil.isUrl(url)) {\n      continue;\n    }\n    needAdd.add(url);\n  }\n  if (!CollectionUtil.isEmpty(needAdd)) {\n    if (mListenUrls == null) {\n      mListenUrls=new HashSet<String>();\n    }\n    mListenUrls.addAll(needAdd);\n  }\n  return this;\n}", "comment": "add the urls for listening", "label": "why"}
{"id": "8549", "raw_code": "<T>List<T> concatValues(final T[]... data){\n  final List<T> rv=new ArrayList<>();\n  for (  T[] values : data) {\n    rv.addAll(Arrays.asList(values));\n  }\n  return rv;\n}", "comment": "helper for concatenating several arrays .", "label": "why"}
{"id": "61314", "raw_code": "void insertOp(int pos,int length,int op){\n  int totalLen=m_ops.getOp(OpMap.MAPINDEX_LENGTH);\n  for (int i=totalLen - 1; i >= pos; i--) {\n    m_ops.setOp(i + length,m_ops.getOp(i));\n  }\n  m_ops.setOp(pos,op);\n  m_ops.setOp(OpMap.MAPINDEX_LENGTH,totalLen + length);\n}", "comment": "insert room for operation .", "label": "why"}
{"id": "35782", "raw_code": "private static synchronized void initDocBuilderFactory(){\n  docBuilderFactory=DocumentBuilderFactory.newInstance();\n  docBuilderFactory.setIgnoringComments(true);\n  docBuilderFactory.setCoalescing(true);\n}", "comment": "initialize the document builder factory so that it can be reused and does not need to be reinitialized for each parse action .", "label": "why"}
{"id": "78633", "raw_code": "private final StringBuilder appendParameterSignature(StringBuilder buffer,char[][] parameterTypes,char[][] parameterNames){\n  if (parameterTypes != null) {\n    for (int i=0; i < parameterTypes.length; i++) {\n      if (i > 0) {\n        buffer.append(',');\n        buffer.append(' ');\n      }\n      buffer.append(parameterTypes[i]);\n      if (parameterNames != null && parameterNames[i] != null) {\n        buffer.append(' ');\n        buffer.append(parameterNames[i]);\n      }\n    }\n  }\n  return buffer;\n}", "comment": "creates a display string of a parameter list ( without the parentheses ) for the given parameter types and names .", "label": "why"}
{"id": "19725", "raw_code": "public void completeHeartbeat(Database database,long seqno,String eventId) throws SQLException {\n  if (logger.isDebugEnabled())   logger.debug(\"Processing slave heartbeat update\");\n  Statement st=null;\n  ResultSet rs=null;\n  Timestamp sts=new Timestamp(0);\n  Timestamp now=new Timestamp(System.currentTimeMillis());\n  ArrayList<Column> whereClause=new ArrayList<Column>();\n  ArrayList<Column> values=new ArrayList<Column>();\n  if (logger.isDebugEnabled())   logger.debug(\"Processing slave heartbeat update: \" + now);\n  try {\n    st=database.createStatement();\n    rs=st.executeQuery(sourceTsQuery);\n    if (rs.next())     sts=rs.getTimestamp(1);\n  }\n  finally {\n    if (rs != null) {\n      try {\n        rs.close();\n      }\n catch (      SQLException e) {\n      }\n    }\n    if (st != null) {\n      try {\n        st.close();\n      }\n catch (      SQLException e) {\n      }\n    }\n  }\n  long lag_millis=now.getTime() - sts.getTime();\n  hbId.setValue(KEY);\n  whereClause.add(hbId);\n  hbSeqno.setValue(seqno);\n  hbEventId.setValue(eventId);\n  hbTargetTstamp.setValue(now);\n  hbLagMillis.setValue(lag_millis);\n  values.add(hbSeqno);\n  values.add(hbEventId);\n  values.add(hbTargetTstamp);\n  values.add(hbLagMillis);\n  database.update(hbTable,whereClause,values);\n}", "comment": "execute this call to fill in heartbeat data on the slave .", "label": "why"}
{"id": "17069", "raw_code": "public void removeCategoriesListener(SnapshotCategoriesListener listener){\n  listeners.remove(listener);\n}", "comment": "removes a listener for changes of registered snapshot categories .", "label": "why"}
{"id": "77512", "raw_code": "public List<String> makeURLList(String shard){\n  List<String> urls=StrUtils.splitSmart(shard,\"|\",true);\n  for (int i=0; i < urls.size(); i++) {\n    urls.set(i,buildUrl(urls.get(i)));\n  }\n  if (urls.size() > 1)   Collections.shuffle(urls,r);\n  return urls;\n}", "comment": "creates a randomized list of urls for the given shard .", "label": "why"}
{"id": "44129", "raw_code": "private byte[] toZLIB(RenderedImage image,Color bkg,String colorModel) throws IOException {\n  return ImageGraphics2D.toByteArray(image,ImageConstants.RAW,ImageConstants.ENCODING_FLATE_ASCII85,ImageGraphics2D.getRAWProperties(bkg,colorModel));\n}", "comment": "creates the zlib bytes for pdf images", "label": "why"}
{"id": "46537", "raw_code": "protected SizeRequirements calculateMinorAxisRequirements(int axis,SizeRequirements r){\n  updateGrid();\n  calculateColumnRequirements(axis);\n  if (r == null) {\n    r=new SizeRequirements();\n  }\n  long min=0;\n  long pref=0;\n  int n=columnRequirements.length;\n  for (int i=0; i < n; i++) {\n    SizeRequirements req=columnRequirements[i];\n    min+=req.minimum;\n    pref+=req.preferred;\n  }\n  int adjust=(n + 1) * cellSpacing + 2 * borderWidth;\n  min+=adjust;\n  pref+=adjust;\n  r.minimum=(int)min;\n  r.preferred=(int)pref;\n  r.maximum=(int)pref;\n  AttributeSet attr=getAttributes();\n  CSS.LengthValue cssWidth=(CSS.LengthValue)attr.getAttribute(CSS.Attribute.WIDTH);\n  if (BlockView.spanSetFromAttributes(axis,r,cssWidth,null)) {\n    if (r.minimum < (int)min) {\n      r.maximum=r.minimum=r.preferred=(int)min;\n    }\n  }\n  totalColumnRequirements.minimum=r.minimum;\n  totalColumnRequirements.preferred=r.preferred;\n  totalColumnRequirements.maximum=r.maximum;\n  Object o=attr.getAttribute(CSS.Attribute.TEXT_ALIGN);\n  if (o != null) {\n    String ta=o.toString();\n    if (ta.equals(\"left\")) {\n      r.alignment=0;\n    }\n else     if (ta.equals(\"center\")) {\n      r.alignment=0.5f;\n    }\n else     if (ta.equals(\"right\")) {\n      r.alignment=1;\n    }\n else {\n      r.alignment=0;\n    }\n  }\n else {\n    r.alignment=0;\n  }\n  return r;\n}", "comment": "calculate the requirements for the minor axis .", "label": "why"}
{"id": "38935", "raw_code": "@Override public Instances defineDataFormat() throws Exception {\n  ArrayList<Attribute> atts;\n  ArrayList<String> attValues;\n  int i;\n  m_Random=new Random(getSeed());\n  m_nextClassShouldBeZero=true;\n  m_lastLabel=Double.NaN;\n  setNumExamplesAct(getNumExamples());\n  atts=new ArrayList<Attribute>();\n  atts.add(new Attribute(\"salary\"));\n  atts.add(new Attribute(\"commission\"));\n  atts.add(new Attribute(\"age\"));\n  attValues=new ArrayList<String>();\n  for (i=0; i < 5; i++) {\n    attValues.add(\"\" + i);\n  }\n  atts.add(new Attribute(\"elevel\",attValues));\n  attValues=new ArrayList<String>();\n  for (i=1; i <= 20; i++) {\n    attValues.add(\"\" + i);\n  }\n  atts.add(new Attribute(\"car\",attValues));\n  attValues=new ArrayList<String>();\n  for (i=0; i < 9; i++) {\n    attValues.add(\"\" + i);\n  }\n  atts.add(new Attribute(\"zipcode\",attValues));\n  atts.add(new Attribute(\"hvalue\"));\n  atts.add(new Attribute(\"hyears\"));\n  atts.add(new Attribute(\"loan\"));\n  attValues=new ArrayList<String>();\n  for (i=0; i < 2; i++) {\n    attValues.add(\"\" + i);\n  }\n  atts.add(new Attribute(\"group\",attValues));\n  m_DatasetFormat=new Instances(getRelationNameToUse(),atts,0);\n  return m_DatasetFormat;\n}", "comment": "initializes the format for the dataset produced .", "label": "why"}
{"id": "66771", "raw_code": "public void showDroidsafeTextMarkers(IEditorPart openedEditor,String className){\n  if (openedEditor != null && openedEditor instanceof ITextEditor && fProcessedClasses != null) {\n    ITextEditor editor=(ITextEditor)openedEditor;\n    if (fProcessedClasses.contains(className)) {\n      if (fClassesNeedUpdate.contains(className)) {\n        ClassMarkerProcessor classProcessor=get(className);\n        classProcessor.updateTaintMarkers(editor);\n        fClassesNeedUpdate.remove(className);\n      }\n    }\n else {\n      fProcessedClasses.add(className);\n      Map<String,Map<IntRange,Map<String,Set<CallLocationModel>>>> classTaintedDataMap=fTaintedDataMap.get(className);\n      Map<String,Set<IntRange>> classUnreachableMethodMap=fUnreachableSourceMethodMap.get(className);\n      if (classTaintedDataMap != null || classUnreachableMethodMap != null) {\n        IEditorInput input=editor.getEditorInput();\n        if (input instanceof FileEditorInput) {\n          ClassMarkerProcessor classProcessor=get(className);\n          classProcessor.showDroidsafeTextMarkers(editor);\n        }\n      }\n    }\n  }\n}", "comment": "displays the annotations of the droidsafe text markers for the given class name in the given java editor .", "label": "why"}
{"id": "14418", "raw_code": "private boolean verifyLogRecord(String[] record,int macPos) throws Exception {\n  StringBuilder data=new StringBuilder();\n  for (int m=0; m < record.length - 2; m++) {\n    data.append(record[m]);\n  }\n  curMAC=record[macPos];\n  verified=helper.verifyMAC(data.toString(),helper.toByteArray(curMAC));\n  return verified;\n}", "comment": "verifies the passed logrecord to check for tampering .", "label": "why"}
{"id": "52498", "raw_code": "public static <T>Collection<T> makeImmutable(Collection<T> mutableCollection){\n  Collection<T> newCollection;\n  try {\n    @SuppressWarnings(\"unchecked\") Class<Collection<T>> cls=(Class<Collection<T>>)mutableCollection.getClass();\n    newCollection=cls.newInstance();\n  }\n catch (  InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e);\n  }\n  for (  T element : mutableCollection) {\n    newCollection.add(Utils.makeImmutable(element));\n  }\n  return Collections.unmodifiableCollection(newCollection);\n}", "comment": "a recursive call to make a collection and all it ' s values immutable .", "label": "why"}
{"id": "71239", "raw_code": "private QuadEdge[] fetchTriangleToVisit(QuadEdge edge,Stack edgeStack,boolean includeFrame,Set visitedEdges){\n  QuadEdge curr=edge;\n  int edgeCount=0;\n  boolean isFrame=false;\n  do {\n    triEdges[edgeCount]=curr;\n    if (isFrameEdge(curr))     isFrame=true;\n    QuadEdge sym=curr.sym();\n    if (!visitedEdges.contains(sym))     edgeStack.push(sym);\n    visitedEdges.add(curr);\n    edgeCount++;\n    curr=curr.lNext();\n  }\n while (curr != edge);\n  if (isFrame && !includeFrame)   return null;\n  return triEdges;\n}", "comment": "stores the edges for a visited triangle .", "label": "why"}
{"id": "24189", "raw_code": "private final String loadXmlDefinition(){\n  final Cache cache=CacheFactory.getAnyInstance();\n  final StringWriter stringWriter=new StringWriter();\n  final PrintWriter printWriter=new PrintWriter(stringWriter);\n  CacheXmlGenerator.generate(cache,printWriter,true,false,false);\n  printWriter.close();\n  return loadXmlDefinition(stringWriter.toString());\n}", "comment": "use the cachexmlgenerator to create xml from the entity associated with the current cache .", "label": "why"}
{"id": "78006", "raw_code": "public void poll(final TcpSocketStatisticsHandler handler){\n  this.statisticsHandler=handler;\n  try {\n    fileLoader.load();\n    final ByteBuffer buffer=fileLoader.getBuffer();\n    lineParser.reset();\n    lineParser.handleToken(buffer,buffer.position(),buffer.limit());\n  }\n  finally {\n    this.statisticsHandler=null;\n  }\n  monitoredSockets.purgeEntriesOlderThan(updateCount);\n  updateCount++;\n}", "comment": "read from monitored file , report any changed values for monitored socket statistics .", "label": "why"}
{"id": "83396", "raw_code": "public UrbanSimZoneCSVWriterV2(String matsim4opusTempDirectory,String matsimOutputDirectory){\n  this.matsim4opusTempDirectory=matsim4opusTempDirectory;\n  this.matsimOutputDirectory=matsimOutputDirectory;\n  try {\n    log.info(\"Initializing UrbanSimZoneCSVWriterV2 ...\");\n    zoneWriter=IOUtils.getBufferedWriter(matsim4opusTempDirectory + FILE_NAME);\n    log.info(\"Writing data into \" + matsim4opusTempDirectory + FILE_NAME+ \" ...\");\n    zoneWriter.write(Labels.ZONE_ID + \",\" + Labels.ACCESSIBILITY_BY_FREESPEED+ \",\"+ Labels.ACCESSIBILITY_BY_CAR+ \",\"+ Labels.ACCESSIBILITY_BY_BIKE+ \",\"+ Labels.ACCESSIBILITY_BY_WALK+ \",\"+ Labels.ACCESSIBILITY_BY_PT);\n    zoneWriter.newLine();\n    log.info(\"... done!\");\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}", "comment": "writes the header for zones csv file", "label": "why"}
{"id": "24391", "raw_code": "public static final void pause(final int milliseconds){\n  if (milliseconds >= 1000 || logger.isDebugEnabled()) {\n    logger.info(\"Pausing for {} ms...\",milliseconds);\n  }\n  final long target=System.currentTimeMillis() + milliseconds;\n  try {\n    for (; ; ) {\n      long msLeft=target - System.currentTimeMillis();\n      if (msLeft <= 0) {\n        break;\n      }\n      Thread.sleep(msLeft);\n    }\n  }\n catch (  InterruptedException e) {\n    Assert.fail(\"interrupted\",e);\n  }\n}", "comment": "pause for the specified milliseconds .", "label": "why"}
{"id": "82988", "raw_code": "protected void generateFields(){\n  for (Iterator<Element> iterator=mElements.iterator(); iterator.hasNext(); ) {\n    Element element=iterator.next();\n    if (!element.used) {\n      iterator.remove();\n      continue;\n    }\n    PsiField[] fields=mClass.getFields();\n    boolean duplicateField=false;\n    for (    PsiField field : fields) {\n      String name=field.getName();\n      if (name != null && name.equals(element.getFieldName())) {\n        duplicateField=true;\n        break;\n      }\n    }\n    if (duplicateField) {\n      iterator.remove();\n      continue;\n    }\n    mClass.add(mFactory.createFieldFromText(\"private \" + element.name + \" \"+ element.getFieldName()+ \";\",mClass));\n  }\n}", "comment": "create fields for injections inside main class", "label": "why"}
{"id": "77713", "raw_code": "public MediaConfig createChannelFileAttachment(String file,MediaConfig config){\n  config.addCredentials(this);\n  String xml=POSTFILE(this.url + \"/create-channel-attachment\",file,config.name,config.toXML());\n  Element root=parse(xml);\n  if (root == null) {\n    return null;\n  }\n  try {\n    MediaConfig media=new MediaConfig();\n    media.parseXML(root);\n    return media;\n  }\n catch (  Exception exception) {\n    this.exception=SDKException.parseFailure(exception);\n    throw this.exception;\n  }\n}", "comment": "create a new file / image / media attachment for a chat channel .", "label": "why"}
{"id": "79728", "raw_code": "public void addHttpSessionToken(String site,String token){\n  if (!site.contains(\":\")) {\n    site=site + (\":80\");\n  }\n  HttpSessionTokensSet siteTokens=sessionTokens.get(site);\n  if (siteTokens == null) {\n    siteTokens=new HttpSessionTokensSet();\n    sessionTokens.put(site,siteTokens);\n  }\n  log.info(\"Added new session token for site '\" + site + \"': \"+ token);\n  siteTokens.addToken(token);\n  unmarkRemovedDefaultSessionToken(site,token);\n}", "comment": "adds a new session token for a particular site .", "label": "why"}
{"id": "53795", "raw_code": "public boolean incrementReceived(){\n  Long diff=System.currentTimeMillis() - startTime;\n  if (diff >= 1000) {\n    packetsPerSecond=intervalPackets;\n    startTime=System.currentTimeMillis();\n    intervalPackets=1;\n    return true;\n  }\n else {\n    intervalPackets++;\n  }\n  this.receivedPackets++;\n  return false;\n}", "comment": "used for incrementing the number of packets received from the client", "label": "why"}
{"id": "26275", "raw_code": "public static Map<String,Object> createImage(DispatchContext dctx,Map<String,? extends Object> context){\n  Map<String,Object> result=createImageMethod(dctx,context);\n  return result;\n}", "comment": "a service wrapper for the createimagemethod method .", "label": "why"}
{"id": "52164", "raw_code": "public double localScore(int i,int... parents){\n  for (  int p : parents)   if (forbidden.contains(p))   return Double.NaN;\n  double residualVariance=covariances.get(i,i);\n  int n=getSampleSize();\n  int p=parents.length;\n  Matrix covxx=getSelection1(covariances,parents);\n  try {\n    Matrix covxxInv=covxx.inverse();\n    Matrix covxy=getSelection2(covariances,parents,i);\n    Matrix b=covxxInv.times(covxy);\n    double dot=0.0;\n    for (int j=0; j < covxy.getRowDimension(); j++) {\n      for (int k=0; k < covxy.getColumnDimension(); k++) {\n        dot+=covxy.get(j,k) * b.get(j,k);\n      }\n    }\n    residualVariance-=dot;\n    if (residualVariance <= 0) {\n      if (isVerbose()) {\n        out.println(\"Nonpositive residual varianceY: resVar / varianceY = \" + (residualVariance / covariances.get(i,i)));\n      }\n      return Double.NaN;\n    }\n    double c=getPenaltyDiscount();\n    return score(residualVariance,n,logn,p,c);\n  }\n catch (  Exception e) {\n    boolean removedOne=true;\n    while (removedOne) {\n      List<Integer> _parents=new ArrayList<>();\n      for (int y=0; y < parents.length; y++)       _parents.add(parents[y]);\n      _parents.removeAll(forbidden);\n      parents=new int[_parents.size()];\n      for (int y=0; y < _parents.size(); y++)       parents[y]=_parents.get(y);\n      removedOne=printMinimalLinearlyDependentSet(parents,covariances);\n    }\n    return Double.NaN;\n  }\n}", "comment": "calculates the sample likelihood and bic score for i given its parents in a simple sem model", "label": "why"}
{"id": "21902", "raw_code": "protected List<VolumeDescriptor> createChangeVirtualPoolDescriptors(StorageSystem vplexSystem,Volume volume,VirtualPool newVpool,String taskId,List<Recommendation> recommendations,VirtualPoolCapabilityValuesWrapper capabilities,ControllerOperationValuesWrapper operationsWrapper) throws InternalException {\n  URI volumeVarrayURI=volume.getVirtualArray();\n  VirtualArray volumeVarray=_dbClient.queryObject(VirtualArray.class,volumeVarrayURI);\n  s_logger.info(\"Virtual volume varray is {}\",volumeVarrayURI);\n  URI volumeVpoolURI=volume.getVirtualPool();\n  VirtualPool currentVpool=_dbClient.queryObject(VirtualPool.class,volumeVpoolURI);\n  List<VolumeDescriptor> descriptors=new ArrayList<VolumeDescriptor>();\n  VolumeDescriptor vplexVirtualVolumeDesc=new VolumeDescriptor(VolumeDescriptor.Type.VPLEX_VIRT_VOLUME,volume.getStorageController(),volume.getId(),volume.getPool(),null);\n  Map<String,Object> volumeParams=new HashMap<String,Object>();\n  volumeParams.put(VolumeDescriptor.PARAM_VPOOL_CHANGE_EXISTING_VOLUME_ID,volume.getId());\n  volumeParams.put(VolumeDescriptor.PARAM_VPOOL_CHANGE_NEW_VPOOL_ID,newVpool.getId());\n  volumeParams.put(VolumeDescriptor.PARAM_VPOOL_CHANGE_OLD_VPOOL_ID,volume.getVirtualPool());\n  if (operationsWrapper != null) {\n    if (operationsWrapper.getMigrationSuspendBeforeCommit() != null) {\n      volumeParams.put(VolumeDescriptor.PARAM_MIGRATION_SUSPEND_BEFORE_COMMIT,operationsWrapper.getMigrationSuspendBeforeCommit());\n    }\n    if (operationsWrapper.getMigrationSuspendBeforeDeleteSource() != null) {\n      volumeParams.put(VolumeDescriptor.PARAM_MIGRATION_SUSPEND_BEFORE_DELETE_SOURCE,operationsWrapper.getMigrationSuspendBeforeDeleteSource());\n    }\n  }\n  vplexVirtualVolumeDesc.setParameters(volumeParams);\n  descriptors.add(vplexVirtualVolumeDesc);\n  if (VirtualPoolChangeAnalyzer.vpoolChangeRequiresMigration(currentVpool,newVpool)) {\n    Volume migSrcVolume=getAssociatedVolumeInVArray(volume,volumeVarrayURI);\n    descriptors.addAll(createBackendVolumeMigrationDescriptors(vplexSystem,volume,migSrcVolume,volumeVarray,newVpool,getVolumeCapacity(migSrcVolume != null ? migSrcVolume : volume),taskId,recommendations,false,capabilities));\n  }\n  URI haVarrayURI=VirtualPoolChangeAnalyzer.getHaVarrayURI(currentVpool);\n  if (haVarrayURI != null) {\n    VirtualArray haVarray=_dbClient.queryObject(VirtualArray.class,haVarrayURI);\n    VirtualPool currentHaVpool=VirtualPoolChangeAnalyzer.getHaVpool(currentVpool,_dbClient);\n    VirtualPool newHaVpool=VirtualPoolChangeAnalyzer.getNewHaVpool(currentVpool,newVpool,_dbClient);\n    if (VirtualPoolChangeAnalyzer.vpoolChangeRequiresMigration(currentHaVpool,newHaVpool)) {\n      Volume migSrcVolume=getAssociatedVolumeInVArray(volume,haVarrayURI);\n      descriptors.addAll(createBackendVolumeMigrationDescriptors(vplexSystem,volume,migSrcVolume,haVarray,newHaVpool,getVolumeCapacity(migSrcVolume != null ? migSrcVolume : volume),taskId,recommendations,true,capabilities));\n    }\n  }\n  return descriptors;\n}", "comment": "change the virtualpool for the passed virtual volume on the passed vplex storage system .", "label": "why"}
{"id": "47034", "raw_code": "public boolean equals(Object obj){\n  if (this == obj)   return true;\n  if (obj instanceof ECFieldFp) {\n    return (p.equals(((ECFieldFp)obj).p));\n  }\n  return false;\n}", "comment": "compares this prime finite field for equality with the specified object .", "label": "why"}
{"id": "78498", "raw_code": "private void generateLegalTimesTree(){\n  int k0=KeyEvent.KEYCODE_0;\n  int k1=KeyEvent.KEYCODE_1;\n  int k2=KeyEvent.KEYCODE_2;\n  int k3=KeyEvent.KEYCODE_3;\n  int k4=KeyEvent.KEYCODE_4;\n  int k5=KeyEvent.KEYCODE_5;\n  int k6=KeyEvent.KEYCODE_6;\n  int k7=KeyEvent.KEYCODE_7;\n  int k8=KeyEvent.KEYCODE_8;\n  int k9=KeyEvent.KEYCODE_9;\n  mLegalTimesTree=new Node();\n  if (mIs24HourMode) {\n    Node minuteFirstDigit=new Node(k0,k1,k2,k3,k4,k5);\n    Node minuteSecondDigit=new Node(k0,k1,k2,k3,k4,k5,k6,k7,k8,k9);\n    minuteFirstDigit.addChild(minuteSecondDigit);\n    Node firstDigit=new Node(k0,k1);\n    mLegalTimesTree.addChild(firstDigit);\n    Node secondDigit=new Node(k0,k1,k2,k3,k4,k5);\n    firstDigit.addChild(secondDigit);\n    secondDigit.addChild(minuteFirstDigit);\n    Node thirdDigit=new Node(k6,k7,k8,k9);\n    secondDigit.addChild(thirdDigit);\n    secondDigit=new Node(k6,k7,k8,k9);\n    firstDigit.addChild(secondDigit);\n    secondDigit.addChild(minuteFirstDigit);\n    firstDigit=new Node(k2);\n    mLegalTimesTree.addChild(firstDigit);\n    secondDigit=new Node(k0,k1,k2,k3);\n    firstDigit.addChild(secondDigit);\n    secondDigit.addChild(minuteFirstDigit);\n    secondDigit=new Node(k4,k5);\n    firstDigit.addChild(secondDigit);\n    secondDigit.addChild(minuteSecondDigit);\n    firstDigit=new Node(k3,k4,k5,k6,k7,k8,k9);\n    mLegalTimesTree.addChild(firstDigit);\n    firstDigit.addChild(minuteFirstDigit);\n  }\n else {\n    Node ampm=new Node(getAmOrPmKeyCode(AM),getAmOrPmKeyCode(PM));\n    Node firstDigit=new Node(k1);\n    mLegalTimesTree.addChild(firstDigit);\n    firstDigit.addChild(ampm);\n    Node secondDigit=new Node(k0,k1,k2);\n    firstDigit.addChild(secondDigit);\n    secondDigit.addChild(ampm);\n    Node thirdDigit=new Node(k0,k1,k2,k3,k4,k5);\n    secondDigit.addChild(thirdDigit);\n    thirdDigit.addChild(ampm);\n    Node fourthDigit=new Node(k0,k1,k2,k3,k4,k5,k6,k7,k8,k9);\n    thirdDigit.addChild(fourthDigit);\n    fourthDigit.addChild(ampm);\n    thirdDigit=new Node(k6,k7,k8,k9);\n    secondDigit.addChild(thirdDigit);\n    thirdDigit.addChild(ampm);\n    secondDigit=new Node(k3,k4,k5);\n    firstDigit.addChild(secondDigit);\n    thirdDigit=new Node(k0,k1,k2,k3,k4,k5,k6,k7,k8,k9);\n    secondDigit.addChild(thirdDigit);\n    thirdDigit.addChild(ampm);\n    firstDigit=new Node(k2,k3,k4,k5,k6,k7,k8,k9);\n    mLegalTimesTree.addChild(firstDigit);\n    firstDigit.addChild(ampm);\n    secondDigit=new Node(k0,k1,k2,k3,k4,k5);\n    firstDigit.addChild(secondDigit);\n    thirdDigit=new Node(k0,k1,k2,k3,k4,k5,k6,k7,k8,k9);\n    secondDigit.addChild(thirdDigit);\n    thirdDigit.addChild(ampm);\n  }\n}", "comment": "create a tree for deciding what keys can legally be typed .", "label": "why"}
{"id": "2635", "raw_code": "public static String readStream(InputStream in){\n  BufferedReader reader=new BufferedReader(new InputStreamReader(in));\n  StringBuilder sb=new StringBuilder();\n  String line=null;\n  try {\n    while ((line=reader.readLine()) != null) {\n      sb.append(line + \"\\n\");\n    }\n  }\n catch (  IOException e) {\n    FreshAirLog.e(\"Error reading stream\",e);\n  }\n finally {\n    try {\n      in.close();\n    }\n catch (    IOException e) {\n    }\n    try {\n      reader.close();\n    }\n catch (    IOException e) {\n    }\n  }\n  return sb.toString();\n}", "comment": "utility method for pulling plain text from an inputstream object", "label": "why"}
{"id": "86115", "raw_code": "@Override public void onDrawEye(Eye eye){\n  GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);\n  Engine.checkGLError(\"mColorParam\");\n  if (!prefOrientationProviderString.equals(\"0\")) {\n    if (firstOnDrawEye > 0) {\n      firstOnDrawEye--;\n      float[] m=new float[16];\n      Matrix.invertM(m,0,mHeadViewSDK,0);\n      Matrix.multiplyMM(m,0,eye.getEyeView(),0,m,0);\n      if (eye.getType() == Eye.Type.RIGHT) {\n        mEyeRightView=m;\n      }\n else       if (eye.getType() == Eye.Type.LEFT) {\n        mEyeLeftView=m;\n      }\n      return;\n    }\n    float[] m=new float[16];\n    if (eye.getType() == Eye.Type.RIGHT) {\n      Matrix.multiplyMM(m,0,mHeadViewUse,0,mEyeRightView,0);\n    }\n else {\n      Matrix.multiplyMM(m,0,mHeadViewUse,0,mEyeLeftView,0);\n    }\n    Matrix.multiplyMM(mView,0,m,0,mCamera,0);\n  }\n else {\n    Matrix.multiplyMM(mView,0,eye.getEyeView(),0,mCamera,0);\n  }\n  float[] perspective=eye.getPerspective(Z_NEAR,Z_FAR);\n  GLES20.glEnable(GLES20.GL_DEPTH_TEST);\n  GLES20.glBlendFunc(GLES20.GL_SRC_ALPHA,GLES20.GL_ONE_MINUS_SRC_ALPHA);\n  GLES20.glEnable(GLES20.GL_BLEND);\n  if (prefShowEnv && bgEnv.isReady()) {\n    Matrix.multiplyMM(mModelView,0,mView,0,bgEnv.model,0);\n    Matrix.multiplyMM(mModelViewProjection,0,perspective,0,mModelView,0);\n    bgEnv.draw(eye.getType(),mModelViewProjection);\n  }\n  GLES20.glDisable(GLES20.GL_DEPTH_TEST);\n  Matrix.multiplyMM(mModelViewProjection,0,perspective,0,cameraPreview.model,0);\n  cameraPreview.draw(eye.getType(),mModelViewProjection);\n  Matrix.multiplyMM(mModelView,0,mView,0,screen.model,0);\n  Matrix.multiplyMM(mModelViewProjection,0,perspective,0,mModelView,0);\n  screen.draw(eye.getType(),mModelViewProjection);\n  for (  ButtonThing button : buttonList) {\n    Matrix.multiplyMM(mModelView,0,mView,0,button.model,0);\n    Matrix.multiplyMM(mModelViewProjection,0,perspective,0,mModelView,0);\n    button.draw(eye.getType(),mModelViewProjection);\n  }\n  Matrix.multiplyMM(mModelViewProjection,0,perspective,0,aimPoint.model,0);\n  aimPoint.draw(Eye.Type.MONOCULAR,mModelViewProjection);\n}", "comment": "draws a frame for an eye .", "label": "why"}
{"id": "26279", "raw_code": "public static Map<String,Object> findContentParents(DispatchContext dctx,Map<String,? extends Object> context){\n  Map<String,Object> results=FastMap.newInstance();\n  List<Object> parentList=FastList.newInstance();\n  results.put(\"parentList\",parentList);\n  LocalDispatcher dispatcher=dctx.getDispatcher();\n  String contentId=(String)context.get(\"contentId\");\n  String contentAssocTypeId=(String)context.get(\"contentAssocTypeId\");\n  String direction=(String)context.get(\"direction\");\n  if (UtilValidate.isEmpty(direction)) {\n    direction=\"To\";\n  }\n  Map<String,Object> traversMap=FastMap.newInstance();\n  traversMap.put(\"contentId\",contentId);\n  traversMap.put(\"direction\",direction);\n  traversMap.put(\"contentAssocTypeId\",contentAssocTypeId);\n  try {\n    Map<String,Object> thisResults=dispatcher.runSync(\"traverseContent\",traversMap);\n    String errorMsg=ServiceUtil.getErrorMessage(thisResults);\n    if (UtilValidate.isNotEmpty(errorMsg)) {\n      Debug.logError(\"Problem in traverseContent. \" + errorMsg,module);\n      return ServiceUtil.returnError(errorMsg);\n    }\n    Map<String,Object> nodeMap=UtilGenerics.checkMap(thisResults.get(\"nodeMap\"));\n    walkParentTree(nodeMap,parentList);\n  }\n catch (  GenericServiceException e) {\n    return ServiceUtil.returnFailure(e.getMessage());\n  }\n  return results;\n}", "comment": "this is a generic service for traversing a content tree , typical of a blog response tree .", "label": "why"}
{"id": "59953", "raw_code": "@RpcMethod public void detachISO(String vmId,boolean isDeleteFile,AsyncMethodCallback<Host.AsyncClient.detach_iso_call> handler) throws RpcException {\n  ensureClient();\n  DetachISORequest detachISORequest=new DetachISORequest(vmId);\n  detachISORequest.setDelete_file(isDeleteFile);\n  clientProxy.setTimeout(DETACH_ISO_TIMEOUT_MS);\n  logger.info(\"detach_iso vm {}, target {}, request {}\",vmId,getHostIp(),detachISORequest);\n  try {\n    clientProxy.detach_iso(detachISORequest,handler);\n  }\n catch (  TException e) {\n    throw new RpcException(e.getMessage());\n  }\n}", "comment": "this method performs an asynchronous thrift call to detach an iso from a vm .", "label": "why"}
{"id": "59079", "raw_code": "protected void tearDown(){\n  try {\n    ds.close();\n    sds.close();\n  }\n catch (  Exception e) {\n  }\n}", "comment": "tears down the fixture , for example , close a network connection .", "label": "why"}
{"id": "74971", "raw_code": "private static long signFromBit_antiCyclic(final double value){\n  return Double.doubleToRawLongBits(value) >> 62 | 1;\n}", "comment": "redefined here , to avoid cyclic dependency with ( strict ) fastmath .", "label": "why"}
{"id": "64754", "raw_code": "protected final void firePropertyChange(PropertyChangeEvent evt){\n  pcs.firePropertyChange(evt);\n}", "comment": "fire an existing propertychangeevent to any registered listeners .", "label": "why"}
{"id": "56550", "raw_code": "public static <T>FastFuture<T> fromCompletableFuture(final CompletableFuture<T> cf){\n  final FastFuture<T> f=new FastFuture<>();\n  cf.thenAccept(null);\n  cf.exceptionally(null);\n  return f;\n}", "comment": "internal conversion method to convert completablefutures to fastfuture .", "label": "why"}
{"id": "62535", "raw_code": "private static synchronized String formatAndParse(SimpleDateFormat formatDate,SimpleDateFormat parseDate,String text){\n  try {\n    Date date=parseDate.parse(text);\n    String result=formatDate.format(date);\n    return result;\n  }\n catch (  ParseException e) {\n    logger.warning(\"Unable to parse:\" + text);\n  }\n  return \"\";\n}", "comment": "synchronized because simpledatformat aren ' t thread safe", "label": "why"}
{"id": "51977", "raw_code": "private void onMainContentScrolled(int currentY,int deltaY){\n  if (deltaY > mActionBarAutoHideSensivity) {\n    deltaY=mActionBarAutoHideSensivity;\n  }\n else   if (deltaY < -mActionBarAutoHideSensivity) {\n    deltaY=-mActionBarAutoHideSensivity;\n  }\n  if (Math.signum(deltaY) * Math.signum(mActionBarAutoHideSignal) < 0) {\n    mActionBarAutoHideSignal=deltaY;\n  }\n else {\n    mActionBarAutoHideSignal+=deltaY;\n  }\n  boolean shouldShow=currentY < mActionBarAutoHideMinY || (mActionBarAutoHideSignal <= -mActionBarAutoHideSensivity);\n  autoShowOrHideActionBar(shouldShow);\n}", "comment": "indicates that the main content has scrolled ( for the purposes of showing / hiding the action bar for the \" action bar auto hide \" effect ) .", "label": "why"}
{"id": "83352", "raw_code": "public void writeToFile(String filename){\n  GridUtils.writeSpatialGridTable(this,filename);\n}", "comment": "just for debugging convenience", "label": "why"}
{"id": "80383", "raw_code": "private void applyTradingBonus(Player player){\n  player.incrementTradescore();\n}", "comment": "rewards player for a successfull trade", "label": "why"}
{"id": "75978", "raw_code": "private void updateBaseMatrix(Drawable d){\n  ImageView imageView=getImageView();\n  if (null == imageView || null == d) {\n    return;\n  }\n  final float viewWidth=imageView.getWidth();\n  final float viewHeight=imageView.getHeight();\n  final int drawableWidth=d.getIntrinsicWidth();\n  final int drawableHeight=d.getIntrinsicHeight();\n  mBaseMatrix.reset();\n  final float widthScale=viewWidth / drawableWidth;\n  final float heightScale=viewHeight / drawableHeight;\n  if (mScaleType == ScaleType.CENTER) {\n    mBaseMatrix.postTranslate((viewWidth - drawableWidth) / 2F,(viewHeight - drawableHeight) / 2F);\n  }\n else   if (mScaleType == ScaleType.CENTER_CROP) {\n    float scale=Math.max(widthScale,heightScale);\n    mBaseMatrix.postScale(scale,scale);\n    mBaseMatrix.postTranslate((viewWidth - drawableWidth * scale) / 2F,(viewHeight - drawableHeight * scale) / 2F);\n  }\n else   if (mScaleType == ScaleType.CENTER_INSIDE) {\n    float scale=Math.min(1.0f,Math.min(widthScale,heightScale));\n    mBaseMatrix.postScale(scale,scale);\n    mBaseMatrix.postTranslate((viewWidth - drawableWidth * scale) / 2F,(viewHeight - drawableHeight * scale) / 2F);\n  }\n else {\n    RectF mTempSrc=new RectF(0,0,drawableWidth,drawableHeight);\n    RectF mTempDst=new RectF(0,0,viewWidth,viewHeight);\nswitch (mScaleType) {\ncase FIT_CENTER:\n      mBaseMatrix.setRectToRect(mTempSrc,mTempDst,ScaleToFit.CENTER);\n    break;\ncase FIT_START:\n  mBaseMatrix.setRectToRect(mTempSrc,mTempDst,ScaleToFit.START);\nbreak;\ncase FIT_END:\nmBaseMatrix.setRectToRect(mTempSrc,mTempDst,ScaleToFit.END);\nbreak;\ncase FIT_XY:\nmBaseMatrix.setRectToRect(mTempSrc,mTempDst,ScaleToFit.FILL);\nbreak;\ndefault :\nbreak;\n}\n}\nresetMatrix();\n}", "comment": "calculate matrix for fit _ center", "label": "why"}
{"id": "3817", "raw_code": "public QDate(){\n  this(_gmtTimeZone);\n}", "comment": "creates the date for gmt .", "label": "why"}
{"id": "22722", "raw_code": "public EtagCache resetStats(){\n  hits.set(0);\n  misses.set(0);\n  return this;\n}", "comment": "reset stats tracked for cache hits and misses", "label": "why"}
{"id": "11697", "raw_code": "public static int numPixelsBetween(int x1,int y1,int x2,int y2){\n  return (int)Math.sqrt(Math.pow((double)(x1 - x2),2.0) + Math.pow((double)(y1 - y2),2.0));\n}", "comment": "little math utility that both tools use , that just implements the pythagorean theorem to do the number of pixels between two screen points .", "label": "why"}
{"id": "74910", "raw_code": "static boolean allowsPopup(FormObject formObject){\nswitch (formObject.getParameterConstant(PdfDictionary.Subtype)) {\ncase PdfDictionary.Text:\ncase PdfDictionary.Square:\ncase PdfDictionary.Highlight:\ncase PdfDictionary.Underline:\ncase PdfDictionary.StrickOut:\ncase PdfDictionary.Stamp:\n    return true;\ndefault :\n  return false;\n}\n}", "comment": "utility method to check if formobject should have a popup", "label": "why"}
{"id": "9772", "raw_code": "public DSignCsr(JFrame parent,PKCS10CertificationRequest pkcs10Csr,File csrFile,PrivateKey signPrivateKey,KeyPairType signKeyPairType,X509Certificate verificationCertificate,Provider provider) throws CryptoException {\n  super(parent,Dialog.ModalityType.DOCUMENT_MODAL);\n  this.pkcs10Csr=pkcs10Csr;\n  this.csrFile=csrFile;\n  this.signPrivateKey=signPrivateKey;\n  this.signKeyPairType=signKeyPairType;\n  this.verificationCertificate=verificationCertificate;\n  this.provider=provider;\n  setTitle(res.getString(\"DSignCsr.Title\"));\n  initComponents();\n}", "comment": "creates a new dsigncsr dialog for a pkcs # 10 formatted csr .", "label": "why"}
{"id": "57042", "raw_code": "protected static void init(){\n  String notificationfactoryClassName=null;\n  try {\n    notificationfactoryClassName=System.getProperty(NOTIFICATION_FACTORY_NAME);\n  }\n catch (  SecurityException e) {\n    throw new RuntimeException(e);\n  }\n  if (notificationfactoryClassName != null) {\n    Class<?> nfc;\n    try {\n      nfc=Class.forName(notificationfactoryClassName);\n      factory=(INotificationManagerFactory)nfc.newInstance();\n    }\n catch (    ClassNotFoundException|InstantiationException|IllegalAccessException e) {\n      throw new RuntimeException(e);\n    }\n  }\n else {\n    factory=new SyslogNotificationFactory();\n  }\n}", "comment": "a simple mechanism to initialize factory with dynamic binding .", "label": "why"}
{"id": "64094", "raw_code": "public AgeFileFilter(Date cutoffDate,boolean acceptOlder){\n  this(cutoffDate.getTime(),acceptOlder);\n}", "comment": "constructs a new age file filter for files on any one side of a certain cutoff date .", "label": "why"}
{"id": "47697", "raw_code": "protected void acceptDrop(int dropOperation){\n  DropTargetContextPeer peer=getDropTargetContextPeer();\n  if (peer != null) {\n    peer.acceptDrop(dropOperation);\n  }\n}", "comment": "called to signal that the drop is acceptable using the specified operation .", "label": "why"}
{"id": "64817", "raw_code": "private void calculateD(double[] b){\n  int length=mExtremalIndices.size() - 1;\n  mD=new double[length];\n  for (int k=0; k < length; k++) {\n    mD[k]=b[k] * (mGrid.getCosineFrequencyGrid()[mExtremalIndices.get(k)] - mGrid.getCosineFrequencyGrid()[mExtremalIndices.get(length)]);\n  }\n}", "comment": "calculates the set of d values for the current extremal index set .", "label": "why"}
{"id": "4516", "raw_code": "private void fetchMyServiceCardsFromServer(){\n  RetroCallback retroCallback;\n  retroCallback=new RetroCallback(this);\n  retroCallback.setRequestId(HttpConstants.ApiResponseCodes.GET_MY_SERVICES);\n  retroCallbackList.add(retroCallback);\n  mYeloApi.getMyServiceCards(retroCallback);\n}", "comment": "helper http function to get list of my service cards .", "label": "why"}
{"id": "30642", "raw_code": "public static <U>AtomicIntegerFieldUpdater<U> newUpdater(Class<U> tclass,String fieldName){\n  if (UnsafeHolder.isAvailable()) {\n    return new AtomicIntegerFieldUpdaterImpl<U>(tclass,fieldName);\n  }\n  return AtomicIntegerFieldUpdater.newUpdater(tclass,fieldName);\n}", "comment": "creates an updater for objects with the given field .", "label": "why"}
{"id": "18450", "raw_code": "public Process executeAsync(final CommandLine command,Map<String,String> environment) throws IOException {\n  if (workingDirectory != null && !workingDirectory.exists()) {\n    throw new IOException(workingDirectory + \" doesn't exist.\");\n  }\n  return executeInternal(command,environment,workingDirectory,streamHandler,null);\n}", "comment": "methods for starting asynchronous execution .", "label": "why"}
{"id": "49474", "raw_code": "public void add(final SAMRecord read,final int position){\n  recordAndOffsets.add(new RecordAndOffset(read,position));\n}", "comment": "accumulate info for one read at the locus .", "label": "why"}
{"id": "9864", "raw_code": "public static String buildResponseUrl(String tenant,LogoutState logoutState){\n  String retval=null;\n  LogoutResponse samlResponse=logoutState.generateResponseForTenant(tenant,logoutState.getMessageSource(),logoutState.getLocale());\n  if (samlResponse != null) {\n    log.info(\"SAML SLO Response is \" + samlResponse.toString());\n    retval=logoutState.generateResponseUrlForTenant(samlResponse,tenant);\n  }\n  return retval;\n}", "comment": "helper method to generate logoutresponse redirect url", "label": "why"}
{"id": "75225", "raw_code": "protected void run_ThreadSizeLoop() throws Exception {\n  for (int i=25; i <= 100; i+=25) {\n    setNumWorkers(i);\n    try {\n      Thread.sleep(60 * 1000);\n    }\n catch (    InterruptedException e) {\n    }\n  }\n}", "comment": "a simple method to do nothing very much .", "label": "why"}
{"id": "25925", "raw_code": "@Override public boolean lock(){\n  try {\n    if (!FileFactory.isFileExist(location,FileFactory.getFileType(tmpPath))) {\n      FileFactory.mkdirs(location,FileFactory.getFileType(tmpPath));\n    }\n    String lockFilePath=location + CarbonCommonConstants.FILE_SEPARATOR + lockFile;\n    if (!FileFactory.isFileExist(lockFilePath,FileFactory.getFileType(location))) {\n      FileFactory.createNewLockFile(lockFilePath,FileFactory.getFileType(location));\n    }\n    fileOutputStream=new FileOutputStream(lockFilePath);\n    channel=fileOutputStream.getChannel();\n    try {\n      fileLock=channel.tryLock();\n    }\n catch (    OverlappingFileLockException e) {\n      return false;\n    }\n    if (null != fileLock) {\n      return true;\n    }\n else {\n      return false;\n    }\n  }\n catch (  IOException e) {\n    return false;\n  }\n}", "comment": "lock api for locking of the file channel of the lock file .", "label": "why"}
{"id": "86513", "raw_code": "public void removeEventListener(ZWaveEventListener eventListener){\nsynchronized (zwaveEventListeners) {\n    zwaveEventListeners.remove(eventListener);\n  }\n}", "comment": "remove a listener for zwave events to this controller .", "label": "why"}
{"id": "64457", "raw_code": "public static Recipe fromCursor(Cursor cursor){\n  Recipe recipe=new Recipe(null);\n  for (int c=0; c < cursor.getColumnCount(); c++) {\n    String columnName=cursor.getColumnName(c);\n    if (columnName.equals(RecipeTable.ID_COLUMN)) {\n      recipe.id=cursor.getString(c);\n    }\n else     if (columnName.equals(RecipeTable.TITLE_COLUMN)) {\n      recipe.setTitle(cursor.getString(c));\n    }\n else     if (columnName.equals(RecipeTable.DESCRIPTION_COLUMN)) {\n      recipe.setDescription(cursor.getString(c));\n    }\n else     if (columnName.equals(RecipeTable.PHOTO_COLUMN)) {\n      recipe.setPhoto(cursor.getString(c));\n    }\n else     if (columnName.equals(RecipeTable.PREP_TIME_COLUMN)) {\n      recipe.setPrepTime(cursor.getString(c));\n    }\n  }\n  return recipe;\n}", "comment": "static helper method for populating attributes from a database cursor .", "label": "why"}
{"id": "73917", "raw_code": "private void resetNotes(){\n  if (errorInStatus1) {\n    if (editMode) {\n      statusText1.setText(editStatus1);\n    }\n else {\n      statusText1.setText(stdStatus1);\n    }\n    errorInStatus1=false;\n  }\n  resetNotes2();\n}", "comment": "method to reset the notes error after error display", "label": "why"}
{"id": "21098", "raw_code": "public void auditCallhome(OperationTypeEnum auditType,String operationalStatus,String description,Object... descparams){\n  _auditMgr.recordAuditLog(null,null,EVENT_SERVICE_TYPE,auditType,System.currentTimeMillis(),operationalStatus,description,descparams);\n}", "comment": "record audit log for callhome service", "label": "why"}
{"id": "34302", "raw_code": "protected MediaType selectMediaType(ServerWebExchange exchange,List<MediaType> producibleTypes){\n  List<MediaType> acceptableTypes=getAcceptableTypes(exchange);\n  producibleTypes=getProducibleTypes(exchange,producibleTypes);\n  Set<MediaType> compatibleMediaTypes=new LinkedHashSet<>();\n  for (  MediaType acceptable : acceptableTypes) {\n    for (    MediaType producible : producibleTypes) {\n      if (acceptable.isCompatibleWith(producible)) {\n        compatibleMediaTypes.add(selectMoreSpecificMediaType(acceptable,producible));\n      }\n    }\n  }\n  List<MediaType> result=new ArrayList<>(compatibleMediaTypes);\n  MediaType.sortBySpecificityAndQuality(result);\n  for (  MediaType mediaType : compatibleMediaTypes) {\n    if (mediaType.isConcrete()) {\n      return mediaType;\n    }\n else     if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION_ALL)) {\n      return MediaType.APPLICATION_OCTET_STREAM;\n    }\n  }\n  return null;\n}", "comment": "select the best media type for the current request through a content negotiation algorithm .", "label": "why"}
{"id": "46252", "raw_code": "public void paintBorder(Component c,Graphics g,int x,int y,int width,int height){\n  if (!(c instanceof JPopupMenu)) {\n    return;\n  }\n  Font origFont=g.getFont();\n  Color origColor=g.getColor();\n  JPopupMenu popup=(JPopupMenu)c;\n  String title=popup.getLabel();\n  if (title == null) {\n    return;\n  }\n  g.setFont(font);\n  FontMetrics fm=SwingUtilities2.getFontMetrics(popup,g,font);\n  int fontHeight=fm.getHeight();\n  int descent=fm.getDescent();\n  int ascent=fm.getAscent();\n  Point textLoc=new Point();\n  int stringWidth=SwingUtilities2.stringWidth(popup,fm,title);\n  textLoc.y=y + ascent + TEXT_SPACING;\n  textLoc.x=x + ((width - stringWidth) / 2);\n  g.setColor(background);\n  g.fillRect(textLoc.x - TEXT_SPACING,textLoc.y - (fontHeight - descent),stringWidth + (2 * TEXT_SPACING),fontHeight - descent);\n  g.setColor(foreground);\n  SwingUtilities2.drawString(popup,g,title,textLoc.x,textLoc.y);\n  MotifGraphicsUtils.drawGroove(g,x,textLoc.y + TEXT_SPACING,width,GROOVE_HEIGHT,shadowColor,highlightColor);\n  g.setFont(origFont);\n  g.setColor(origColor);\n}", "comment": "paints the border for the specified component with the specified position and size .", "label": "why"}
{"id": "24572", "raw_code": "public int addDir(File file){\n  if (!file.exists()) {\n    return 0;\n  }\n  String[] names=getNames(getFiles(file,\".class\"));\n  loadClass(file,names);\n  return 1;\n}", "comment": "adds new locations for command classes", "label": "why"}
{"id": "7570", "raw_code": "@Override public boolean equals(Object obj){\n  if (obj == this) {\n    return true;\n  }\n  if (!(obj instanceof BubbleXYItemLabelGenerator)) {\n    return false;\n  }\n  if (!super.equals(obj)) {\n    return false;\n  }\n  BubbleXYItemLabelGenerator that=(BubbleXYItemLabelGenerator)obj;\n  if (!ObjectUtilities.equal(this.zFormat,that.zFormat)) {\n    return false;\n  }\n  if (!ObjectUtilities.equal(this.zDateFormat,that.zDateFormat)) {\n    return false;\n  }\n  return true;\n}", "comment": "tests this object for equality with an arbitrary object .", "label": "why"}
{"id": "84207", "raw_code": "public void resetReferences(){\n  if (_refs != null)   _refs.clear();\n}", "comment": "resets the references for streaming .", "label": "why"}
{"id": "74146", "raw_code": "public String checkStartBlock(int mode){\n  if (log.isDebugEnabled())   log.debug(\"checkStartBlock for warrant \\\"\" + getDisplayName() + \"\\\".\");\n  BlockOrder bo=_orders.get(0);\n  OBlock block=bo.getBlock();\n  String msg=block.allocate(this);\n  if (msg != null) {\n    return msg;\n  }\n  msg=bo.setPath(this);\n  if (msg != null) {\n    return msg;\n  }\n  int state=block.getState();\n  if ((state & OBlock.DARK) != 0 || _tempRunBlind) {\n    msg=Bundle.getMessage(\"BlockDark\",block.getDisplayName());\n  }\n else   if ((state & OBlock.OCCUPIED) == 0) {\n    if (mode == MODE_LEARN) {\n      msg=\"learnStart\";\n    }\n else {\n      msg=\"warnStart\";\n    }\n    msg=Bundle.getMessage(msg,getTrainName(),block.getDisplayName());\n  }\n else {\n    TrackerTableAction.stopTrackerIn(block);\n  }\n  return msg;\n}", "comment": "check start block for occupied for start of run", "label": "why"}
{"id": "14460", "raw_code": "protected Logger(String name,String resourceBundleName){\n  super(name,resourceBundleName);\n}", "comment": "protected method to construct a logger for a named subsystem .", "label": "why"}
{"id": "57382", "raw_code": "public BerInputStream(InputStream in,int initialSize) throws IOException {\n  this.in=in;\n  buffer=new byte[initialSize];\n  next();\n  if (length != INDEFINIT_LENGTH) {\n    if (buffer.length < (length + offset)) {\n      byte[] newBuffer=new byte[length + offset];\n      System.arraycopy(buffer,0,newBuffer,0,offset);\n      buffer=newBuffer;\n    }\n  }\n else {\n    isIndefinedLength=true;\n    throw new ASN1Exception(\"Decoding indefinite length encoding is not supported\");\n  }\n}", "comment": "creates stream for decoding .", "label": "why"}
{"id": "82880", "raw_code": "public AppraiseGitReviewClient(Repository repo){\n  this.repo=repo;\n  this.author=new PersonIdent(repo);\n}", "comment": "creates a new client for the given git repository .", "label": "why"}
{"id": "4759", "raw_code": "protected SOAPRequest createSOAPRequest(final String methodName,final SOAPMethodRequestWriter requestWriter){\n  final PostMethod method=new PostMethod(endpoint.toString());\n  method.setContentChunked(false);\n  setRequestHeaders(method,methodName);\n  final SOAPRequestEntity requestEntity=buildRequestEntity(methodName,requestWriter);\n  requestEntity.setSOAPHeaderProvider(soapHeaderProvider);\n  final BufferedSOAPRequestEntity bufferedEntity=new BufferedSOAPRequestEntity(requestEntity);\n  method.setRequestEntity(bufferedEntity);\n  return new SOAPRequest(method,requestEntity);\n}", "comment": "create a soap request for the given method name .", "label": "why"}
{"id": "38960", "raw_code": "private void generateUniformIntegerExamples(Instances format,int numInstances,SubspaceClusterDefinition cl,String cName){\n  Instance example=null;\n  int numAtts=m_NumAttributes;\n  if (getClassFlag()) {\n    numAtts++;\n  }\n  example=new DenseInstance(numAtts);\n  example.setDataset(format);\n  boolean[] attributes=cl.getAttributes();\n  double[] minValue=cl.getMinValue();\n  double[] maxValue=cl.getMaxValue();\n  int[] minInt=new int[minValue.length];\n  int[] maxInt=new int[maxValue.length];\n  int[] intValue=new int[maxValue.length];\n  int[] numInt=new int[minValue.length];\n  int num=1;\n  for (int i=0; i < minValue.length; i++) {\n    minInt[i]=(int)Math.ceil(minValue[i]);\n    maxInt[i]=(int)Math.floor(maxValue[i]);\n    numInt[i]=(maxInt[i] - minInt[i] + 1);\n    num=num * numInt[i];\n  }\n  int numEach=numInstances / num;\n  int rest=numInstances - numEach * num;\n  for (int i=0; i < m_NumAttributes; i++) {\n    if (attributes[i]) {\n      example.setValue(i,minInt[i]);\n      intValue[i]=minInt[i];\n    }\n else {\n      example.setMissing(i);\n    }\n  }\n  if (getClassFlag()) {\n    example.setClassValue(cName);\n  }\n  int added=0;\n  int attr=0;\n  do {\n    for (int k=0; k < numEach; k++) {\n      format.add(example);\n      example=(Instance)example.copy();\n      added++;\n    }\n    if (rest > 0) {\n      format.add(example);\n      example=(Instance)example.copy();\n      added++;\n      rest--;\n    }\n    if (added >= numInstances) {\n      break;\n    }\n    boolean done=false;\n    do {\n      if (attributes[attr] && (intValue[attr] + 1 <= maxInt[attr])) {\n        intValue[attr]++;\n        done=true;\n      }\n else {\n        attr++;\n      }\n    }\n while (!done);\n    example.setValue(attr,intValue[attr]);\n  }\n while (added < numInstances);\n}", "comment": "generate examples for a uniform cluster dataset .", "label": "why"}
{"id": "84344", "raw_code": "public void displayState(){\n  PrintWriter xout=context.get(Log.outKey);\n  xout.println(\"File Object History : \" + fileObjectHistory);\n  xout.println(\"Open Type Names     : \" + openTypeNames);\n  xout.println(\"Gen. Src Names      : \" + generatedSourceNames);\n  xout.println(\"Gen. Cls Names      : \" + generatedClasses.keySet());\n  xout.println(\"Agg. Gen. Src Names : \" + aggregateGeneratedSourceNames);\n  xout.println(\"Agg. Gen. Cls Names : \" + aggregateGeneratedClassNames);\n}", "comment": "debugging function to display internal state .", "label": "why"}
{"id": "10298", "raw_code": "public static String generateAutoTag(int stackOffset){\n  StackTraceElement[] currentStack=getCurrentStack();\n  StackTraceElement element=currentStack[stackOffset];\n  String className=element.getClassName();\n  String pkgPath[]=className.split(\"\\\\.\");\n  if (pkgPath.length > 0) {\n    className=pkgPath[pkgPath.length - 1];\n  }\n  StringBuilder sbInnerClass=new StringBuilder();\n  int index;\n  String strLoop=className;\n  while ((index=strLoop.lastIndexOf(\"$\")) != -1) {\n    String piece=strLoop.substring(index + 1);\n    sbInnerClass.insert(0,piece);\n    if (!piece.matches(\"[0-9$]+\")) {\n      break;\n    }\n    sbInnerClass.insert(0,\"$\");\n    strLoop=strLoop.substring(0,index);\n  }\n  if (sbInnerClass.length() > 0 && sbInnerClass.charAt(0) == '$') {\n    sbInnerClass.deleteCharAt(0);\n  }\n  String innerClassName=sbInnerClass.toString();\n  if (TextUtils.isDigitsOnly(innerClassName)) {\n    innerClassName=null;\n  }\n  return TextUtils.isEmpty(innerClassName) ? className : innerClassName;\n}", "comment": "generate auto tag for logs .", "label": "why"}
{"id": "61777", "raw_code": "public boolean peekSample(MediaCodec.BufferInfo out_bufferInfo){\n  update();\n  boolean result=false;\n  if (!mAvailableOutputBuffers.isEmpty()) {\n    int index=mAvailableOutputBuffers.peek();\n    MediaCodec.BufferInfo info=mOutputBufferInfo[index];\n    out_bufferInfo.set(info.offset,info.size,info.presentationTimeUs,info.flags);\n    result=true;\n  }\n  return result;\n}", "comment": "performs a peek ( ) operation in the queue to extract media info for the buffer ready to be released i . e . the head element of the queue .", "label": "why"}
{"id": "36428", "raw_code": "public AnnotationDrawer(final AnnotationsModel model,final ProcessRendererModel rendererModel){\n  this.model=model;\n  this.rendererModel=rendererModel;\n  this.displayCache=new HashMap<>();\n  this.cachedID=new HashMap<>();\n  pane=new JEditorPane(\"text/html\",\"\");\n  pane.setBorder(null);\n  pane.setOpaque(false);\n}", "comment": "creates a new drawer for the specified model and decorator .", "label": "why"}
{"id": "72342", "raw_code": "public static void threadSleep(long millis){\n  try {\n    Thread.sleep(millis);\n  }\n catch (  InterruptedException ex) {\n    Log.e(\"Exception\",StringUtils.exceptionStackTraceToString(ex));\n  }\n}", "comment": "makes the thread sleep for some time", "label": "why"}
{"id": "80247", "raw_code": "ManagedWindowDecorator(Window window,String windowId){\n  this.window=window;\n  name=\"system.\" + windowId;\n}", "comment": "create a managed window decorator with an identity for a window .", "label": "why"}
{"id": "62859", "raw_code": "private boolean needsUpdate(Long bundleVersion,String beanVersion){\n  if (beanVersion.contains(\"OAD\")) {\n    Log.i(TAG,\"Bundle version: \" + bundleVersion);\n    Log.i(TAG,\"Bean version: \" + beanVersion);\n    return true;\n  }\n else {\n    try {\n      long parsedVersion=Long.parseLong(beanVersion.split(\" \")[0]);\n      Log.i(TAG,\"Bundle version: \" + bundleVersion);\n      Log.i(TAG,\"Bean version: \" + parsedVersion);\n      if (bundleVersion > parsedVersion) {\n        return true;\n      }\n else {\n        Log.i(TAG,\"No update required!\");\n      }\n    }\n catch (    NumberFormatException e) {\n      Log.e(TAG,\"Couldn't parse Bean Version: \" + beanVersion);\n      fail(BeanError.UNPARSABLE_FW_VERSION);\n    }\n  }\n  return false;\n}", "comment": "helper function to determine whether a bean needs a fw update given a specific bundle version", "label": "why"}
{"id": "10391", "raw_code": "protected String buildQualifierRegex(String qualifierValue){\n  StringBuilder sb=new StringBuilder();\n  sb.append(\"^\");\n  sb.append(qualifierValue);\n  sb.append(\"$\");\n  return sb.toString();\n}", "comment": "just used for like and not _ like", "label": "why"}
{"id": "5014", "raw_code": "private void decideUILookAndFeel(MainOptions options){\n  try {\n    boolean systemPlaf=false;\n    systemPlaf=options.system_plaf;\n    String systemPlafReq=System.getenv(\"systemplaf\");\n    if (systemPlafReq != null && systemPlafReq.equalsIgnoreCase(\"true\"))     systemPlaf=true;\n    if (systemPlaf)     UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n  }\n catch (  Exception exc) {\n    exc.printStackTrace();\n  }\n}", "comment": "normally the look and feel should be the standard one , java , allow to set the systemplaf to have the system look and feel", "label": "why"}
{"id": "32183", "raw_code": "public void register(GridCacheTtlManager mgr){\nsynchronized (mux) {\n    if (cleanupWorker == null)     startCleanupWorker();\n    mgrs.add(mgr);\n  }\n}", "comment": "register ttl manager of cache for periodical check on expired entries .", "label": "why"}
{"id": "4234", "raw_code": "public static String generateScaleMarkers(int proteinLength,int maxNumScaleMarkers){\n  if (maxNumScaleMarkers < 2) {\n    maxNumScaleMarkers=2;\n  }\n  int scale=calcScale(proteinLength,maxNumScaleMarkers);\n  StringBuilder sb=new StringBuilder(\"0\");\n  int index=0;\n  int numRemaining=proteinLength;\n  while (index <= proteinLength) {\n    index+=scale;\n    numRemaining-=scale;\n    sb.append(\",\");\n    if ((numRemaining > 0) && (numRemaining < scale)) {\n      if (numRemaining < (scale / 2)) {\n        sb.append(proteinLength);\n        break;\n      }\n    }\n    if (index >= proteinLength) {\n      sb.append(proteinLength);\n    }\n else {\n      sb.append(index);\n    }\n  }\n  return sb.toString();\n}", "comment": "generate a string of comma - separated numbers that will be used to mark the scale of the match diagram .", "label": "why"}
{"id": "71644", "raw_code": "protected int createHashCode(){\n  int result=uri.hashCode() ^ prefix.hashCode();\n  if (result == 0) {\n    result=0xbabe;\n  }\n  return result;\n}", "comment": "factory method to create the hashcode allowing derived classes to change the behaviour", "label": "why"}
{"id": "42995", "raw_code": "public ResultFileReader(Problem problem,File file) throws IOException {\n  super();\n  this.problem=problem;\n  reader=new BufferedReader(new FileReader(file));\n  line=reader.readLine();\n}", "comment": "constructs a result file reader for reading the approximation sets from the specified result file .", "label": "why"}
{"id": "44925", "raw_code": "static private String SHORT_Max_Plus(){\n  long tempValue=Short.MAX_VALUE + 1;\n  return String.valueOf(tempValue);\n}", "comment": "get the max value plus one for a short", "label": "why"}
{"id": "11110", "raw_code": "public void firePropertyChange(String name,Object oldValue,Object newValue){\n  beanContextChildSupport.firePropertyChange(name,oldValue,newValue);\n}", "comment": "method for beancontextchild interface .", "label": "why"}
{"id": "56869", "raw_code": "public void createDatabaseEntitiesForStoragePolicyTesting(){\n  createDatabaseEntitiesForStoragePolicyTesting(AbstractServiceTest.STORAGE_POLICY_NAMESPACE_CD,Arrays.asList(AbstractServiceTest.STORAGE_POLICY_RULE_TYPE),AbstractServiceTest.BDEF_NAMESPACE,AbstractServiceTest.BDEF_NAME,Arrays.asList(AbstractServiceTest.FORMAT_FILE_TYPE_CODE),Arrays.asList(AbstractServiceTest.STORAGE_NAME),Arrays.asList(AbstractServiceTest.STORAGE_NAME_2));\n}", "comment": "create and persist database entities required for storage policy service testing .", "label": "why"}
{"id": "33245", "raw_code": "public RemoverManager track(Remover remover){\n  if (handlers == null) {\n    handlers=new ArrayList<>();\n  }\n  handlers.add(remover);\n  return this;\n}", "comment": "tracks a new handler so that it can be removed in bulk .", "label": "why"}
{"id": "82934", "raw_code": "public String constructTSDBMetricName(){\n  StringBuilder sb=new StringBuilder(getScope());\n  if (_namespace != null && !_namespace.isEmpty()) {\n    sb.append(getNamespace());\n  }\n  return sb.toString();\n}", "comment": "constructs a native tsdb metric name for this metric .", "label": "why"}
{"id": "39084", "raw_code": "public void enableDependency(Capability c){\n  if (doNotCheckCapabilities()) {\n    return;\n  }\n  if (c == Capability.NOMINAL_ATTRIBUTES) {\n    enableDependency(Capability.BINARY_ATTRIBUTES);\n  }\n else   if (c == Capability.BINARY_ATTRIBUTES) {\n    enableDependency(Capability.UNARY_ATTRIBUTES);\n  }\n else   if (c == Capability.UNARY_ATTRIBUTES) {\n    enableDependency(Capability.EMPTY_NOMINAL_ATTRIBUTES);\n  }\n else   if (c == Capability.NOMINAL_CLASS) {\n    enableDependency(Capability.BINARY_CLASS);\n  }\n  m_Dependencies.add(c);\n}", "comment": "enables the dependency flag for the given capability enabling nominal _ attributes also enables binary _ attributes , unary _ attributes and empty _ nominal _ attributes .", "label": "why"}
{"id": "71281", "raw_code": "public IVariable[] extractRobotDebugVariables(final int stackTraceId,final Map<String,Object> newVariables){\n  final RobotDebugVariablesContext currentVariablesContext=findCurrentVariablesContext(stackTraceId);\n  Map<String,IVariable> previousVariablesMap=initPreviousVariablesState(currentVariablesContext);\n  final Map<String,IVariable> nonGlobalVariablesMap=new LinkedHashMap<>();\n  if (previousVariablesMap == null) {\n    initNewNonGlobalVariables(newVariables,nonGlobalVariablesMap);\n  }\n else {\n    initVariablesComparingWithPreviousState(newVariables,previousVariablesMap,nonGlobalVariablesMap);\n  }\n  final LinkedList<IVariable> currentVariablesList=createCurrentVariablesList(nonGlobalVariablesMap);\n  saveCurrentVariablesState(stackTraceId,currentVariablesContext,nonGlobalVariablesMap);\n  return currentVariablesList.toArray(new IVariable[currentVariablesList.size()]);\n}", "comment": "extract and sort variables for given stacktrace level .", "label": "why"}
{"id": "73954", "raw_code": "@Override public void messageItemDetails(String strClass,String item,String description,String[] msgOption,int[] msgNumber,int defaultOption){\n  HashMap<Integer,String> options=new HashMap<>(msgOption.length);\n  for (int i=0; i < msgOption.length; i++) {\n    options.put(msgNumber[i],msgOption[i]);\n  }\n  messageItemDetails(strClass,description,item,options,defaultOption);\n}", "comment": "add descriptive details about a specific message box , so that if it needs to be reset in the preferences , then it is easily identifiable .", "label": "why"}
{"id": "78969", "raw_code": "public void closeStream(){\n  CarbonUtil.closeStreams(stream);\n  executorService.shutdown();\n}", "comment": "below method will be used to close streams", "label": "why"}
{"id": "7927", "raw_code": "public static List seriesNameListFromDataArray(Object[][] data){\n  int seriesCount=data.length;\n  List seriesNameList=new java.util.ArrayList(seriesCount);\n  for (int i=0; i < seriesCount; i++) {\n    seriesNameList.add(\"Series \" + (i + 1));\n  }\n  return seriesNameList;\n}", "comment": "utility method for automatically generating series names .", "label": "why"}
{"id": "13132", "raw_code": "private static String expandSystemIdStrictOn(String systemId,String baseSystemId) throws URI.MalformedURIException {\n  URI systemURI=new URI(systemId,true);\n  if (systemURI.isAbsoluteURI()) {\n    return systemId;\n  }\n  URI baseURI=null;\n  if (baseSystemId == null || baseSystemId.length() == 0) {\n    baseURI=getUserDir();\n  }\n else {\n    baseURI=new URI(baseSystemId,true);\n    if (!baseURI.isAbsoluteURI()) {\n      baseURI.absolutize(getUserDir());\n    }\n  }\n  systemURI.absolutize(baseURI);\n  return systemURI.toString();\n}", "comment": "helper method for expandsystemid ( string , string , boolean ) : string", "label": "why"}
{"id": "54789", "raw_code": "public static void free(DMessage msg){\n  int index=size2Index(msg.getSize());\n  msg.clear();\n  if (index < 0)   ;\n else   if (m_cache[index] != null)   ;\n else   m_cache[index]=msg;\n}", "comment": "put a dmessage into the cache for reuse", "label": "why"}
{"id": "64656", "raw_code": "protected static Long convertUuidToLong(UUID uuid){\n  if (uuid == null) {\n    return null;\n  }\n  Long convertedUuid;\n  if (uuid.version() == 1) {\n    convertedUuid=uuid.timestamp();\n  }\n else {\n    convertedUuid=uuid.getMostSignificantBits();\n  }\n  return convertedUuid;\n}", "comment": "converts a uuid to a long for bucketing purposes .", "label": "why"}
{"id": "22032", "raw_code": "public TaskResourceRep unlinkTargetVolumesFromSnapshotSession(URI snapSessionURI,SnapshotSessionUnlinkTargetsParam param){\n  return unlinkTargetVolumesFromSnapshotSession(snapSessionURI,param,OperationTypeEnum.UNLINK_SNAPSHOT_SESSION_TARGET);\n}", "comment": "implements a request to unlink the passed targets from the blocksnapshotsession instance with the passed uri .", "label": "why"}
{"id": "73915", "raw_code": "public void updateButtonActionPerformed(){\n  if (!readReceiveDelay()) {\n    return;\n  }\n  if (!readPulseWidth()) {\n    return;\n  }\n  if (!checkConsistency()) {\n    return;\n  }\n  if (curNode.getNodeType() != nodeType) {\n    curNode.setNodeType(nodeType);\n  }\n  setNodeParameters();\n  changedNode=true;\n  editMode=false;\n  curNode=null;\n  addButton.setVisible(true);\n  editButton.setVisible(true);\n  deleteButton.setVisible(true);\n  doneButton.setVisible(true);\n  updateButton.setVisible(false);\n  cancelButton.setVisible(false);\n  nodeAddrField.setVisible(true);\n  nodeAddrStatic.setVisible(false);\n  statusText2.setText(stdStatus2);\n  statusText3.setText(stdStatus3);\n  statusText1.setText(rb.getString(\"FeedBackUpdate\") + \" \" + Integer.toString(nodeAddress));\n  errorInStatus1=true;\n}", "comment": "method to handle update button", "label": "why"}
{"id": "6594", "raw_code": "private Component createSeparator(){\n  JSeparator sep=new JSeparator(SwingConstants.VERTICAL);\n  sep.setPreferredSize(new Dimension(2,30));\n  sep.setMinimumSize(new Dimension(2,30));\n  return sep;\n}", "comment": "creates a vertical separator for visually separating status bar elements", "label": "why"}
{"id": "53469", "raw_code": "public static double[][] computeWeightMatrix(final int quanth,final int quants,final int quantb){\n  final int dim=quanth * quants * quantb;\n  assert (dim > 0);\n  final double[][] m=new double[dim][dim];\n  for (int x=0; x < dim; x++) {\n    final int hx=x / (quantb * quants);\n    final int sx=(x / quantb) % quants;\n    final int bx=x % quantb;\n    for (int y=x; y < dim; y++) {\n      final int hy=y / (quantb * quants);\n      final int sy=(y / quantb) % quants;\n      final int by=y % quantb;\n      final double chx=Math.cos((hx + .5) / quanth * MathUtil.TWOPI);\n      final double chy=Math.cos((hy + .5) / quanth * MathUtil.TWOPI);\n      final double shx=MathUtil.cosToSin((hx + .5) / quanth * MathUtil.TWOPI,chx);\n      final double shy=MathUtil.cosToSin((hy + .5) / quanth * MathUtil.TWOPI,chy);\n      final double cos=chx * (sx + .5) / quants - chy * (sy + .5) / quants;\n      final double sin=shx * (sx + .5) / quants - shy * (sy + .5) / quants;\n      final double db=(bx - by) / (double)quantb;\n      final double val=1. - Math.sqrt((db * db + sin * sin + cos * cos) / 5);\n      m[x][y]=m[y][x]=val;\n    }\n  }\n  return m;\n}", "comment": "compute the weight matrix for hsb similarity .", "label": "why"}
{"id": "14268", "raw_code": "private static void createOrgAuthConfig(String realmName) throws Exception {\n  String classMethod=\"UpgradeUtils:createOrgAuthConfig: \";\n  OrganizationConfigManager org=new OrganizationConfigManager(ssoToken,realmName);\n  ServiceConfig orgConfig=org.getServiceConfig(AUTH_SERVICE_NAME);\n  if (orgConfig != null) {\n    Map aa=orgConfig.getAttributes();\n    if (debug.messageEnabled()) {\n      debug.message(classMethod + \"Org is :\" + realmName);\n      debug.message(classMethod + \"Attribute Map is :\" + aa);\n    }\n    String orgName=realmName;\n    if (LDAPUtils.isDN(realmName)) {\n      orgName=LDAPUtils.rdnValueFromDn(realmName);\n    }\n    String authConfigName=orgName + \"-authconfig\";\n    String adminAuthConfigName=orgName + \"-admin-authconfig\";\n    Set authConfigAttrValue=(Set)aa.get(ATTR_ORG_AUTH_MODULE);\n    if (debug.messageEnabled()) {\n      debug.message(classMethod + \"authConfigAttrValue : \" + authConfigAttrValue);\n    }\n    Set newVal=new HashSet();\n    if (authConfigAttrValue.size() != 1 && !authConfigAttrValue.contains(authConfigName)) {\n      newVal.add(authConfigName);\n      orgConfig.replaceAttributeValues(ATTR_ORG_AUTH_MODULE,authConfigAttrValue,newVal);\n    }\n    Set adminConfigAttrValue=(Set)aa.get(ATTR_ADMIN_AUTH_MODULE);\n    if (debug.messageEnabled()) {\n      debug.message(\"adminauthConfigAttrValue : \" + adminConfigAttrValue);\n    }\n    if (adminConfigAttrValue.size() != 1 && !adminConfigAttrValue.contains(adminAuthConfigName)) {\n      newVal.clear();\n      newVal.add(adminAuthConfigName);\n      orgConfig.replaceAttributeValues(ATTR_ADMIN_AUTH_MODULE,adminConfigAttrValue,newVal);\n    }\n    aa=orgConfig.getAttributes();\n    ServiceConfig s=org.getServiceConfig(AUTH_CONFIG_SERVICE);\n    ServiceConfig authConfig=s.getSubConfig(NAMED_CONFIG);\n    if (authConfig == null) {\n      s.addSubConfig(NAMED_CONFIG,null,0,null);\n      authConfig=s.getSubConfig(NAMED_CONFIG);\n    }\n    Map aMap=new HashMap();\n    aMap.put(ATTR_AUTH_CONFIG,authConfigAttrValue);\n    authConfig.addSubConfig(authConfigName,SUB_NAMED_CONFIG,0,aMap);\n    aMap.clear();\n    aMap.put(ATTR_AUTH_CONFIG,adminConfigAttrValue);\n    authConfig.addSubConfig(adminAuthConfigName,SUB_NAMED_CONFIG,0,aMap);\n  }\n}", "comment": "creates auth configurations for auth modules configuration in core auth service .", "label": "why"}
{"id": "39248", "raw_code": "public CholeskyDecomposition(Matrix Arg){\n  double[][] A=Arg.getArray();\n  n=Arg.getRowDimension();\n  L=new double[n][n];\n  isspd=(Arg.getColumnDimension() == n);\n  for (int j=0; j < n; j++) {\n    double[] Lrowj=L[j];\n    double d=0.0;\n    for (int k=0; k < j; k++) {\n      double[] Lrowk=L[k];\n      double s=0.0;\n      for (int i=0; i < k; i++) {\n        s+=Lrowk[i] * Lrowj[i];\n      }\n      Lrowj[k]=s=(A[j][k] - s) / L[k][k];\n      d=d + s * s;\n      isspd=isspd & (A[k][j] == A[j][k]);\n    }\n    d=A[j][j] - d;\n    isspd=isspd & (d > 0.0);\n    L[j][j]=Math.sqrt(Math.max(d,0.0));\n    for (int k=j + 1; k < n; k++) {\n      L[j][k]=0.0;\n    }\n  }\n}", "comment": "cholesky algorithm for symmetric and positive definite matrix .", "label": "why"}
{"id": "25901", "raw_code": "public void addProperty(String key,String value){\n  carbonProperties.setProperty(key,value);\n}", "comment": "this method will be used to add a new property", "label": "why"}
{"id": "57270", "raw_code": "public static void registerApp(int application,String appName) throws AppIDException {\n  if ((application & APP_ID_MASK) != application) {\n    throw new InvalidAppIDValueException(application);\n  }\n  String oldApp=appIdMap.putIfAbsent(application,appName);\n  if (oldApp != null && !oldApp.equals(appName)) {\n    throw new AppIDInUseException(application,oldApp,appName);\n  }\n}", "comment": "a lame attempt to prevent duplicate application id .", "label": "why"}
{"id": "24115", "raw_code": "public boolean putProfile(Profile profile){\n  return putProfile(profile,false);\n}", "comment": "create or update a profile for a remote counterpart .", "label": "why"}
{"id": "47787", "raw_code": "private static int convertSRGBtoLinearRGB(int color){\n  float input, output;\n  input=color / 255.0f;\n  if (input <= 0.04045f) {\n    output=input / 12.92f;\n  }\n else {\n    output=(float)Math.pow((input + 0.055) / 1.055,2.4);\n  }\n  return Math.round(output * 255.0f);\n}", "comment": "helper function to convert a color component in srgb space to linear rgb space .", "label": "why"}
{"id": "71121", "raw_code": "public void addSplitEdges(List edgeList){\n  addEndpoints();\n  Iterator it=iterator();\n  EdgeIntersection eiPrev=(EdgeIntersection)it.next();\n  while (it.hasNext()) {\n    EdgeIntersection ei=(EdgeIntersection)it.next();\n    Edge newEdge=createSplitEdge(eiPrev,ei);\n    edgeList.add(newEdge);\n    eiPrev=ei;\n  }\n}", "comment": "creates new edges for all the edges that the intersections in this list split the parent edge into .", "label": "why"}
{"id": "34629", "raw_code": "public void updateMaxTextWidths(float requiredWidth,float matchContentsWidth){\n  mMaxRequiredWidth=Math.max(mMaxRequiredWidth,requiredWidth);\n  mMaxMatchContentsWidth=Math.max(mMaxMatchContentsWidth,matchContentsWidth);\n}", "comment": "updates the max text width values for the suggestions .", "label": "why"}
{"id": "49937", "raw_code": "public boolean addNode(Lop node){\n  if (nodes.contains(node))   return false;\n  nodes.add(node);\n  return true;\n}", "comment": "method to add a node to the dag .", "label": "why"}
{"id": "65252", "raw_code": "private MethodDescriptor[] sortMethodDescriptors(MethodDescriptor[] methodDescriptors){\n  return methodSorter != null ? methodSorter.sortMethodDescriptors(methodDescriptors) : methodDescriptors;\n}", "comment": "as of this writing , this is only used for testing if method order really doesn ' t mater .", "label": "why"}
{"id": "71843", "raw_code": "private static String[] collationMatchingRuleNames(final List<String> localeNames,final int numSuffix,final String symbolicSuffix){\n  final List<String> names=new ArrayList<>();\n  for (  String localeName : localeNames) {\n    if (symbolicSuffix.isEmpty()) {\n      names.add(localeName);\n    }\n else {\n      names.add(localeName + \".\" + numSuffix);\n      names.add(localeName + \".\" + symbolicSuffix);\n    }\n  }\n  return names.toArray(new String[names.size()]);\n}", "comment": "build the complete list of names for a collation matching rule .", "label": "why"}
{"id": "9454", "raw_code": "public void registerManufacturerSpecificBuilder(int companyId,ADManufacturerSpecificBuilder builder){\n  if (companyId < 0 || 0xFFFF < companyId) {\n    String message=String.format(\"'companyId' is out of the valid range: %d\",companyId);\n    throw new IllegalArgumentException(message);\n  }\n  if (builder == null) {\n    return;\n  }\n  Integer key=Integer.valueOf(companyId);\n  List<ADManufacturerSpecificBuilder> builders=mMSBuilders.get(key);\n  if (builders == null) {\n    builders=new ArrayList<ADManufacturerSpecificBuilder>();\n    mMSBuilders.put(key,builders);\n  }\n  builders.add(0,builder);\n}", "comment": "register a builder for the company id .", "label": "why"}
{"id": "36982", "raw_code": "public static ReilGraph copyReilCode(final Window parent,final INaviCodeNode node){\n  final ReilTranslator<INaviInstruction> translator=new ReilTranslator<INaviInstruction>();\n  try {\n    return translator.translate(new StandardEnvironment(),node);\n  }\n catch (  final InternalTranslationException e) {\n    CUtilityFunctions.logException(e);\n    final String message=\"E000XXX: \" + \"Could not show REIL code for node\";\n    final String description=CUtilityFunctions.createDescription(String.format(\"BinNavi could not show the REIL code for basic block at '%X'.\",node.getAddress()),new String[]{\"The instructions could not be converted to REIL code.\"},new String[]{\"You can not fix this problem yourself. Please contact \" + \"the BinNavi support.\"});\n    NaviErrorDialog.show(parent,message,description,e);\n  }\n  return null;\n}", "comment": "copy reil code for node", "label": "why"}
{"id": "49950", "raw_code": "public String prepOperand(String label,DataType dt,ValueType vt,boolean literal){\n  StringBuilder sb=new StringBuilder();\n  sb.append(label);\n  sb.append(Lop.DATATYPE_PREFIX);\n  sb.append(dt);\n  sb.append(Lop.VALUETYPE_PREFIX);\n  sb.append(vt);\n  sb.append(Lop.LITERAL_PREFIX);\n  sb.append(literal);\n  return sb.toString();\n}", "comment": "method to prepare instruction operand with given parameters .", "label": "why"}
{"id": "16036", "raw_code": "public ISO9796d2PSSSigner(AsymmetricBlockCipher cipher,Digest digest,int saltLength,boolean implicit){\n  this.cipher=cipher;\n  this.digest=digest;\n  this.hLen=digest.getDigestSize();\n  this.saltLength=saltLength;\n  if (implicit) {\n    trailer=TRAILER_IMPLICIT;\n  }\n else {\n    Integer trailerObj=(Integer)trailerMap.get(digest.getAlgorithmName());\n    if (trailerObj != null) {\n      trailer=trailerObj.intValue();\n    }\n else {\n      throw new IllegalArgumentException(\"no valid trailer for digest\");\n    }\n  }\n}", "comment": "generate a signer for the with either implicit or explicit trailers for iso9796 - 2 , scheme 2 or 3 .", "label": "why"}
{"id": "1506", "raw_code": "public Line3D(Stack<Vector3> points,float thickness,int[] colors,boolean createVBOs){\n  super();\n  mPoints=points;\n  mLineThickness=thickness;\n  mColors=colors;\n  if (colors != null && colors.length != points.size())   throw new RuntimeException(\"The number of line points and colors is not the same.\");\n  init(createVBOs);\n}", "comment": "creates a line primitive with a specified color for each point .", "label": "why"}
{"id": "74156", "raw_code": "public synchronized void init(){\n  ArrayList<Warrant> tempList=new ArrayList<Warrant>();\n  List<String> systemNameList=_manager.getSystemNameList();\n  Iterator<String> iter=systemNameList.iterator();\n  while (iter.hasNext()) {\n    Warrant w=_manager.getBySystemName(iter.next());\n    if (!_warList.contains(w)) {\n      w.addPropertyChangeListener(this);\n    }\n else {\n      _warList.remove(w);\n    }\n    tempList.add(w);\n  }\n  for (int i=0; i < _warList.size(); i++) {\n    Warrant w=_warList.get(i);\n    if (!_warNX.contains(w)) {\n      w.removePropertyChangeListener(this);\n    }\n  }\n  for (int i=0; i < _warNX.size(); i++) {\n    tempList.add(_warNX.get(i));\n  }\n  _warList=tempList;\n}", "comment": "preserve current listeners so that there is no gap to miss a propertychange", "label": "why"}
{"id": "28860", "raw_code": "public void reset(boolean clear){\n  gotVersion=false;\n  gotHeaderLength=false;\n  gotHeader=false;\n  gotBody=false;\n  gotBodyBoundary=false;\n  headerLength=0;\n  bodyLength=0;\n  bodyBytesReceived=0;\n  if (clear) {\n    bufferOffset=0;\n    buffer.clear();\n    bodyFile=null;\n    if (bodyStream != null) {\n      try {\n        bodyStream.close();\n      }\n catch (      IOException e) {\n        e.printStackTrace();\n      }\n      bodyStream=null;\n    }\n  }\n}", "comment": "reset the state of the receiver in preparation for a new sessionmessage .", "label": "why"}
{"id": "26579", "raw_code": "public void sendMetric(final String name,final double value){\n  logger.debug(String.format(\"sendMetric(%s, %f)\",name,value));\n  if (telemetryClient != null) {\n    telemetryClient.trackMetric(name,value);\n  }\n}", "comment": "call sendmetric to track the new value of the named metric .", "label": "why"}
{"id": "15627", "raw_code": "public static URL findResourceBase(String baseResource,ClassLoader loader){\n  URL url=loader.getResource(baseResource);\n  return findResourceBase(url,baseResource);\n}", "comment": "find the classpath url for a specific classpath resource .", "label": "why"}
{"id": "85879", "raw_code": "public HttpMethodInfo(Method method,Object handler,Object[] args,MultivaluedMap<String,Object> formParameters,Response responder){\n  this.method=method;\n  this.handler=handler;\n  this.args=Arrays.copyOf(args,args.length);\n  this.formParameters=formParameters;\n  this.responder=responder;\n}", "comment": "construct httpmethodinfo object for a handler method that does not support streaming .", "label": "why"}
{"id": "38369", "raw_code": "private void drawText(int x1,int y1,int s,boolean e_or_n,Graphics g){\n  Color oldColor=g.getColor();\n  g.setPaintMode();\n  if (m_FontColor == null) {\n    g.setColor(Color.black);\n  }\n else {\n    g.setColor(m_FontColor);\n  }\n  String st;\n  if (e_or_n) {\n    Edge e=m_edges[s].m_edge;\n    for (int noa=0; (st=e.getLine(noa)) != null; noa++) {\n      g.drawString(st,(m_edges[s].m_width - m_fontSize.stringWidth(st)) / 2 + x1,y1 + (noa + 1) * m_fontSize.getHeight());\n    }\n  }\n else {\n    Node e=m_nodes[s].m_node;\n    for (int noa=0; (st=e.getLine(noa)) != null; noa++) {\n      g.drawString(st,(m_nodes[s].m_width - m_fontSize.stringWidth(st)) / 2 + x1,y1 + (noa + 1) * m_fontSize.getHeight());\n    }\n  }\n  g.setColor(oldColor);\n}", "comment": "draws the text for either an edge or a node .", "label": "why"}
{"id": "40476", "raw_code": "public void tableSwitch(final int[] keys,final TableSwitchGenerator generator,final boolean useTable){\n  for (int i=1; i < keys.length; ++i) {\n    if (keys[i] < keys[i - 1]) {\n      throw new IllegalArgumentException(\"keys must be sorted ascending\");\n    }\n  }\n  Label def=newLabel();\n  Label end=newLabel();\n  if (keys.length > 0) {\n    int len=keys.length;\n    int min=keys[0];\n    int max=keys[len - 1];\n    int range=max - min + 1;\n    if (useTable) {\n      Label[] labels=new Label[range];\n      Arrays.fill(labels,def);\n      for (int i=0; i < len; ++i) {\n        labels[keys[i] - min]=newLabel();\n      }\n      mv.visitTableSwitchInsn(min,max,def,labels);\n      for (int i=0; i < range; ++i) {\n        Label label=labels[i];\n        if (label != def) {\n          mark(label);\n          generator.generateCase(i + min,end);\n        }\n      }\n    }\n else {\n      Label[] labels=new Label[len];\n      for (int i=0; i < len; ++i) {\n        labels[i]=newLabel();\n      }\n      mv.visitLookupSwitchInsn(def,keys,labels);\n      for (int i=0; i < len; ++i) {\n        mark(labels[i]);\n        generator.generateCase(keys[i],end);\n      }\n    }\n  }\n  mark(def);\n  generator.generateDefault();\n  mark(end);\n}", "comment": "generates the instructions for a switch statement .", "label": "why"}
{"id": "46588", "raw_code": "static SizeRequirements calculateTiledRequirements(LayoutIterator iter,SizeRequirements r){\n  long minimum=0;\n  long maximum=0;\n  long preferred=0;\n  int lastMargin=0;\n  int totalSpacing=0;\n  int n=iter.getCount();\n  for (int i=0; i < n; i++) {\n    iter.setIndex(i);\n    int margin0=lastMargin;\n    int margin1=(int)iter.getLeadingCollapseSpan();\n    totalSpacing+=Math.max(margin0,margin1);\n    preferred+=(int)iter.getPreferredSpan(0);\n    minimum+=iter.getMinimumSpan(0);\n    maximum+=iter.getMaximumSpan(0);\n    lastMargin=(int)iter.getTrailingCollapseSpan();\n  }\n  totalSpacing+=lastMargin;\n  totalSpacing+=2 * iter.getBorderWidth();\n  minimum+=totalSpacing;\n  preferred+=totalSpacing;\n  maximum+=totalSpacing;\n  if (r == null) {\n    r=new SizeRequirements();\n  }\n  r.minimum=(minimum > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)minimum;\n  r.preferred=(preferred > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)preferred;\n  r.maximum=(maximum > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)maximum;\n  return r;\n}", "comment": "calculate the requirements needed to tile the requirements given by the iterator that would be tiled .", "label": "why"}
{"id": "53216", "raw_code": "private void divide(int[] idx,double[] data,ArrayList<int[]> ret,int start,int end,int depth){\n  if (depth == 0) {\n    int[] a=Arrays.copyOfRange(idx,start,end);\n    Arrays.sort(a);\n    ret.add(a);\n    return;\n  }\n  final int count=end - start;\n  if (count == 0) {\n    for (int j=1 << depth; j > 0; --j) {\n      ret.add(new int[0]);\n    }\n    return;\n  }\n  double m=0.;\n  for (int i=start; i < end; i++) {\n    m+=data[i];\n  }\n  m/=count;\n  int pos=Arrays.binarySearch(data,start,end,m);\n  if (pos >= 0) {\n    final int opt=(start + end) >> 1;\n    while (data[pos] == m) {\n      if (pos < opt) {\n        pos++;\n      }\n else       if (pos > opt) {\n        pos--;\n      }\n else {\n        break;\n      }\n    }\n  }\n else {\n    pos=(-pos - 1);\n  }\n  divide(idx,data,ret,start,pos,depth - 1);\n  divide(idx,data,ret,pos,end,depth - 1);\n}", "comment": "recursive call to further subdivide the array .", "label": "why"}
{"id": "4940", "raw_code": "public final boolean insert_via(BrdViaInfo p_via_info,PlaPointInt p_location,NetNosList p_net_no_arr,int p_trace_clearance_class_no,int[] p_trace_pen_halfwidth_arr,int p_max_recursion_depth,int p_max_via_recursion_depth,int p_pull_tight_accuracy,int p_pull_tight_time_limit){\n  shove_fail_clear();\n  changed_area_clear();\n  boolean r_ok=shove_via_algo.shove_via_insert(p_via_info,p_location,p_net_no_arr,p_trace_clearance_class_no,p_trace_pen_halfwidth_arr,p_max_recursion_depth,p_max_via_recursion_depth);\n  if (!r_ok)   return false;\n  NetNosList opt_net_no_arr=p_max_recursion_depth <= 0 ? p_net_no_arr : NetNosList.EMPTY;\n  TimeLimitStoppable t_limit=new TimeLimitStoppable(s_PREVENT_ENDLESS_LOOP);\n  changed_area_optimize(opt_net_no_arr,p_pull_tight_accuracy,null,t_limit,null);\n  return true;\n}", "comment": "shoves aside traces , so that a via with the input parameters can be inserted without clearance violations .", "label": "why"}
{"id": "74860", "raw_code": "private char[] fFormatDigits(final double x){\n  String sx;\n  int i, j, k;\n  final int n1In;\n  final int n2In;\n  int expon=0;\n  boolean minusSign=false;\n  if (x > 0.0) {\n    sx=Double.toString(x);\n  }\n else   if (x < 0.0) {\n    sx=Double.toString(-x);\n    minusSign=true;\n  }\n else {\n    sx=Double.toString(x);\n    if (sx.charAt(0) == '-') {\n      minusSign=true;\n      sx=sx.substring(1);\n    }\n  }\n  final int ePos=sx.indexOf('E');\n  final int rPos=sx.indexOf('.');\n  if (rPos != -1) {\n    n1In=rPos;\n  }\n else   if (ePos != -1) {\n    n1In=ePos;\n  }\n else {\n    n1In=sx.length();\n  }\n  if (rPos != -1) {\n    if (ePos != -1) {\n      n2In=ePos - rPos - 1;\n    }\n else {\n      n2In=sx.length() - rPos - 1;\n    }\n  }\n else {\n    n2In=0;\n  }\n  if (ePos != -1) {\n    int ie=ePos + 1;\n    expon=0;\n    if (sx.charAt(ie) == '-') {\n      for (++ie; ie < sx.length(); ie++) {\n        if (sx.charAt(ie) != '0') {\n          break;\n        }\n      }\n      if (ie < sx.length()) {\n        expon=-Integer.parseInt(sx.substring(ie));\n      }\n    }\n else {\n      if (sx.charAt(ie) == '+') {\n        ++ie;\n      }\n      for (; ie < sx.length(); ie++) {\n        if (sx.charAt(ie) != '0') {\n          break;\n        }\n      }\n      if (ie < sx.length()) {\n        expon=Integer.parseInt(sx.substring(ie));\n      }\n    }\n  }\n  final int p;\n  if (precisionSet) {\n    p=precision;\n  }\n else {\n    p=defaultDigits - 1;\n  }\n  final char[] ca1=sx.toCharArray();\n  final char[] ca2=new char[n1In + n2In];\n  final char[] ca3;\n  final char[] ca4;\n  final char[] ca5;\n  for (j=0; j < n1In; j++) {\n    ca2[j]=ca1[j];\n  }\n  i=j + 1;\n  for (k=0; k < n2In; j++, i++, k++) {\n    ca2[j]=ca1[i];\n  }\n  if (n1In + expon <= 0) {\n    ca3=new char[-expon + n2In];\n    for (j=0, k=0; k < (-n1In - expon); k++, j++) {\n      ca3[j]='0';\n    }\n    for (i=0; i < (n1In + n2In); i++, j++) {\n      ca3[j]=ca2[i];\n    }\n  }\n else {\n    ca3=ca2;\n  }\n  boolean carry=false;\n  if (p < -expon + n2In) {\n    if (expon < 0) {\n      i=p;\n    }\n else {\n      i=p + n1In;\n    }\n    carry=checkForCarry(ca3,i);\n    if (carry) {\n      carry=startSymbolicCarry(ca3,i - 1,0);\n    }\n  }\n  if (n1In + expon <= 0) {\n    ca4=new char[2 + p];\n    if (!carry) {\n      ca4[0]='0';\n    }\n else {\n      ca4[0]='1';\n    }\n    if (alternateForm || !precisionSet || precision != 0) {\n      ca4[1]='.';\n      for (i=0, j=2; i < Math.min(p,ca3.length); i++, j++) {\n        ca4[j]=ca3[i];\n      }\n      for (; j < ca4.length; j++) {\n        ca4[j]='0';\n      }\n    }\n  }\n else {\n    if (!carry) {\n      if (alternateForm || !precisionSet || precision != 0) {\n        ca4=new char[n1In + expon + p+ 1];\n      }\n else {\n        ca4=new char[n1In + expon];\n      }\n      j=0;\n    }\n else {\n      if (alternateForm || !precisionSet || precision != 0) {\n        ca4=new char[n1In + expon + p+ 2];\n      }\n else {\n        ca4=new char[n1In + expon + 1];\n      }\n      ca4[0]='1';\n      j=1;\n    }\n    for (i=0; i < Math.min(n1In + expon,ca3.length); i++, j++) {\n      ca4[j]=ca3[i];\n    }\n    for (; i < n1In + expon; i++, j++) {\n      ca4[j]='0';\n    }\n    if (alternateForm || !precisionSet || precision != 0) {\n      ca4[j]='.';\n      j++;\n      for (k=0; i < ca3.length && k < p; i++, j++, k++) {\n        ca4[j]=ca3[i];\n      }\n      for (; j < ca4.length; j++) {\n        ca4[j]='0';\n      }\n    }\n  }\n  int nZeros=0;\n  if (!leftJustify && leadingZeros) {\n    int xThousands=0;\n    if (thousands) {\n      int xlead=0;\n      if (ca4[0] == '+' || ca4[0] == '-' || ca4[0] == ' ') {\n        xlead=1;\n      }\n      int xdp=xlead;\n      for (; xdp < ca4.length; xdp++) {\n        if (ca4[xdp] == '.') {\n          break;\n        }\n      }\n      xThousands=(xdp - xlead) / 3;\n    }\n    if (fieldWidthSet) {\n      nZeros=fieldWidth - ca4.length;\n    }\n    if ((!minusSign && (leadingSign || leadingSpace)) || minusSign) {\n      nZeros--;\n    }\n    nZeros-=xThousands;\n    if (nZeros < 0) {\n      nZeros=0;\n    }\n  }\n  j=0;\n  if ((!minusSign && (leadingSign || leadingSpace)) || minusSign) {\n    ca5=new char[ca4.length + nZeros + 1];\n    j++;\n  }\n else {\n    ca5=new char[ca4.length + nZeros];\n  }\n  if (!minusSign) {\n    if (leadingSign) {\n      ca5[0]='+';\n    }\n    if (leadingSpace) {\n      ca5[0]=' ';\n    }\n  }\n else {\n    ca5[0]='-';\n  }\n  for (i=0; i < nZeros; i++, j++) {\n    ca5[j]='0';\n  }\n  for (i=0; i < ca4.length; i++, j++) {\n    ca5[j]=ca4[i];\n  }\n  int lead=0;\n  if (ca5[0] == '+' || ca5[0] == '-' || ca5[0] == ' ') {\n    lead=1;\n  }\n  int dp=lead;\n  for (; dp < ca5.length; dp++) {\n    if (ca5[dp] == '.') {\n      break;\n    }\n  }\n  final int nThousands=(dp - lead) / 3;\n  if (dp < ca5.length) {\n    ca5[dp]=dfs.getDecimalSeparator();\n  }\n  char[] ca6=ca5;\n  if (thousands && nThousands > 0) {\n    ca6=new char[ca5.length + nThousands + lead];\n    ca6[0]=ca5[0];\n    for (i=lead, k=lead; i < dp; i++) {\n      if (i > 0 && (dp - i) % 3 == 0) {\n        ca6[k]=dfs.getGroupingSeparator();\n        ca6[k + 1]=ca5[i];\n        k+=2;\n      }\n else {\n        ca6[k]=ca5[i];\n        k++;\n      }\n    }\n    for (; i < ca5.length; i++, k++) {\n      ca6[k]=ca5[i];\n    }\n  }\n  return ca6;\n}", "comment": "for f format , the flag character ' - ' , means that the output should be left justified within the field .", "label": "why"}
{"id": "5037", "raw_code": "public PlaPointInt round_to_the_left(PlaDirection p_dir){\n  PlaPointFloat dir=p_dir.to_float();\n  double rounded_x;\n  if (dir.v_y > 0) {\n    rounded_x=Math.floor(v_x);\n  }\n else   if (dir.v_y < 0) {\n    rounded_x=Math.ceil(v_x);\n  }\n else {\n    rounded_x=Math.round(v_x);\n  }\n  double rounded_y;\n  if (dir.v_x > 0) {\n    rounded_y=Math.ceil(v_y);\n  }\n else   if (dir.v_x < 0) {\n    rounded_y=Math.floor(v_y);\n  }\n else {\n    rounded_y=Math.round(v_y);\n  }\n  return new PlaPointInt(rounded_x,rounded_y);\n}", "comment": "rounds this point , so that if this point is on the left side of any directed line with direction p _ dir , the result point will also be on the left side .", "label": "why"}
{"id": "58312", "raw_code": "protected HttpHost determineProxy(HttpHost target,HttpRequest request,HttpContext context) throws HttpException {\n  ProxySelector psel=this.proxySelector;\n  if (psel == null)   psel=ProxySelector.getDefault();\n  if (psel == null)   return null;\n  URI targetURI=null;\n  try {\n    targetURI=new URI(target.toURI());\n  }\n catch (  URISyntaxException usx) {\n    throw new HttpException(\"Cannot convert host to URI: \" + target,usx);\n  }\n  List<Proxy> proxies=psel.select(targetURI);\n  Proxy p=chooseProxy(proxies,target,request,context);\n  HttpHost result=null;\n  if (p.type() == Proxy.Type.HTTP) {\n    if (!(p.address() instanceof InetSocketAddress)) {\n      throw new HttpException(\"Unable to handle non-Inet proxy address: \" + p.address());\n    }\n    final InetSocketAddress isa=(InetSocketAddress)p.address();\n    result=new HttpHost(getHost(isa),isa.getPort());\n  }\n  return result;\n}", "comment": "determines a proxy for the given target .", "label": "why"}
{"id": "75202", "raw_code": "private synchronized void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {\n  s.defaultReadObject();\n  init(getMask(actions));\n}", "comment": "readobject is called to restore the state of the servicepermission from a stream .", "label": "why"}
{"id": "57940", "raw_code": "public Iterator enumerateLiteralResultAttributes(){\n  return (null == m_avts) ? null : m_avts.iterator();\n}", "comment": "compiling templates requires that we be able to list the avts added 9 / 5 / 2000 to support compilation experiment", "label": "why"}
{"id": "47155", "raw_code": "private long acquireWrite(boolean interruptible,long deadline){\n  WNode node=null, p;\n  for (int spins=-1; ; ) {\n    long m, s, ns;\n    if ((m=(s=state) & ABITS) == 0L) {\n      if (U.compareAndSwapLong(this,STATE,s,ns=s + WBIT))       return ns;\n    }\n else     if (spins < 0)     spins=(m == WBIT && wtail == whead) ? SPINS : 0;\n else     if (spins > 0) {\n      if (LockSupport.nextSecondarySeed() >= 0)       --spins;\n    }\n else     if ((p=wtail) == null) {\n      WNode hd=new WNode(WMODE,null);\n      if (U.compareAndSwapObject(this,WHEAD,null,hd))       wtail=hd;\n    }\n else     if (node == null)     node=new WNode(WMODE,p);\n else     if (node.prev != p)     node.prev=p;\n else     if (U.compareAndSwapObject(this,WTAIL,p,node)) {\n      p.next=node;\n      break;\n    }\n  }\n  for (int spins=-1; ; ) {\n    WNode h, np, pp;\n    int ps;\n    if ((h=whead) == p) {\n      if (spins < 0)       spins=HEAD_SPINS;\n else       if (spins < MAX_HEAD_SPINS)       spins<<=1;\n      for (int k=spins; ; ) {\n        long s, ns;\n        if (((s=state) & ABITS) == 0L) {\n          if (U.compareAndSwapLong(this,STATE,s,ns=s + WBIT)) {\n            whead=node;\n            node.prev=null;\n            return ns;\n          }\n        }\n else         if (LockSupport.nextSecondarySeed() >= 0 && --k <= 0)         break;\n      }\n    }\n else     if (h != null) {\n      WNode c;\n      Thread w;\n      while ((c=h.cowait) != null) {\n        if (U.compareAndSwapObject(h,WCOWAIT,c,c.cowait) && (w=c.thread) != null)         U.unpark(w);\n      }\n    }\n    if (whead == h) {\n      if ((np=node.prev) != p) {\n        if (np != null)         (p=np).next=node;\n      }\n else       if ((ps=p.status) == 0)       U.compareAndSwapInt(p,WSTATUS,0,WAITING);\n else       if (ps == CANCELLED) {\n        if ((pp=p.prev) != null) {\n          node.prev=pp;\n          pp.next=node;\n        }\n      }\n else {\n        long time;\n        if (deadline == 0L)         time=0L;\n else         if ((time=deadline - System.nanoTime()) <= 0L)         return cancelWaiter(node,node,false);\n        Thread wt=Thread.currentThread();\n        U.putObject(wt,PARKBLOCKER,this);\n        node.thread=wt;\n        if (p.status < 0 && (p != h || (state & ABITS) != 0L) && whead == h && node.prev == p)         U.park(false,time);\n        node.thread=null;\n        U.putObject(wt,PARKBLOCKER,null);\n        if (interruptible && Thread.interrupted())         return cancelWaiter(node,node,true);\n      }\n    }\n  }\n}", "comment": "see above for explanation .", "label": "why"}
{"id": "31893", "raw_code": "public IpcSharedMemorySpace(String tokFileName,int writerPid,int readerPid,int size,boolean reader,IgniteLogger parent) throws IgniteCheckedException {\n  assert size > 0 : \"Size cannot be less than 1 byte\";\n  log=parent.getLogger(IpcSharedMemorySpace.class);\n  opSize=size;\n  shmemPtr=IpcSharedMemoryUtils.allocateSystemResources(tokFileName,size,DEBUG && log.isDebugEnabled());\n  shmemId=IpcSharedMemoryUtils.sharedMemoryId(shmemPtr);\n  semId=IpcSharedMemoryUtils.semaphoreId(shmemPtr);\n  isReader=reader;\n  this.tokFileName=tokFileName;\n  this.readerPid=readerPid;\n  this.writerPid=writerPid;\n  if (DEBUG && log.isDebugEnabled())   log.debug(\"Shared memory space has been created: \" + this);\n}", "comment": "this will allocate system resources for the space .", "label": "why"}
{"id": "49511", "raw_code": "public static String arrayToHexString(byte[] array){\n  return arrayToHexString(array,0,array.length);\n}", "comment": "helper method to convert a byte [ ] array ( such as a msgid ) to a hex string", "label": "why"}
{"id": "55115", "raw_code": "public static List<Node> parseExpression(Context context,HashSet<String> configNamespaces,String text){\n  return parseExpression(context,configNamespaces,text,0,false);\n}", "comment": "this method should be used to parse an expression , like \" a = b \" .", "label": "why"}
{"id": "51254", "raw_code": "Node<K,V> findNear(K kkey,int rel){\n  Comparable<? super K> key=comparable(kkey);\n  for (; ; ) {\n    Node<K,V> b=findPredecessor(key);\n    Node<K,V> n=b.next;\n    for (; ; ) {\n      if (n == null)       return ((rel & LT) == 0 || b.isBaseHeader()) ? null : b;\n      Node<K,V> f=n.next;\n      if (n != b.next)       break;\n      Object v=n.value;\n      if (v == null) {\n        n.helpDelete(b,f);\n        break;\n      }\n      if (v == n || b.value == null)       break;\n      int c=key.compareTo(n.key);\n      if ((c == 0 && (rel & EQ) != 0) || (c < 0 && (rel & LT) == 0))       return n;\n      if (c <= 0 && (rel & LT) != 0)       return b.isBaseHeader() ? null : b;\n      b=n;\n      n=f;\n    }\n  }\n}", "comment": "utility for ceiling , floor , lower , higher methods .", "label": "why"}
{"id": "54795", "raw_code": "public int action(String fault,String action){\n  Integer current=get(fault);\n  if (current == null)   throw new IllegalArgumentException(fault);\n  boolean no=action.startsWith(\"no\");\n  if (no)   action=action.substring(2);\n  Integer bit=getAction(action);\n  if (bit == null)   throw new IllegalArgumentException(action);\n  int old=current.intValue();\n  int mask=bit.intValue();\n  int n=(old & (~mask));\n  n=(no) ? n : (n | mask);\n  put(fault,new Integer(n));\n  return n;\n}", "comment": "sets the action bits as appropriate for the given fault and action", "label": "why"}
{"id": "68800", "raw_code": "protected void doFunction(float[] inputs,int inputOffset,float[] outputs,int outputOffset){\n  float input=inputs[inputOffset];\n  for (int i=0; i < getNumOutputs(); i++) {\n    outputs[i + outputOffset]=getC0(i) + (float)(Math.pow(input,getN()) * (getC1(i) - getC0(i)));\n  }\n}", "comment": "calculate the function value for the input .", "label": "why"}
{"id": "38302", "raw_code": "public void addCheckBoxActionListener(ActionListener al){\n  m_enableDistributedExperiment.addActionListener(al);\n}", "comment": "enable objects to listen for changes to the check box", "label": "why"}
{"id": "28582", "raw_code": "private Rect calcBounds(int index,Paint paint){\n  Rect bounds=new Rect();\n  CharSequence title=getTitle(index);\n  bounds.right=(int)paint.measureText(title,0,title.length());\n  bounds.bottom=(int)(paint.descent() - paint.ascent());\n  return bounds;\n}", "comment": "calculate the bounds for a view ' s title", "label": "why"}
{"id": "85291", "raw_code": "GF256Poly addOrSubtract(GF256Poly other){\n  if (!field.equals(other.field)) {\n    throw new IllegalArgumentException(\"GF256Polys do not have same GF256 field\");\n  }\n  if (isZero()) {\n    return other;\n  }\n  if (other.isZero()) {\n    return this;\n  }\n  int[] smallerCoefficients=this.coefficients;\n  int[] largerCoefficients=other.coefficients;\n  if (smallerCoefficients.length > largerCoefficients.length) {\n    int[] temp=smallerCoefficients;\n    smallerCoefficients=largerCoefficients;\n    largerCoefficients=temp;\n  }\n  int[] sumDiff=new int[largerCoefficients.length];\n  int lengthDiff=largerCoefficients.length - smallerCoefficients.length;\n  System.arraycopy(largerCoefficients,0,sumDiff,0,lengthDiff);\n  for (int i=lengthDiff; i < largerCoefficients.length; i++) {\n    sumDiff[i]=GF256.addOrSubtract(smallerCoefficients[i - lengthDiff],largerCoefficients[i]);\n  }\n  return new GF256Poly(field,sumDiff);\n}", "comment": "gf addition or subtraction ( they are identical for a gf ( 2 ^ n )", "label": "why"}
{"id": "51661", "raw_code": "@Override public int clampViewPositionHorizontal(View child,int left,int dx){\n  if (mDraggedView == null) {\n    return 0;\n  }\n  final int leftBound=0 - MAX_OVERFLOW - (mColumnSizeSide / 2);\n  final int rightBound=getWidth() + MAX_OVERFLOW + (mColumnSizeSide / 2);\n  return Math.min(Math.max(left,leftBound),rightBound);\n}", "comment": "override method used to configure the horizontal drag .", "label": "why"}
{"id": "35343", "raw_code": "private Token toPrefixToken(ILeafNode leaf){\n  Lexer lexer=new InternalN4JSLexer();\n  String text=leaf.getText();\n  String prefix=text.substring(0,endOffset - leaf.getTotalOffset());\n  ANTLRStringStream stream=new ANTLRStringStream(prefix);\n  lexer.setCharStream(stream);\n  Token nextToken=lexer.nextToken();\n  return new CommonToken(nextToken.getType(),nextToken.getText());\n}", "comment": "produce an antlr token for the prefix of the given leaf that overlaps the requested region", "label": "why"}
{"id": "598", "raw_code": "protected void initLookup(){\n  m_lookup=new HashMap();\n  for (int i=0; i < m_names.length; ++i) {\n    m_lookup.put(m_names[i],new Integer(i));\n  }\n}", "comment": "lazily construct the lookup table for this schema .", "label": "why"}
{"id": "80379", "raw_code": "protected static boolean approxUnit(final StringBuilder sbuf,final int amount,final int size,final String name){\n  int count=amount / size;\n  int remainder;\n  if (count == 0) {\n    return false;\n  }\n  remainder=amount - (count * size);\n  if (remainder >= (size * 95 / 100)) {\n    count++;\n    sbuf.append(count);\n  }\n else   if (remainder >= (size * 3 / 4)) {\n    count++;\n    sbuf.append(\"just under \");\n    sbuf.append(count);\n  }\n else   if (remainder >= (size * 1 / 4)) {\n    sbuf.append(\"about \");\n    sbuf.append(count);\n    sbuf.append(\" and a half\");\n    count=2;\n  }\n else   if (remainder >= (size * 5 / 100)) {\n    sbuf.append(\"just over \");\n    sbuf.append(count);\n  }\n else {\n    sbuf.append(count);\n  }\n  sbuf.append(' ');\n  sbuf.append(Grammar.plnoun(count,name));\n  return true;\n}", "comment": "for a given amount and unit size , generate the approximate value .", "label": "why"}
{"id": "11440", "raw_code": "protected double LLToWorldReturningLon(double lat,double lon,Point2D lp){\n  double phi_deg=lat;\n  double phi=ProjMath.degToRad(phi_deg);\n  double lamba_deg=lon;\n  double lamba=ProjMath.degToRad(lamba_deg);\n  double dlamda=lamba - lamdaf;\n  if (dlamda > Math.PI) {\n    dlamda-=MoreMath.TWO_PI_D;\n  }\n else   if (dlamda < -Math.PI) {\n    dlamda+=MoreMath.TWO_PI_D;\n  }\n  double e=ellps.ecc;\n  double r=0.0d;\n  if (!MoreMath.approximately_equal(Math.abs(phi),MoreMath.HALF_PI,EPS10)) {\n    double t=lambTsfn(phi,Math.sin(phi),e);\n    r=ellps.radius * F * Math.pow(t,n);\n  }\n  double theta=n * dlamda;\n  double easting=falseEasting + r * Math.sin(theta - alpha);\n  double northing=falseNorthing + rf - r * Math.cos(theta - alpha);\n  lp.setLocation(easting,northing);\n  return dlamda;\n}", "comment": "lltoworld that returns normalized longitude in radians , to be used for more calculations in some methods .", "label": "why"}
{"id": "1543", "raw_code": "public void destroyScene(){\n  clearAnimations();\n  clearCameras();\n  clearLights();\n  clearPlugins();\n  clearChildren();\n  clearFrameCallbacks();\n}", "comment": "clears any references the scene is holding for its contents .", "label": "why"}
{"id": "76685", "raw_code": "public static Query newPrefixQuery(String field,InetAddress value,int prefixLength){\n  if (value == null) {\n    throw new IllegalArgumentException(\"InetAddress must not be null\");\n  }\n  if (prefixLength < 0 || prefixLength > 8 * value.getAddress().length) {\n    throw new IllegalArgumentException(\"illegal prefixLength '\" + prefixLength + \"'. Must be 0-32 for IPv4 ranges, 0-128 for IPv6 ranges\");\n  }\n  byte lower[]=value.getAddress();\n  byte upper[]=value.getAddress();\n  for (int i=prefixLength; i < 8 * lower.length; i++) {\n    int m=1 << (7 - (i & 7));\n    lower[i >> 3]&=~m;\n    upper[i >> 3]|=m;\n  }\n  try {\n    return newRangeQuery(field,InetAddress.getByAddress(lower),InetAddress.getByAddress(upper));\n  }\n catch (  UnknownHostException e) {\n    throw new AssertionError(e);\n  }\n}", "comment": "create a prefix query for matching a cidr network range .", "label": "why"}
{"id": "70356", "raw_code": "private synchronized void loadHexImage(IHex hex){\n  hexTileset.assignMatch(hex,boardview);\n  hexTileset.trackHexImages(hex,tracker);\n}", "comment": "loads the image ( s ) for this hex into the tracker .", "label": "why"}
{"id": "66938", "raw_code": "private void writeJavaFieldSpec(JavaFieldSpec spec,Document document,Element parentElement){\n  Element parameter=document.createElement(\"parameter\");\n  parameter.appendChild(parentElement);\n  parameter.setAttribute(\"package\",spec.getPackageName());\n  parameter.setAttribute(\"class\",spec.getClassName());\n  parameter.setAttribute(\"field\",spec.getFieldName());\n}", "comment": "writes out a source / sink specification object for java static fields", "label": "why"}
{"id": "47671", "raw_code": "private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n  s.defaultReadObject();\n  init(getMask(actions));\n}", "comment": "readobject is called to restore the state of the filepermission from a stream .", "label": "why"}
{"id": "69908", "raw_code": "public static String tmpJournal(){\n  final File file=Code.wrapThrow(null);\n  file.deleteOnExit();\n  return file.getAbsolutePath();\n}", "comment": "create a tmp journal file for test cases .", "label": "why"}
{"id": "52965", "raw_code": "protected static void printErrorMessage(Exception e){\n  if (e instanceof AbortException) {\n    LoggingConfiguration.setVerbose(Level.VERBOSE);\n    LOG.verbose(e.getMessage());\n  }\n else   if (e instanceof UnspecifiedParameterException) {\n    LOG.error(e.getMessage());\n  }\n else   if (e instanceof ParameterException) {\n    LOG.error(e.getMessage());\n  }\n else {\n    LOG.exception(e);\n  }\n}", "comment": "print an error message for the given error .", "label": "why"}
{"id": "75239", "raw_code": "public String requestStatistics(){\n  sb.setLength(0);\n  makeStringBuffer(sb);\n  return sb.toString();\n}", "comment": "a method for other parts of the application to get stats the command processor uses this to report stats on request", "label": "why"}
{"id": "33152", "raw_code": "public static MoveParticipant[] loadMoveParticipants(RefactoringStatus status,RefactoringProcessor processor,Object element,MoveArguments arguments,IParticipantDescriptorFilter filter,String[] affectedNatures,SharableParticipants shared){\n  RefactoringParticipant[] participants=fgMoveExtensions.getParticipants(status,processor,element,arguments,filter,affectedNatures,shared);\n  MoveParticipant[] result=new MoveParticipant[participants.length];\n  System.arraycopy(participants,0,result,0,participants.length);\n  return result;\n}", "comment": "loads the move participants for the given element .", "label": "why"}
{"id": "34892", "raw_code": "public void reset(){\n  engineReset();\n  state=INITIAL;\n}", "comment": "resets the digest for further use .", "label": "why"}
{"id": "30291", "raw_code": "EgDemandDetails insertPenalty(final BigDecimal chqBouncePenalty,final Module module){\n  EgDemandDetails demandDetail=null;\n  if (chqBouncePenalty != null && chqBouncePenalty.compareTo(BigDecimal.ZERO) > 0) {\n    final Installment currInstallment=getCurrentInstallment(module);\n    final EgDemandReasonMaster egDemandReasonMaster=demandGenericDao.getDemandReasonMasterByCode(DEMANDRSN_CODE_CHQ_BOUNCE_PENALTY,module);\n    if (egDemandReasonMaster == null)     throw new ApplicationRuntimeException(\" Penalty Demand reason Master is null in method  insertPenalty\");\n    final EgDemandReason egDemandReason=demandGenericDao.getDmdReasonByDmdReasonMsterInstallAndMod(egDemandReasonMaster,currInstallment,module);\n    if (egDemandReason == null)     throw new ApplicationRuntimeException(\" Penalty Demand reason is null in method  insertPenalty \");\n    demandDetail=EgDemandDetails.fromReasonAndAmounts(chqBouncePenalty,egDemandReason,BigDecimal.ZERO);\n  }\n  return demandDetail;\n}", "comment": "method used to insert penalty in egdemanddetail table .", "label": "why"}
{"id": "79725", "raw_code": "private void markRemovedDefaultSessionToken(String site,String token){\n  if (removedDefaultTokens == null)   removedDefaultTokens=new HashMap<>(1);\n  HashSet<String> removedSet=removedDefaultTokens.get(site);\n  if (removedSet == null) {\n    removedSet=new HashSet<>(1);\n    removedDefaultTokens.put(site,removedSet);\n  }\n  removedSet.add(token);\n}", "comment": "marks a default session token as removed for a particular site .", "label": "why"}
{"id": "21622", "raw_code": "private Map<URI,Map<URI,Map<String,List<URI>>>> createDeviceToCGMapFromDescriptors(List<VolumeDescriptor> addDescriptors,List<VolumeDescriptor> removeDescriptors){\n  Map<URI,Map<URI,Map<String,List<URI>>>> deviceToCGMap=new HashMap<URI,Map<URI,Map<String,List<URI>>>>();\n  for (  VolumeDescriptor descr : addDescriptors) {\n    URI deviceURI=descr.getDeviceURI();\n    Map<URI,Map<String,List<URI>>> volumesToUpdateByCG=deviceToCGMap.get(deviceURI);\n    if (volumesToUpdateByCG == null) {\n      volumesToUpdateByCG=new HashMap<URI,Map<String,List<URI>>>();\n      deviceToCGMap.put(deviceURI,volumesToUpdateByCG);\n    }\n    URI consistencyGroupURI=descr.getConsistencyGroupURI();\n    Map<String,List<URI>> volumesToUpdate=volumesToUpdateByCG.get(consistencyGroupURI);\n    if (volumesToUpdate == null) {\n      volumesToUpdate=new HashMap<String,List<URI>>();\n      volumesToUpdateByCG.put(consistencyGroupURI,volumesToUpdate);\n    }\n    List<URI> volumesToAdd=volumesToUpdate.get(ADD_VOLUMES_TO_CG_KEY);\n    if (volumesToAdd == null) {\n      volumesToAdd=new ArrayList<URI>();\n      volumesToUpdate.put(ADD_VOLUMES_TO_CG_KEY,volumesToAdd);\n    }\n    volumesToAdd.add(descr.getVolumeURI());\n  }\n  for (  VolumeDescriptor descr : removeDescriptors) {\n    URI deviceURI=descr.getDeviceURI();\n    Map<URI,Map<String,List<URI>>> volumesToUpdateByCG=deviceToCGMap.get(deviceURI);\n    if (volumesToUpdateByCG == null) {\n      volumesToUpdateByCG=new HashMap<URI,Map<String,List<URI>>>();\n      deviceToCGMap.put(deviceURI,volumesToUpdateByCG);\n    }\n    URI consistencyGroupURI=descr.getConsistencyGroupURI();\n    Map<String,List<URI>> volumesToUpdate=volumesToUpdateByCG.get(consistencyGroupURI);\n    if (volumesToUpdate == null) {\n      volumesToUpdate=new HashMap<String,List<URI>>();\n      volumesToUpdateByCG.put(consistencyGroupURI,volumesToUpdate);\n    }\n    List<URI> volumesToRemove=volumesToUpdate.get(REMOVE_VOLUMES_FROM_CG_KEY);\n    if (volumesToRemove == null) {\n      volumesToRemove=new ArrayList<URI>();\n      volumesToUpdate.put(REMOVE_VOLUMES_FROM_CG_KEY,volumesToRemove);\n    }\n    volumesToRemove.add(descr.getVolumeURI());\n  }\n  return deviceToCGMap;\n}", "comment": "convenience method to create a map device to cg to volume to add and remove .", "label": "why"}
{"id": "61368", "raw_code": "protected void fireEndElem(String name) throws org.xml.sax.SAXException {\n  if (m_tracer != null) {\n    flushMyWriter();\n    m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_ENDELEMENT,name,(Attributes)null);\n  }\n}", "comment": "to fire off the end element trace event", "label": "why"}
{"id": "56007", "raw_code": "private CharSequence createTickerText(String title,String body){\n  SpannableStringBuilder spannableStringBuilder=new SpannableStringBuilder();\n  spannableStringBuilder.append(title);\n  spannableStringBuilder.append(\"\\n\");\n  spannableStringBuilder.append(body);\n  spannableStringBuilder.setSpan(new StyleSpan(android.graphics.Typeface.BOLD),0,title.length(),Spannable.SPAN_INCLUSIVE_INCLUSIVE);\n  return spannableStringBuilder;\n}", "comment": "creates the ticker text for a notification having | title | and | body | .", "label": "why"}
{"id": "10639", "raw_code": "public DrawerBuilder addStickyDrawerItems(@NonNull IDrawerItem... stickyDrawerItems){\n  if (this.mStickyDrawerItems == null) {\n    this.mStickyDrawerItems=new ArrayList<>();\n  }\n  Collections.addAll(this.mStickyDrawerItems,IdDistributor.checkIds(stickyDrawerItems));\n  return this;\n}", "comment": "add a initial draweritem or a draweritem array for the stickydrawerfooter", "label": "why"}
{"id": "78198", "raw_code": "public byte[] extractData(byte[] stegoData,String stegoFileName,byte[] origSigData) throws OpenStegoException {\n  return null;\n}", "comment": "method to extract the message from the stego data", "label": "why"}
{"id": "11275", "raw_code": "public void actionPerformed(ActionEvent ae){\n  String command=ae.getActionCommand();\n  if (command == DisplayPaletteCmd) {\n    if (Debug.debugging(\"layer\")) {\n      Debug.output(getName() + \" displaying palette\");\n    }\n    showPalette();\n  }\n else   if (command == HidePaletteCmd) {\n    if (Debug.debugging(\"layer\")) {\n      Debug.output(getName() + \" hiding palette\");\n    }\n    hidePalette();\n  }\n else   if (command == DisplayPropertiesCmd) {\n    Inspector inspector=new Inspector();\n    inspector.inspectPropertyConsumer(this);\n  }\n}", "comment": "the default actionperformed method for layer .", "label": "why"}
{"id": "52507", "raw_code": "@JsonCreator public DataSourceMetadata(@JsonProperty(\"name\") String name,@JsonProperty(\"properties\") Map<String,String> properties,@JsonProperty(\"segments\") List<DataSegment> segments){\n  this.name=name;\n  this.properties=Collections.unmodifiableMap(properties);\n  this.segments=Collections.unmodifiableList(segments);\n}", "comment": "store the full metadata for a druid data source , mainly as a list of segments .", "label": "why"}
{"id": "17634", "raw_code": "private final boolean parkAndCheckInterrupt(){\n  LockSupport.park(this);\n  return Thread.interrupted();\n}", "comment": "convenience method to park and then check if interrupted", "label": "why"}
{"id": "53272", "raw_code": "private void heapifyUp(int twopos,Comparable<Object> cur){\n  while (twopos > 0) {\n    final int parent=(twopos - 1) >>> 1;\n    Comparable<Object> par=twoheap[parent];\n    if (cur.compareTo(par) <= 0) {\n      break;\n    }\n    twoheap[twopos]=par;\n    twopos=parent;\n  }\n  twoheap[twopos]=cur;\n}", "comment": "heapify - up method for 2 - ary heap .", "label": "why"}
{"id": "27560", "raw_code": "void fullyUnlock(){\n  takeLock.unlock();\n  putLock.unlock();\n}", "comment": "unlock to allow both puts and takes .", "label": "why"}
{"id": "72016", "raw_code": "private void validateClassName(String className){\n  String nvalue=className.trim();\n  if (!nvalue.matches(CLASS_RE)) {\n    throw PropertyException.illegalPropertyValueException(this,className);\n  }\n}", "comment": "do some basic checks to make sure the string representation is valid .", "label": "why"}
{"id": "77969", "raw_code": "public SetChangelogMapping(String source,String taskName,int changelogPartitionNumber){\n  super(source);\n  setType(TYPE);\n  setKey(taskName);\n  putMessageValue(CHANGELOG_VALUE_KEY,String.valueOf(changelogPartitionNumber));\n}", "comment": "the change log mapping message is used to store changelog partition information for a given task name .", "label": "why"}
{"id": "2351", "raw_code": "public static Calendar reduceCalendar(Calendar calendar){\n  calendar.set(Calendar.MILLISECOND,0);\n  calendar.set(Calendar.SECOND,0);\n  calendar.set(Calendar.MINUTE,0);\n  calendar.set(Calendar.HOUR,0);\n  calendar.set(Calendar.HOUR_OF_DAY,0);\n  return calendar;\n}", "comment": "sets the supplied calendar object with 0 values for fields lower than days", "label": "why"}
{"id": "9025", "raw_code": "public static String trimOrPad(String str,int length,char padChar){\n  String result;\n  if (str == null) {\n    result=\"\";\n  }\n else {\n    result=str;\n  }\n  if (result.length() > length) {\n    return result.substring(0,length);\n  }\n  while (result.length() < length) {\n    result+=padChar;\n  }\n  return result;\n}", "comment": "trims or pads this string , so it has this exact length .", "label": "why"}
{"id": "35126", "raw_code": "private static void logOsInfo(){\n  Logger.appendLog(\"[Main][I]User Os is \" + Cfg.getOs());\n  Logger.appendLog(\"[Main][I]Os name : \" + Os.getOsName());\n  Logger.appendLog(\"[Main][I]User Platform is : \" + Os.platform());\n  Logger.appendLog(\"[Main][I]JAVA version : \" + System.getProperty(\"java.version\"));\n  Logger.appendLog(\"[Main][I]Available cores (cpu) = \" + HostInfo.availableCpus());\n  Logger.appendLog(\"[Main][I]Max allocated memory = \" + HostInfo.getMaxMemory() + \" bytes\");\n}", "comment": "log system informations to the log file this have no effect on the software it ' s here for logging purpose", "label": "why"}
{"id": "62239", "raw_code": "public static ExecutionSystem newExecutionSystem(URI uri,Map<String,?> env) throws IOException {\n  return newExecutionSystem(uri,env,null);\n}", "comment": "creates a new execution system for the specified uri .", "label": "why"}
{"id": "1137", "raw_code": "public void append(char c[]){\n  int maxlength=buffer.length - pos;\n  if (c.length < maxlength) {\n    System.arraycopy(c,0,buffer,pos,c.length);\n    pos+=c.length;\n  }\n else {\n    System.arraycopy(c,0,buffer,pos,maxlength);\n    curr.next=new Entity(buffer);\n    curr=curr.next;\n    length+=buffer.length;\n    buffer=new char[(buffer.length > c.length - maxlength) ? buffer.length : c.length - maxlength];\n    if (c.length > maxlength) {\n      System.arraycopy(c,maxlength,buffer,0,c.length - maxlength);\n      pos=c.length - maxlength;\n    }\n else {\n      pos=0;\n    }\n  }\n}", "comment": "method to appennd a charr array to the buffer", "label": "why"}
{"id": "55101", "raw_code": "public int checksum(){\n  return calculateChecksum(compile_checksum.toString());\n}", "comment": "this value is good for naming the cache file .", "label": "why"}
{"id": "78436", "raw_code": "private void createInsertList(final IItem item,List<IItem> tempList,List<IItem> insertList,int depth,int removed){\n  if (!tempList.contains(item)) {\n    tempList.add(item);\n    if (depth == 0) {\n      insertList.add(item);\n    }\n    if (item.getItems() != null) {\n      depth++;\n      for (      IItem child : item.getItems()) {\n        createInsertList(child,tempList,insertList,depth,removed);\n      }\n    }\n  }\n else {\n    insertList.remove(item);\n    removed++;\n  }\n}", "comment": "recursive helper method for createinsertlist", "label": "why"}
{"id": "23541", "raw_code": "private int decodeRunLength(int k){\n  if ((k & 1) == 1) {\n    return ((k >>> 1) & 63) ^ 63;\n  }\n else {\n    return Integer.numberOfLeadingZeros(k << p + (31 - sp)) + 1;\n  }\n}", "comment": "more of less the opposite of the encoding function but just for getting out run lengths .", "label": "why"}
{"id": "73926", "raw_code": "public void continueButtonActionPerformed(java.awt.event.ActionEvent e){\n  if (testRunning && testSuspended) {\n    testSuspended=false;\n    if (wrapTest) {\n      statusText1.setText(\"Running Wraparound Test\");\n      statusText1.setVisible(true);\n    }\n  }\n}", "comment": "method to handle continue button in diagnostic frame", "label": "why"}
{"id": "31737", "raw_code": "private Map<UUID,int[]> reducers(Collection<ClusterNode> top,Map<UUID,Collection<HadoopInputSplit>> mappers,int reducerCnt){\n  int totalWeight=0;\n  List<WeightedNode> nodes=new ArrayList<>(top.size());\n  for (  ClusterNode node : top) {\n    Collection<HadoopInputSplit> split=mappers.get(node.id());\n    int weight=reducerNodeWeight(node,split != null ? split.size() : 0);\n    nodes.add(new WeightedNode(node.id(),weight,weight));\n    totalWeight+=weight;\n  }\n  int totalAdjustedWeight=0;\n  for (  WeightedNode node : nodes) {\n    node.floatWeight=((float)node.weight * reducerCnt) / totalWeight;\n    node.weight=Math.round(node.floatWeight);\n    totalAdjustedWeight+=node.weight;\n  }\n  Collections.sort(nodes);\n  if (totalAdjustedWeight > reducerCnt) {\n    ListIterator<WeightedNode> iter=nodes.listIterator(nodes.size() - 1);\n    while (totalAdjustedWeight != reducerCnt) {\n      if (!iter.hasPrevious())       iter=nodes.listIterator(nodes.size() - 1);\n      WeightedNode node=iter.previous();\n      if (node.weight > 0) {\n        node.weight-=1;\n        totalAdjustedWeight--;\n      }\n    }\n  }\n else   if (totalAdjustedWeight < reducerCnt) {\n    ListIterator<WeightedNode> iter=nodes.listIterator(0);\n    while (totalAdjustedWeight != reducerCnt) {\n      if (!iter.hasNext())       iter=nodes.listIterator(0);\n      WeightedNode node=iter.next();\n      if (node.floatWeight > 0.0f) {\n        node.weight+=1;\n        totalAdjustedWeight++;\n      }\n    }\n  }\n  int idx=0;\n  Map<UUID,int[]> reducers=new HashMap<>(nodes.size(),1.0f);\n  for (  WeightedNode node : nodes) {\n    if (node.weight > 0) {\n      int[] arr=new int[node.weight];\n      for (int i=0; i < arr.length; i++)       arr[i]=idx++;\n      reducers.put(node.nodeId,arr);\n    }\n  }\n  return reducers;\n}", "comment": "create plan for reducers .", "label": "why"}
{"id": "69607", "raw_code": "public String eventTopic(String eventId){\n  if (eventId == null) {\n    eventId=\"+\";\n  }\n  return evtTopic.replace(\"{EVENTID}\",eventId);\n}", "comment": "get the mqtt topic for an device event .", "label": "why"}
{"id": "82802", "raw_code": "private void removeOurUIs(){\n  for (  String uiName : UI_LIST) {\n    uiDefaults.remove(uiName + \"UI\");\n  }\n}", "comment": "use our ui delegate for the specified ui control type .", "label": "why"}
{"id": "52982", "raw_code": "public static <O>KNNQuery<O> precomputedKNNQuery(Database database,Relation<O> relation,DistanceQuery<O> dq,int k){\n  KNNQuery<O> knnq=database.getKNNQuery(dq,k,DatabaseQuery.HINT_HEAVY_USE,DatabaseQuery.HINT_OPTIMIZED_ONLY,DatabaseQuery.HINT_NO_CACHE);\n  if (knnq instanceof PreprocessorKNNQuery) {\n    return knnq;\n  }\n  MaterializeKNNPreprocessor<O> preproc=new MaterializeKNNPreprocessor<>(relation,dq.getDistanceFunction(),k);\n  preproc.initialize();\n  return preproc.getKNNQuery(dq,k);\n}", "comment": "get ( or create ) a precomputed knn query for the database .", "label": "why"}
{"id": "52325", "raw_code": "public static SortedSet<Integer> adjustPosition(Set<Integer> positions,int startPosition,int endPosition,int adjustBy){\n  SortedSet<Integer> newPositions=new TreeSet<>();\n  for (  Integer entry : positions) {\n    int position=entry;\n    if (position < startPosition || position > endPosition) {\n      newPositions.add(position);\n    }\n else     if (adjustBy > 0) {\n      newPositions.add(position + adjustBy);\n    }\n else     if (adjustBy < 0) {\n      if (position > startPosition + adjustBy && position <= startPosition) {\n        ;\n      }\n else {\n        newPositions.add(position + adjustBy);\n      }\n    }\n  }\n  return newPositions;\n}", "comment": "internal method to handle the selections if items are added / removed", "label": "why"}
{"id": "1514", "raw_code": "public final long readUnsignedInt() throws IOException {\n  mPosition+=4;\n  d.readFully(w,0,4);\n  return ((long)(w[3]) << 24 | (w[2] & 0xff) << 16 | (w[1] & 0xff) << 8 | (w[0] & 0xff)) & 0X00000000FFFFFFFFL;\n}", "comment": "like datainputstream . readint except little endian and for unsigned integers .", "label": "why"}
{"id": "24252", "raw_code": "static boolean isRefreshNotificationRegistered(NotificationListener client,RefreshNotificationType type){\n  boolean isRegistered=false;\n  Map<RefreshNotificationType,Integer> notifications=null;\nsynchronized (refreshClients) {\n    notifications=(Map<RefreshNotificationType,Integer>)refreshClients.get(client);\n  }\n  if (notifications != null) {\n    Integer timerNotificationId=notifications.get(type);\n    if (timerNotificationId != null) {\n      isRegistered=true;\n    }\n  }\n  return isRegistered;\n}", "comment": "verifies a refresh notification for the specified client mbean .", "label": "why"}
{"id": "30309", "raw_code": "public BigDecimal calculateTotalCollectedAmt(final BillReceiptInfo bri,final List<EgBillDetails> billDetList) throws InvalidAccountHeadException {\n  return bri.getTotalAmount();\n}", "comment": "called to calculate the total receipt amount i , e the amount which has been paid for the bill from the billreceiptinfo the amount will be calculated .", "label": "why"}
{"id": "35831", "raw_code": "static String escapeStringForASCII(String s){\n  String out=\"\";\n  char[] cArray=s.toCharArray();\n  for (int i=0; i < cArray.length; i++) {\n    char c=cArray[i];\n    if (c > 127) {\n      out+=\"\\\\U\";\n      String hex=Integer.toHexString(c);\n      while (hex.length() < 4)       hex=\"0\" + hex;\n      out+=hex;\n    }\n else     if (c == '\\\\') {\n      out+=\"\\\\\\\\\";\n    }\n else     if (c == '\\\"') {\n      out+=\"\\\\\\\"\";\n    }\n else     if (c == '\\b') {\n      out+=\"\\\\b\";\n    }\n else     if (c == '\\n') {\n      out+=\"\\\\n\";\n    }\n else     if (c == '\\r') {\n      out+=\"\\\\r\";\n    }\n else     if (c == '\\t') {\n      out+=\"\\\\t\";\n    }\n else {\n      out+=c;\n    }\n  }\n  return out;\n}", "comment": "escapes a string for use in ascii property lists .", "label": "why"}
{"id": "78962", "raw_code": "private void clearDictionaryCache(){\n  Map<String,Dictionary> dictionaryCaches=surrogateKeyGen.getDictionaryCaches();\n  List<Dictionary> reverseDictionaries=new ArrayList<>(dictionaryCaches.values());\n  for (int i=0; i < reverseDictionaries.size(); i++) {\n    Dictionary dictionary=reverseDictionaries.get(i);\n    dictionary.clear();\n  }\n}", "comment": "this method will clear the dictionary access count so that any unused column can be removed from the cache", "label": "why"}
{"id": "8122", "raw_code": "public static String toTypeString(Object[] arguments,int maxSize){\n  if (arguments == null) {\n    return \"null\";\n  }\n  StringBuilder argBuf=new StringBuilder();\n  for (int i=0; i < arguments.length; i++) {\n    if (maxSize != -1 && argBuf.length() > maxSize) {\n      argBuf.append(\"...\");\n      break;\n    }\n else {\n      if (i > 0) {\n        argBuf.append(\", \");\n      }\n      argBuf.append(arguments[i] != null ? typeName(arguments[i]) : \"null\");\n    }\n  }\n  return argBuf.toString();\n}", "comment": "a helper method to format the arguments types as a comma - separated list .", "label": "why"}
{"id": "10491", "raw_code": "protected JsonEncoding findEncoding(MediaType mediaType,MultivaluedMap<String,Object> httpHeaders){\n  return JsonEncoding.UTF8;\n}", "comment": "helper method to use for determining desired output encoding .", "label": "why"}
{"id": "51869", "raw_code": "static BufferedImage convertImage(BufferedImage image){\nswitch (image.getType()) {\ncase BufferedImage.TYPE_INT_ARGB_PRE:\n    return image;\ncase BufferedImage.TYPE_4BYTE_ABGR:\n  image.coerceData(true);\nreturn image;\n}\nBufferedImage convertedImage=new BufferedImage(image.getWidth(),image.getHeight(),BufferedImage.TYPE_INT_ARGB_PRE);\nGraphics2D g=convertedImage.createGraphics();\ng.setColor(new java.awt.Color(0f,0f,0f,0f));\ng.fillRect(0,0,image.getWidth(),image.getHeight());\ng.drawImage(image,0,0,null);\ng.dispose();\nreturn convertedImage;\n}", "comment": "converts the given image into a format for quick upload to the gpu .", "label": "why"}
{"id": "15521", "raw_code": "private void destroyBeans(Map<String,Object> viewMap,Map<String,ViewScopeContextObject> contextMap){\n  ArrayList<String> removalNameList=new ArrayList<>();\n  if (contextMap != null) {\n    for (    Map.Entry<String,ViewScopeContextObject> entry : contextMap.entrySet()) {\n      String passivationCapableId=entry.getKey();\n      Contextual contextual=beanManager.getPassivationCapableBean(passivationCapableId);\n      ViewScopeContextObject contextObject=entry.getValue();\n      CreationalContext creationalContext=beanManager.createCreationalContext(contextual);\n      contextual.destroy(viewMap.get(contextObject.getName()),creationalContext);\n      removalNameList.add(contextObject.getName());\n    }\n    Iterator<String> removalNames=removalNameList.iterator();\n    while (removalNames.hasNext()) {\n      String name=removalNames.next();\n      viewMap.remove(name);\n    }\n    contextMap.clear();\n  }\n}", "comment": "destroy the view scoped beans for the given view and context map .", "label": "why"}
{"id": "316", "raw_code": "private static boolean hasSpecializedHandlerIntents(Context context,Intent intent){\n  try {\n    PackageManager pm=context.getPackageManager();\n    List<ResolveInfo> handlers=pm.queryIntentActivities(intent,PackageManager.GET_RESOLVED_FILTER);\n    if (handlers == null || handlers.size() == 0) {\n      return false;\n    }\n    for (    ResolveInfo resolveInfo : handlers) {\n      IntentFilter filter=resolveInfo.filter;\n      if (filter == null)       continue;\n      if (filter.countDataAuthorities() == 0 || filter.countDataPaths() == 0)       continue;\n      if (resolveInfo.activityInfo == null)       continue;\n      return true;\n    }\n  }\n catch (  RuntimeException e) {\n    Log.e(TAG,\"Runtime exception while getting specialized handlers\");\n  }\n  return false;\n}", "comment": "used to check whether there is a specialized handler for a given intent .", "label": "why"}
{"id": "23049", "raw_code": "public void requestContactCapabilities(Set<ContactId> contacts) throws RcsServiceNotRegisteredException, RcsServiceNotAvailableException, RcsGenericException {\n  if (mApi == null) {\n    throw new RcsServiceNotAvailableException();\n  }\n  if (contacts == null || contacts.isEmpty()) {\n    throw new RcsIllegalArgumentException(\"contacts must not be null or empty!\");\n  }\n  try {\n    mApi.requestContactCapabilities2(new ArrayList<>(contacts));\n  }\n catch (  Exception e) {\n    RcsIllegalArgumentException.assertException(e);\n    RcsServiceNotRegisteredException.assertException(e);\n    throw new RcsGenericException(e);\n  }\n}", "comment": "requests capabilities for a group of remote contacts .", "label": "why"}
{"id": "49753", "raw_code": "@SuppressLint(\"DefaultLocale\") public void elementType(String name,int model,int memberOf,int flags){\n  ElementType e=new ElementType(name,model,memberOf,flags,this);\n  theElementTypes.put(name.toLowerCase(),e);\n  if (memberOf == M_ROOT)   theRoot=e;\n}", "comment": "add or replace an element type for this schema .", "label": "why"}
{"id": "49020", "raw_code": "private Object[] unmarshalParametersChecked(DeserializationChecker checker,Method method,MarshalInputStream in) throws IOException, ClassNotFoundException {\n  int callID=methodCallIDCount.getAndIncrement();\n  MyChecker myChecker=new MyChecker(checker,method,callID);\n  in.setStreamChecker(myChecker);\n  try {\n    Class<?>[] types=method.getParameterTypes();\n    Object[] values=new Object[types.length];\n    for (int i=0; i < types.length; i++) {\n      myChecker.setIndex(i);\n      values[i]=unmarshalValue(types[i],in);\n    }\n    myChecker.end(callID);\n    return values;\n  }\n  finally {\n    in.setStreamChecker(null);\n  }\n}", "comment": "unmarshal parameters for the given method of the given instance over the given marshalinputstream .", "label": "why"}
{"id": "76368", "raw_code": "public static void fullReset(){\n  resetRuntime();\nsynchronized (readProperties) {\n    readProperties.clear();\n  }\n}", "comment": "fully reset the state , not only the one related to latest test case execution", "label": "why"}
{"id": "20410", "raw_code": "public FileInputStream openRead() throws FileNotFoundException {\n  if (mBackupName.exists()) {\n    mBaseName.delete();\n    mBackupName.renameTo(mBaseName);\n  }\n  return new FileInputStream(mBaseName);\n}", "comment": "open the atomic file for reading .", "label": "why"}
{"id": "21970", "raw_code": "private void validateVNXFileSMISProviderMandatoryDetails(StorageSystemRequestParam param){\n  ArgValidator.checkFieldValidIP(param.getSmisProviderIP(),\"smis_provider_ip\");\n  ArgValidator.checkFieldNotNull(param.getSmisPortNumber(),\"smis_port_number\");\n  ArgValidator.checkFieldRange(param.getSmisPortNumber(),1,65535,\"smis_port_number\");\n  ArgValidator.checkFieldNotEmpty(param.getSmisUserName(),\"smis_user_name\");\n  ArgValidator.checkFieldNotEmpty(param.getSmisPassword(),\"smis_password\");\n}", "comment": "validates smi - s provider attributes of the vnxfile as it is a mandatory fields for indications", "label": "why"}
{"id": "35881", "raw_code": "public void createAccrualBasedJournalEntriesAndReversalsForLoanCharges(final Office office,final String currencyCode,final Integer accountTypeToBeDebited,final Integer accountTypeToBeCredited,final Long loanProductId,final Long loanId,final String transactionId,final Date transactionDate,final BigDecimal totalAmount,final Boolean isReversal,final List<ChargePaymentDTO> chargePaymentDTOs){\n  GLAccount receivableAccount=getLinkedGLAccountForLoanCharges(loanProductId,accountTypeToBeDebited,null);\n  final Map<GLAccount,BigDecimal> creditDetailsMap=new LinkedHashMap<>();\n  for (  final ChargePaymentDTO chargePaymentDTO : chargePaymentDTOs) {\n    final Long chargeId=chargePaymentDTO.getChargeId();\n    final GLAccount chargeSpecificAccount=getLinkedGLAccountForLoanCharges(loanProductId,accountTypeToBeCredited,chargeId);\n    BigDecimal chargeSpecificAmount=chargePaymentDTO.getAmount();\n    if (creditDetailsMap.containsKey(chargeSpecificAccount)) {\n      final BigDecimal existingAmount=creditDetailsMap.get(chargeSpecificAccount);\n      chargeSpecificAmount=chargeSpecificAmount.add(existingAmount);\n    }\n    creditDetailsMap.put(chargeSpecificAccount,chargeSpecificAmount);\n  }\n  BigDecimal totalCreditedAmount=BigDecimal.ZERO;\n  for (  final Map.Entry<GLAccount,BigDecimal> entry : creditDetailsMap.entrySet()) {\n    final GLAccount account=entry.getKey();\n    final BigDecimal amount=entry.getValue();\n    totalCreditedAmount=totalCreditedAmount.add(amount);\n    if (isReversal) {\n      createDebitJournalEntryForLoan(office,currencyCode,account,loanId,transactionId,transactionDate,amount);\n      createCreditJournalEntryForLoan(office,currencyCode,receivableAccount,loanId,transactionId,transactionDate,amount);\n    }\n else {\n      createDebitJournalEntryForLoan(office,currencyCode,receivableAccount,loanId,transactionId,transactionDate,amount);\n      createCreditJournalEntryForLoan(office,currencyCode,account,loanId,transactionId,transactionDate,amount);\n    }\n  }\n  if (totalAmount.compareTo(totalCreditedAmount) != 0) {\n    throw new PlatformDataIntegrityException(\"Meltdown in advanced accounting...sum of all charges is not equal to the fee charge for a transaction\",\"Meltdown in advanced accounting...sum of all charges is not equal to the fee charge for a transaction\",totalCreditedAmount,totalAmount);\n  }\n}", "comment": "convenience method that creates a pair of related debits and credits for accrual based accounting .", "label": "why"}
{"id": "60231", "raw_code": "public boolean isValidTemplate(){\n  return isValidTemplate(template);\n}", "comment": "validates this template to see if its valid for plugin v3 . 10 or higher .", "label": "why"}
{"id": "7662", "raw_code": "@Override public void drawItem(Graphics2D g2,CategoryItemRendererState state,Rectangle2D dataArea,CategoryPlot plot,CategoryAxis domainAxis,ValueAxis rangeAxis,CategoryDataset dataset,int row,int column,int pass){\n  int visibleRow=state.getVisibleSeriesIndex(row);\n  if (visibleRow < 0) {\n    return;\n  }\n  Number dataValue=dataset.getValue(row,column);\n  if (dataValue == null) {\n    return;\n  }\n  double value=dataValue.doubleValue();\n  PlotOrientation orientation=plot.getOrientation();\n  double barW0=calculateBarW0(plot,orientation,dataArea,domainAxis,state,visibleRow,column);\n  RectangleEdge edge=plot.getRangeAxisEdge();\n  double barL=rangeAxis.valueToJava2D(value,dataArea,edge);\n  Line2D line;\n  double x, y;\n  if (orientation.isHorizontal()) {\n    x=barL;\n    y=barW0 + state.getBarWidth() / 2.0;\n    line=new Line2D.Double(barL,barW0,barL,barW0 + state.getBarWidth());\n  }\n else {\n    x=barW0 + state.getBarWidth() / 2.0;\n    y=barL;\n    line=new Line2D.Double(barW0,barL,barW0 + state.getBarWidth(),barL);\n  }\n  if (state.getElementHinting()) {\n    beginElementGroup(g2,dataset.getRowKey(row),dataset.getColumnKey(column));\n  }\n  Stroke itemStroke=getItemStroke(row,column);\n  Paint itemPaint=getItemPaint(row,column);\n  g2.setStroke(itemStroke);\n  g2.setPaint(itemPaint);\n  g2.draw(line);\n  if (state.getElementHinting()) {\n    endElementGroup(g2);\n  }\n  CategoryItemLabelGenerator generator=getItemLabelGenerator(row,column);\n  if (generator != null && isItemLabelVisible(row,column)) {\n    drawItemLabel(g2,orientation,dataset,row,column,x,y,(value < 0.0));\n  }\n  int datasetIndex=plot.indexOf(dataset);\n  updateCrosshairValues(state.getCrosshairState(),dataset.getRowKey(row),dataset.getColumnKey(column),value,datasetIndex,barW0,barL,orientation);\n  EntityCollection entities=state.getEntityCollection();\n  if (entities != null) {\n    addItemEntity(entities,dataset,row,column,line.getBounds());\n  }\n}", "comment": "draws the bar for a single ( series , category ) data item .", "label": "why"}
{"id": "56039", "raw_code": "@Override public void onTabClosing(long time,int id){\n  reset();\n  forceAnimationToFinish();\n  TabModel model=mTabModelSelector.getModelForTabId(id);\n  if (model != null) {\n    mClosedTab=createLayoutTab(id,model.isIncognito(),NO_CLOSE_BUTTON,NO_TITLE);\n    mClosedTab.setBorderAlpha(0.0f);\n    mLayoutTabs=new LayoutTab[]{mClosedTab};\n    updateCacheVisibleIds(new LinkedList<Integer>(Arrays.asList(id)));\n  }\n else {\n    mLayoutTabs=null;\n    mClosedTab=null;\n  }\n  super.onTabClosing(time,id);\n}", "comment": "set up for the tab closing animation", "label": "why"}
{"id": "67371", "raw_code": "public static Charset forName(String charsetName){\n  return forName(charsetName,null);\n}", "comment": "safely gets charset for the specified name", "label": "why"}
{"id": "85272", "raw_code": "void ReconstructPrivateSubrs(int Font,IndexBaseItem[] fdPrivateBase,OffsetItem[] fdSubrs){\n  for (int i=0; i < fonts[Font].fdprivateLengths.length; i++) {\n    if (fdSubrs[i] != null && fonts[Font].PrivateSubrsOffset[i] >= 0) {\n      OutputList.addLast(new SubrMarkerItem(fdSubrs[i],fdPrivateBase[i]));\n      if (NewLSubrsIndex[i] != null)       OutputList.addLast(new RangeItem(new RandomAccessFileOrArray(rasFactory.createSource(NewLSubrsIndex[i])),0,NewLSubrsIndex[i].length));\n    }\n  }\n}", "comment": "function adds the new lsubrs dicts ( only for the fds used ) to the list", "label": "why"}
{"id": "16529", "raw_code": "protected final void firePropertyChange(String propertyName,long oldValue,long newValue){\n  firePropertyChange(propertyName,Long.valueOf(oldValue),Long.valueOf(newValue));\n}", "comment": "support for reporting bound property changes for integer properties .", "label": "why"}
{"id": "66953", "raw_code": "public SootMethodAndClass parseSootMethodString(String parseString){\n  if (!parseString.startsWith(\"<\") || !parseString.endsWith(\">\")) {\n    throw new IllegalArgumentException(\"Illegal format of \" + parseString + \" (should use soot method representation)\");\n  }\n  String name=\"\";\n  String className=\"\";\n  String returnType=\"\";\n  Pattern pattern=Pattern.compile(\"<(.*?):\");\n  Matcher matcher=pattern.matcher(parseString);\n  if (matcher.find()) {\n    className=matcher.group(1);\n  }\n  pattern=Pattern.compile(\": (.*?) \");\n  matcher=pattern.matcher(parseString);\n  if (matcher.find()) {\n    returnType=matcher.group(1);\n    parseString=parseString.substring(matcher.end(1));\n  }\n  pattern=Pattern.compile(\" (.*?)\\\\(\");\n  matcher=pattern.matcher(parseString);\n  if (matcher.find()) {\n    name=matcher.group(1);\n  }\n  List<String> paramList=new ArrayList<String>();\n  pattern=Pattern.compile(\"\\\\((.*?)\\\\)\");\n  matcher=pattern.matcher(parseString);\n  if (matcher.find()) {\n    String params=matcher.group(1);\n    for (    String param : params.split(\",\"))     paramList.add(param.trim());\n  }\n  return new SootMethodAndClass(name,className,returnType,paramList);\n}", "comment": "parses a string in soot representation , for example :", "label": "why"}
{"id": "12891", "raw_code": "public static LinkedList<MaryModule> modulesRequiredForProcessing(MaryDataType sourceType,MaryDataType targetType,Locale locale,Voice voice){\n  if (!registrationComplete)   throw new IllegalStateException(\"Cannot inquire about modules while registration is ongoing\");\n  if (sourceType == null)   throw new NullPointerException(\"Received null source type\");\n  if (targetType == null)   throw new NullPointerException(\"Received null target type\");\n  LinkedList<MaryDataType> seenTypes=new LinkedList<MaryDataType>();\n  seenTypes.add(sourceType);\n  return modulesRequiredForProcessing(sourceType,targetType,locale,voice,seenTypes);\n}", "comment": "a method for determining the list of modules required to transform the given source data type into the requested target data type .", "label": "why"}
{"id": "67902", "raw_code": "public static long calculateElapsedGC(){\n  long timeMillis=0;\n  for (  GarbageCollectorMXBean gcbean : gcbeans) {\n    timeMillis+=gcbean.getCollectionTime();\n  }\n  return timeMillis;\n}", "comment": "ask each gc bean for its elapsed collection time", "label": "why"}
{"id": "956", "raw_code": "private void addConnectionView(Connection connection){\n  PlatformImpl.runAndWait(null);\n}", "comment": "add a view for the given connection to the pipeline view .", "label": "why"}
{"id": "39699", "raw_code": "@Override public SoftwarePIDController withTolerance(double tolerance){\n  target=target.withTolerance(Math.abs(tolerance));\n  return this;\n}", "comment": "sets the absolute tolerance for this controller .", "label": "why"}
{"id": "8814", "raw_code": "private String classToEntryPath(Class<?> clazz){\n  String name=\"\";\n  Class<?> parent;\n  while ((parent=clazz.getEnclosingClass()) != null) {\n    name=\"$\" + clazz.getSimpleName() + name;\n    clazz=parent;\n  }\n  return classNameToEntryPath(clazz.getCanonicalName() + name);\n}", "comment": "utility method to get the jar entry path from a class name .", "label": "why"}
{"id": "74474", "raw_code": "private void startStoppedChanged(){\n  clock.setStartStopped(startStoppedCheckBox.isSelected());\n  changed=true;\n}", "comment": "method to handle start stopped check box change", "label": "why"}
{"id": "41700", "raw_code": "public void exportSymbols(String[] exportNames,Symbol[] symbols){\n  if (exportedSymbols == null) {\n    exportedSymbols=new ArrayList();\n  }\n  for (int i=0; i < exportNames.length && i < symbols.length; i++) {\n    exportedSymbols.add(new ExportedSymbol(symbols[i],exportNames[i]));\n  }\n}", "comment": "export a number of symbols with the given names so that other movies can import and use them .", "label": "why"}
{"id": "739", "raw_code": "protected void tag(String tag,ArrayList names,ArrayList values,int nattr,boolean close){\n  spacing();\n  m_out.print('<');\n  m_out.print(tag);\n  for (int i=0; i < nattr; ++i) {\n    m_out.print(' ');\n    m_out.print((String)names.get(i));\n    m_out.print('=');\n    m_out.print('\\\"');\n    escapeString((String)values.get(i));\n    m_out.print('\\\"');\n  }\n  if (close)   m_out.print('/');\n  m_out.print('>');\n  println();\n  if (!close) {\n    m_tagStack.add(tag);\n  }\n}", "comment": "internal method for printing a tag with attributes .", "label": "why"}
{"id": "36713", "raw_code": "protected void drawCloud(int x,int y,int w,int h,Color fillColor,Paint fillPaint,Color penColor,boolean shadow){\n  GeneralPath path=new GeneralPath();\n  path.moveTo((float)(x + 0.25 * w),(float)(y + 0.25 * h));\n  path.curveTo((float)(x + 0.05 * w),(float)(y + 0.25 * h),(float)x,(float)(y + 0.5 * h),(float)(x + 0.16 * w),(float)(y + 0.55 * h));\n  path.curveTo((float)x,(float)(y + 0.66 * h),(float)(x + 0.18 * w),(float)(y + 0.9 * h),(float)(x + 0.31 * w),(float)(y + 0.8 * h));\n  path.curveTo((float)(x + 0.4 * w),(float)(y + h),(float)(x + 0.7 * w),(float)(y + h),(float)(x + 0.8 * w),(float)(y + 0.8 * h));\n  path.curveTo((float)(x + w),(float)(y + 0.8 * h),(float)(x + w),(float)(y + 0.6 * h),(float)(x + 0.875 * w),(float)(y + 0.5 * h));\n  path.curveTo((float)(x + w),(float)(y + 0.3 * h),(float)(x + 0.8 * w),(float)(y + 0.1 * h),(float)(x + 0.625 * w),(float)(y + 0.2 * h));\n  path.curveTo((float)(x + 0.5 * w),(float)(y + 0.05 * h),(float)(x + 0.3 * w),(float)(y + 0.05 * h),(float)(x + 0.25 * w),(float)(y + 0.25 * h));\n  path.closePath();\n  drawPath(path,fillColor,fillPaint,penColor,shadow);\n}", "comment": "draws a cloud shape for the given parameters .", "label": "why"}
{"id": "2270", "raw_code": "@AfterMethod public void tearDown() throws Exception {\n  Throwable t=threadFailure.getAndSet(null);\n  if (t != null) {\n    if (t instanceof Error)     throw (Error)t;\n else     if (t instanceof RuntimeException)     throw (RuntimeException)t;\n else     if (t instanceof Exception)     throw (Exception)t;\n else {\n      AssertionFailedError afe=new AssertionFailedError(t.toString());\n      afe.initCause(t);\n      throw afe;\n    }\n  }\n  if (Thread.interrupted())   tearDownFail(\"interrupt status set in main thread\");\n  checkForkJoinPoolThreadLeaks();\n}", "comment": "extra checks that get done for all test cases .", "label": "why"}
{"id": "49002", "raw_code": "void rememberFactory(String host,RMISocketFactory factory){\nsynchronized (successTable) {\n    while (hostList.size() >= MaxRememberedHosts) {\n      successTable.remove(hostList.elementAt(0));\n      hostList.removeElementAt(0);\n    }\n    hostList.addElement(host);\n    successTable.put(host,factory);\n  }\n}", "comment": "remember a successful factory for connecting to host .", "label": "why"}
{"id": "11960", "raw_code": "private void adjustBackingFileLength(byte[] buffer,long index) throws IOException {\n  if (buffer == null || buffer.length == 0) {\n    throw new IOException(\"Buffer null or empty!\");\n  }\n  long newsize=fHeader.headerSize() + (index * CHUNK_ENC_SIZE) + CHUNK_IV_SIZE+ buffer.length+ CHUNK_TLEN;\n  if (newsize > realLength()) {\n    backingRandomAccessFile.setLength(newsize);\n  }\n}", "comment": "helper methods which adjusts the actual length of the backing file for caching .", "label": "why"}
{"id": "52256", "raw_code": "public void doDoubleClickAction(){\n  doDoubleClickAction(null);\n}", "comment": "launches an dialog allowing the user to pick a new name for this variable , where no constraints are placed on the name .", "label": "why"}
{"id": "52243", "raw_code": "public static Node serializableInstance(){\n  return new GraphNode(\"X\");\n}", "comment": "generates a simple exemplar of this class to test serialization .", "label": "why"}
{"id": "7888", "raw_code": "private double maxIgnoreNaN(double a,double b){\n  if (Double.isNaN(a)) {\n    return b;\n  }\n  if (Double.isNaN(b)) {\n    return a;\n  }\n else {\n    return Math.max(a,b);\n  }\n}", "comment": "a function to find the maximum of two values , but ignoring any double . nan values .", "label": "why"}
{"id": "68323", "raw_code": "public void crabDownDirBlockForModification(BlockId blk){\n  lockTbl.xLock(blk,txNum);\n  writenIndexBlks.add(blk);\n}", "comment": "sets exclusive lock on the directory block when crabbing down for modification .", "label": "why"}
{"id": "4746", "raw_code": "private static void removeReferenceToConnection(final HttpConnectionWithReference connection){\nsynchronized (REFERENCE_TO_CONNECTION_SOURCE) {\n    REFERENCE_TO_CONNECTION_SOURCE.remove(connection.reference);\n  }\n}", "comment": "removes the reference being stored for the given connection .", "label": "why"}
{"id": "48937", "raw_code": "public void generate(BatchEnvironment env,ClassDefinition cdef,File destDir){\n  RemoteClass remoteClass=RemoteClass.forClass(env,cdef);\n  if (remoteClass == null)   return;\n  RMIGenerator gen;\n  try {\n    gen=new RMIGenerator(env,cdef,destDir,remoteClass,version);\n  }\n catch (  ClassNotFound e) {\n    env.error(0,\"rmic.class.not.found\",e.name);\n    return;\n  }\n  gen.generate();\n}", "comment": "generate the source files for the stub and / or skeleton classes needed by rmi for the given remote implementation class .", "label": "why"}
{"id": "14763", "raw_code": "public ServiceConfig createOrganizationConfig(String orgName,Map attrs) throws SMSException, SSOException {\n  validateSSM();\n  ServiceSchemaImpl ss=ssm.getSchema(SchemaType.ORGANIZATION);\n  if (ss == null) {\n    String[] args={serviceName};\n    throw (new SMSException(IUMSConstants.UMS_BUNDLE_NAME,\"sms-service-does-not-have-org-schema\",args));\n  }\n  String orgdn=DNMapper.orgNameToDN(orgName);\n  CreateServiceConfig.checkBaseNodesForOrg(token,orgdn,serviceName,version);\n  String orgDN=scm.constructServiceConfigDN(SMSUtils.DEFAULT,CreateServiceConfig.ORG_CONFIG_NODE,orgdn);\n  try {\n    CachedSMSEntry cEntry=CachedSMSEntry.getInstance(token,orgDN);\n    if (cEntry.isDirty()) {\n      cEntry.refresh();\n    }\n    if (cEntry.isNewEntry()) {\n      CreateServiceConfig.createSubConfigEntry(token,orgDN,ss,null,null,attrs,orgName);\n      if (ServiceManager.isCoexistenceMode()) {\n        String smsDN=DNMapper.orgNameToDN(orgName);\n        OrgConfigViaAMSDK amsdk=new OrgConfigViaAMSDK(token,DNMapper.realmNameToAMSDKName(smsDN),smsDN);\n        amsdk.assignService(serviceName);\n      }\n    }\n else     if (attrs != null && !attrs.isEmpty()) {\n      ServiceConfig sc=getOrganizationConfig(orgName,null);\n      sc.setAttributes(attrs);\n    }\n  }\n catch (  ServiceAlreadyExistsException slee) {\n  }\n  return (getOrganizationConfig(orgName,null));\n}", "comment": "creates organization configuration for the default instance of the service given configuration attributes .", "label": "why"}
{"id": "64876", "raw_code": "private static String formatSampleRate(int rate){\n  return MHZ_FORMATTER.format((double)rate / 1E6d);\n}", "comment": "formats the rate in hertz for display as megahertz", "label": "why"}
{"id": "86135", "raw_code": "TypeSimplifier(Types typeUtils,String packageName,Set<TypeMirror> types,TypeMirror base){\n  this.typeUtils=typeUtils;\n  Set<TypeMirror> typesPlusBase=new TypeMirrorSet(types);\n  if (base != null) {\n    typesPlusBase.add(base);\n  }\n  Set<TypeMirror> referenced=referencedClassTypes(typeUtils,typesPlusBase);\n  Set<TypeMirror> defined=nonPrivateDeclaredTypes(typeUtils,base);\n  this.imports=findImports(typeUtils,packageName,referenced,defined);\n}", "comment": "makes a new simplifier for the given package and set of types .", "label": "why"}
{"id": "55751", "raw_code": "public static byte[] escape(final byte[] bytes){\n  final byte[] temp=new byte[2 * bytes.length];\n  int currentPosition=0;\n  for (  final byte b : bytes) {\n    if (b == ESCAPE_CHAR) {\n      temp[currentPosition++]=ESCAPE_CHAR;\n      temp[currentPosition++]=REPLACEMENT_CHAR;\n    }\n else     if (b == DELIMITER) {\n      temp[currentPosition++]=ESCAPE_CHAR;\n      temp[currentPosition++]=ESCAPE_CHAR;\n    }\n else {\n      temp[currentPosition++]=b;\n    }\n  }\n  final byte[] escaped=new byte[currentPosition];\n  System.arraycopy(temp,0,escaped,0,currentPosition);\n  return escaped;\n}", "comment": "escapes the provided string so that it no longer contains the constants . delimiter character .", "label": "why"}
{"id": "51078", "raw_code": "public static void drawVerticalMarginIndicator(Graphics2D g,String text,int x,int y1,int y2){\n  if (y1 > y2) {\n    int temp=y1;\n    y1=y2;\n    y2=temp;\n  }\n  if (text == null) {\n    g.drawLine(x,y1,x,y2);\n    g.drawLine(x,y1,x - CONNECTION_ARROW_SIZE,y1 + CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y1,x + CONNECTION_ARROW_SIZE,y1 + CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y2,x - CONNECTION_ARROW_SIZE,y2 - CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y2,x + CONNECTION_ARROW_SIZE,y2 - CONNECTION_ARROW_SIZE);\n    return;\n  }\n  Canvas c=new Canvas();\n  FontMetrics fm=c.getFontMetrics(sFont);\n  g.setFont(sFont);\n  int padding=4;\n  Rectangle2D bounds=fm.getStringBounds(text,g);\n  int th=(int)bounds.getHeight();\n  int offset=3 * CONNECTION_ARROW_SIZE;\n  int h=((y2 - y1) - (th + 2 * padding)) / 2;\n  if (h <= padding) {\n    g.drawLine(x,y1,x,y2);\n    g.drawString(text,(int)(x - bounds.getWidth() / 2) + offset,y2 - h - padding);\n    g.drawLine(x - CONNECTION_ARROW_SIZE,y1,x + CONNECTION_ARROW_SIZE,y1);\n    g.drawLine(x - CONNECTION_ARROW_SIZE,y2,x + CONNECTION_ARROW_SIZE,y2);\n  }\n else {\n    g.drawLine(x,y1,x,y1 + h);\n    g.drawLine(x,y2 - h,x,y2);\n    g.drawString(text,(int)(x - bounds.getWidth() / 2),y2 - h - padding);\n    g.drawLine(x,y1,x - CONNECTION_ARROW_SIZE,y1 + CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y1,x + CONNECTION_ARROW_SIZE,y1 + CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y2,x - CONNECTION_ARROW_SIZE,y2 - CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y2,x + CONNECTION_ARROW_SIZE,y2 - CONNECTION_ARROW_SIZE);\n  }\n}", "comment": "utility function to draw a vertical margin indicator", "label": "why"}
{"id": "39196", "raw_code": "public static double info(int counts[]){\n  int total=0;\n  double x=0;\n  for (  int count : counts) {\n    x-=xlogx(count);\n    total+=count;\n  }\n  return x + xlogx(total);\n}", "comment": "computes entropy for an array of integers .", "label": "why"}
{"id": "48564", "raw_code": "protected void decodeLineSuffix(PushbackInputStream inStream,OutputStream outStream) throws IOException {\n  int c;\n  while (true) {\n    c=inStream.read();\n    if (c == -1) {\n      throw new CEStreamExhausted();\n    }\n    if (c == '\\n') {\n      break;\n    }\n    if (c == '\\r') {\n      c=inStream.read();\n      if ((c != '\\n') && (c != -1)) {\n        inStream.unread(c);\n      }\n      break;\n    }\n  }\n}", "comment": "find the end of the line for the next operation .", "label": "why"}
{"id": "11237", "raw_code": "public void addPropertyChangeListener(String propertyName,PropertyChangeListener in_pcl){\n  beanContextChildSupport.addPropertyChangeListener(propertyName,in_pcl);\n}", "comment": "method for beancontextchild interface .", "label": "why"}
{"id": "765", "raw_code": "public boolean isPersistent(){\n  return m_persist;\n}", "comment": "indicates if the tooltip will stay persistent on the screen to support interaction within the tooltip component .", "label": "why"}
{"id": "25543", "raw_code": "private void updateLtp(SingleChannelElement sce){\n  IndividualChannelStream ics=sce.ics;\n  float saved[]=sce.saved;\n  float savedLtp[]=sce.coeffs;\n  final float lwindow[]=ics.useKbWindow[0] ? ff_aac_kbd_long_1024 : ff_sine_1024;\n  final float swindow[]=ics.useKbWindow[0] ? ff_aac_kbd_short_128 : ff_sine_128;\n  if (ics.windowSequence[0] == EIGHT_SHORT_SEQUENCE) {\n    System.arraycopy(saved,0,savedLtp,0,512);\n    Arrays.fill(savedLtp,576,576 + 448,0f);\n    FloatDSP.vectorFmulReverse(savedLtp,448,ac.bufMdct,960,swindow,64,64);\n    for (int i=0; i < 64; i++) {\n      savedLtp[i + 512]=ac.bufMdct[1023 - i] * swindow[63 - i];\n    }\n  }\n else   if (ics.windowSequence[0] == LONG_START_SEQUENCE) {\n    System.arraycopy(ac.bufMdct,512,savedLtp,0,448);\n    Arrays.fill(savedLtp,576,576 + 448,0f);\n    FloatDSP.vectorFmulReverse(savedLtp,448,ac.bufMdct,960,swindow,64,64);\n    for (int i=0; i < 64; i++) {\n      savedLtp[i + 512]=ac.bufMdct[1023 - i] * swindow[63 - i];\n    }\n  }\n else {\n    FloatDSP.vectorFmulReverse(savedLtp,0,ac.bufMdct,512,lwindow,512,512);\n    for (int i=0; i < 512; i++) {\n      savedLtp[i + 512]=ac.bufMdct[1023 - i] * lwindow[511 - i];\n    }\n  }\n  System.arraycopy(sce.ltpState,1024,sce.ltpState,0,1024);\n  System.arraycopy(sce.ret,0,sce.ltpState,1024,1024);\n  System.arraycopy(savedLtp,0,sce.ltpState,2048,1024);\n}", "comment": "update the ltp buffer for next frame", "label": "why"}
{"id": "42165", "raw_code": "public AllocationSite(int line,int column){\nsynchronized (sites) {\n    this.id=sites.size();\n    sites.add(this);\n  }\n  this.line=line;\n  this.column=column;\n}", "comment": "create an allocation site for a given source code line / column .", "label": "why"}
{"id": "26954", "raw_code": "public final static int parseInt(char[] digitChars,int offset,int len){\n  int num=digitChars[offset] - '0';\n  len+=offset;\n  if (++offset < len) {\n    num=(num * 10) + (digitChars[offset] - '0');\n    if (++offset < len) {\n      num=(num * 10) + (digitChars[offset] - '0');\n      if (++offset < len) {\n        num=(num * 10) + (digitChars[offset] - '0');\n        if (++offset < len) {\n          num=(num * 10) + (digitChars[offset] - '0');\n          if (++offset < len) {\n            num=(num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n              num=(num * 10) + (digitChars[offset] - '0');\n              if (++offset < len) {\n                num=(num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                  num=(num * 10) + (digitChars[offset] - '0');\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return num;\n}", "comment": "fast method for parsing integers that are known to fit into regular 32 - bit signed int type .", "label": "why"}
{"id": "83850", "raw_code": "public int[] breadthFirstSearch(int intialValue,IBFSTraversable<N> traversable,int firstValue,IIntegerBfsNextValueIterator<N> nextValueIterator,List<Integer> sourcesIndex){\n  int[] results=new int[nodes.length];\n  Arrays.fill(results,intialValue);\n  boolean[] alreadyScanned=new boolean[nodes.length];\n  Arrays.fill(alreadyScanned,false);\n  Set<Integer> currentNodesIndex=new HashSet<>(sourcesIndex);\n  iterativeIntegerBreadthFirstSearch(results,alreadyScanned,currentNodesIndex,firstValue,0,traversable,nextValueIterator);\n  return results;\n}", "comment": "breadth - first search implementation for integers .", "label": "why"}
{"id": "21554", "raw_code": "private void rollbackMethodForCreateSnapshot(boolean isSnapshotCreated,boolean isDummyLunPathAdded,HDSApiClient hdsApiClient,StorageSystem storage,URI snapshot) throws Exception {\n  if (isDummyLunPathAdded) {\n    log.info(\"Remove dummy path while doing roll back\");\n    hdsProtectionOperations.removeDummyLunPath(storage,snapshot);\n  }\n  if (isSnapshotCreated) {\n    log.info(\"Remove snapshot volume for roll back\");\n    BlockSnapshot snapshotObj=dbClient.queryObject(BlockSnapshot.class,snapshot);\n    String systemObjectID=HDSUtils.getSystemObjectID(storage);\n    String logicalUnitObjId=HDSUtils.getLogicalUnitObjectId(snapshotObj.getNativeId(),storage);\n    hdsApiClient.deleteSnapshotVolume(systemObjectID,logicalUnitObjId,storage.getModel());\n  }\n}", "comment": "roll back method to clean up stale snapshot volume on storage system", "label": "why"}
{"id": "28231", "raw_code": "static void removeRedundantAffix(TranslatorUtils.IContain iContain,List<String> strList){\n  if (strList.size() <= 1) {\n    return;\n  }\n  int w=0;\n  for (  String str : strList) {\n    if (w == 0 || !iContain.containFunc(str,strList.get(w - 1))) {\n      strList.set(w,str);\n      w++;\n    }\n  }\n  strList=strList.subList(0,w);\n}", "comment": "this function ensures that prefix / suffix sets aren ' t redundant .", "label": "why"}
{"id": "37744", "raw_code": "protected void updateStatsForConditionalDensityEstimator(ConditionalDensityEstimator classifier,Instance classMissing,double classValue) throws Exception {\n  if (m_PriorEstimator == null) {\n    setNumericPriorsFromBuffer();\n  }\n  m_SumSchemeEntropy-=classifier.logDensity(classMissing,classValue) * classMissing.weight() / Utils.log2;\n  m_SumPriorEntropy-=m_PriorEstimator.logDensity(classValue) * classMissing.weight() / Utils.log2;\n}", "comment": "updates stats for conditional density estimator based on current test instance .", "label": "why"}
{"id": "53505", "raw_code": "public static boolean compareDoubles(double a,double b){\n  if (Double.isNaN(a) && Double.isNaN(b))   return true;\n  if (!Double.isInfinite(a) && !Double.isInfinite(b))   return Math.abs(a - b) <= EPSILON;\n  return a == b;\n}", "comment": "compares two doubles for equality .", "label": "why"}
{"id": "85826", "raw_code": "public Rect updateFastScrollerBounds(BaseRecyclerView rv,int lastTouchY){\n  mInvalidateRect.set(mBgBounds);\n  if (isVisible()) {\n    int edgePadding=rv.getMaxScrollbarWidth();\n    int bgPadding=(mBgOriginalSize - mTextBounds.height()) / 2;\n    int bgHeight=mBgOriginalSize;\n    int bgWidth=Math.max(mBgOriginalSize,mTextBounds.width() + (2 * bgPadding));\n    if (Utilities.isRtl(mRes)) {\n      mBgBounds.left=rv.getBackgroundPadding().left + (2 * rv.getMaxScrollbarWidth());\n      mBgBounds.right=mBgBounds.left + bgWidth;\n    }\n else {\n      mBgBounds.right=rv.getWidth() - rv.getBackgroundPadding().right - (2 * rv.getMaxScrollbarWidth());\n      mBgBounds.left=mBgBounds.right - bgWidth;\n    }\n    mBgBounds.top=lastTouchY - (int)(FAST_SCROLL_OVERLAY_Y_OFFSET_FACTOR * bgHeight);\n    mBgBounds.top=Math.max(edgePadding,Math.min(mBgBounds.top,rv.getHeight() - edgePadding - bgHeight));\n    mBgBounds.bottom=mBgBounds.top + bgHeight;\n  }\n else {\n    mBgBounds.setEmpty();\n  }\n  mInvalidateRect.union(mBgBounds);\n  return mInvalidateRect;\n}", "comment": "updates the bounds for the fast scroller .", "label": "why"}
{"id": "70577", "raw_code": "public boolean textboxKeyTyped(char p_146201_1_,int p_146201_2_){\n  if (!isFocused)   return false;\n else   if (GuiScreen.func_175278_g(p_146201_2_)) {\n    setCursorPositionEnd();\n    setSelectionPos(0);\n    return true;\n  }\n else   if (GuiScreen.func_175280_f(p_146201_2_)) {\n    GuiScreen.setClipboardString(getSelectedText());\n    return true;\n  }\n else   if (GuiScreen.func_175279_e(p_146201_2_)) {\n    if (isEnabled)     writeText(GuiScreen.getClipboardString());\n    return true;\n  }\n else   if (GuiScreen.func_175277_d(p_146201_2_)) {\n    GuiScreen.setClipboardString(getSelectedText());\n    if (isEnabled)     writeText(\"\");\n    return true;\n  }\n else switch (p_146201_2_) {\ncase 14:\n    if (GuiScreen.isCtrlKeyDown()) {\n      if (isEnabled)       deleteWords(-1);\n    }\n else     if (isEnabled)     deleteFromCursor(-1);\n  return true;\ncase 199:\nif (GuiScreen.isShiftKeyDown()) setSelectionPos(0);\n else setCursorPositionZero();\nreturn true;\ncase 203:\nif (GuiScreen.isShiftKeyDown()) {\nif (GuiScreen.isCtrlKeyDown()) setSelectionPos(getNthWordFromPos(-1,getSelectionEnd()));\n else setSelectionPos(getSelectionEnd() - 1);\n}\n else if (GuiScreen.isCtrlKeyDown()) setCursorPosition(getNthWordFromCursor(-1));\n else moveCursorBy(-1);\nreturn true;\ncase 205:\nif (GuiScreen.isShiftKeyDown()) {\nif (GuiScreen.isCtrlKeyDown()) setSelectionPos(getNthWordFromPos(1,getSelectionEnd()));\n else setSelectionPos(getSelectionEnd() + 1);\n}\n else if (GuiScreen.isCtrlKeyDown()) setCursorPosition(getNthWordFromCursor(1));\n else moveCursorBy(1);\nreturn true;\ncase 207:\nif (GuiScreen.isShiftKeyDown()) setSelectionPos(text.length());\n else setCursorPositionEnd();\nreturn true;\ncase 211:\nif (GuiScreen.isCtrlKeyDown()) {\nif (isEnabled) deleteWords(1);\n}\n else if (isEnabled) deleteFromCursor(1);\nreturn true;\ndefault :\nif (EmailAllowedCharacters.isAllowedCharacter(p_146201_1_)) {\nif (isEnabled) writeText(Character.toString(p_146201_1_));\nreturn true;\n}\n else return false;\n}\n}", "comment": "call this method from your guiscreen to process the keys into the textbox", "label": "why"}
{"id": "12387", "raw_code": "private void stopDrag(MotionEvent ev){\n  mTouchMode=TOUCH_MODE_IDLE;\n  final boolean commitChange=ev.getAction() == MotionEvent.ACTION_UP && isEnabled();\n  final boolean oldState=isChecked();\n  final boolean newState;\n  if (commitChange) {\n    mVelocityTracker.computeCurrentVelocity(1000);\n    final float xvel=mVelocityTracker.getXVelocity();\n    if (Math.abs(xvel) > mMinFlingVelocity) {\n      newState=ViewUtils.isLayoutRtl(this) ? (xvel < 0) : (xvel > 0);\n    }\n else {\n      newState=getTargetCheckedState();\n    }\n  }\n else {\n    newState=oldState;\n  }\n  if (newState != oldState) {\n    playSoundEffect(SoundEffectConstants.CLICK);\n  }\n  setChecked(newState);\n  cancelSuperTouch(ev);\n}", "comment": "called from ontouchevent to end a drag operation .", "label": "why"}
{"id": "72368", "raw_code": "private static long addAndCheck(long a,long b,Localizable pattern) throws MathRuntimeException {\n  final long result=a + b;\n  if (!((a ^ b) < 0 || (a ^ result) >= 0)) {\n    throw new MathRuntimeException(pattern,a,b);\n  }\n  return result;\n}", "comment": "add two long integers , checking for overflow .", "label": "why"}
{"id": "7646", "raw_code": "@Override public void drawBackground(Graphics2D g2,CategoryPlot plot,Rectangle2D dataArea){\n  float x0=(float)dataArea.getX();\n  float x1=x0 + (float)Math.abs(this.xOffset);\n  float x3=(float)dataArea.getMaxX();\n  float x2=x3 - (float)Math.abs(this.xOffset);\n  float y0=(float)dataArea.getMaxY();\n  float y1=y0 - (float)Math.abs(this.yOffset);\n  float y3=(float)dataArea.getMinY();\n  float y2=y3 + (float)Math.abs(this.yOffset);\n  GeneralPath clip=new GeneralPath();\n  clip.moveTo(x0,y0);\n  clip.lineTo(x0,y2);\n  clip.lineTo(x1,y3);\n  clip.lineTo(x3,y3);\n  clip.lineTo(x3,y1);\n  clip.lineTo(x2,y0);\n  clip.closePath();\n  Composite originalComposite=g2.getComposite();\n  g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,plot.getBackgroundAlpha()));\n  Paint backgroundPaint=plot.getBackgroundPaint();\n  if (backgroundPaint != null) {\n    g2.setPaint(backgroundPaint);\n    g2.fill(clip);\n  }\n  GeneralPath leftWall=new GeneralPath();\n  leftWall.moveTo(x0,y0);\n  leftWall.lineTo(x0,y2);\n  leftWall.lineTo(x1,y3);\n  leftWall.lineTo(x1,y1);\n  leftWall.closePath();\n  g2.setPaint(getWallPaint());\n  g2.fill(leftWall);\n  GeneralPath bottomWall=new GeneralPath();\n  bottomWall.moveTo(x0,y0);\n  bottomWall.lineTo(x1,y1);\n  bottomWall.lineTo(x3,y1);\n  bottomWall.lineTo(x2,y0);\n  bottomWall.closePath();\n  g2.setPaint(getWallPaint());\n  g2.fill(bottomWall);\n  g2.setPaint(Color.lightGray);\n  Line2D corner=new Line2D.Double(x0,y0,x1,y1);\n  g2.draw(corner);\n  corner.setLine(x1,y1,x1,y3);\n  g2.draw(corner);\n  corner.setLine(x1,y1,x3,y1);\n  g2.draw(corner);\n  Image backgroundImage=plot.getBackgroundImage();\n  if (backgroundImage != null) {\n    Rectangle2D adjusted=new Rectangle2D.Double(dataArea.getX() + getXOffset(),dataArea.getY(),dataArea.getWidth() - getXOffset(),dataArea.getHeight() - getYOffset());\n    plot.drawBackgroundImage(g2,adjusted);\n  }\n  g2.setComposite(originalComposite);\n}", "comment": "draws the background for the plot .", "label": "why"}
{"id": "63344", "raw_code": "public static void dropIndex(Connection conn,String schema,String table) throws SQLException {\n  init(conn);\n  PreparedStatement prep=conn.prepareStatement(\"SELECT ID FROM \" + SCHEMA + \".INDEXES WHERE SCHEMA=? AND TABLE=?\");\n  prep.setString(1,schema);\n  prep.setString(2,table);\n  ResultSet rs=prep.executeQuery();\n  if (!rs.next()) {\n    return;\n  }\n  int indexId=rs.getInt(1);\n  prep=conn.prepareStatement(\"DELETE FROM \" + SCHEMA + \".INDEXES WHERE ID=?\");\n  prep.setInt(1,indexId);\n  prep.execute();\n  createOrDropTrigger(conn,schema,table,false);\n  prep=conn.prepareStatement(\"DELETE FROM \" + SCHEMA + \".ROWS WHERE INDEXID=? AND ROWNUM<10000\");\n  while (true) {\n    prep.setInt(1,indexId);\n    int deleted=prep.executeUpdate();\n    if (deleted == 0) {\n      break;\n    }\n  }\n  prep=conn.prepareStatement(\"DELETE FROM \" + SCHEMA + \".MAP M \"+ \"WHERE NOT EXISTS (SELECT * FROM \"+ SCHEMA+ \".ROWS R WHERE R.ID=M.ROWID) AND ROWID<10000\");\n  while (true) {\n    int deleted=prep.executeUpdate();\n    if (deleted == 0) {\n      break;\n    }\n  }\n}", "comment": "drop an existing full text index for a table .", "label": "why"}
{"id": "18392", "raw_code": "protected void deleteLeastUsedEntry(){\n  try {\n    poolLock.lock();\n    BasicPoolEntry entry=freeConnections.remove();\n    if (entry != null) {\n      deleteEntry(entry);\n    }\n else     if (log.isDebugEnabled()) {\n      log.debug(\"No free connection to delete.\");\n    }\n  }\n  finally {\n    poolLock.unlock();\n  }\n}", "comment": "delete an old , free pool entry to make room for a new one .", "label": "why"}
{"id": "45984", "raw_code": "void changeState(int newState){\n  int oldState;\nsynchronized (stateLock) {\n    if (state == newState)     return;\n    oldState=state;\n    state=newState;\n    stateLock.notifyAll();\n  }\n  sendStateChangeNotification(oldState,newState);\n}", "comment": "for internal use only .", "label": "why"}
{"id": "83907", "raw_code": "private static MetricValue number_to_metric_value_(Number elem){\n  if (elem == null)   return MetricValue.EMPTY;\n  final String num=elem.toString();\n  try {\n    return MetricValue.fromIntValue(Long.parseLong(num));\n  }\n catch (  NumberFormatException ex) {\n  }\n  try {\n    return MetricValue.fromDblValue(Double.parseDouble(num));\n  }\n catch (  NumberFormatException ex) {\n  }\n  return MetricValue.fromStrValue(num);\n}", "comment": "work around for google gson parser emitting numbers as ' lazily parsed ' numbers .", "label": "why"}
{"id": "4231", "raw_code": "public boolean isConfigured(){\n  LOG.debug(\"lookup url: \" + url);\n  return url != null && !url.isEmpty();\n}", "comment": "method to quickly indicate if the service is not configured .", "label": "why"}
{"id": "19879", "raw_code": "public void removeStorage() throws BackupException {\n  logger.debug(\"Removing contents of storage directory: \" + dataDirSpec.getAbsolutePath());\n  processHelper.exec(\"Removing contents of storage directory\",rmCmd);\n}", "comment": "clears storage in preparation for restore operation .", "label": "why"}
{"id": "77772", "raw_code": "public static void silentCloseInputStream(InputStream is){\n  try {\n    if (is != null) {\n      is.close();\n    }\n  }\n catch (  IOException e) {\n    log.w(LOG_TAG,\"Cannot close input stream\",e);\n  }\n}", "comment": "a utility function to close an input stream without raising an exception .", "label": "why"}
{"id": "17048", "raw_code": "public Storage(){\n  this(new File(getTemporaryStorageDirectoryString()));\n}", "comment": "creates new instance of storage for storing temporary data .", "label": "why"}
{"id": "47055", "raw_code": "private void releaseWaiters(int phase){\n  QNode q;\n  Thread t;\n  AtomicReference<QNode> head=(phase & 1) == 0 ? evenQ : oddQ;\n  while ((q=head.get()) != null && q.phase != (int)(root.state >>> PHASE_SHIFT)) {\n    if (head.compareAndSet(q,q.next) && (t=q.thread) != null) {\n      q.thread=null;\n      LockSupport.unpark(t);\n    }\n  }\n}", "comment": "removes and signals threads from queue for phase .", "label": "why"}
{"id": "18338", "raw_code": "protected boolean declAlreadyDeclared(String prefix){\n  int startDecls=m_contextIndexes.peek();\n  java.util.Vector prefixMappings=m_prefixMappings;\n  int nDecls=prefixMappings.size();\n  for (int i=startDecls; i < nDecls; i+=2) {\n    String prefixDecl=(String)prefixMappings.elementAt(i);\n    if (prefixDecl == null)     continue;\n    if (prefixDecl.equals(prefix))     return true;\n  }\n  return false;\n}", "comment": "check if a declaration has already been made for a given prefix .", "label": "why"}
{"id": "55198", "raw_code": "String parse(String cellStr,int layoutConstant){\n  return cellStr.split(LayoutConstants.CELL_PTRN)[layoutConstant];\n}", "comment": "utility method to parse a cell definition for a particular value .", "label": "why"}
{"id": "74139", "raw_code": "public void pseudoPropertyChange(String propName,Object old,Object n){\n  if (log.isDebugEnabled()) {\n    log.debug(\"pseudoPropertyChange: Block \\\"\" + getSystemName() + \" property \\\"\"+ propName+ \"\\\" new value= \"+ n.toString());\n  }\n  firePropertyChange(propName,old,n);\n}", "comment": "call for circuit builder to make icon color changes for its gui", "label": "why"}
{"id": "73807", "raw_code": "@Override protected void addChooserFilters(JFileChooser chooser){\n  javax.swing.filechooser.FileNameExtensionFilter filter=new javax.swing.filechooser.FileNameExtensionFilter(Bundle.getMessage(\"FileFilterLabel\",\"*.dfm, *.hex\"),\"dmf\",\"hex\");\n  chooser.addChoosableFileFilter(new javax.swing.filechooser.FileNameExtensionFilter(\"Digitrax Mangled Firmware (*.dmf)\",\"dmf\"));\n  chooser.addChoosableFileFilter(new javax.swing.filechooser.FileNameExtensionFilter(\"Intel Hex Format Firmware (*.hex)\",\"hex\"));\n  chooser.addChoosableFileFilter(filter);\n  chooser.setFileFilter(filter);\n}", "comment": "add filter ( s ) for possible types to the input file chooser .", "label": "why"}
{"id": "53147", "raw_code": "public static double quantile(double p,double k,double theta,double shift){\n  return Math.exp(GammaDistribution.quantile(p,k,theta)) + shift;\n}", "comment": "compute probit ( inverse cdf ) for loggamma distributions .", "label": "why"}
{"id": "5787", "raw_code": "private float clampMag(float value,float absMin,float absMax){\n  final float absValue=Math.abs(value);\n  if (absValue < absMin)   return 0;\n  if (absValue > absMax)   return value > 0 ? absMax : -absMax;\n  return value;\n}", "comment": "clamp the magnitude of value for absmin and absmax .", "label": "why"}
{"id": "14057", "raw_code": "protected boolean isIDPProxyEnabled(FSAuthnRequest authnRequest) throws FSException {\n  if (authnRequest.getMinorVersion() != IFSConstants.FF_12_PROTOCOL_MINOR_VERSION) {\n    return false;\n  }\n  FSScoping scoping=authnRequest.getScoping();\n  if (scoping != null && scoping.getProxyCount() == 0) {\n    return false;\n  }\n  String enabledString=IDFFMetaUtils.getFirstAttributeValueFromConfig(spConfig,IFSConstants.ENABLE_IDP_PROXY);\n  if (enabledString != null && enabledString.equalsIgnoreCase(\"true\")) {\n    return true;\n  }\n else {\n    return false;\n  }\n}", "comment": "checks if the identity provider is configured for proxying the authentication requests for a requesting service provider .", "label": "why"}
{"id": "16534", "raw_code": "protected final void fireVetoableChange(String propertyName,double oldValue,double newValue) throws PropertyVetoException {\n  fireVetoableChange(propertyName,Double.valueOf(oldValue),Double.valueOf(newValue));\n}", "comment": "support for reporting changes for constrained integer properties .", "label": "why"}
{"id": "82678", "raw_code": "public void show(@IdRes final int itemId){\n  map.add(itemId);\n  navigation.invalidateBadge(itemId);\n}", "comment": "request to display a new badge over the passed menu item id", "label": "why"}
{"id": "62363", "raw_code": "public void clone(Vector3f source){\n  System.arraycopy(source.points,0,points,0,3);\n}", "comment": "clone the input vector so that this vector has the same values .", "label": "why"}
{"id": "8388", "raw_code": "public static ObjectOutputStream newObjectOutputStream(Path self) throws IOException {\n  return new ObjectOutputStream(Files.newOutputStream(self));\n}", "comment": "create an object output stream for this path .", "label": "why"}
{"id": "63080", "raw_code": "@Override public Set<K> keySet(){\n  HashSet<K> set=new HashSet<K>();\n  for (  Segment<K,V> s : segments) {\n    set.addAll(s.keySet());\n  }\n  return set;\n}", "comment": "get the set of keys for resident entries .", "label": "why"}
{"id": "34204", "raw_code": "public void add(final CertificateValidity certificateValidity){\n  certificateValidityList.add(certificateValidity);\n}", "comment": "this method allows to add a candidate for the signing certificate .", "label": "why"}
{"id": "14694", "raw_code": "public void addPolicyListener(PolicyListener policyListener){\n  policyCache.addPolicyListener(policyListener);\n}", "comment": "adds a policy listener that would be notified whenever a policy is added , removed or changed", "label": "why"}
{"id": "73937", "raw_code": "public static synchronized void addPropertyChangeListener(PropertyChangeListener l){\n  if (!listeners.contains(l)) {\n    listeners.add(l);\n  }\n}", "comment": "register for notification on changes to specific types", "label": "why"}
{"id": "37984", "raw_code": "protected double computeStdDev(Instance inst,Matrix k) throws Exception {\n  double kappa=m_kernel.eval(-1,-1,inst) + m_deltaSquared;\n  double s=0;\n  int n=m_L.length;\n  for (int i=0; i < n; i++) {\n    double t=0;\n    for (int j=0; j < n; j++) {\n      t-=k.get(j,0) * (i > j ? m_L[i][j] : m_L[j][i]);\n    }\n    s+=t * k.get(i,0);\n  }\n  double sigma=m_delta;\n  if (kappa > s) {\n    sigma=Math.sqrt(kappa - s);\n  }\n  return sigma;\n}", "comment": "computes standard deviation for given instance , without transforming target back into original space .", "label": "why"}
{"id": "80951", "raw_code": "public boolean matchesRawNamePattern(Object item){\n  String prefix=patternMatcher.getPattern();\n  String text=getElementName(item);\n  if (text == null)   return false;\n  int textLength=text.length();\n  int prefixLength=prefix.length();\n  if (textLength < prefixLength) {\n    return false;\n  }\n  for (int i=prefixLength - 1; i >= 0; i--) {\n    if (Character.toLowerCase(prefix.charAt(i)) != Character.toLowerCase(text.charAt(i)))     return false;\n  }\n  return true;\n}", "comment": "general method for matching raw name pattern .", "label": "why"}
{"id": "78101", "raw_code": "private void parseMenu(XmlPullParser parser,AttributeSet attrs,SublimeMenu menu) throws XmlPullParserException, IOException {\n  MenuState menuState=new MenuState(menu);\n  int eventType=parser.getEventType();\n  String tagName;\n  boolean lookingForEndOfUnknownTag=false;\n  String unknownTagName=null;\n  do {\n    if (eventType == XmlPullParser.START_TAG) {\n      tagName=parser.getName();\n      if (tagName.equals(XML_MENU)) {\n        eventType=parser.next();\n        break;\n      }\n      throw new RuntimeException(\"Expecting menu, got \" + tagName);\n    }\n    eventType=parser.next();\n  }\n while (eventType != XmlPullParser.END_DOCUMENT);\n  boolean reachedEndOfMenu=false;\n  while (!reachedEndOfMenu) {\nswitch (eventType) {\ncase XmlPullParser.START_TAG:\n      if (lookingForEndOfUnknownTag) {\n        break;\n      }\n    tagName=parser.getName();\n  if (tagName.equals(XML_GROUP)) {\n    if (menuState.groupId != MenuState.defaultGroupId) {\n      throw new RuntimeException(\"A 'Group' item cannot have \" + \"other 'Group' items as children.\");\n    }\n    menuState.readGroup(attrs);\n    menuState.addGroup();\n  }\n else   if (tagName.equals(XML_TEXT) || tagName.equals(XML_TEXT_WITH_BADGE) || tagName.equals(XML_CHECKBOX)|| tagName.equals(XML_SWITCH)) {\n    menuState.readMenuItem(attrs,tagName);\n  }\n else   if (tagName.equals(XML_SEPARATOR)) {\n    menuState.readMenuItem(attrs,tagName);\n  }\n else   if (tagName.equals(XML_GROUP_HEADER)) {\n    if (menuState.groupId == MenuState.defaultGroupId) {\n      throw new RuntimeException(\"'GroupHeader' item should \" + \"be placed inside a Group element.\");\n    }\n    menuState.readMenuItem(attrs,tagName);\n  }\n else   if (tagName.equals(XML_MENU)) {\n    throw new RuntimeException(\"Sub-menus are not supported. \" + \"Similar functionality can be afforded \" + \"using the 'group' tag.\");\n  }\n else {\n    lookingForEndOfUnknownTag=true;\n    unknownTagName=tagName;\n  }\nbreak;\ncase XmlPullParser.END_TAG:\ntagName=parser.getName();\nif (lookingForEndOfUnknownTag && tagName.equals(unknownTagName)) {\nlookingForEndOfUnknownTag=false;\nunknownTagName=null;\n}\n else if (tagName.equals(XML_GROUP)) {\nif (menuState.isGroupCollapsible() && menuState.groupHeadersAdded != 1) {\nif (menuState.groupHeadersAdded < 1) {\n  throw new RuntimeException(\"A 'GroupHeader' is required \" + \"to create a 'collapsible' Group.\");\n}\n else {\n  throw new RuntimeException(\"A 'collapsible' Group can only \" + \"have ONE 'GroupHeader'. You have provided: \" + menuState.groupHeadersAdded + \".\");\n}\n}\nmenuState.resetGroup();\n}\n else if (tagName.equals(XML_TEXT) || tagName.equals(XML_TEXT_WITH_BADGE) || tagName.equals(XML_CHECKBOX)|| tagName.equals(XML_SWITCH)|| tagName.equals(XML_GROUP_HEADER)|| tagName.equals(XML_SEPARATOR)) {\nif (!menuState.hasAddedItem()) {\nmenuState.addItem();\n}\n}\n else if (tagName.equals(XML_MENU)) {\nreachedEndOfMenu=true;\n}\nbreak;\ncase XmlPullParser.END_DOCUMENT:\nthrow new RuntimeException(\"Unexpected end of document\");\n}\neventType=parser.next();\n}\n}", "comment": "called internally to fill the given menu .", "label": "why"}
{"id": "77948", "raw_code": "@Override public void requestResources(SamzaResourceRequest resourceRequest){\n  final int DEFAULT_PRIORITY=0;\n  log.info(\"Requesting resources on  \" + resourceRequest.getPreferredHost() + \" for container \"+ resourceRequest.getContainerID());\n  int memoryMb=resourceRequest.getMemoryMB();\n  int cpuCores=resourceRequest.getNumCores();\n  String containerLabel=yarnConfig.getContainerLabel();\n  String preferredHost=resourceRequest.getPreferredHost();\n  Resource capability=Resource.newInstance(memoryMb,cpuCores);\n  Priority priority=Priority.newInstance(DEFAULT_PRIORITY);\n  AMRMClient.ContainerRequest issuedRequest;\n  if (preferredHost.equals(\"ANY_HOST\")) {\n    log.info(\"Making a request for ANY_HOST \" + preferredHost);\n    issuedRequest=new AMRMClient.ContainerRequest(capability,null,null,priority,true,containerLabel);\n  }\n else {\n    log.info(\"Making a preferred host request on \" + preferredHost);\n    issuedRequest=new AMRMClient.ContainerRequest(capability,new String[]{preferredHost},null,priority,true,containerLabel);\n  }\nsynchronized (lock) {\n    requestsMap.put(resourceRequest,issuedRequest);\n    amClient.addContainerRequest(issuedRequest);\n  }\n}", "comment": "request resources for running container processes .", "label": "why"}
{"id": "74866", "raw_code": "private String printDFormat(String sx){\n  int nLeadingZeros=0;\n  int nBlanks=0, n=0;\n  int i=0;\n  final int jFirst;\n  final boolean neg=sx.charAt(0) == '-';\n  if (sx.equals(\"0\") && precisionSet && precision == 0) {\n    sx=\"\";\n  }\n  if (!neg) {\n    if (precisionSet && sx.length() < precision) {\n      nLeadingZeros=precision - sx.length();\n    }\n  }\n else {\n    if (precisionSet && (sx.length() - 1) < precision) {\n      nLeadingZeros=precision - sx.length() + 1;\n    }\n  }\n  if (nLeadingZeros < 0) {\n    nLeadingZeros=0;\n  }\n  if (fieldWidthSet) {\n    nBlanks=fieldWidth - nLeadingZeros - sx.length();\n    if (!neg && (leadingSign || leadingSpace)) {\n      nBlanks--;\n    }\n  }\n  if (nBlanks < 0) {\n    nBlanks=0;\n  }\n  if (leadingSign) {\n    n++;\n  }\n else   if (leadingSpace) {\n    n++;\n  }\n  n+=nBlanks;\n  n+=nLeadingZeros;\n  n+=sx.length();\n  final char[] ca=new char[n];\n  if (leftJustify) {\n    if (neg) {\n      ca[i++]='-';\n    }\n else     if (leadingSign) {\n      ca[i++]='+';\n    }\n else     if (leadingSpace) {\n      ca[i++]=' ';\n    }\n    final char[] csx=sx.toCharArray();\n    jFirst=neg ? 1 : 0;\n    for (int j=0; j < nLeadingZeros; i++, j++) {\n      ca[i]='0';\n    }\n    for (int j=jFirst; j < csx.length; j++, i++) {\n      ca[i]=csx[j];\n    }\n    for (int j=0; j < nBlanks; i++, j++) {\n      ca[i]=' ';\n    }\n  }\n else {\n    if (!leadingZeros) {\n      for (i=0; i < nBlanks; i++) {\n        ca[i]=' ';\n      }\n      if (neg) {\n        ca[i++]='-';\n      }\n else       if (leadingSign) {\n        ca[i++]='+';\n      }\n else       if (leadingSpace) {\n        ca[i++]=' ';\n      }\n    }\n else {\n      if (neg) {\n        ca[i++]='-';\n      }\n else       if (leadingSign) {\n        ca[i++]='+';\n      }\n else       if (leadingSpace) {\n        ca[i++]=' ';\n      }\n      for (int j=0; j < nBlanks; j++, i++) {\n        ca[i]='0';\n      }\n    }\n    for (int j=0; j < nLeadingZeros; j++, i++) {\n      ca[i]='0';\n    }\n    final char[] csx=sx.toCharArray();\n    jFirst=neg ? 1 : 0;\n    for (int j=jFirst; j < csx.length; j++, i++) {\n      ca[i]=csx[j];\n    }\n  }\n  return new String(ca);\n}", "comment": "utility method for formatting using the d conversion character .", "label": "why"}
{"id": "8984", "raw_code": "public List<FileStatus> browse(String filePath) throws Exception {\n  LOG.info(\"HDFS File Path   :  \" + filePath + \"   and EndPoint  : \"+ hdfsEndPoint);\n  FileSystem hdfsFileSystem=null;\n  FileStatus[] listStatus;\n  try {\n    Configuration config=createConfig();\n    hdfsFileSystem=getFileSystem(config);\n    Path path=new Path(filePath);\n    listStatus=hdfsFileSystem.listStatus(path);\n  }\n catch (  Exception ex) {\n    LOG.error(\" Exception when browsing files for the path \" + filePath,ex.getMessage());\n    throw new Exception(\" Exception When browsing Files in HDFS .. Message :  \" + ex.getMessage());\n  }\n finally {\n    if (hdfsFileSystem != null)     hdfsFileSystem.close();\n  }\n  return Arrays.asList(listStatus);\n}", "comment": "brows the files for the specific path", "label": "why"}
{"id": "56073", "raw_code": "private void cleanupMinidumpFile(){\n  if (!CrashFileManager.tryMarkAsUploaded(mFileToUpload)) {\n    Log.w(TAG,\"Unable to mark \" + mFileToUpload + \" as uploaded.\");\n    if (!mFileToUpload.delete()) {\n      Log.w(TAG,\"Cannot delete \" + mFileToUpload);\n    }\n  }\n}", "comment": "mark file we just uploaded for cleanup later .", "label": "why"}
{"id": "67627", "raw_code": "protected static boolean eq(Object o1,Object o2){\n  return o1 == null ? o2 == null : o1.equals(o2);\n}", "comment": "helper method to check for equality between two object , including null checks .", "label": "why"}
{"id": "12610", "raw_code": "public ViterbiPoint(Item item){\n  this.item=item;\n}", "comment": "creates a viterbipoint for the given item .", "label": "why"}
{"id": "33344", "raw_code": "private void emitListAdd(Method method,String fieldName,StringBuilder builder){\n  builder.append(\"    public void \");\n  builder.append(getListAdderName(fieldName));\n  builder.append(\"(\");\n  builder.append(getTypeArgumentImplName((ParameterizedType)method.getGenericReturnType(),0));\n  builder.append(\" v) {\\n      \");\n  builder.append(getEnsureName(fieldName));\n  builder.append(\"();\\n      \");\n  builder.append(fieldName);\n  builder.append(\".add(v);\\n\");\n  builder.append(\"    }\\n\\n\");\n}", "comment": "emits an add method to add to a list .", "label": "why"}
{"id": "75500", "raw_code": "private void updateBaseMatrix(Drawable d){\n  ImageView imageView=getImageView();\n  if (null == imageView || null == d) {\n    return;\n  }\n  final float viewWidth=getImageViewWidth(imageView);\n  final float viewHeight=getImageViewHeight(imageView);\n  final int drawableWidth=d.getIntrinsicWidth();\n  final int drawableHeight=d.getIntrinsicHeight();\n  mBaseMatrix.reset();\n  final float widthScale=viewWidth / drawableWidth;\n  final float heightScale=viewHeight / drawableHeight;\n  if (mScaleType == ScaleType.CENTER) {\n    mBaseMatrix.postTranslate((viewWidth - drawableWidth) / 2F,(viewHeight - drawableHeight) / 2F);\n  }\n else   if (mScaleType == ScaleType.CENTER_CROP) {\n    float scale=Math.max(widthScale,heightScale);\n    mBaseMatrix.postScale(scale,scale);\n    mBaseMatrix.postTranslate((viewWidth - drawableWidth * scale) / 2F,(viewHeight - drawableHeight * scale) / 2F);\n  }\n else   if (mScaleType == ScaleType.CENTER_INSIDE) {\n    float scale=Math.min(1.0f,Math.min(widthScale,heightScale));\n    mBaseMatrix.postScale(scale,scale);\n    mBaseMatrix.postTranslate((viewWidth - drawableWidth * scale) / 2F,(viewHeight - drawableHeight * scale) / 2F);\n  }\n else {\n    RectF mTempSrc=new RectF(0,0,drawableWidth,drawableHeight);\n    RectF mTempDst=new RectF(0,0,viewWidth,viewHeight);\n    if ((int)mBaseRotation % 180 != 0) {\n      mTempSrc=new RectF(0,0,drawableHeight,drawableWidth);\n    }\nswitch (mScaleType) {\ncase FIT_CENTER:\n      mBaseMatrix.setRectToRect(mTempSrc,mTempDst,ScaleToFit.CENTER);\n    break;\ncase FIT_START:\n  mBaseMatrix.setRectToRect(mTempSrc,mTempDst,ScaleToFit.START);\nbreak;\ncase FIT_END:\nmBaseMatrix.setRectToRect(mTempSrc,mTempDst,ScaleToFit.END);\nbreak;\ncase FIT_XY:\nmBaseMatrix.setRectToRect(mTempSrc,mTempDst,ScaleToFit.FILL);\nbreak;\ndefault :\nbreak;\n}\n}\nresetMatrix();\n}", "comment": "calculate matrix for fit _ center", "label": "why"}
{"id": "44030", "raw_code": "private void startAnimation(){\n  ValueAnimator animator=ValueAnimator.ofFloat(1.0f);\n  ArrayList<NameValuesHolder> nameValueList=(ArrayList<NameValuesHolder>)mPendingAnimations.clone();\n  mPendingAnimations.clear();\n  int propertyMask=0;\n  int propertyCount=nameValueList.size();\n  for (int i=0; i < propertyCount; ++i) {\n    NameValuesHolder nameValuesHolder=nameValueList.get(i);\n    propertyMask|=nameValuesHolder.mNameConstant;\n  }\n  mAnimatorMap.put(animator,new PropertyBundle(propertyMask,nameValueList));\n  animator.addUpdateListener(mAnimatorEventListener);\n  animator.addListener(mAnimatorEventListener);\n  if (mStartDelaySet) {\n    animator.setStartDelay(mStartDelay);\n  }\n  if (mDurationSet) {\n    animator.setDuration(mDuration);\n  }\n  if (mInterpolatorSet) {\n    animator.setInterpolator(mInterpolator);\n  }\n  animator.start();\n}", "comment": "starts the underlying animator for a set of properties .", "label": "why"}
{"id": "30495", "raw_code": "public static void registerTransportMBean(String containerName){\n  MBeanServer mBeanServer=getMBeanServer(containerName);\n  if (mBeanServer == null)   return;\n  TransportProtocolMonitorMBean transportConnectionsInfoMBean=new TransportProtocolMonitor();\n  ObjectName objName=TransportConstants.createTransportMBeanObjectName(containerName);\n  if (!mBeanServer.isRegistered(objName)) {\n    try {\n      mBeanServer.registerMBean(transportConnectionsInfoMBean,objName);\n    }\n catch (    InstanceAlreadyExistsException e) {\n      if (_logger.isLoggable(Level.CONFIG)) {\n        _logger.config(alreadyRegistredTransportMBeanMessage + containerName + \">\");\n      }\n    }\ncatch (    NotCompliantMBeanException e) {\n      if (_logger.isLoggable(Level.WARNING)) {\n        _logger.log(Level.SEVERE,failedTransportMBeanRegistrationMessagePrefix + containerName + \">\",e);\n      }\n    }\ncatch (    MBeanRegistrationException e) {\n      if (_logger.isLoggable(Level.SEVERE)) {\n        _logger.log(Level.SEVERE,failedTransportMBeanRegistrationMessagePrefix + containerName + \">\",e);\n      }\n    }\n    if (_logger.isLoggable(Level.CONFIG)) {\n      _logger.config(successfulTransportMBeanRegistrationMessage + containerName + \">\");\n    }\n  }\n else {\n    if (_logger.isLoggable(Level.CONFIG)) {\n      _logger.config(alreadyRegistredTransportMBeanMessage);\n    }\n  }\n}", "comment": "create management bean for jspace container .", "label": "why"}
{"id": "71862", "raw_code": "public void removeListener(final TimeoutEventListener listener){\n  listeners.remove(listener);\n}", "comment": "deregisters a timeout event listener for timeout notification .", "label": "why"}
{"id": "79076", "raw_code": "private synchronized void addTableLockObject(AbsoluteTableIdentifier absoluteTableIdentifier){\n  if (null == tableLockMap.get(absoluteTableIdentifier)) {\n    tableLockMap.put(absoluteTableIdentifier,new Object());\n  }\n}", "comment": "method to add table level lock if lock is not present for the table", "label": "why"}
{"id": "83117", "raw_code": "private void printBootstrapMap(){\n  LOG.info(\"Bootstrap map:\");\n  for (  Integer i : chainMap.keySet()) {\n    LOG.info(String.format(\"  %6d: %d\",i,chainMap.get(i)));\n  }\n}", "comment": "just a small method to show how many times each activity chain index was sampled .", "label": "why"}
{"id": "75892", "raw_code": "private static int loadBuildNumber(Context context,PackageManager packageManager){\n  try {\n    ApplicationInfo appInfo=packageManager.getApplicationInfo(context.getPackageName(),PackageManager.GET_META_DATA);\n    Bundle metaData=appInfo.metaData;\n    if (metaData != null) {\n      return metaData.getInt(BUNDLE_BUILD_NUMBER,0);\n    }\n  }\n catch (  PackageManager.NameNotFoundException e) {\n    L.e(\"Exception thrown when accessing the application info:\");\n    e.printStackTrace();\n  }\n  return 0;\n}", "comment": "helper method to load the build number from the androidmanifest .", "label": "why"}
{"id": "39622", "raw_code": "@Override public boolean start() throws IOException {\n  LOG.info(\"Starting reader using {}\",initialCheckpointGenerator);\n  try {\n    KinesisReaderCheckpoint initialCheckpoint=initialCheckpointGenerator.generate(kinesis);\n    List<ShardRecordsIterator> iterators=newArrayList();\n    for (    ShardCheckpoint checkpoint : initialCheckpoint) {\n      iterators.add(checkpoint.getShardRecordsIterator(kinesis));\n    }\n    shardIterators=new RoundRobin<>(iterators);\n  }\n catch (  TransientKinesisException e) {\n    throw new IOException(e);\n  }\n  return advance();\n}", "comment": "generates initial checkpoint and instantiates iterators for shards .", "label": "why"}
{"id": "71804", "raw_code": "public void addFakeView(View childView){\n  childView.layout(0,0,getWidth(),childView.getMeasuredHeight());\n  views.add(childView);\n}", "comment": "add a view for the dummyview to draw .", "label": "why"}
{"id": "55680", "raw_code": "public ScannerException(File file,ErrorMessages message){\n  this(file,ErrorMessages.get(message),message,-1,-1);\n}", "comment": "creates a new scannerexception for a file with a message only .", "label": "why"}
{"id": "63968", "raw_code": "@CallSuper protected void onPageScrolled(int position,float offset,int offsetPixels){\n  if (mDecorChildCount > 0) {\n    final int scrollX=getScrollX();\n    int paddingLeft=getPaddingLeft();\n    int paddingRight=getPaddingRight();\n    final int width=getWidth();\n    final int childCount=getChildCount();\n    for (int i=0; i < childCount; i++) {\n      final View child=getChildAt(i);\n      final LayoutParams lp=(LayoutParams)child.getLayoutParams();\n      if (!lp.isDecor)       continue;\n      final int hgrav=lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;\n      int childLeft=0;\nswitch (hgrav) {\ndefault :\n        childLeft=paddingLeft;\n      break;\ncase Gravity.LEFT:\n    childLeft=paddingLeft;\n  paddingLeft+=child.getWidth();\nbreak;\ncase Gravity.CENTER_HORIZONTAL:\nchildLeft=Math.max((width - child.getMeasuredWidth()) / 2,paddingLeft);\nbreak;\ncase Gravity.RIGHT:\nchildLeft=width - paddingRight - child.getMeasuredWidth();\npaddingRight+=child.getMeasuredWidth();\nbreak;\n}\nchildLeft+=scrollX;\nfinal int childOffset=childLeft - child.getLeft();\nif (childOffset != 0) {\nchild.offsetLeftAndRight(childOffset);\n}\n}\n}\ndispatchOnPageScrolled(position,offset,offsetPixels);\nif (mPageTransformer != null) {\nfinal int scrollX=getScrollX();\nfinal int childCount=getChildCount();\nfor (int i=0; i < childCount; i++) {\nfinal View child=getChildAt(i);\nfinal LayoutParams lp=(LayoutParams)child.getLayoutParams();\nif (lp.isDecor) continue;\nfinal float transformPos=(float)(child.getLeft() - scrollX) / getClientWidth();\nmPageTransformer.transformPage(child,transformPos);\n}\n}\nmCalledSuper=true;\n}", "comment": "this method will be invoked when the current page is scrolled , either as part of a programmatically initiated smooth scroll or a user initiated touch scroll .", "label": "usage"}
{"id": "13290", "raw_code": "protected void resetCommon() throws XNIException {\n  int count=fCommonComponents.size();\n  for (int i=0; i < count; i++) {\n    XMLComponent c=(XMLComponent)fCommonComponents.get(i);\n    c.reset(this);\n  }\n}", "comment": "reset all common components before parsing", "label": "usage"}
{"id": "68937", "raw_code": "public void onAccuracyChanged(Sensor sensor,int accuracy){\n  if (sensor.getType() != Sensor.TYPE_ACCELEROMETER) {\n    return;\n  }\n  if (this.status == AccelListener.STOPPED) {\n    return;\n  }\n  this.accuracy=accuracy;\n}", "comment": "called when the accuracy of the sensor has changed .", "label": "usage"}
{"id": "23838", "raw_code": "protected void closeCallbacksExceptListener(){\n  closeCacheCallback(getCacheLoader());\n  closeCacheCallback(getCacheWriter());\n  closeCacheCallback(getEvictionController());\n}", "comment": "the listener is not closed until after the afterregiondestroy event", "label": "usage"}
{"id": "65838", "raw_code": "public void mouseClicked(MouseEvent e){\n  if (e.getClickCount() > 1) {\n    System.gc();\n  }\n}", "comment": "invoked when the mouse has been clicked on a component .", "label": "usage"}
{"id": "39988", "raw_code": "protected void onPageScrolled(int position,float offset,int offsetPixels){\n  if (mDecorChildCount > 0) {\n    final int scrollX=getScrollX();\n    int paddingLeft=getPaddingLeft();\n    int paddingRight=getPaddingRight();\n    final int width=getWidth();\n    final int childCount=getChildCount();\n    for (int i=0; i < childCount; i++) {\n      final View child=getChildAt(i);\n      final LayoutParams lp=(LayoutParams)child.getLayoutParams();\n      if (!lp.isDecor)       continue;\n      final int hgrav=lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;\n      int childLeft=0;\nswitch (hgrav) {\ndefault :\n        childLeft=paddingLeft;\n      break;\ncase Gravity.LEFT:\n    childLeft=paddingLeft;\n  paddingLeft+=child.getWidth();\nbreak;\ncase Gravity.CENTER_HORIZONTAL:\nchildLeft=Math.max((width - child.getMeasuredWidth()) / 2,paddingLeft);\nbreak;\ncase Gravity.RIGHT:\nchildLeft=width - paddingRight - child.getMeasuredWidth();\npaddingRight+=child.getMeasuredWidth();\nbreak;\n}\nchildLeft+=scrollX;\nfinal int childOffset=childLeft - child.getLeft();\nif (childOffset != 0) {\nchild.offsetLeftAndRight(childOffset);\n}\n}\n}\nif (mOnPageChangeListener != null) {\nmOnPageChangeListener.onPageScrolled(position,offset,offsetPixels);\n}\nif (mInternalPageChangeListener != null) {\nmInternalPageChangeListener.onPageScrolled(position,offset,offsetPixels);\n}\nif (mPageTransformer != null) {\nfinal int scrollX=getScrollX();\nfinal int childCount=getChildCount();\nfor (int i=0; i < childCount; i++) {\nfinal View child=getChildAt(i);\nfinal LayoutParams lp=(LayoutParams)child.getLayoutParams();\nif (lp.isDecor) continue;\nfinal float transformPos=(float)(child.getLeft() - scrollX) / getClientWidth();\nmPageTransformer.transformPage(child,transformPos);\n}\n}\nmCalledSuper=true;\n}", "comment": "this method will be invoked when the current page is scrolled , either as part of a programmatically initiated smooth scroll or a user initiated touch scroll .", "label": "usage"}
{"id": "39498", "raw_code": "protected boolean isCorrectMethod(Method method,Object[] args){\n  return (proxySignature.equals(method.getName()) && args.length == 1);\n}", "comment": "compare the method that was called to the intended method when the osxadapter instance was created ( e . g . handleabout , handlequit , handleopenfile , etc . ) .", "label": "usage"}
{"id": "10928", "raw_code": "protected void configureFromProperties(InputStream is,String rootDirectory) throws IOException {\n  Properties props=new Properties();\n  props.load(is);\n  props.put(ROOT_DIR_PATH_PROPERTY,rootDirectory);\n  String oldPrefix=getPropertyPrefix();\n  setProperties(null,props);\n  setPropertyPrefix(oldPrefix);\n}", "comment": "called with an input stream for a properties file , used for reading tiles . omp files .", "label": "usage"}
{"id": "75368", "raw_code": "@Override public void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  mHandler=new Handler();\n  setContentView(R.layout.voice_recognition);\n  Button speakButton=(Button)findViewById(R.id.btn_speak);\n  mList=(ListView)findViewById(R.id.list);\n  mSupportedLanguageView=(Spinner)findViewById(R.id.supported_languages);\n  PackageManager pm=getPackageManager();\n  List<ResolveInfo> activities=pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH),0);\n  if (activities.size() != 0) {\n    speakButton.setOnClickListener(this);\n  }\n else {\n    speakButton.setEnabled(false);\n    speakButton.setText(\"Recognizer not present\");\n  }\n  refreshVoiceSettings();\n}", "comment": "called with the activity is first created .", "label": "usage"}
{"id": "11663", "raw_code": "public boolean mouseDragged(MouseEvent e){\n  if (grabbed_plot_graphics_) {\n    int x=e.getX();\n    int y=e.getY();\n    int dx=x - prevX;\n    int dy=y - prevY;\n    plotX+=dx;\n    plotY+=dy;\n    prevX=x;\n    prevY=y;\n    graph.resize(plotX,plotY,plotWidth,plotHeight);\n    OMGraphicList plotGraphics=graph.getPlotGraphics();\n    plotGraphics.generate(getProjection(),true);\n    repaint();\n  }\n  return false;\n}", "comment": "called whenever the mouse is dragged on this layer and one of the requested mouse modes is active .", "label": "usage"}
{"id": "76676", "raw_code": "protected void processChildren(QueryNode queryTree) throws QueryNodeException {\n  List<QueryNode> children=queryTree.getChildren();\n  ChildrenList newChildren;\n  if (children != null && children.size() > 0) {\n    newChildren=allocateChildrenList();\n    try {\n      for (      QueryNode child : children) {\n        child=processIteration(child);\n        if (child == null) {\n          throw new NullPointerException();\n        }\n        newChildren.add(child);\n      }\n      List<QueryNode> orderedChildrenList=setChildrenOrder(newChildren);\n      queryTree.set(orderedChildrenList);\n    }\n  finally {\n      newChildren.beingUsed=false;\n    }\n  }\n}", "comment": "this method is called every time a child is processed .", "label": "usage"}
{"id": "68444", "raw_code": "public void actionPerformed(ActionEvent e){\n  navigateToPriorDemo();\n}", "comment": "invoked when an action occurs .", "label": "usage"}
{"id": "49211", "raw_code": "void doHandleJavaMouseEvent(MouseEvent mouseEvent){\n  if (!XToolkit.isLeftMouseButton(mouseEvent) && !XToolkit.isRightMouseButton(mouseEvent)) {\n    return;\n  }\n  XBaseWindow grabWindow=XAwtState.getGrabWindow();\n  Point ptGlobal=mouseEvent.getLocationOnScreen();\n  if (!hasPointerMoved) {\n    if (grabInputPoint == null || (Math.abs(ptGlobal.x - grabInputPoint.x) > getMouseMovementSmudge()) || (Math.abs(ptGlobal.y - grabInputPoint.y) > getMouseMovementSmudge())) {\n      hasPointerMoved=true;\n    }\n  }\n  XBaseMenuWindow wnd=getMenuWindowFromPoint(ptGlobal);\n  XMenuItemPeer item=(wnd != null) ? wnd.getItemFromPoint(wnd.toLocal(ptGlobal)) : null;\n  XBaseMenuWindow cwnd=getShowingLeaf();\nswitch (mouseEvent.getID()) {\ncase MouseEvent.MOUSE_PRESSED:\n    showingMousePressedSubmenu=null;\n  if ((grabWindow == this) && (wnd == null)) {\n    ungrabInput();\n  }\n else {\n    grabInput();\n    if (item != null && !item.isSeparator() && item.isTargetItemEnabled()) {\n      if (wnd.getShowingSubmenu() == item) {\n        showingMousePressedSubmenu=(XMenuPeer)item;\n      }\n      wnd.selectItem(item,true);\n    }\n else {\n      if (wnd != null) {\n        wnd.selectItem(null,false);\n      }\n    }\n  }\nbreak;\ncase MouseEvent.MOUSE_RELEASED:\nif (item != null && !item.isSeparator() && item.isTargetItemEnabled()) {\nif (item instanceof XMenuPeer) {\n  if (showingMousePressedSubmenu == item) {\n    if (wnd instanceof XMenuBarPeer) {\n      ungrabInput();\n    }\n else {\n      wnd.selectItem(item,false);\n    }\n  }\n}\n else {\n  item.action(mouseEvent.getWhen());\n  ungrabInput();\n}\n}\n else {\nif (hasPointerMoved || (wnd instanceof XMenuBarPeer)) {\n  ungrabInput();\n}\n}\nshowingMousePressedSubmenu=null;\nbreak;\ncase MouseEvent.MOUSE_DRAGGED:\nif (wnd != null) {\nif (item != null && !item.isSeparator() && item.isTargetItemEnabled()) {\nif (grabWindow == this) {\nwnd.selectItem(item,true);\n}\n}\n else {\nwnd.selectItem(null,false);\n}\n}\n else {\nif (cwnd != null) {\ncwnd.selectItem(null,false);\n}\n}\nbreak;\n}\n}", "comment": "performs handling of java mouse event note that this function should be invoked only from root of menu window ' s hierarchy that grabs input focus", "label": "usage"}
{"id": "25509", "raw_code": "private boolean loadUnpackedUMD(String filename) throws IOException, GeneralJpcspException {\n  if (doUmdBuffering) {\n    return false;\n  }\n  File file=new File(filename);\n  if (file.exists()) {\n    RandomAccessFile raf=new RandomAccessFile(file,\"r\");\n    FileChannel roChannel=raf.getChannel();\n    ByteBuffer readbuffer=roChannel.map(FileChannel.MapMode.READ_ONLY,0,(int)roChannel.size());\n    emulator.load(\"disc0:/PSP_GAME/SYSDIR/EBOOT.BIN\",readbuffer);\n    raf.close();\n    log.info(\"Using unpacked UMD EBOOT.BIN image\");\n    return true;\n  }\n  return false;\n}", "comment": "don ' t call this directly , see loadumd ( file file )", "label": "usage"}
{"id": "17178", "raw_code": "public void addTranslator(ClassPool cp,Translator t) throws NotFoundException, CannotCompileException {\n  source=cp;\n  translator=t;\n  t.start(cp);\n}", "comment": "adds a translator , which is called whenever a class is loaded .", "label": "usage"}
{"id": "63507", "raw_code": "public static ResultSet pointTable(double x,double y){\n  GeometryFactory factory=new GeometryFactory();\n  SimpleResultSet rs=new SimpleResultSet();\n  rs.addColumn(\"THE_GEOM\",Types.JAVA_OBJECT,\"GEOMETRY\",0,0);\n  rs.addRow(factory.createPoint(new Coordinate(x,y)));\n  return rs;\n}", "comment": "this method is called via reflection from the database .", "label": "usage"}
{"id": "80148", "raw_code": "private void onHPChange(final int amount){\n  if (User.squaredDistanceTo(x,y) < HEARING_DISTANCE_SQ) {\n    if (amount > 0) {\n      addTextIndicator(\"+\" + amount,NotificationType.POSITIVE);\n    }\n else {\n      addTextIndicator(String.valueOf(amount),NotificationType.NEGATIVE);\n    }\n  }\n}", "comment": "called when entity adjusts hp .", "label": "usage"}
{"id": "83818", "raw_code": "public boolean computeAngleOffset(){\n  if (mFinished) {\n    return false;\n  }\n  long systemClock=AnimationUtils.currentAnimationTimeMillis();\n  long timePassed=systemClock - mStartTime;\n  if (timePassed < mDuration) {\nswitch (mMode) {\ncase SCROLL_MODE:\n      float sc=(float)timePassed / mDuration;\n    mCurrAngle=mStartAngle + Math.round(mDeltaAngle * sc);\n  break;\ncase FLING_MODE:\nfloat timePassedSeconds=timePassed / 1000.0f;\nfloat distance;\nif (mVelocity < 0) {\ndistance=mCoeffVelocity * mVelocity * timePassedSeconds - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);\n}\n else {\ndistance=-mCoeffVelocity * mVelocity * timePassedSeconds - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);\n}\nmCurrAngle=mStartAngle - Math.signum(mVelocity) * Math.round(distance);\nbreak;\n}\nreturn true;\n}\n else {\nmFinished=true;\nreturn false;\n}\n}", "comment": "call this when you want to know the new location .", "label": "usage"}
{"id": "36604", "raw_code": "@Override public void valueChanged(TreeSelectionEvent e){\n  if (preventEvent) {\n    return;\n  }\n  if (mainFrame != null) {\n    List<Operator> selectedOperators=getSelectedOperators();\n    if (selectedOperators != null && !selectedOperators.isEmpty()) {\n      mainFrame.selectOperators(selectedOperators);\n    }\n  }\n}", "comment": "this method will be invoked after a user selection of an operator in the tree .", "label": "usage"}
{"id": "13792", "raw_code": "public void schemaChanged(String serviceName,String version){\nsynchronized (mapRealmToFormat) {\n    mapRealmToFormat.remove(ROOT);\n  }\n}", "comment": "this method will be invoked when a service ' s schema has been changed .", "label": "usage"}
{"id": "25881", "raw_code": "@Override public AbstractScannedResult scanBlocklet(BlocksChunkHolder blocksChunkHolder) throws QueryExecutionException {\n  try {\n    fillScannedResult(blocksChunkHolder);\n  }\n catch (  FilterUnsupportedException e) {\n    throw new QueryExecutionException(e.getMessage());\n  }\n  return scannedResult;\n}", "comment": "below method will be used to process the block", "label": "usage"}
{"id": "59637", "raw_code": "public void addSwipeListener(SwipeListener listener){\n  if (mListeners == null) {\n    mListeners=new ArrayList<SwipeListener>();\n  }\n  mListeners.add(listener);\n}", "comment": "add a callback to be invoked when a swipe event is sent to this view .", "label": "usage"}
{"id": "35508", "raw_code": "@Override public void onFailure(IMqttToken asyncActionToken,Throwable exception){\n  exception.printStackTrace();\n  Log.e(\"TrafficService\",\"Error connecting: \" + exception.getMessage());\n  onDisconnect(false);\n}", "comment": "called when there was an error connecting", "label": "usage"}
{"id": "11343", "raw_code": "protected void cutSelectedBean(){\n  if (Debug.debugging(\"beanbox\"))   Debug.output(\"Enter> cutSelectedBean\");\n  if (selectedBean == null || selectedBeanLocation == null) {\n    if (Debug.debugging(\"beanbox\"))     Debug.output(\"selectedBean=\" + selectedBean);\n    if (Debug.debugging(\"beanbox\"))     Debug.output(\"selectedBeanLocation=\" + selectedBeanLocation);\n    clearSelection();\n    return;\n  }\n  try {\n    serBean=new ByteArrayOutputStream();\n    ObjectOutputStream oos=new ObjectOutputStream(serBean);\n    oos.writeObject(selectedBean);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    clearSelection();\n    if (Debug.debugging(\"beanbox\"))     Debug.output(\"Exit> copySelectedBean\");\n    return;\n  }\n  cutBean=selectedBean;\n  selectedBeanBox.showCut(selectedBean);\n  if (Debug.debugging(\"beanbox\"))   Debug.output(\"Exit> cutSelectedBean\");\n}", "comment": "this method is called when the user chooses to cut a bean by some means such by by pressing ctrl - x .", "label": "usage"}
{"id": "11319", "raw_code": "public void actionPerformed(java.awt.event.ActionEvent e){\n  Object source=e.getSource();\n  if (!(source instanceof JMenuItem))   return;\n  JMenuItem mi=(JMenuItem)source;\n  String name=mi.getText();\n  OMGraphicHandlerLayer targetLayer=(OMGraphicHandlerLayer)layers.get(name);\n  if (targetLayer == null) {\n    Debug.message(\"defaultdndcatcher\",\"ERROR> DefaultDnDCatcher::actionPerformed: \" + \"no layer found with name \" + name);\n    return;\n  }\n  targetLayer.doAction((OMGraphic)transferData,new OMAction(OMAction.UPDATE_GRAPHIC_MASK));\n}", "comment": "invoked when an action from the popup menu occurs .", "label": "usage"}
{"id": "25502", "raw_code": "public void pushDrawList(PspGeList list){\nsynchronized (drawListQueue) {\n    drawListQueue.add(list);\n  }\n}", "comment": "called from pspge module", "label": "usage"}
{"id": "33914", "raw_code": "private void applyTo(ClassVisitor v,Field f){\n  if (Log.isLoggingOn()) {\n    Log.logLine(String.format(\"Visiting field %s\",f.toGenericString()));\n  }\n  v.visit(f);\n}", "comment": "apply a visitor to a field .", "label": "usage"}
{"id": "2536", "raw_code": "public IOUtils(){\n  super();\n}", "comment": "instances should not be constructed in standard programming .", "label": "usage"}
{"id": "84599", "raw_code": "public void makeDirty(){\n  betaChanged=true;\n  newMode=true;\n  precisionChanged=true;\n  regressionInterface.makeDirty(instance);\n}", "comment": "forces a complete recalculation of the likelihood next time getlikelihood is called", "label": "usage"}
{"id": "69714", "raw_code": "protected void drawConnectorCenters(Canvas c){\n  List<Connection> connections=mBlock.getAllConnections();\n  Paint paint=new Paint();\n  paint.setStyle(Paint.Style.FILL);\n  for (int i=0; i < connections.size(); i++) {\n    Connection conn=connections.get(i);\n    if (conn.inDragMode()) {\n      if (conn.isConnected()) {\n        paint.setColor(Color.RED);\n      }\n else {\n        paint.setColor(Color.MAGENTA);\n      }\n    }\n else {\n      if (conn.isConnected()) {\n        paint.setColor(Color.GREEN);\n      }\n else {\n        paint.setColor(Color.CYAN);\n      }\n    }\n    mTempWorkspacePoint.set(conn.getPosition().x - mBlock.getPosition().x,conn.getPosition().y - mBlock.getPosition().y);\n    mHelper.workspaceToVirtualViewDelta(mTempWorkspacePoint,mTempConnectionPosition);\n    if (mHelper.useRtl()) {\n      mTempConnectionPosition.x+=mBlockViewSize.x;\n    }\n    c.drawCircle(mTempConnectionPosition.x,mTempConnectionPosition.y,10,paint);\n  }\n}", "comment": "this is a developer testing function subclasses can call to draw dots at the model ' s location of all connections on this block .", "label": "usage"}
{"id": "64152", "raw_code": "public FileSystemUtils(){\n  super();\n}", "comment": "instances should not be constructed in standard programming .", "label": "usage"}
{"id": "31521", "raw_code": "@Override public void onDetachedFromRecyclerView(RecyclerView recyclerView){\n  super.onDetachedFromRecyclerView(recyclerView);\n  mAttachedRecyclerViewPool.remove(recyclerView);\n}", "comment": "implementation of adapter . ondetachedfromrecyclerview ( recyclerview ) called when this expandablerecycleradapter is detached from a recyclerview .", "label": "usage"}
{"id": "50178", "raw_code": "public void handleMaintenance(Operation maintOp){\n  performPendingRequestMaintenance();\n  checkAndScheduleSynchronization(this.cachedGroupState.membershipUpdateTimeMicros);\n  maintOp.complete();\n}", "comment": "invoked by parent during its maintenance interval", "label": "usage"}
{"id": "53945", "raw_code": "public void start(){\n  if (setState(EnumSet.of(TaskState.INITIAL,TaskState.QUEUED),TaskState.RUNNING)) {\n    DHT.logDebug(\"Starting Task: \" + toString());\n    startTime=System.currentTimeMillis();\n    try {\n      serializedUpdate.run();\n    }\n catch (    Exception e) {\n      DHT.log(e,LogLevel.Error);\n    }\n  }\n}", "comment": "start the task , to be used when a task is queued .", "label": "usage"}
{"id": "16920", "raw_code": "public ActionRequestHelper dependsOn(ActionRequestHelper dependency){\n  mDependencies.add(dependency);\n  return this;\n}", "comment": "this request will execute after the dependency completes .", "label": "usage"}
{"id": "25328", "raw_code": "public void onStart(){\n  if (mAudioMirrorBuffer == null) {\n    mAudioMirrorBuffer=new byte[262144];\n  }\n  if (mStreamer != null) {\n    mStreamer.start();\n  }\n  if (mInsecureStreamer != null) {\n    mInsecureStreamer.start();\n  }\n}", "comment": "called when the playback service starts", "label": "usage"}
{"id": "11246", "raw_code": "public void httpRequest(HttpRequestEvent e) throws java.io.IOException {\n  String request=e.getRequest();\n  if (Debug.debugging(\"shis\")) {\n    Debug.output(\"SHIS: Handling request - \\\"\" + request + \"\\\"\");\n  }\n  if (request.charAt(0) == '/') {\n    request=request.substring(0,request.length());\n  }\n  int index=0;\n  index=request.indexOf('?');\n  if (index != -1) {\n    request=request.substring(index + 1,request.length());\n    Debug.message(\"shis\",\"SHIS: GET Request received\");\n  }\n else {\n    Debug.message(\"shis\",\"SHIS: Probably a POST Request received\");\n  }\n  try {\n    iServer.handleRequest(request,e.getOutputStream());\n  }\n catch (  IOException ioe) {\n    Debug.error(\"SHIS: caught IOException - \\n\" + ioe.getMessage());\n  }\ncatch (  MapRequestFormatException exception) {\n    String message=\"OpenMap SimpleHttpImageServer encountered an problem with your request:\\n\\n\" + exception.getMessage() + \"\\n\\n\"+ ErrorMessage;\n    HttpConnection.writeHttpResponse(e.getOutputStream(),HttpConnection.CONTENT_PLAIN,message);\n  }\n}", "comment": "invoked when an http request is received .", "label": "usage"}
{"id": "3515", "raw_code": "public void clientDisconnect(){\n  try {\n    OutHttpApp responseStream=_responseStream;\n    if (responseStream != null) {\n      responseStream.close();\n    }\n  }\n catch (  Exception e) {\n    log.log(Level.FINER,e.toString(),e);\n  }\n  ConnectionTcp conn=connTcp();\n  if (conn != null) {\n    conn.clientDisconnect();\n  }\n  killKeepalive(\"client disconnect\");\n}", "comment": "called when the client has disconnected", "label": "usage"}
{"id": "10541", "raw_code": "private final void _writeUTF8Segments(byte[] utf8,int offset,int totalLen) throws IOException, JsonGenerationException {\n  do {\n    int len=Math.min(_outputMaxContiguous,totalLen);\n    _writeUTF8Segment(utf8,offset,len);\n    offset+=len;\n    totalLen-=len;\n  }\n while (totalLen > 0);\n}", "comment": "method called when utf - 8 encoded ( but not yet escaped ! ) content is not guaranteed to fit in the output buffer after escaping ; as such , we just need to chunk writes .", "label": "usage"}
{"id": "48785", "raw_code": "protected final void dragDropFinished(final boolean success,final int operations,final int x,final int y){\n  DragSourceEvent event=new DragSourceDropEvent(getDragSourceContext(),operations & sourceActions,success,x,y);\n  EventDispatcher dispatcher=new EventDispatcher(DISPATCH_FINISH,event);\n  SunToolkit.invokeLaterOnAppContext(SunToolkit.targetToAppContext(getComponent()),dispatcher);\n  startSecondaryEventLoop();\n  setNativeContext(0);\n  dragImage=null;\n  dragImageOffset=null;\n}", "comment": "upcall from native code via implemented class ( do )", "label": "usage"}
{"id": "63597", "raw_code": "public int onBlockExploded(){\n  return (int)(fuseTime / 2 + Math.random() * fuseTime / 4);\n}", "comment": "called when the block for of this explosive is destroy by an explosion", "label": "usage"}
{"id": "29969", "raw_code": "public void stop(){\n  setLedOn(false);\n  if (null != blinkFuture) {\n    blinkFuture.cancel(true);\n  }\n  if (null != blinkService) {\n    blinkService.shutdownNow();\n  }\n}", "comment": "calling this method will stop all threads .", "label": "usage"}
{"id": "50171", "raw_code": "private void addReplicationFactor(Operation op){\n  op.addRequestHeader(Operation.REPLICATION_QUORUM_HEADER,Operation.REPLICATION_QUORUM_HEADER_VALUE_ALL);\n}", "comment": "authorization related operations should take effect on all replicas , before they complete .", "label": "usage"}
{"id": "83647", "raw_code": "@Override public boolean onPreferenceClick(Preference preference){\n  if (preference == mPlayExample) {\n    getSampleText();\n    return true;\n  }\n  return false;\n}", "comment": "called when mplayexample is clicked", "label": "usage"}
{"id": "68091", "raw_code": "protected void onException(final WroRuntimeException e){\n  throw e;\n}", "comment": "invoked when an unexpected exception occurred during processing .", "label": "usage"}
{"id": "49295", "raw_code": "@Override @SuppressWarnings(\"unchecked\") public void completed(int bytesTransferred,boolean canInvokeDirect){\n  if (bytesTransferred == 0) {\n    bytesTransferred=-1;\n  }\n else {\n    updateBuffers(bytesTransferred);\n  }\n  releaseBuffers();\nsynchronized (result) {\n    if (result.isDone())     return;\n    enableReading();\n    if (scatteringRead) {\n      result.setResult((V)Long.valueOf(bytesTransferred));\n    }\n else {\n      result.setResult((V)Integer.valueOf(bytesTransferred));\n    }\n  }\n  if (canInvokeDirect) {\n    Invoker.invokeUnchecked(result);\n  }\n else {\n    Invoker.invoke(result);\n  }\n}", "comment": "executed when the i / o has completed", "label": "usage"}
{"id": "6348", "raw_code": "public static void printStackTrace(Throwable e){\n  try {\n    Debug.printStackTrace(e);\n  }\n catch (  Throwable f) {\n    e.printStackTrace();\n  }\n}", "comment": "used in environments where full debug may not be available", "label": "usage"}
{"id": "56112", "raw_code": "public void onSinksReceived(String sourceUrn,List<MediaSink> sinks){\n  mSinks.put(sourceUrn,sinks);\n  nativeOnSinksReceived(mNativeMediaRouterAndroid,sourceUrn,sinks.size());\n}", "comment": "called when the sinks found by the media route provider for the particular | sourceurn | have changed .", "label": "usage"}
{"id": "10150", "raw_code": "public static Long[] valuesOf(long[] array){\n  Long[] dest=new Long[array.length];\n  for (int i=0; i < array.length; i++) {\n    dest[i]=Long.valueOf(array[i]);\n  }\n  return dest;\n}", "comment": "converts to object array .", "label": "done"}
{"id": "54799", "raw_code": "public void run(){\n  while (m_keyboardStream != null) {\n    try {\n      if (m_keyboardReadRequest) {\n        String s=m_keyboardStream.readLine();\n        m_keyboardInput.add(s);\n        m_keyboardReadRequest=false;\nsynchronized (this) {\n          notifyAll();\n        }\n      }\n else       try {\n        Thread.sleep(50);\n      }\n catch (      InterruptedException ie) {\n      }\n    }\n catch (    IOException io) {\n    }\n  }\n}", "comment": "a seperate thread collects our input so that we can block in the docontinue on the main thread and then allow the user to interrupt us via keyboard input on this thread .", "label": "done"}
{"id": "37730", "raw_code": "@Override public AggregateableEvaluation aggregate(Evaluation evaluation){\n  m_Incorrect+=evaluation.incorrect();\n  m_Correct+=evaluation.correct();\n  m_Unclassified+=evaluation.unclassified();\n  m_MissingClass+=evaluation.m_MissingClass;\n  m_WithClass+=evaluation.m_WithClass;\n  if (evaluation.m_ConfusionMatrix != null) {\n    double[][] newMatrix=evaluation.confusionMatrix();\n    if (newMatrix != null) {\n      for (int i=0; i < m_ConfusionMatrix.length; i++) {\n        for (int j=0; j < m_ConfusionMatrix[i].length; j++) {\n          m_ConfusionMatrix[i][j]+=newMatrix[i][j];\n        }\n      }\n    }\n  }\n  double[] newClassPriors=evaluation.m_ClassPriors;\n  if (newClassPriors != null && m_ClassPriors != null) {\n    for (int i=0; i < this.m_ClassPriors.length; i++) {\n      m_ClassPriors[i]=newClassPriors[i];\n    }\n  }\n  m_ClassPriorsSum=evaluation.m_ClassPriorsSum;\n  m_TotalCost+=evaluation.totalCost();\n  m_SumErr+=evaluation.m_SumErr;\n  m_SumAbsErr+=evaluation.m_SumAbsErr;\n  m_SumSqrErr+=evaluation.m_SumSqrErr;\n  m_SumClass+=evaluation.m_SumClass;\n  m_SumSqrClass+=evaluation.m_SumSqrClass;\n  m_SumPredicted+=evaluation.m_SumPredicted;\n  m_SumSqrPredicted+=evaluation.m_SumSqrPredicted;\n  m_SumClassPredicted+=evaluation.m_SumClassPredicted;\n  m_SumPriorAbsErr+=evaluation.m_SumPriorAbsErr;\n  m_SumPriorSqrErr+=evaluation.m_SumPriorSqrErr;\n  m_SumKBInfo+=evaluation.m_SumKBInfo;\n  double[] newMarginCounts=evaluation.m_MarginCounts;\n  if (newMarginCounts != null) {\n    for (int i=0; i < m_MarginCounts.length; i++) {\n      m_MarginCounts[i]+=newMarginCounts[i];\n    }\n  }\n  m_ComplexityStatisticsAvailable=evaluation.m_ComplexityStatisticsAvailable;\n  m_CoverageStatisticsAvailable=evaluation.m_CoverageStatisticsAvailable;\n  m_SumPriorEntropy+=evaluation.m_SumPriorEntropy;\n  m_SumSchemeEntropy+=evaluation.m_SumSchemeEntropy;\n  m_TotalSizeOfRegions+=evaluation.m_TotalSizeOfRegions;\n  m_TotalCoverage+=evaluation.m_TotalCoverage;\n  ArrayList<Prediction> predsToAdd=evaluation.m_Predictions;\n  if (predsToAdd != null) {\n    if (m_Predictions == null) {\n      m_Predictions=new ArrayList<Prediction>();\n    }\n    for (int i=0; i < predsToAdd.size(); i++) {\n      m_Predictions.add(predsToAdd.get(i));\n    }\n  }\n  return this;\n}", "comment": "adds the statistics encapsulated in the supplied evaluation object into this one .", "label": "done"}
{"id": "50146", "raw_code": "public QuickActionView addActions(Collection<Action> actions){\n  checkShown();\n  mActions.addAll(actions);\n  return this;\n}", "comment": "adds a collection of actions to the quickactionview", "label": "done"}
{"id": "81874", "raw_code": "public void addSeriesRenderer(int index,SimpleSeriesRenderer renderer){\n  mRenderers.add(index,renderer);\n}", "comment": "adds a simple renderer to the multiple renderer .", "label": "done"}
{"id": "5867", "raw_code": "public static boolean copyStream(InputStream is,OutputStream os,CopyListener listener,int bufferSize) throws IOException {\n  int current=0;\n  int total=is.available();\n  if (total <= 0) {\n    total=DEFAULT_IMAGE_TOTAL_SIZE;\n  }\n  final byte[] bytes=new byte[bufferSize];\n  int count;\n  if (shouldStopLoading(listener,current,total))   return false;\n  while ((count=is.read(bytes,0,bufferSize)) != -1) {\n    os.write(bytes,0,count);\n    current+=count;\n    if (shouldStopLoading(listener,current,total))     return false;\n  }\n  os.flush();\n  return true;\n}", "comment": "copies stream , fires progress events by listener , can be interrupted by listener .", "label": "done"}
{"id": "49792", "raw_code": "public CharSeq concat(CharSeq another){\n  return new CharSeq(str + another.str);\n}", "comment": "append string of the given charseq to this charseq", "label": "done"}
{"id": "62807", "raw_code": "@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {\n  resp.setContentType(\"text/plain\");\n  PrintWriter sendToClient=resp.getWriter();\n  for (  Video v : this.videos) {\n    sendToClient.write(v.getName() + \" : \" + v.getUrl()+ \"\\n\");\n  }\n}", "comment": "this method processes all of the http get requests routed to the servlet by the web container .", "label": "done"}
{"id": "74058", "raw_code": "protected void notifyStateChange(int oldState,int newState){\n  mState=newState;\n  if (oldState != newState) {\n    firePropertyChange(\"KnownState\",Integer.valueOf(oldState),Integer.valueOf(newState));\n  }\n}", "comment": "change the stored state value and do notification , but don ' t change anything in the hardware", "label": "done"}
{"id": "67362", "raw_code": "public void addRestrictedDomain(String domainName){\n  if (StringUtils.isEmpty(domainName)) {\n    return;\n  }\n  if (restrictedDomains == null) {\n    restrictedDomains=new ArrayList<>();\n  }\n  restrictedDomains.add(domainName);\n}", "comment": "adds specified domain name to the list of restricted domains", "label": "done"}
{"id": "31500", "raw_code": "private static int encodeText(CharSequence msg,int startpos,int count,StringBuilder sb,int initialSubmode){\n  StringBuilder tmp=new StringBuilder(count);\n  int submode=initialSubmode;\n  int idx=0;\n  while (true) {\n    char ch=msg.charAt(startpos + idx);\nswitch (submode) {\ncase SUBMODE_ALPHA:\n      if (isAlphaUpper(ch)) {\n        if (ch == ' ') {\n          tmp.append((char)26);\n        }\n else {\n          tmp.append((char)(ch - 65));\n        }\n      }\n else {\n        if (isAlphaLower(ch)) {\n          submode=SUBMODE_LOWER;\n          tmp.append((char)27);\n          continue;\n        }\n else         if (isMixed(ch)) {\n          submode=SUBMODE_MIXED;\n          tmp.append((char)28);\n          continue;\n        }\n else {\n          tmp.append((char)29);\n          tmp.append((char)PUNCTUATION[ch]);\n          break;\n        }\n      }\n    break;\ncase SUBMODE_LOWER:\n  if (isAlphaLower(ch)) {\n    if (ch == ' ') {\n      tmp.append((char)26);\n    }\n else {\n      tmp.append((char)(ch - 97));\n    }\n  }\n else {\n    if (isAlphaUpper(ch)) {\n      tmp.append((char)27);\n      tmp.append((char)(ch - 65));\n      break;\n    }\n else     if (isMixed(ch)) {\n      submode=SUBMODE_MIXED;\n      tmp.append((char)28);\n      continue;\n    }\n else {\n      tmp.append((char)29);\n      tmp.append((char)PUNCTUATION[ch]);\n      break;\n    }\n  }\nbreak;\ncase SUBMODE_MIXED:\nif (isMixed(ch)) {\ntmp.append((char)MIXED[ch]);\n}\n else {\nif (isAlphaUpper(ch)) {\n  submode=SUBMODE_ALPHA;\n  tmp.append((char)28);\n  continue;\n}\n else if (isAlphaLower(ch)) {\n  submode=SUBMODE_LOWER;\n  tmp.append((char)27);\n  continue;\n}\n else {\n  if (startpos + idx + 1 < count) {\n    char next=msg.charAt(startpos + idx + 1);\n    if (isPunctuation(next)) {\n      submode=SUBMODE_PUNCTUATION;\n      tmp.append((char)25);\n      continue;\n    }\n  }\n  tmp.append((char)29);\n  tmp.append((char)PUNCTUATION[ch]);\n}\n}\nbreak;\ndefault :\nif (isPunctuation(ch)) {\ntmp.append((char)PUNCTUATION[ch]);\n}\n else {\nsubmode=SUBMODE_ALPHA;\ntmp.append((char)29);\ncontinue;\n}\n}\nidx++;\nif (idx >= count) {\nbreak;\n}\n}\nchar h=0;\nint len=tmp.length();\nfor (int i=0; i < len; i++) {\nboolean odd=(i % 2) != 0;\nif (odd) {\nh=(char)((h * 30) + tmp.charAt(i));\nsb.append(h);\n}\n else {\nh=tmp.charAt(i);\n}\n}\nif ((len % 2) != 0) {\nsb.append((char)((h * 30) + 29));\n}\nreturn submode;\n}", "comment": "encode parts of the message using text compaction as described in iso / iec 15438 : 2001 ( e ) , chapter 4 . 4 . 2 .", "label": "done"}
{"id": "58189", "raw_code": "public static boolean isValidNCName(String ncName){\n  if (ncName.length() == 0)   return false;\n  char ch=ncName.charAt(0);\n  if (isNCNameStart(ch) == false)   return false;\n  for (int i=1; i < ncName.length(); i++) {\n    ch=ncName.charAt(i);\n    if (isNCName(ch) == false) {\n      return false;\n    }\n  }\n  return true;\n}", "comment": "check to see if a string is a valid ncname according to [ 4 ] from the xml namespaces 1 . 0 recommendation", "label": "done"}
{"id": "23998", "raw_code": "protected void recoverPrimary(Set excludedServers){\n  if (pool.getPoolOrCacheCancelInProgress() != null) {\n    return;\n  }\n  final boolean isDebugEnabled=logger.isDebugEnabled();\n  if (queueConnections.getPrimary() != null) {\n    if (isDebugEnabled) {\n      logger.debug(\"Primary recovery not needed\");\n    }\n    return;\n  }\n  if (isDebugEnabled) {\n    logger.debug(\"SubscriptionManager redundancy satisfier - primary endpoint has been lost. Attempting to recover\");\n  }\n  if (printRecoveringPrimary) {\n    logger.info(LocalizedMessage.create(LocalizedStrings.QueueManagerImpl_SUBSCRIPTION_MANAGER_REDUNDANCY_SATISFIER_PRIMARY_ENDPOINT_HAS_BEEN_LOST_ATTEMPTIMG_TO_RECOVER));\n    printRecoveringPrimary=false;\n  }\n  QueueConnectionImpl newPrimary=null;\n  while (newPrimary == null && pool.getPoolOrCacheCancelInProgress() == null) {\n    List backups=queueConnections.getBackups();\n    newPrimary=promoteBackupToPrimary(backups);\n    if (newPrimary == null) {\n      break;\n    }\n    if (!addToConnectionList(newPrimary,true)) {\nsynchronized (lock) {\n        queueConnections=queueConnections.removeConnection(newPrimary);\n      }\n      newPrimary=null;\n    }\n  }\n  if (newPrimary != null) {\n    if (isDebugEnabled) {\n      logger.debug(\"SubscriptionManager redundancy satisfier - Switched backup server to primary: {}\",newPrimary.getEndpoint());\n    }\n    if (PoolImpl.AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG) {\n      ClientServerObserver bo=ClientServerObserverHolder.getInstance();\n      bo.afterPrimaryRecovered(newPrimary.getServer());\n    }\n    cqsConnected();\n    printPrimaryNotFoundError=true;\n    printRecoveringPrimary=true;\n    return;\n  }\n  while (newPrimary == null) {\n    newPrimary=createNewPrimary(excludedServers);\n    if (newPrimary == null) {\n      break;\n    }\n    if (!addToConnectionList(newPrimary,true)) {\n      excludedServers.add(newPrimary.getServer());\n      newPrimary=null;\n    }\n    if (newPrimary != null) {\n      if (isDebugEnabled) {\n        logger.debug(\"SubscriptionManager redundancy satisfier - Non backup server was made primary. Recovering interest {}\",newPrimary.getEndpoint());\n      }\n      if (!recoverInterest(newPrimary,true)) {\n        excludedServers.add(newPrimary.getServer());\n        newPrimary=null;\n      }\n      cqsConnected();\n    }\n    if (newPrimary != null && PoolImpl.AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG) {\n      ClientServerObserver bo=ClientServerObserverHolder.getInstance();\n      bo.afterPrimaryRecovered(newPrimary.getServer());\n    }\n    printPrimaryNotFoundError=true;\n    printRecoveringPrimary=true;\n    return;\n  }\n  cqsDisconnected();\n  if (isDebugEnabled) {\n    logger.debug(\"SubscriptionManager redundancy satisfier - Could not recover a new primary\");\n  }\nsynchronized (lock) {\n    queueConnections=queueConnections.setPrimaryDiscoveryFailed(null);\n    lock.notifyAll();\n  }\n}", "comment": "find a new primary , adding any failed servers we encounter to the excluded servers list first we try to make a backup server the primary , but if run out of backup servers we will try to find a new server .", "label": "done"}
{"id": "61283", "raw_code": "public void addNodesInDocOrder(DTMIterator iterator,XPathContext support){\n  if (!m_mutable)   throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE,null));\n  int node;\n  while (DTM.NULL != (node=iterator.nextNode())) {\n    addNodeInDocOrder(node,support);\n  }\n}", "comment": "copy nodelist members into this nodelist , adding in document order .", "label": "done"}
{"id": "47690", "raw_code": "public void print(File file) throws IOException {\n  checkExec();\n  SecurityManager sm=System.getSecurityManager();\n  if (sm != null) {\n    sm.checkPrintJobAccess();\n  }\n  checkActionSupport(Action.PRINT);\n  checkFileValidation(file);\n  peer.print(file);\n}", "comment": "prints a file with the native desktop printing facility , using the associated application ' s print command .", "label": "done"}
{"id": "69160", "raw_code": "@Override public String expect(Pattern pattern){\n  final String token=read(pattern);\n  if (token == null) {\n    throw new ParserException(\"Expected pattern '\" + pattern.pattern() + \"' was not encountered in document: \"+ document);\n  }\n  return token;\n}", "comment": "this will attempt to read string matching the given pattern from the document at the current point indicated by the cursor .", "label": "done"}
{"id": "79044", "raw_code": "private FileChannel updateCache(String filePath){\n  FileChannel fileChannel=fileNameAndStreamCache.get(filePath);\n  try {\n    if (null == fileChannel) {\n      FileInputStream stream=new FileInputStream(filePath);\n      fileChannel=stream.getChannel();\n      fileNameAndStreamCache.put(filePath,fileChannel);\n    }\n  }\n catch (  IOException e) {\n    LOGGER.error(e,e.getMessage());\n  }\n  return fileChannel;\n}", "comment": "this method will be used to check whether stream is already present in cache or not for filepath if not present then create it and then add to cache , other wise get from cache", "label": "done"}
{"id": "4739", "raw_code": "public void addParameters(final NameValuePair[] parameters){\n  LOG.trace(\"enter PostMethod.addParameters(NameValuePair[])\");\n  if (parameters == null) {\n    LOG.warn(\"Attempt to addParameters(null) ignored\");\n  }\n else {\n    super.clearRequestBody();\n    for (int i=0; i < parameters.length; i++) {\n      params.add(parameters[i]);\n    }\n  }\n}", "comment": "adds an array of parameters to be used in the post request body .", "label": "done"}
{"id": "14988", "raw_code": "public static Set updateAndGetRemovableOCs(Set origSet,Set removeOCs){\n  Set returnOCs=removeOCs;\n  if (removeOCs != null && !removeOCs.isEmpty()) {\n    returnOCs=new HashSet();\n    Iterator itr1=origSet.iterator();\n    while (itr1.hasNext()) {\n      String origOC=(String)itr1.next();\n      Iterator itr2=removeOCs.iterator();\n      while (itr2.hasNext()) {\n        String removeOC=(String)itr2.next();\n        if (origOC.equalsIgnoreCase(removeOC)) {\n          returnOCs.add(origOC);\n          break;\n        }\n      }\n    }\n    origSet.removeAll(returnOCs);\n  }\n  return returnOCs;\n}", "comment": "method which removes the specified object class from original set and returns the set of object classes that were removed .", "label": "done"}
{"id": "11854", "raw_code": "public synchronized OMGraphicList prepare(){\n  Projection projection=getProjection();\n  boolean DEBUG_FINE=logger.isLoggable(Level.FINE);\n  if (projection == null) {\n    if (DEBUG_FINE) {\n      logger.fine(getName() + \": prepare called with null projection\");\n    }\n    return new OMGraphicList();\n  }\n  if (spatialIndex == null) {\n    if (DEBUG_FINE) {\n      logger.fine(getName() + \": spatialIndex is null!\");\n    }\n    OMGraphicList list=getList();\n    if (list != null) {\n      list.generate(projection,true);\n      return list;\n    }\n else {\n      return new OMGraphicList();\n    }\n  }\n  Point2D ul=projection.getUpperLeft();\n  Point2D lr=projection.getLowerRight();\n  double ulLat=ul.getY();\n  double ulLon=ul.getX();\n  double lrLat=lr.getY();\n  double lrLon=lr.getX();\n  OMGraphicList list=new OMGraphicList();\n  if (ProjMath.isCrossingDateline(ulLon,lrLon,projection.getScale())) {\n    if (DEBUG_FINE) {\n      logger.fine(\"ShapeLayer.computeGraphics(): Dateline is on screen\");\n    }\n    double ymin=Math.min(ulLat,lrLat);\n    double ymax=Math.max(ulLat,lrLat);\n    try {\n      list=spatialIndex.getOMGraphics(ulLon,ymin,180.0d,ymax,list,drawingAttributes,projection,coordTransform);\n      list=spatialIndex.getOMGraphics(-180.0d,ymin,lrLon,ymax,list,drawingAttributes,projection,coordTransform);\n    }\n catch (    InterruptedIOException iioe) {\n      list=null;\n    }\ncatch (    IOException ex) {\n      if (DEBUG_FINE) {\n        ex.printStackTrace();\n      }\n    }\ncatch (    FormatException fe) {\n      if (DEBUG_FINE) {\n        fe.printStackTrace();\n      }\n    }\ncatch (    NullPointerException npe) {\n      if (DEBUG_FINE) {\n        npe.printStackTrace();\n      }\n    }\n  }\n else {\n    double xmin=Math.min(ulLon,lrLon);\n    double xmax=Math.max(ulLon,lrLon);\n    double ymin=Math.min(ulLat,lrLat);\n    double ymax=Math.max(ulLat,lrLat);\n    try {\n      list=spatialIndex.getOMGraphics(xmin,ymin,xmax,ymax,list,drawingAttributes,projection,coordTransform);\n    }\n catch (    InterruptedIOException iioe) {\n      list=null;\n    }\ncatch (    java.io.IOException ex) {\n      if (DEBUG_FINE) {\n        ex.printStackTrace();\n      }\n    }\ncatch (    FormatException fe) {\n      if (DEBUG_FINE) {\n        fe.printStackTrace();\n      }\n    }\ncatch (    NullPointerException npe) {\n      if (DEBUG_FINE) {\n        npe.printStackTrace();\n      }\n    }\n  }\n  return list;\n}", "comment": "create the omgraphics using the shape file and spatialindex .", "label": "done"}
{"id": "31208", "raw_code": "private float calculateSelectorRadius(){\n  if (mfSelectorRadius == 0.0f) {\n    int nHeight=mSelectedView.getHeight();\n    int nWidth=mSelectedView.getWidth();\n    int nLargerSide=Math.max(nWidth,nHeight);\n    mfSelectorRadius=((nLargerSide ^ 2) / 2);\n  }\n  return mfSelectorRadius;\n}", "comment": "calculate selector radius the selector radius can be calculated by a simple math calculation of the larger side .", "label": "done"}
{"id": "14139", "raw_code": "private static void insertValue(final Map<String,List<String>> paramsMap,final String paramVal,final String parameterName){\n  if (paramVal != null) {\n    List<String> list=new ArrayList<>();\n    list.add(paramVal);\n    paramsMap.put(parameterName,list);\n  }\n}", "comment": "puts the given parameter value into a new list object then adds it to the map .", "label": "done"}
{"id": "72986", "raw_code": "public grammaticalityEstimator(Set FileNames,int iMinChar,int iMaxChar,int iCharWindow,int iMinWord,int iMaxWord,int iWordWindow){\n  iMinCharNGram=iMinChar;\n  iMaxCharNGram=iMaxChar;\n  iMinWordNGram=iMinWord;\n  iMaxWordNGram=iMaxWord;\n  iWordDist=iWordWindow;\n  iCharDist=iCharWindow;\n  DistroDocs=new TreeMap<Integer,DistributionDocument>();\n  DistroWordDocs=new TreeMap<Integer,DistributionWordDocument>();\n  StringBuffer sb=new StringBuffer();\n  Iterator iTexts=FileNames.iterator();\n  while (iTexts.hasNext()) {\n    String sFile=(String)iTexts.next();\n    try {\n      BufferedReader bf=new BufferedReader(new FileReader(sFile));\n      String sTmp;\n      while ((sTmp=bf.readLine()) != null)       sb.append(sTmp);\n      bf.close();\n    }\n catch (    FileNotFoundException ex) {\n      ex.printStackTrace(System.err);\n    }\ncatch (    IOException ex) {\n      ex.printStackTrace(System.err);\n    }\n    sb.append((char)0);\n  }\n  FullTextDataString=sb.toString();\n  for (int iCnt=iMinCharNGram; iCnt <= iMaxCharNGram; iCnt++) {\n    DistroDocs.put(iCnt,new DistributionDocument(iCharDist,iCnt));\n  }\n  for (int iCnt=iMinWordNGram; iCnt <= iMaxWordNGram; iCnt++) {\n    DistroWordDocs.put(iCnt,new DistributionWordDocument(iWordDist,iCnt));\n  }\n}", "comment": "creates a new instance of grammaticalityestimator , using a given set of documents for training .", "label": "done"}
{"id": "72471", "raw_code": "public void checkNextPoissonConsistency(double mean){\n  final int sampleSize=1000;\n  final int minExpectedCount=7;\n  long maxObservedValue=0;\n  final double alpha=0.001;\n  UnitTestUtils.Frequency<Long> frequency=new UnitTestUtils.Frequency<Long>();\n  for (int i=0; i < sampleSize; i++) {\n    long value=randomData.nextPoisson(mean);\n    if (value > maxObservedValue) {\n      maxObservedValue=value;\n    }\n    frequency.addValue(value);\n  }\n  PoissonDistribution poissonDistribution=new PoissonDistribution(mean);\n  int lower=1;\n  while (poissonDistribution.cumulativeProbability(lower - 1) * sampleSize < minExpectedCount) {\n    lower++;\n  }\n  int upper=(int)(5 * mean);\n  while ((1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize < minExpectedCount) {\n    upper--;\n  }\n  int binWidth=0;\n  boolean widthSufficient=false;\n  double lowerBinMass=0;\n  double upperBinMass=0;\n  while (!widthSufficient) {\n    binWidth++;\n    lowerBinMass=poissonDistribution.probability(lower - 1,lower + binWidth - 1);\n    upperBinMass=poissonDistribution.probability(upper - binWidth - 1,upper - 1);\n    widthSufficient=FastMath.min(lowerBinMass,upperBinMass) * sampleSize >= minExpectedCount;\n  }\n  List<Integer> binBounds=new ArrayList<Integer>();\n  binBounds.add(lower);\n  int bound=lower + binWidth;\n  while (bound < upper - binWidth) {\n    binBounds.add(bound);\n    bound+=binWidth;\n  }\n  binBounds.add(upper);\n  final int binCount=binBounds.size() + 1;\n  long[] observed=new long[binCount];\n  double[] expected=new double[binCount];\n  observed[0]=0;\n  for (int i=0; i < lower; i++) {\n    observed[0]+=frequency.getCount((long)i);\n  }\n  expected[0]=poissonDistribution.cumulativeProbability(lower - 1) * sampleSize;\n  observed[binCount - 1]=0;\n  for (int i=upper; i <= maxObservedValue; i++) {\n    observed[binCount - 1]+=frequency.getCount((long)i);\n  }\n  expected[binCount - 1]=(1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize;\n  for (int i=1; i < binCount - 1; i++) {\n    observed[i]=0;\n    for (int j=binBounds.get(i - 1); j < binBounds.get(i); j++) {\n      observed[i]+=frequency.getCount((long)j);\n    }\n    expected[i]=(poissonDistribution.cumulativeProbability(binBounds.get(i) - 1) - poissonDistribution.cumulativeProbability(binBounds.get(i - 1) - 1)) * sampleSize;\n  }\n  if (UnitTestUtils.chiSquareTest(expected,observed) < alpha) {\n    StringBuilder msgBuffer=new StringBuilder();\n    DecimalFormat df=new DecimalFormat(\"#.##\");\n    msgBuffer.append(\"Chisquare test failed for mean = \");\n    msgBuffer.append(mean);\n    msgBuffer.append(\" p-value = \");\n    msgBuffer.append(UnitTestUtils.chiSquareTest(expected,observed));\n    msgBuffer.append(\" chisquare statistic = \");\n    msgBuffer.append(UnitTestUtils.chiSquare(expected,observed));\n    msgBuffer.append(\". \\n\");\n    msgBuffer.append(\"bin\\t\\texpected\\tobserved\\n\");\n    for (int i=0; i < expected.length; i++) {\n      msgBuffer.append(\"[\");\n      msgBuffer.append(i == 0 ? 1 : binBounds.get(i - 1));\n      msgBuffer.append(\",\");\n      msgBuffer.append(i == binBounds.size() ? \"inf\" : binBounds.get(i));\n      msgBuffer.append(\")\");\n      msgBuffer.append(\"\\t\\t\");\n      msgBuffer.append(df.format(expected[i]));\n      msgBuffer.append(\"\\t\\t\");\n      msgBuffer.append(observed[i]);\n      msgBuffer.append(\"\\n\");\n    }\n    msgBuffer.append(\"This test can fail randomly due to sampling error with probability \");\n    msgBuffer.append(alpha);\n    msgBuffer.append(\".\");\n    Assert.fail(msgBuffer.toString());\n  }\n}", "comment": "verifies that nextpoisson ( mean ) generates an empirical distribution of values consistent with poissondistributionimpl by generating 1000 values , computing a grouped frequency distribution of the observed values and comparing this distribution to the corresponding expected distribution computed using poissondistributionimpl .", "label": "done"}
{"id": "2608", "raw_code": "public static void checkValid(double[] x){\n  for (  double v : x) {\n    if (Double.isNaN(v)) {\n      throw new RuntimeException(\"Invalid entry \" + v);\n    }\n  }\n}", "comment": "loop and ensure all elements are non - infiite and non - nan , throws an exception if one is", "label": "done"}
{"id": "70192", "raw_code": "protected void processConnectionEvent(ConnectionEvent event){\n  for (Enumeration<ConnectionListener> e=connectionListeners.elements(); e.hasMoreElements(); ) {\n    ConnectionListener l=e.nextElement();\nswitch (event.getType()) {\ncase ConnectionEvent.CONNECTED:\n      l.connected((ConnectedEvent)event);\n    break;\ncase ConnectionEvent.DISCONNECTED:\n  l.disconnected((DisconnectedEvent)event);\nbreak;\ncase ConnectionEvent.PACKET_RECEIVED:\nl.packetReceived((PacketReceivedEvent)event);\nbreak;\n}\n}\n}", "comment": "processes game events occurring on this connection by dispatching them to any registered gamelistener objects .", "label": "done"}
{"id": "87028", "raw_code": "public void addEventListener(SIPDialogEventListener newListener){\n  eventListeners.add(newListener);\n}", "comment": "adds a new event listener to this dialog .", "label": "done"}
{"id": "26015", "raw_code": "private boolean journalRebuildRequired(){\n  final int redundantOpCompactThreshold=2000;\n  return redundantOpCount >= redundantOpCompactThreshold && redundantOpCount >= lruEntries.size();\n}", "comment": "we only rebuild the journal when it will halve the size of the journal and eliminate at least 2000 ops .", "label": "done"}
{"id": "21576", "raw_code": "private void updateVolumeLabels(Volume trustedSrc,Volume invalidTgt){\n  VirtualArray invalidTgtVA=dbClient.queryObject(VirtualArray.class,invalidTgt.getVirtualArray());\n  StringBuilder newLabel=new StringBuilder();\n  newLabel.append(trustedSrc.getLabel());\n  newLabel.append(\"-target-\");\n  newLabel.append(invalidTgtVA.getLabel());\n  log.info(\"Revised name for target: \" + newLabel.toString());\n  invalidTgt.setLabel(newLabel.toString());\n  NamedURI projectURI=invalidTgt.getProject();\n  projectURI.setName(newLabel.toString());\n  invalidTgt.setProject(projectURI);\n  NamedURI tenantURI=invalidTgt.getTenant();\n  tenantURI.setName(newLabel.toString());\n  invalidTgt.setTenant(tenantURI);\n  Volume tgtVplexVolume=VPlexSrdfUtil.getVplexVolumeFromSrdfVolume(dbClient,invalidTgt);\n  if (tgtVplexVolume != null) {\n    Volume srcVplexVolume=VPlexSrdfUtil.getVplexVolumeFromSrdfVolume(dbClient,trustedSrc);\n    if (srcVplexVolume != null) {\n      newLabel.setLength(0);\n      newLabel.append(srcVplexVolume.getLabel());\n      newLabel.append(\"-target-\");\n      newLabel.append(invalidTgtVA.getLabel());\n      log.info(\"Revised name for VPlex target: \" + newLabel.toString());\n      tgtVplexVolume.setLabel(newLabel.toString());\n      projectURI=tgtVplexVolume.getProject();\n      projectURI.setName(newLabel.toString());\n      tgtVplexVolume.setProject(projectURI);\n      tenantURI=tgtVplexVolume.getTenant();\n      tenantURI.setName(newLabel.toString());\n      tgtVplexVolume.setTenant(tenantURI);\n      dbClient.updateAndReindexObject(tgtVplexVolume);\n    }\n  }\n}", "comment": "updates the label field of the invalidtgt , and if the volume is fronted by a vplex volume , also updates the target vplex volume label .", "label": "done"}
{"id": "11276", "raw_code": "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n  in.defaultReadObject();\n  i18n=Environment.getI18n();\n  beanContextChildSupport=new BeanContextChildSupport(this);\n}", "comment": "handle serialization a little bit better , replacing the i18n and beancontextchildsupport .", "label": "done"}
{"id": "78820", "raw_code": "public void add(@NonNull T item){\nsynchronized (lock) {\n    if (items == null) {\n      items=new ArrayList<>();\n    }\n    items.add(item);\n  }\n  if (notifyOnChange) {\n    notifyItemInserted(items.size());\n  }\n}", "comment": "adds the specified item to the end of the list", "label": "done"}
{"id": "66609", "raw_code": "private static int determineConsecutiveDigitCount(CharSequence msg,int startpos){\n  int count=0;\n  int len=msg.length();\n  int idx=startpos;\n  if (idx < len) {\n    char ch=msg.charAt(idx);\n    while (isDigit(ch) && idx < len) {\n      count++;\n      idx++;\n      if (idx < len) {\n        ch=msg.charAt(idx);\n      }\n    }\n  }\n  return count;\n}", "comment": "determines the number of consecutive characters that are encodable using numeric compaction .", "label": "done"}
{"id": "75307", "raw_code": "protected int parseAndAddNode(XmlResourceParser parser,HashMap<String,TagParser> tagParserMap,ArrayList<Long> screenIds) throws XmlPullParserException, IOException {\n  if (TAG_INCLUDE.equals(parser.getName())) {\n    final int resId=getAttributeResourceValue(parser,ATTR_WORKSPACE,0);\n    if (resId != 0) {\n      return parseLayout(resId,screenIds);\n    }\n else {\n      return 0;\n    }\n  }\n  mValues.clear();\n  parseContainerAndScreen(parser,mTemp);\n  final long container=mTemp[0];\n  final long screenId=mTemp[1];\n  mValues.put(Favorites.CONTAINER,container);\n  mValues.put(Favorites.SCREEN,screenId);\n  mValues.put(Favorites.CELLX,convertToDistanceFromEnd(getAttributeValue(parser,ATTR_X),mColumnCount));\n  mValues.put(Favorites.CELLY,convertToDistanceFromEnd(getAttributeValue(parser,ATTR_Y),mRowCount));\n  TagParser tagParser=tagParserMap.get(parser.getName());\n  if (tagParser == null) {\n    if (LOGD)     Log.d(TAG,\"Ignoring unknown element tag: \" + parser.getName());\n    return 0;\n  }\n  long newElementId=tagParser.parseAndAdd(parser);\n  if (newElementId >= 0) {\n    if (!screenIds.contains(screenId) && container == Favorites.CONTAINER_DESKTOP) {\n      screenIds.add(screenId);\n    }\n    return 1;\n  }\n  return 0;\n}", "comment": "parses the current node and returns the number of elements added .", "label": "done"}
{"id": "80201", "raw_code": "private void populateProfiles(final ProfileList profiles){\n  profilesComboBox.removeAllItems();\n  for (  Profile p : profiles) {\n    profilesComboBox.addItem(p);\n  }\n  final int count=profilesComboBox.getItemCount();\n  if (count != 0) {\n    profilesComboBox.setSelectedIndex(count - 1);\n  }\n}", "comment": "populate the profiles combobox and select the default .", "label": "done"}
{"id": "19821", "raw_code": "private long checkFileHeader(BufferedFileDataInput bfdi) throws ReplicatorException, InterruptedException {\n  int magic=0;\n  short major=0;\n  short minor=0;\n  try {\n    bfdi.waitAvailable(HEADER_LENGTH,HEADER_WAIT_MILLIS);\n    magic=bfdi.readInt();\n    major=bfdi.readShort();\n    minor=bfdi.readShort();\n    baseSeqno=bfdi.readLong();\n  }\n catch (  IOException e) {\n    throw new THLException(\"Failed to read file header from  \" + file.getAbsolutePath(),e);\n  }\n  if (magic != MAGIC_NUMBER)   throw new THLException(\"Could not open file \" + file.getAbsolutePath() + \" : invalid magic number\");\n  if (major != MAJOR_VERSION)   throw new THLException(\"Could not open file \" + file.getAbsolutePath() + \" : incompatible major version\");\n  if (minor != MINOR_VERSION)   logger.warn(\"Minor version mismatch : file \" + file.getAbsolutePath() + \" using format \"+ major+ \".\"+ minor+ \" - Tungsten running version \"+ MAJOR_VERSION+ \".\"+ MINOR_VERSION);\n  return baseSeqno;\n}", "comment": "read the file header and return the log sequence number stored in the file header .", "label": "done"}
{"id": "60193", "raw_code": "protected void processMouseEvent(MouseEvent e){\n  if (myInplaceComponent != null && (MouseEvent.MOUSE_PRESSED == e.getID() || MouseEvent.MOUSE_RELEASED == e.getID())) {\n    finishEditing(true);\n  }\n  super.processMouseEvent(e);\n}", "comment": "when there is an inplace editor we \" listen \" all mouse event and finish editing by any mouse _ pressed or mouse _ released event .", "label": "done"}
{"id": "56993", "raw_code": "protected void addModule(Map<Class<? extends IFloodlightService>,IFloodlightModule> moduleMap,Collection<IFloodlightModule> moduleList,IFloodlightModule module){\n  Collection<Class<? extends IFloodlightService>> servs=moduleServiceMap.get(module);\n  if (servs != null) {\n    for (    Class<? extends IFloodlightService> c : servs)     moduleMap.put(c,module);\n  }\n  moduleList.add(module);\n}", "comment": "add a module to the set of modules to load and register its services", "label": "done"}
{"id": "82617", "raw_code": "protected final void refreshLoadingViewsSize(){\n  final int maximumPullScroll=(int)(getMaximumPullScroll() * 1.2f);\n  int pLeft=getPaddingLeft();\n  int pTop=getPaddingTop();\n  int pRight=getPaddingRight();\n  int pBottom=getPaddingBottom();\nswitch (getPullToRefreshScrollDirection()) {\ncase HORIZONTAL:\n    if (mMode.showHeaderLoadingLayout()) {\n      mHeaderLayout.setWidth(maximumPullScroll);\n      pLeft=-maximumPullScroll;\n    }\n else {\n      pLeft=0;\n    }\n  if (mMode.showFooterLoadingLayout()) {\n    mFooterLayout.setWidth(maximumPullScroll);\n    pRight=-maximumPullScroll;\n  }\n else {\n    pRight=0;\n  }\nbreak;\ncase VERTICAL:\nif (mMode.showHeaderLoadingLayout()) {\nmHeaderLayout.setHeight(maximumPullScroll);\npTop=-maximumPullScroll;\n}\n else {\npTop=0;\n}\nif (mMode.showFooterLoadingLayout()) {\nmFooterLayout.setHeight(maximumPullScroll);\npBottom=-maximumPullScroll;\n}\n else {\npBottom=0;\n}\nbreak;\n}\nif (DEBUG) {\nLog.d(LOG_TAG,String.format(\"Setting Padding. L: %d, T: %d, R: %d, B: %d\",pLeft,pTop,pRight,pBottom));\n}\nsetPadding(pLeft,pTop,pRight,pBottom);\n}", "comment": "re - measure the loading views height , and adjust internal padding as necessary", "label": "done"}
{"id": "39653", "raw_code": "private static int numInitialSplits(long numRecords){\n  final int maxSplits=100;\n  final long recordsPerSplit=10000;\n  return (int)Math.min(maxSplits,numRecords / recordsPerSplit + 1);\n}", "comment": "pick a number of initial splits based on the number of records expected to be processed .", "label": "done"}
{"id": "34834", "raw_code": "private static String[] scanForSources(final File sourceDir,final Set<String> sourceIncludes,final Set<String> sourceExcludes){\n  final DirectoryScanner ds=new DirectoryScanner();\n  ds.setFollowSymlinks(true);\n  ds.setBasedir(sourceDir);\n  ds.setIncludes(sourceIncludes.toArray(new String[sourceIncludes.size()]));\n  ds.setExcludes(sourceExcludes.toArray(new String[sourceExcludes.size()]));\n  ds.addDefaultExcludes();\n  try {\n    ds.scan();\n  }\n catch (  IllegalStateException e) {\n    return new String[0];\n  }\n  return ds.getIncludedFiles();\n}", "comment": "scans a single source dir for sources and includes only the files whose name match the patterns in sourceincludes and excludes all files whose names match the patterns in sourceexcludes", "label": "done"}
{"id": "7293", "raw_code": "public void addGetters(int assignedPropertyNumber,String propertyName){\n  for (  EventType type : knownTypes) {\n    EventPropertyGetter getter=type.getGetter(propertyName);\n    VariantPropertyGetterRow row=allGetters.get(type);\n    if (row == null) {\nsynchronized (this) {\n        row=new VariantPropertyGetterRow(type,new EventPropertyGetter[assignedPropertyNumber + 1]);\n        allGetters.put(type,row);\n      }\n    }\n    row.addGetter(assignedPropertyNumber,getter);\n  }\n  properties.add(propertyName);\n}", "comment": "adds the getters for a property that is identified by a property number which indexes into array of getters per type .", "label": "done"}
{"id": "26965", "raw_code": "protected void markUsed(Entry entry){\n  entry.lastUsed=System.nanoTime();\n}", "comment": "marks the specified entry as used by setting its last used time to the current time in nanoseconds .", "label": "done"}
{"id": "82346", "raw_code": "public synchronized boolean removeElement(Object object){\n  int index;\n  if ((index=indexOf(object,0)) == -1) {\n    return false;\n  }\n  removeElementAt(index);\n  return true;\n}", "comment": "removes the first occurrence , starting at the beginning and moving towards the end , of the specified object from this vector .", "label": "done"}
{"id": "61701", "raw_code": "public static SecretKeys generateKey() throws GeneralSecurityException {\n  fixPrng();\n  KeyGenerator keyGen=KeyGenerator.getInstance(CIPHER);\n  keyGen.init(AES_KEY_LENGTH_BITS);\n  SecretKey confidentialityKey=keyGen.generateKey();\n  byte[] integrityKeyBytes=randomBytes(HMAC_KEY_LENGTH_BITS / 8);\n  SecretKey integrityKey=new SecretKeySpec(integrityKeyBytes,HMAC_ALGORITHM);\n  return new SecretKeys(confidentialityKey,integrityKey);\n}", "comment": "a function that generates random aes & hmac keys and prints out exceptions but doesn ' t throw them since none should be encountered .", "label": "done"}
{"id": "57065", "raw_code": "public static int toIPv4Address(String ipAddress){\n  if (ipAddress == null)   throw new IllegalArgumentException(\"Specified IPv4 address must\" + \"contain 4 sets of numerical digits separated by periods\");\n  String[] octets=ipAddress.split(\"\\\\.\");\n  if (octets.length != 4)   throw new IllegalArgumentException(\"Specified IPv4 address must\" + \"contain 4 sets of numerical digits separated by periods\");\n  int result=0;\n  for (int i=0; i < 4; ++i) {\n    int oct=Integer.valueOf(octets[i]);\n    if (oct > 255 || oct < 0)     throw new IllegalArgumentException(\"Octet values in specified\" + \" IPv4 address must be 0 <= value <= 255\");\n    result|=oct << ((3 - i) * 8);\n  }\n  return result;\n}", "comment": "accepts an ipv4 address of the form xxx . xxx . xxx . xxx , ie 192 . 168 . 0 . 1 and returns the corresponding 32 bit integer .", "label": "done"}
{"id": "57022", "raw_code": "public void closeCursor(Cursor cursor){\n  cursor.close();\n  cursorMap.remove(Integer.valueOf(cursor.getCursorId()));\n}", "comment": "close the given cursor and remove it from the map", "label": "done"}
{"id": "78821", "raw_code": "public void add(int position,@NonNull T item){\nsynchronized (lock) {\n    if (items == null) {\n      items=new ArrayList<>();\n    }\n    items.add(position,item);\n  }\n  if (notifyOnChange) {\n    notifyItemInserted(position);\n  }\n}", "comment": "adds the specified item to the list with the specified position", "label": "done"}
{"id": "56891", "raw_code": "public List<String> splitStringWithDefaultDelimiterEscaped(String inputString){\n  String delimiter=configurationHelper.getProperty(ConfigurationValue.FIELD_DATA_DELIMITER);\n  String escapeChar=configurationHelper.getProperty(ConfigurationValue.FIELD_DATA_DELIMITER_ESCAPE_CHAR);\n  List<String> splitString=new ArrayList<>();\n  if (StringUtils.isNotBlank(inputString)) {\n    String regex=\"(?<!\" + Pattern.quote(escapeChar) + \")\"+ Pattern.quote(delimiter);\n    for (    String s : inputString.split(regex)) {\n      splitString.add(s.replace(escapeChar + delimiter,delimiter));\n    }\n  }\n  return splitString;\n}", "comment": "splits the input string based on the default delimiter , and also escapes delimiter .", "label": "done"}
{"id": "38957", "raw_code": "protected boolean checkCoverage(){\n  int i;\n  int n;\n  int[] count;\n  Range r;\n  String attrIndex;\n  SubspaceClusterDefinition cl;\n  count=new int[getNumAttributes()];\n  for (i=0; i < getNumAttributes(); i++) {\n    for (n=0; n < getClusters().length; n++) {\n      cl=(SubspaceClusterDefinition)getClusters()[n];\n      r=new Range(cl.getAttrIndexRange());\n      r.setUpper(getNumAttributes());\n      if (r.isInRange(i)) {\n        count[i]++;\n      }\n    }\n  }\n  attrIndex=\"\";\n  for (i=0; i < count.length; i++) {\n    if (count[i] == 0) {\n      if (attrIndex.length() != 0) {\n        attrIndex+=\",\";\n      }\n      attrIndex+=(i + 1);\n    }\n  }\n  if (attrIndex.length() != 0) {\n    throw new IllegalArgumentException(\"The following attributes are not covered by a cluster \" + \"definition: \" + attrIndex + \"\\n\");\n  }\n  return true;\n}", "comment": "checks , whether all attributes are covered by cluster definitions and returns true in that case .", "label": "done"}
{"id": "60065", "raw_code": "private void updateExistingRow(final SQLiteDatabase database,final long id,boolean bumpCount){\n  String stringId=String.valueOf(id);\n  database.beginTransaction();\n  final Cursor cursor=database.query(SongPlayCountColumns.NAME,null,WHERE_ID_EQUALS,new String[]{stringId},null,null,null);\n  if (cursor != null && cursor.moveToFirst()) {\n    int lastUpdatedIndex=cursor.getColumnIndex(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX);\n    int lastUpdatedWeek=cursor.getInt(lastUpdatedIndex);\n    int weekDiff=mNumberOfWeeksSinceEpoch - lastUpdatedWeek;\n    if (Math.abs(weekDiff) >= NUM_WEEKS) {\n      deleteEntry(database,stringId);\n      if (bumpCount) {\n        createNewPlayedEntry(database,id);\n      }\n    }\n else     if (weekDiff != 0) {\n      int[] playCounts=new int[NUM_WEEKS];\n      if (weekDiff > 0) {\n        for (int i=0; i < NUM_WEEKS - weekDiff; i++) {\n          playCounts[i + weekDiff]=cursor.getInt(getColumnIndexForWeek(i));\n        }\n      }\n else       if (weekDiff < 0) {\n        for (int i=0; i < NUM_WEEKS + weekDiff; i++) {\n          playCounts[i]=cursor.getInt(getColumnIndexForWeek(i - weekDiff));\n        }\n      }\n      if (bumpCount) {\n        playCounts[0]++;\n      }\n      float score=calculateScore(playCounts);\n      if (score < .01f) {\n        deleteEntry(database,stringId);\n      }\n else {\n        ContentValues values=new ContentValues(NUM_WEEKS + 2);\n        values.put(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX,mNumberOfWeeksSinceEpoch);\n        values.put(SongPlayCountColumns.PLAYCOUNTSCORE,score);\n        for (int i=0; i < NUM_WEEKS; i++) {\n          values.put(getColumnNameForWeek(i),playCounts[i]);\n        }\n        database.update(SongPlayCountColumns.NAME,values,WHERE_ID_EQUALS,new String[]{stringId});\n      }\n    }\n else     if (bumpCount) {\n      ContentValues values=new ContentValues(2);\n      int scoreIndex=cursor.getColumnIndex(SongPlayCountColumns.PLAYCOUNTSCORE);\n      float score=cursor.getFloat(scoreIndex) + getScoreMultiplierForWeek(0);\n      values.put(SongPlayCountColumns.PLAYCOUNTSCORE,score);\n      values.put(getColumnNameForWeek(0),cursor.getInt(getColumnIndexForWeek(0)) + 1);\n      database.update(SongPlayCountColumns.NAME,values,WHERE_ID_EQUALS,new String[]{stringId});\n    }\n    cursor.close();\n  }\n else   if (bumpCount) {\n    createNewPlayedEntry(database,id);\n  }\n  database.setTransactionSuccessful();\n  database.endTransaction();\n}", "comment": "this function will take a song entry and update it to the latest week and increase the count for the current week by 1 if necessary", "label": "done"}
{"id": "31526", "raw_code": "public static <R,A,B>CompletionStage<R> combine(CompletionStage<A> a,CompletionStage<B> b,BiFunction<A,B,R> function){\n  return a.thenCombine(b,function);\n}", "comment": "combines multiple stages by applying a function .", "label": "done"}
{"id": "24698", "raw_code": "public List<ValidationErrorMessage> validate(){\n  errorMessageIds.clear();\n  if (paymentProduct == null) {\n    throw new NullPointerException(\"Error validating PaymentRequest, please set a paymentProduct first.\");\n  }\n  for (  PaymentProductField field : paymentProduct.getPaymentProductFields()) {\n    if (!isFieldInAccountOnFileAndNotAltered(field)) {\n      errorMessageIds.addAll(field.validateValue(getValue(field.getId())));\n    }\n  }\n  return errorMessageIds;\n}", "comment": "validates all fields based on their value and their validationrules if a field is prefilled from the account on file , but it has been altered , it will be validated .", "label": "done"}
{"id": "9460", "raw_code": "public void stateChanged(ChangeEvent e){\n  if (ignoreUpdate) {\n    return;\n  }\n  double value=(double)(1800 - setpointSlider.getValue()) / 10;\n  setSetPoint(value);\n  sim.setSetPoint(value);\n}", "comment": "handle a change in the slider by updating the dataset value .", "label": "done"}
{"id": "67709", "raw_code": "public static String[] parseDelimitedList(String list,char delimiter){\n  String delim=\"\" + delimiter;\n  StringTokenizer st=new StringTokenizer(list + delim + \" \",delim,true);\n  ArrayList<String> v=new ArrayList<String>();\n  String lastToken=\"\";\n  String word=\"\";\n  while (st.hasMoreTokens()) {\n    String tok=st.nextToken();\n    if (lastToken != null) {\n      if (tok.equals(delim)) {\n        word=word + lastToken;\n        if (lastToken.equals(delim))         tok=null;\n      }\n else {\n        if (!word.equals(\"\"))         v.add(word);\n        word=\"\";\n      }\n    }\n    lastToken=tok;\n  }\n  return v.toArray(new String[0]);\n}", "comment": "parse a list of substrings separated by a given delimiter .", "label": "done"}
{"id": "70858", "raw_code": "private static void _trustAllHttpsCertificates(){\n  SSLContext context;\n  if (_trustManagers == null) {\n    _trustManagers=new TrustManager[]{new FakeX509TrustManager()};\n  }\n  try {\n    context=SSLContext.getInstance(\"SSL\");\n    context.init(null,_trustManagers,new SecureRandom());\n  }\n catch (  GeneralSecurityException gse) {\n    throw new IllegalStateException(gse.getMessage());\n  }\n  HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());\n}", "comment": "set the default x509 trust manager to an instance of a fake class that trust all certificates , even the self - signed ones .", "label": "done"}
{"id": "701", "raw_code": "public static double safeSqrt(double x){\n  return (x < 0 ? -Math.sqrt(-x) : Math.sqrt(x));\n}", "comment": "the \" safe \" square root of the input value , handling negative values by simply making them positive and then negating the return value .", "label": "done"}
{"id": "46977", "raw_code": "private void bappend(char ch){\n  try {\n    mBuff[++mBuffIdx]=ch;\n  }\n catch (  Exception exp) {\n    char buff[]=new char[mBuff.length << 1];\n    System.arraycopy(mBuff,0,buff,0,mBuff.length);\n    mBuff=buff;\n    mBuff[mBuffIdx]=ch;\n  }\n}", "comment": "appends a character to parser ' s buffer .", "label": "done"}
{"id": "64995", "raw_code": "public String buildUnionSubQuery(String typeDiscriminatorColumn,String[] unionColumns,Set<String> columnsPresentInTable,int computedColumnsOffset,String typeDiscriminatorValue,String selection,String groupBy,String having){\n  int unionColumnsCount=unionColumns.length;\n  String[] projectionIn=new String[unionColumnsCount];\n  for (int i=0; i < unionColumnsCount; i++) {\n    String unionColumn=unionColumns[i];\n    if (unionColumn.equals(typeDiscriminatorColumn)) {\n      projectionIn[i]=\"'\" + typeDiscriminatorValue + \"' AS \"+ typeDiscriminatorColumn;\n    }\n else     if (i <= computedColumnsOffset || columnsPresentInTable.contains(unionColumn)) {\n      projectionIn[i]=unionColumn;\n    }\n else {\n      projectionIn[i]=\"NULL AS \" + unionColumn;\n    }\n  }\n  return buildQuery(projectionIn,selection,groupBy,having,null,null);\n}", "comment": "construct a select statement suitable for use in a group of select statements that will be joined through union operators in buildunionquery .", "label": "done"}
{"id": "55293", "raw_code": "public synchronized void increase(){\n  if (accuracy > 0) {\n    long timePassed=System.currentTimeMillis() - lastAdded;\n    if (timePassed > accuracy) {\n      clearUp();\n      if (count > 0) {\n        data.addFirst(lastAdded + accuracy);\n      }\n      lastAdded=System.currentTimeMillis();\n      count=0;\n    }\n    count++;\n  }\n else {\n    clearUp();\n    data.addFirst(System.currentTimeMillis());\n  }\n}", "comment": "adds an element to the counter or caches it to be added .", "label": "done"}
{"id": "59740", "raw_code": "public static double normalPDF(double x,double variance,double meanValue){\n  double standardDeviation=Math.sqrt(variance);\n  return (1 / (standardDeviation * Math.sqrt(2 * Math.PI))) * Math.pow(Math.E,-((x - meanValue) * (x - meanValue)) / (2 * variance));\n}", "comment": "calculate a normal probability density function ( pdf ) based on a variance and mean value", "label": "done"}
{"id": "42383", "raw_code": "private void clearRegisters(Instruction start,Instruction end){\n  for (Instruction p=start; ; p=p.nextInstructionInCodeOrder()) {\n    for (Enumeration<Operand> ops=p.getOperands(); ops.hasMoreElements(); ) {\n      Operand op=ops.nextElement();\n      if (op instanceof RegisterOperand) {\n        RegisterOperand rOp=(RegisterOperand)op;\n        clearDepGraphNodeForRegister(rOp.getRegister());\n      }\n    }\n    if (p == end)     break;\n  }\n  for (Enumeration<Register> e=GenericPhysicalDefUse.enumerateAllImplicitDefUses(ir); e.hasMoreElements(); ) {\n    Register r=e.nextElement();\n    clearDepGraphNodeForRegister(r);\n  }\n}", "comment": "initialize ( clear ) the dnode field in register for all registers in this basic block by setting them to null .", "label": "done"}
{"id": "16025", "raw_code": "public boolean verifyServerEvidenceMessage(BigInteger serverM2) throws CryptoException {\n  if ((this.A == null) || (this.M1 == null) || (this.S == null)) {\n    throw new CryptoException(\"Impossible to compute and verify M2: \" + \"some data are missing from the previous operations (A,M1,S)\");\n  }\n  BigInteger computedM2=SRP6Util.calculateM2(digest,N,A,M1,S);\n  if (computedM2.equals(serverM2)) {\n    this.M2=serverM2;\n    return true;\n  }\n  return false;\n}", "comment": "authenticates the server evidence message m2 received and saves it only if correct .", "label": "done"}
{"id": "60447", "raw_code": "@Nullable private static String referenceToAttribute(String attrib,boolean includeDummies){\n  while (attrib.startsWith(\"\\\\\\\\\")) {\n    attrib=attrib.substring(2);\n  }\n  if (attrib.startsWith(\"\\\\$\")) {\n    if (includeDummies) {\n      attrib=attrib.substring(1);\n    }\n else     return null;\n  }\n  if (!StringUtil.startsWithChar(attrib,'$')) {\n    return null;\n  }\n  attrib=attrib.substring(1);\n  if (StringUtil.startsWithChar(attrib,'{')) {\n    String cleanAttribute=null;\n    for (int i=1; i < attrib.length(); i++) {\n      char currChar=attrib.charAt(i);\n      if (currChar == '{' || currChar == '.') {\n        cleanAttribute=null;\n        break;\n      }\n else       if (currChar == '}') {\n        cleanAttribute=attrib.substring(1,i);\n        break;\n      }\n    }\n    attrib=cleanAttribute;\n  }\n else {\n    for (int i=0; i < attrib.length(); i++) {\n      char currChar=attrib.charAt(i);\n      if (currChar == '{' || currChar == '}' || currChar == '.') {\n        attrib=attrib.substring(0,i);\n        break;\n      }\n    }\n  }\n  return attrib;\n}", "comment": "removes each two leading ' \\ ' , removes leading $ , removes { } examples : $ qqq - > qqq \\ $ qqq - > qqq if dummy attributes are collected too , null otherwise \\ \\ $ qqq - > qqq $ { qqq } - > qqq", "label": "done"}
{"id": "47567", "raw_code": "static String toLowerCase(String s){\n  int len=s.length();\n  StringBuilder sb=null;\n  for (int i=0; i < len; i++) {\n    char c=s.charAt(i);\n    if ((c >= 'a' && c <= 'z') || (c == '.')) {\n      if (sb != null)       sb.append(c);\n    }\n else     if ((c >= '0' && c <= '9') || (c == '-')) {\n      if (sb != null)       sb.append(c);\n    }\n else     if (c >= 'A' && c <= 'Z') {\n      if (sb == null) {\n        sb=new StringBuilder(len);\n        sb.append(s,0,i);\n      }\n      sb.append((char)(c - CASE_DIFF));\n    }\n else {\n      throw new IllegalArgumentException(\"Invalid characters in hostname\");\n    }\n  }\n  return sb == null ? s : sb.toString();\n}", "comment": "convert to lower case , and check that all chars are ascii alphanumeric , ' - ' or ' . ' only .", "label": "done"}
{"id": "67720", "raw_code": "public static String toUpperCase(String src){\n  if (src == null) {\n    return null;\n  }\n else {\n    return src.toUpperCase();\n  }\n}", "comment": "safely convert the string to uppercase .", "label": "done"}
{"id": "41376", "raw_code": "public static String formatJavaDocBox(String text){\n  requireNonNull(text);\n  return formatTextBox(text,JAVA_DOC_WIDTH,JAVADOC_WORDS,JAVA_DOC_SINGLE_LINE_WORDS);\n}", "comment": "creates and returns a string formatted so it will fit in a box suitable for a java doc header .", "label": "done"}
{"id": "16490", "raw_code": "private static String forceNumberStringToTwoDigits(String text){\n  while (text.length() < 2) {\n    text=\"0\" + text;\n  }\n  if (text.length() > 2) {\n    text=text.substring(text.length() - 2,text.length());\n  }\n  return text;\n}", "comment": "forcenumberstringtotwodigits , this takes a string of digits , and forces it to be two digits long .", "label": "done"}
{"id": "80424", "raw_code": "public void addDropItem(final String name,final double probability,final int min,final int max){\n  dropsItems.add(new DropItem(name,probability,min,max));\n}", "comment": "adds a named item to the list of items that will be dropped on dead if cleardropitemlist hasn ' t been called first , this will change all creatures of this kind .", "label": "done"}
{"id": "82949", "raw_code": "public static <E extends Identifiable>List<E> findByPrimaryKeys(EntityManager em,List<BigInteger> ids,Class<E> type){\n  requireArgument(em != null,\"The entity manager cannot be null.\");\n  requireArgument(ids != null && !ids.isEmpty(),\"IDs cannot be null or empty.\");\n  requireArgument(type != null,\"The entity type cannot be null.\");\n  TypedQuery<E> query=em.createNamedQuery(\"JPAEntity.findByPrimaryKeys\",type);\n  query.setHint(\"javax.persistence.cache.storeMode\",\"REFRESH\");\n  try {\n    query.setParameter(\"ids\",ids);\n    query.setParameter(\"deleted\",false);\n    return query.getResultList();\n  }\n catch (  NoResultException ex) {\n    return new ArrayList<>(0);\n  }\n}", "comment": "finds jpa entities by their primary keys .", "label": "done"}
{"id": "66533", "raw_code": "private void loadWorkflow(Properties ctx,int AD_Workflow_ID,HttpSession sess){\n  MWorkflow wf=new MWorkflow(ctx,AD_Workflow_ID,null);\n  MWFNode[] nodes=wf.getNodes(true,Env.getContextAsInt(ctx,\"#AD_Client_ID\"));\n  MWFNode wfn=null;\n  ArrayList nodes_ID=new ArrayList();\n  for (int i=0; i < nodes.length; i++) {\n    wfn=nodes[i];\n    nodes_ID.add(new Integer(wfn.getAD_WF_Node_ID()));\n  }\n  int imageMap[][]=generateImageMap(nodes_ID);\n  sess.setAttribute(WORKFLOW,wf);\n  sess.setAttribute(NODES,nodes);\n  sess.setAttribute(NODES_ID,nodes_ID);\n  sess.setAttribute(IMAGE_MAP,imageMap);\n  sess.setAttribute(ACTIVE_NODE,new Integer(-999));\n}", "comment": "load workflw and initialize the session attributes .", "label": "done"}
{"id": "27741", "raw_code": "@SuppressWarnings(\"unchecked\") static public void assertSameIteratorAnyOrder(final Object[] expected,final Iterator actual){\n  assertSameIteratorAnyOrder(\"\",expected,actual);\n}", "comment": "verifies that the iterator visits the specified objects in some arbitrary ordering and that the iterator is exhausted once all expected objects have been visited .", "label": "done"}
{"id": "86826", "raw_code": "protected void transferFromFile(File idFile) throws IOException {\n  try (BufferedReader br=new BufferedReader(new FileReader(idFile))){\n    String line;\n    while ((line=br.readLine()) != null) {\n      line=line.trim();\n      if (line.length() > 0) {\n        transfer(line);\n      }\n    }\n  }\n }", "comment": "transfer all the sequences listed in the supplied file , interpreting entries appropriately .", "label": "done"}
{"id": "28249", "raw_code": "private ResultPointsAndTransitions transitionsBetween(ResultPoint from,ResultPoint to){\n  int fromX=(int)from.getX();\n  int fromY=(int)from.getY();\n  int toX=(int)to.getX();\n  int toY=(int)to.getY();\n  boolean steep=Math.abs(toY - fromY) > Math.abs(toX - fromX);\n  if (steep) {\n    int temp=fromX;\n    fromX=fromY;\n    fromY=temp;\n    temp=toX;\n    toX=toY;\n    toY=temp;\n  }\n  int dx=Math.abs(toX - fromX);\n  int dy=Math.abs(toY - fromY);\n  int error=-dx >> 1;\n  int ystep=fromY < toY ? 1 : -1;\n  int xstep=fromX < toX ? 1 : -1;\n  int transitions=0;\n  boolean inBlack=image.get(steep ? fromY : fromX,steep ? fromX : fromY);\n  for (int x=fromX, y=fromY; x != toX; x+=xstep) {\n    boolean isBlack=image.get(steep ? y : x,steep ? x : y);\n    if (isBlack != inBlack) {\n      transitions++;\n      inBlack=isBlack;\n    }\n    error+=dy;\n    if (error > 0) {\n      if (y == toY) {\n        break;\n      }\n      y+=ystep;\n      error-=dx;\n    }\n  }\n  return new ResultPointsAndTransitions(from,to,transitions);\n}", "comment": "counts the number of black / white transitions between two points , using something like bresenham ' s algorithm .", "label": "done"}
{"id": "86671", "raw_code": "public static String toBits(final long x){\n  final StringBuilder sb=new StringBuilder();\n  long t=x;\n  for (int i=0; i < 64; i++) {\n    if ((i & 7) == 0 && i > 0) {\n      sb.append(\":\");\n    }\n    sb.append(t < 0 ? \"1\" : \"0\");\n    t=t << 1;\n  }\n  assert t == 0;\n  return sb.toString();\n}", "comment": "convert a number into a bit string with separators between each group of 8 .", "label": "done"}
{"id": "58335", "raw_code": "public static final byte[] encodeUrl(BitSet urlsafe,byte[] bytes){\n  if (bytes == null) {\n    return null;\n  }\n  if (urlsafe == null) {\n    urlsafe=WWW_FORM_URL;\n  }\n  ByteArrayOutputStream buffer=new ByteArrayOutputStream();\n  for (int i=0; i < bytes.length; i++) {\n    int b=bytes[i];\n    if (b < 0) {\n      b=256 + b;\n    }\n    if (urlsafe.get(b)) {\n      if (b == ' ') {\n        b='+';\n      }\n      buffer.write(b);\n    }\n else {\n      buffer.write('%');\n      char hex1=Character.toUpperCase(Character.forDigit((b >> 4) & 0xF,16));\n      char hex2=Character.toUpperCase(Character.forDigit(b & 0xF,16));\n      buffer.write(hex1);\n      buffer.write(hex2);\n    }\n  }\n  return buffer.toByteArray();\n}", "comment": "encodes an array of bytes into an array of url safe 7 - bit characters .", "label": "done"}
{"id": "22824", "raw_code": "public void addEvent(SimEvent newEvent){\n  newEvent.setSerial(serial++);\n  sortedSet.add(newEvent);\n}", "comment": "adds a new event to the queue .", "label": "done"}
{"id": "67853", "raw_code": "public void hspan(double start,double end,Paint color,String legend){\n  LegendText legendText=new LegendText(color,legend);\n  comments.add(legendText);\n  plotElements.add(new HSpan(start,end,color,legendText));\n}", "comment": "draws a horizontal span into the graph and optionally adds a legend .", "label": "done"}
{"id": "61425", "raw_code": "public static boolean isValidNmtoken(String nmtoken){\n  if (nmtoken.length() == 0)   return false;\n  for (int i=0; i < nmtoken.length(); i++) {\n    char ch=nmtoken.charAt(i);\n    if (!isName(ch)) {\n      return false;\n    }\n  }\n  return true;\n}", "comment": "check to see if a string is a valid nmtoken according to [ 7 ] in the xml 1 . 0 recommendation", "label": "done"}
{"id": "41451", "raw_code": "private static double parseDoubleValue(String parseString,String openTag,String closeTag,DataTypeValidationException exception) throws DataTypeValidationException {\n  String tagValue;\n  tagValue=parseStringValue(parseString,openTag,closeTag,exception);\n  double doubleValue;\n  try {\n    doubleValue=Double.parseDouble(tagValue);\n  }\n catch (  NumberFormatException e) {\n    throw e;\n  }\n  return doubleValue;\n}", "comment": "parses out and converts the text located between first occurrences of the open and closed tags into double .", "label": "done"}
{"id": "54768", "raw_code": "public void putString(String s) throws ArrayIndexOutOfBoundsException, UnsupportedEncodingException {\n  byte[] bytes=s.getBytes(\"UTF-8\");\n  int length=bytes.length;\n  int endAt=m_index + length + 1;\n  if (endAt > m_content.length)   throw new ArrayIndexOutOfBoundsException(endAt + \" > \" + m_content.length);\n  System.arraycopy(bytes,0,m_content,m_index,length);\n  m_index+=length;\n  m_content[m_index++]='\\0';\n  debugAppendString(s);\n}", "comment": "place a string into the message ( using utf - 8 encoding )", "label": "done"}
{"id": "76037", "raw_code": "private static BitMatrix extractPureBits(BitMatrix image) throws NotFoundException {\n  int[] leftTopBlack=image.getTopLeftOnBit();\n  int[] rightBottomBlack=image.getBottomRightOnBit();\n  if (leftTopBlack == null || rightBottomBlack == null) {\n    throw NotFoundException.getNotFoundInstance();\n  }\n  float moduleSize=moduleSize(leftTopBlack,image);\n  int top=leftTopBlack[1];\n  int bottom=rightBottomBlack[1];\n  int left=leftTopBlack[0];\n  int right=rightBottomBlack[0];\n  if (left >= right || top >= bottom) {\n    throw NotFoundException.getNotFoundInstance();\n  }\n  if (bottom - top != right - left) {\n    right=left + (bottom - top);\n  }\n  int matrixWidth=Math.round((right - left + 1) / moduleSize);\n  int matrixHeight=Math.round((bottom - top + 1) / moduleSize);\n  if (matrixWidth <= 0 || matrixHeight <= 0) {\n    throw NotFoundException.getNotFoundInstance();\n  }\n  if (matrixHeight != matrixWidth) {\n    throw NotFoundException.getNotFoundInstance();\n  }\n  int nudge=(int)(moduleSize / 2.0f);\n  top+=nudge;\n  left+=nudge;\n  int nudgedTooFarRight=left + (int)((matrixWidth - 1) * moduleSize) - right;\n  if (nudgedTooFarRight > 0) {\n    if (nudgedTooFarRight > nudge) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n    left-=nudgedTooFarRight;\n  }\n  int nudgedTooFarDown=top + (int)((matrixHeight - 1) * moduleSize) - bottom;\n  if (nudgedTooFarDown > 0) {\n    if (nudgedTooFarDown > nudge) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n    top-=nudgedTooFarDown;\n  }\n  BitMatrix bits=new BitMatrix(matrixWidth,matrixHeight);\n  for (int y=0; y < matrixHeight; y++) {\n    int iOffset=top + (int)(y * moduleSize);\n    for (int x=0; x < matrixWidth; x++) {\n      if (image.get(left + (int)(x * moduleSize),iOffset)) {\n        bits.set(x,y);\n      }\n    }\n  }\n  return bits;\n}", "comment": "this method detects a code in a \" pure \" image - - that is , pure monochrome image which contains only an unrotated , unskewed , image of a code , with some white border around it .", "label": "done"}
{"id": "43962", "raw_code": "public static BNode parseBNode(String nTriplesBNode,ValueFactory valueFactory) throws IllegalArgumentException {\n  if (nTriplesBNode.startsWith(\"_:\")) {\n    return valueFactory.createBNode(nTriplesBNode.substring(2));\n  }\n else {\n    throw new IllegalArgumentException(\"Not a legal N-Triples Blank Node: \" + nTriplesBNode);\n  }\n}", "comment": "parses an n - triples bnode , creates an object for it using the supplied valuefactory and returns this object .", "label": "done"}
{"id": "76612", "raw_code": "public static InetAddress hexToInet6Address(String addrHexString) throws IllegalArgumentException {\n  try {\n    return numericToInetAddress(String.format(\"%s:%s:%s:%s:%s:%s:%s:%s\",addrHexString.substring(0,4),addrHexString.substring(4,8),addrHexString.substring(8,12),addrHexString.substring(12,16),addrHexString.substring(16,20),addrHexString.substring(20,24),addrHexString.substring(24,28),addrHexString.substring(28,32)));\n  }\n catch (  Exception e) {\n    Log.e(\"NetworkUtils\",\"error in hexToInet6Address(\" + addrHexString + \"): \"+ e);\n    throw new IllegalArgumentException(e);\n  }\n}", "comment": "convert a 32 char hex string into a inet6address .", "label": "done"}
{"id": "40153", "raw_code": "public void trackFailure(){\n  retryTime=Utils.currentTimeMillis() + (long)backoff;\n  backoff=Math.min(backoff * params.multiplier,params.maximum);\n}", "comment": "track a failure - multiply the back off interval by the multiplier", "label": "done"}
{"id": "10890", "raw_code": "protected void parseAndAddMapTileSet(URL tileSetProperties) throws IOException, MalformedURLException {\n  Properties descProps=new Properties();\n  Logger logger=getLogger();\n  logger.info(\"going to read props\");\n  InputStream descURLStream=tileSetProperties.openStream();\n  descProps.load(descURLStream);\n  logger.info(\"loaded \" + tileSetProperties.toString() + \" \"+ descProps.toString());\n  MapTileSet mts=createMapTileSetFromProperties(descProps);\n  if (mts != null && mts.allGood()) {\n    String mtsName=mts.getName();\n    mapTileSets.put(mts.getName(),mts);\n    logger.info(\"Adding \" + mtsName + \" dataset\");\n  }\n  descURLStream.close();\n}", "comment": "given a url to a properties file describing a maptileset , create it and add it to the list .", "label": "done"}
{"id": "8893", "raw_code": "public void enablePan(BluetoothAdapter adapter){\n  if (mPan == null)   mPan=(BluetoothPan)connectProxy(adapter,BluetoothProfile.PAN);\n  assertNotNull(mPan);\n  long start=System.currentTimeMillis();\n  mPan.setBluetoothTethering(true);\n  long stop=System.currentTimeMillis();\n  assertTrue(mPan.isTetheringOn());\n  writeOutput(String.format(\"enablePan() completed in %d ms\",(stop - start)));\n}", "comment": "enables pan tethering on the local device and checks to make sure that tethering is enabled .", "label": "done"}
{"id": "13921", "raw_code": "@Get public Representation userCodeForm() throws OAuth2RestletException, InvalidGrantException, NotFoundException, ServerException {\n  final OAuth2Request request=requestFactory.create(getRequest());\n  if (request.getParameter(OAuth2Constants.DeviceCode.USER_CODE) != null) {\n    return verify(null);\n  }\n else {\n    return getTemplateRepresentation(FORM,request,null);\n  }\n}", "comment": "handles get requests to the oauth2 device / user endpoint , returning a form to allow the user to submit their user code", "label": "done"}
{"id": "8886", "raw_code": "public void close(){\n  while (!mReceivers.isEmpty()) {\n    mContext.unregisterReceiver(mReceivers.remove(0));\n  }\n  if (mOutputWriter != null) {\n    try {\n      mOutputWriter.close();\n    }\n catch (    IOException e) {\n      Log.w(mTag,\"Test output file could not be closed\",e);\n    }\n  }\n}", "comment": "closes the utility instance and unregisters any broadcastreceivers .", "label": "done"}
{"id": "5200", "raw_code": "private void resolveFiles(List<String> classpaths,Map<String,String> files,String[] paths,String prefix){\n  for (  String path : paths) {\n    String relativePath=fileHandler.getName(path);\n    if (prefix != null) {\n      relativePath=fileHandler.append(prefix,relativePath);\n    }\n    if (classpaths != null) {\n      classpaths.add(relativePath);\n    }\n    if (fileHandler.isDirectory(path)) {\n      String[] children=fileHandler.getChildren(path);\n      if (children != null && children.length != 0) {\n        resolveFiles(null,files,children,relativePath);\n      }\n    }\n else {\n      files.put(relativePath,path);\n    }\n  }\n}", "comment": "resolves all files it finds into a map , with relative paths as the key and absolute path as the value .", "label": "done"}
{"id": "17369", "raw_code": "private void addToSet(ObjectXmlPersist persist,IFile file,String setName) throws IOException, CoreException {\n  Collection<GraphEdgeMatcherDescriptor> updateSet=loadEdgeMatchers(persist,file);\n  persistUpdatedBundle(persist,file,updateSet,setName);\n}", "comment": "add the set to an existing file .", "label": "done"}
{"id": "80220", "raw_code": "protected void appendHTML(final StringBuilder sbuf,final char ch){\nswitch (ch) {\ncase '<':\n    sbuf.append(\"&lt;\");\n  break;\ncase '>':\nsbuf.append(\"&gt;\");\nbreak;\ncase '&':\nsbuf.append(\"&amp;\");\nbreak;\ndefault :\nsbuf.append(ch);\nbreak;\n}\n}", "comment": "append a character to a buffer , escaping html meta - characters when needed .", "label": "done"}
{"id": "70656", "raw_code": "private Collection<Var> migrateColumns(SQLTable currentTable){\n  List<Var> vars=new ArrayList<>();\n  String tableType=currentTable.getEntityType();\n  Map<String,ResourceType.DataType> columns=currentTable.getColumns();\n  Map<String,String> foreignColumns=currentTable.getForeignKeyColumns();\n  for (  String column : columns.keySet()) {\n    ResourceType.DataType columnType=columns.get(column);\n    if (foreignColumns.containsKey(column)) {\n      vars.addAll(migrateAsRelation(tableType,column,foreignColumns.get(column)));\n    }\n else {\n      vars.addAll(migrateAsResource(tableType,columnType,column));\n    }\n  }\n  return vars;\n}", "comment": "loop through each of the columns in the given table , migrating each as a resource or relation .", "label": "done"}
{"id": "36251", "raw_code": "@Override public int addAttribute(Attribute a){\n  if (a == null) {\n    throw new IllegalArgumentException(\"Attribute must not be null\");\n  }\n else {\n    int index=-1;\n    Attribute original=a;\n    a=(Attribute)a.clone();\n    if (unusedColumnList.size() > 0) {\nsynchronized (unusedColumnList) {\n        if (unusedColumnList.size() > 0) {\n          index=unusedColumnList.remove(0);\n          attributes.set(index,a);\n        }\n else {\n          index=attributes.size();\n          attributes.add(a);\n        }\n      }\n    }\n else {\n      index=attributes.size();\n      attributes.add(a);\n    }\n    a.setTableIndex(index);\n    original.setTableIndex(index);\n    return index;\n  }\n}", "comment": "adds the attribute to the list of attributes assigning it a free column index .", "label": "done"}
{"id": "63177", "raw_code": "public static <X>void sortTopN(X[] array,int offset,int limit,Comparator<? super X> comp){\n  partitionTopN(array,offset,limit,comp);\n  Arrays.sort(array,offset,(int)Math.min((long)offset + limit,array.length),comp);\n}", "comment": "find the top limit values using given comparator and place them as in a full array sort , in descending order .", "label": "done"}
{"id": "53889", "raw_code": "public static void readFully(InputStream in,byte buf[],int off,int len) throws IOException {\n  int toRead=len;\n  while (toRead > 0) {\n    int ret=in.read(buf,off,toRead);\n    if (ret < 0) {\n      throw new IOException(\"Premature EOF from inputStream\");\n    }\n    toRead-=ret;\n    off+=ret;\n  }\n}", "comment": "does the readfully based on the input read .", "label": "done"}
{"id": "26213", "raw_code": "public static String addToCartBulk(HttpServletRequest request,HttpServletResponse response){\n  String categoryId=request.getParameter(\"category_id\");\n  ShoppingCart cart=getCartObject(request);\n  Delegator delegator=(Delegator)request.getAttribute(\"delegator\");\n  LocalDispatcher dispatcher=(LocalDispatcher)request.getAttribute(\"dispatcher\");\n  ShoppingCartHelper cartHelper=new ShoppingCartHelper(delegator,dispatcher,cart);\n  String controlDirective;\n  Map<String,Object> result;\n  Map<String,Object> paramMap=UtilHttp.getParameterMap(request);\n  String catalogId=CatalogWorker.getCurrentCatalogId(request);\n  result=cartHelper.addToCartBulk(catalogId,categoryId,paramMap);\n  controlDirective=processResult(result,request);\n  if (controlDirective.equals(ERROR)) {\n    return \"error\";\n  }\n else {\n    return \"success\";\n  }\n}", "comment": "adds all products in a category according to quantity request parameter for each ; if no parameter for a certain product in the category , or if quantity is 0 , do not add", "label": "done"}
{"id": "36127", "raw_code": "public void addFrequentSet(FrequentItemSet itemSet){\n  frequentSets.add(itemSet);\n  maximumSetSize=Math.max(itemSet.getNumberOfItems(),maximumSetSize);\n}", "comment": "adds a frequent item set to this container .", "label": "done"}
{"id": "55397", "raw_code": "private static int showUrlsPrompt(Component parent,List<String> urls){\n  String text=\"<html><body style='width: 100px;'>\";\n  for (  String url : urls) {\n    url=splitUrl(url);\n    text+=url + \"<br />\";\n  }\n  String okOption=\"Open URL\";\n  if (urls.size() > 1) {\n    okOption=\"Open \" + urls.size() + \" URLs\";\n  }\n  String[] options={okOption,\"Cancel\"};\n  if (urls.size() == 1) {\n    options=new String[]{okOption,\"Copy URL\",\"Cancel\"};\n  }\n  int chosenOption=JOptionPane.showOptionDialog(parent,text,\"Open in default browser?\",JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,1);\n  return chosenOption;\n}", "comment": "actually show the dialog that contain the given urls and give the user the option to open the url , copy it or cancel the dialog .", "label": "done"}
{"id": "84968", "raw_code": "private static String computeRegexString(String originalString,String oldName,String newName){\n  StringBuilder builder=new StringBuilder(originalString.length());\n  String oldNameOrNewNameRegEx=String.format(\"(%s)|(%s)\",Pattern.quote(oldName),Pattern.quote(newName));\n  int i=originalString.indexOf(oldName);\n  if (i >= 0) {\n    int prevI=0;\n    while (i >= 0) {\n      builder.append(Pattern.quote(originalString.substring(prevI,i)));\n      builder.append(oldNameOrNewNameRegEx);\n      prevI=i;\n      i=originalString.indexOf(oldName,i + oldName.length());\n    }\n    builder.append(Pattern.quote(originalString.substring(prevI + oldName.length(),originalString.length())));\n  }\n  return builder.toString();\n}", "comment": "computes a regular expression string where each instance of the old name can be fulfilled by either the old name or new name .", "label": "done"}
{"id": "43816", "raw_code": "private boolean copyDocument(SearchDocument newDocument,SearchDocument document,Map<String,Set<String>> removedProperties){\n  boolean mutated=false;\n  for (  String oldFieldName : document.getPropertyNames()) {\n    newDocument.addProperty(oldFieldName);\n    List<String> oldValues=document.getProperty(oldFieldName);\n    if (oldValues != null) {\n      Set<String> objectsRemoved=(removedProperties != null) ? removedProperties.get(oldFieldName) : null;\n      for (      String oldValue : oldValues) {\n        if ((objectsRemoved != null) && (objectsRemoved.contains(oldValue))) {\n          mutated=true;\n        }\n else {\n          addProperty(oldFieldName,oldValue,newDocument);\n        }\n      }\n    }\n  }\n  return mutated;\n}", "comment": "creates a copy of the old document ; updating the retrieved document instance works ok for stored properties but indexed data gets lost when doing an indexwriter . updatedocument with it .", "label": "done"}
{"id": "31530", "raw_code": "public static double dmod_d(double lhs,double rhs){\n  return rhs != 0 ? lhs - rhs * Math.floor(lhs / rhs) : Double.NaN;\n}", "comment": "take modulo for double numbers according to lua math , and return a double result .", "label": "done"}
{"id": "17758", "raw_code": "public FloatBuffer put(float[] src,int srcOffset,int floatCount){\n  Arrays.checkOffsetAndCount(src.length,srcOffset,floatCount);\n  if (floatCount > remaining()) {\n    throw new BufferOverflowException();\n  }\n  for (int i=srcOffset; i < srcOffset + floatCount; ++i) {\n    put(src[i]);\n  }\n  return this;\n}", "comment": "writes floats from the given float array , starting from the specified offset , to the current position and increases the position by the number of floats written .", "label": "done"}
{"id": "25087", "raw_code": "public GT_MetaGenerated_Item(String aUnlocalized,short aOffset,short aItemAmount){\n  super(aUnlocalized);\n  setCreativeTab(GregTech_API.TAB_GREGTECH_MATERIALS);\n  setHasSubtypes(true);\n  setMaxDamage(0);\n  mEnabledItems=new BitSet(aItemAmount);\n  mVisibleItems=new BitSet(aItemAmount);\n  mOffset=(short)Math.min(32766,aOffset);\n  mItemAmount=(short)Math.min(aItemAmount,32766 - mOffset);\n  mIconList=new IIcon[aItemAmount][1];\n  sInstances.put(getUnlocalizedName(),this);\n}", "comment": "creates the item using these parameters .", "label": "done"}
{"id": "71607", "raw_code": "public static ParsedSql parseSqlStatement(String sql){\n  Set<String> namedParameters=new HashSet<String>();\n  ParsedSql parsedSql=new ParsedSql(sql);\n  char[] statement=sql.toCharArray();\n  int namedParameterCount=0;\n  int unnamedParameterCount=0;\n  int totalParameterCount=0;\n  int i=0;\n  while (i < statement.length) {\n    int skipToPosition=skipCommentsAndQuotes(statement,i);\n    if (i != skipToPosition) {\n      if (skipToPosition >= statement.length) {\n        break;\n      }\n      i=skipToPosition;\n    }\n    char c=statement[i];\n    if (c == ':' || c == '&') {\n      int j=i + 1;\n      if (j < statement.length && statement[j] == ':' && c == ':') {\n        i=i + 2;\n        continue;\n      }\n      while (j < statement.length && !isParameterSeparator(statement[j])) {\n        j++;\n      }\n      if (j - i > 1) {\n        String parameter=sql.substring(i + 1,j);\n        if (!namedParameters.contains(parameter)) {\n          namedParameters.add(parameter);\n          namedParameterCount++;\n        }\n        parsedSql.addNamedParameter(parameter,i,j);\n        totalParameterCount++;\n      }\n      i=j - 1;\n    }\n else {\n      if (c == '?') {\n        unnamedParameterCount++;\n        totalParameterCount++;\n      }\n    }\n    i++;\n  }\n  parsedSql.setNamedParameterCount(namedParameterCount);\n  parsedSql.setUnnamedParameterCount(unnamedParameterCount);\n  parsedSql.setTotalParameterCount(totalParameterCount);\n  return parsedSql;\n}", "comment": "parse the sql statement and locate any placeholders or named parameters .", "label": "done"}
{"id": "23691", "raw_code": "public void checkKey(Object key) throws PartitionedRegionException {\n  if (!hasHash) {\n    return;\n  }\n  if (key == null) {\n    return;\n  }\n  int expected=key.hashCode();\n  if (expected == keyHash) {\n    return;\n  }\n  throw new PartitionedRegionException(\"Object hashCode inconsistent between cache peers. Here = \" + expected + \"; peer calculated = \"+ keyHash);\n}", "comment": "if possible , validate the given key ' s hashcode against any that was returned by the peer .", "label": "done"}
{"id": "74579", "raw_code": "public static void println(Object x){\n  out.println(x);\n}", "comment": "prints an object to this output stream and then terminates the line .", "label": "done"}
{"id": "86978", "raw_code": "public void removeAttribute(String name){\n  if (name != null)   if (attributesList != null) {\n    for (int i=0; i < attributesList.size(); i++) {\n      Object o=attributesList.elementAt(i);\n      if (o instanceof AttributeField) {\n        AttributeField a=(AttributeField)o;\n        try {\n          String n=a.getName();\n          if (n != null) {\n            if (name.equals(n)) {\n              attributesList.remove(a);\n            }\n          }\n        }\n catch (        SdpParseException e) {\n        }\n      }\n    }\n  }\n}", "comment": "removes the attribute specified by the value parameter .", "label": "done"}
{"id": "54600", "raw_code": "void addFillComponents(Container panel,int[] cols,int[] rows){\n  Dimension filler=new Dimension(10,10);\n  boolean filled_cell_11=false;\n  CellConstraints cc=new CellConstraints();\n  if (cols.length > 0 && rows.length > 0) {\n    if (cols[0] == 1 && rows[0] == 1) {\n      panel.add(Box.createRigidArea(filler),cc.xy(1,1));\n      filled_cell_11=true;\n    }\n  }\n  for (int index=0; index < cols.length; index++) {\n    if (cols[index] == 1 && filled_cell_11) {\n      continue;\n    }\n    panel.add(Box.createRigidArea(filler),cc.xy(cols[index],1));\n  }\n  for (int index=0; index < rows.length; index++) {\n    if (rows[index] == 1 && filled_cell_11) {\n      continue;\n    }\n    panel.add(Box.createRigidArea(filler),cc.xy(1,rows[index]));\n  }\n}", "comment": "adds fill components to empty cells in the first row and first column of the grid .", "label": "done"}
{"id": "4956", "raw_code": "public boolean is_overlap(){\n  Set<BrdItem> start_contacts=get_start_contacts();\n  Set<BrdItem> end_contacts=get_end_contacts();\n  for (  BrdItem end_contact : end_contacts) {\n    if (start_contacts.contains(end_contact))     return true;\n  }\n  return false;\n}", "comment": "looks , if this trace is connected to the same object at its start and its end point", "label": "done"}
{"id": "67500", "raw_code": "static Object ensureNotNull(Location location,Object value){\n  if (value == null) {\n    throw new EvalException(location,\"Snippet runtime does not support null values.\");\n  }\n  return value;\n}", "comment": "ensure the given value is not null and return it .", "label": "done"}
{"id": "51680", "raw_code": "private static String padRight(String s,int minLength){\n  return String.format(\"%1$-\" + minLength + \"s\",s);\n}", "comment": "adds padding to the end of a string with a repeating character if the string ' s length is less than the minimum length", "label": "done"}
{"id": "20449", "raw_code": "public void testmirror(File orig,File origni,File truecolor){\n  File mirror=TestSupport.addSuffixToName(orig,\"_mirror\");\n  File recov=TestSupport.addSuffixToName(orig,\"_recov\");\n  long crc0=0;\n  boolean interlaced;\n  boolean palete;\n{\n    PngReader pngr=new PngReader(orig);\n    PngWriter pngw=null;\n    try {\n      if (rand.nextBoolean())       pngr.setLineSetFactory(ImageLineSetDefault.getFactoryByte());\n      palete=pngr.imgInfo.indexed;\n      pngr.prepareSimpleDigestComputation();\n      interlaced=pngr.isInterlaced();\n      pngw=new PngWriter(mirror,pngr.imgInfo,true);\n      pngw.setFilterType(FilterType.FILTER_CYCLIC);\n      pngw.copyChunksFrom(pngr.getChunksList());\n      IImageLineSet<? extends IImageLine> lines=pngr.readRows();\n      for (int row=0; row < pngr.imgInfo.rows; row++) {\n        mirrorLine(lines.getImageLine(row),pngr.imgInfo);\n        pngw.writeRow(lines.getImageLine(row));\n      }\n      pngr.end();\n      crc0=PngHelperInternal.getDigest(pngr);\n      pngw.end();\n    }\n  finally {\n      pngr.close();\n      if (pngw != null)       pngw.close();\n    }\n  }\n{\n    PngReader pngr2=new PngReader(mirror);\n    PngWriter pngw=null;\n    try {\n      if (pngr2.imgInfo.bitDepth < 16 && rand.nextBoolean())       pngr2.setLineSetFactory(ImageLineSetDefault.getFactoryByte());\n      pngw=new PngWriter(recov,pngr2.imgInfo,true);\n      pngw.setFilterType(FilterType.FILTER_DEFAULT);\n      pngw.copyChunksFrom(pngr2.getChunksList());\n      for (int row=0; row < pngr2.imgInfo.rows; row++) {\n        IImageLine line=pngr2.readRow();\n        mirrorLine(line,pngr2.imgInfo);\n        pngw.writeRow(line);\n      }\n      pngr2.end();\n      pngw.end();\n    }\n  finally {\n      pngr2.close();\n      if (pngw != null)       pngw.close();\n    }\n  }\n  if (!interlaced)   TestSupport.testCrcEquals(recov,crc0);\n else   TestSupport.testSameCrc(recov,origni);\n  if (interlaced)   additionalTestInterlaced(orig,origni);\n  if (palete && truecolor.exists())   additionalTestPalette(orig,truecolor);\n}", "comment": "takes a image , mirrors it using row - per - row int reading , mirror it again using byte ( if possible ) and compares if the original was interlaced , compares with origni", "label": "done"}
{"id": "55794", "raw_code": "public static void calcTextSize(Paint paint,String demoText,FSize outputFSize){\n  Rect r=mCalcTextSizeRect;\n  r.set(0,0,0,0);\n  paint.getTextBounds(demoText,0,demoText.length(),r);\n  outputFSize.width=r.width();\n  outputFSize.height=r.height();\n}", "comment": "calculates the approximate size of a text , depending on a demo text avoid repeated calls ( e . g . inside drawing methods )", "label": "done"}
{"id": "14102", "raw_code": "private void updateStatus(String relayState,int currentStatus){\n  Integer tmp=(Integer)currentStatusMap.get(relayState);\n  if (tmp != null) {\n    int previousStatus=tmp.intValue();\nswitch (previousStatus) {\ncase LOGOUT_SUCCEEDED_STATUS:\n      if (currentStatus > previousStatus) {\n        currentStatusMap.put(relayState,new Integer(currentStatus));\n      }\n    break;\ncase LOGOUT_FAILED_STATUS:\n  if (currentStatus < LOGOUT_FAILED_STATUS) {\n    currentStatusMap.put(relayState,new Integer(LOGOUT_PARTIAL_STATUS));\n  }\nbreak;\ndefault :\nbreak;\n}\n}\n else {\ncurrentStatusMap.put(relayState,new Integer(currentStatus));\n}\n}", "comment": "updates logout status based on current status and what stored in the internal map .", "label": "done"}
{"id": "60637", "raw_code": "public static int[] oidStrToInts(String oid) throws IOException {\n  int length=oid.length();\n  if (oid.charAt(length - 1) == '.') {\n    throw new IOException(\"Bad OID: \" + oid);\n  }\n  int[] result=new int[length / 2 + 1];\n  int number=0;\n  for (int i=0; i < length; i++) {\n    int value=0;\n    int pos=i;\n    for (; i < length; i++) {\n      char ch=oid.charAt(i);\n      if ((ch < '0') || (ch > '9')) {\n        break;\n      }\n      value=10 * value + (ch - '0');\n    }\n    if (i == pos) {\n      throw new IOException(\"Bad OID: \" + oid);\n    }\n    result[number++]=value;\n    if (i == length) {\n      break;\n    }\n    char ch=oid.charAt(i);\n    if (ch != '.') {\n      throw new IOException(\"Bad OID: \" + oid);\n    }\n  }\n  if (number < 2) {\n    throw new IOException(\"OID should consist of no less than 2 components: \" + oid);\n  }\n  return Arrays.copyOfRange(result,0,number);\n}", "comment": "converts oid into array of ints .", "label": "done"}
{"id": "13542", "raw_code": "private static void appendJSONPair(StringBuilder json,String key,String value) throws UnsupportedEncodingException {\n  boolean isValueNumeric=false;\n  try {\n    if (value.equals(\"0\") || !value.endsWith(\"0\")) {\n      Double.parseDouble(value);\n      isValueNumeric=true;\n    }\n  }\n catch (  NumberFormatException e) {\n    isValueNumeric=false;\n  }\n  if (json.charAt(json.length() - 1) != '{') {\n    json.append(',');\n  }\n  json.append(escapeJSON(key));\n  json.append(':');\n  if (isValueNumeric) {\n    json.append(value);\n  }\n else {\n    json.append(escapeJSON(value));\n  }\n}", "comment": "appends a json encoded key / value pair to the given string builder .", "label": "done"}
{"id": "53091", "raw_code": "@Override public void writeExternal(ObjectOutput out) throws IOException {\n  super.writeExternal(out);\n  out.writeDouble(knnDistance);\n}", "comment": "calls the super method and writes the knn distance of this entry to the specified stream .", "label": "done"}
{"id": "19938", "raw_code": "public static KEYSTORE_TYPE fromString(String x) throws ConfigurationException {\n  for (  KEYSTORE_TYPE currentType : KEYSTORE_TYPE.values()) {\n    if (x.equalsIgnoreCase(currentType.toString()))     return currentType;\n  }\n  throw new ConfigurationException(MessageFormat.format(\"Cannot cast into a known CERTIFICATE_KEY_TYPE: {0}\",x));\n}", "comment": "converts a string into the corresponding keystore _ type", "label": "done"}
{"id": "56383", "raw_code": "public ObjectMapper nextLevel(ObjectMapper level){\n  ObjectMapper previous=levelStack.peek();\n  levelStack.push(level);\n  return previous;\n}", "comment": "sets the new current nested level and pushes old current nested level down the stack returns that level .", "label": "done"}
{"id": "67837", "raw_code": "protected static int toDigit(final char ch,final int index) throws HexDecodeException {\n  final int digit=Character.digit(ch,16);\n  if (digit == -1) {\n    throw new HexDecodeException(\"Illegal hexadecimal character \" + ch + \" at index \"+ index);\n  }\n  return digit;\n}", "comment": "converts a hexadecimal character to an integer .", "label": "done"}
{"id": "78324", "raw_code": "public JSONObject toJson() throws JSONException {\n  JSONObject json=new JSONObject();\n  JSONArray jpods=new JSONArray();\n  for (  DiasporaPod pod : pods) {\n    jpods.put(pod.toJson());\n  }\n  json.put(\"pods\",jpods);\n  json.put(\"timestamp\",System.currentTimeMillis());\n  return json;\n}", "comment": "convert diasporapodlist to json", "label": "done"}
{"id": "9599", "raw_code": "public static KeyStore load(File keyStoreFile,Password password) throws CryptoException, FileNotFoundException {\n  KeyStoreType keyStoreType=null;\n  try {\n    keyStoreType=CryptoFileUtil.detectKeyStoreType(new FileInputStream(keyStoreFile));\n  }\n catch (  FileNotFoundException ex) {\n    throw ex;\n  }\ncatch (  IOException ex) {\n    throw new CryptoException(res.getString(\"NoLoadKeyStore.exception.message\"),ex);\n  }\n  if (keyStoreType == null) {\n    return null;\n  }\n  return load(keyStoreFile,password,keyStoreType);\n}", "comment": "load a keystore , auto - detecting the type , from a file accessed by a password .", "label": "done"}
{"id": "48733", "raw_code": "private int readServerResponse() throws IOException {\n  StringBuffer replyBuf=new StringBuffer(32);\n  int c;\n  int continuingCode=-1;\n  int code;\n  String response;\n  serverResponse.setSize(0);\n  while (true) {\n    while ((c=in.read()) != -1) {\n      if (c == '\\r') {\n        if ((c=in.read()) != '\\n') {\n          replyBuf.append('\\r');\n        }\n      }\n      replyBuf.append((char)c);\n      if (c == '\\n') {\n        break;\n      }\n    }\n    response=replyBuf.toString();\n    replyBuf.setLength(0);\n    if (logger.isLoggable(PlatformLogger.Level.FINEST)) {\n      logger.finest(\"Server [\" + serverAddr + \"] --> \"+ response);\n    }\n    if (response.length() == 0) {\n      code=-1;\n    }\n else {\n      try {\n        code=Integer.parseInt(response.substring(0,3));\n      }\n catch (      NumberFormatException e) {\n        code=-1;\n      }\ncatch (      StringIndexOutOfBoundsException e) {\n        continue;\n      }\n    }\n    serverResponse.addElement(response);\n    if (continuingCode != -1) {\n      if (code != continuingCode || (response.length() >= 4 && response.charAt(3) == '-')) {\n        continue;\n      }\n else {\n        continuingCode=-1;\n        break;\n      }\n    }\n else     if (response.length() >= 4 && response.charAt(3) == '-') {\n      continuingCode=code;\n      continue;\n    }\n else {\n      break;\n    }\n  }\n  return code;\n}", "comment": "pulls the response from the server and returns the code as a number .", "label": "done"}
{"id": "20443", "raw_code": "protected void processBytes(byte[] buf,int off,int len){\n  nBytesIn+=len;\n  if (len < 1 || state.isDone())   return;\n  if (state == State.ROW_READY)   throw new PngjInputException(\"this should only be called if waitingForMoreInput\");\n  if (inf.needsDictionary() || !inf.needsInput())   throw new RuntimeException(\"should not happen\");\n  inf.setInput(buf,off,len);\n  if (isCallbackMode()) {\n    while (inflateData()) {\n      int nextRowLen=processRowCallback();\n      prepareForNextRow(nextRowLen);\n      if (isDone())       processDoneCallback();\n    }\n  }\n else   inflateData();\n}", "comment": "feeds the inflater with the compressed bytes in poll mode , the caller should not call repeatedly this , without consuming first , checking isdatareadyforconsumer ( )", "label": "done"}
{"id": "85403", "raw_code": "public void emitRetainedVars(GenerateJsVisitor gen){\n  if (!retainedVars.isEmpty()) {\n    gen.out(\"var \");\n    boolean first=true;\n    for (    String varName : retainedVars) {\n      if (!first) {\n        gen.out(\",\");\n      }\n      first=false;\n      gen.out(varName);\n    }\n    gen.endLine(true);\n    retainedVars.clear();\n  }\n}", "comment": "writes all retained variables to the output of the specified generator , then clears them .", "label": "done"}
{"id": "57734", "raw_code": "@Override public int read() throws IOException {\nsynchronized (lock) {\n    checkNotClosed();\n    if (pos != count) {\n      return str.charAt(pos++);\n    }\n    return -1;\n  }\n}", "comment": "reads a single character from the source string and returns it as an integer with the two higher - order bytes set to 0 .", "label": "done"}
{"id": "8980", "raw_code": "public void accumulate(TaggedLogAPIEntity entity) throws Exception {\n  AggregateAPIEntity current=root;\n  for (  String groupby : groupbys) {\n    String tagv=locateGroupbyField(groupby,entity);\n    if (tagv == null || tagv.isEmpty()) {\n      tagv=UNASSIGNED_GROUPBY_ROOT_FIELD_NAME;\n    }\n    Map<String,AggregateAPIEntity> children=current.getEntityList();\n    if (children.get(tagv) == null) {\n      children.put(tagv,factory.create());\n      current.setNumDirectDescendants(current.getNumDirectDescendants() + 1);\n    }\n    AggregateAPIEntity child=children.get(tagv);\n    if (counting)     count(child);\n    for (    String sumFunctionField : sumFunctionFields) {\n      sum(child,entity,sumFunctionField);\n    }\n    current=child;\n  }\n}", "comment": "currently only group by tags groupbys ' first item always is site , which is a reserved field", "label": "done"}
{"id": "83068", "raw_code": "public void writeLinkedKml(final String filename,final KmlType kml){\n  if (filename.equals(\"doc.kml\")) {\n    throw new IllegalArgumentException(\"The filename 'doc.kml' is reserved for the primary kml.\");\n  }\n  if (filename.equals(\"main.kml\")) {\n    throw new IllegalArgumentException(\"The filename 'main.kml' is reserved for the main kml.\");\n  }\n  writeKml(filename,kml);\n}", "comment": "adds the specified kml - object to the file .", "label": "done"}
{"id": "69124", "raw_code": "private void registerNewClient(JsonObject jData){\n  Client newClient=gson.fromJson(jData,Client.class);\n  if (newClient.isValid()) {\n    addClient(newClient);\n    broadcastNewClient(newClient);\n    sendClientList(newClient);\n  }\n else {\n    logger.log(Level.WARNING,\"Could not unpack received data into a Client.\");\n  }\n}", "comment": "create client from given json data , add client to client list , broadcast newly registered client to all previously registered clients and send client list to new client .", "label": "done"}
{"id": "43970", "raw_code": "@Override public void parse(InputStream in,String baseURI) throws IOException, RDFParseException, RDFHandlerException {\n  if (in == null) {\n    throw new IllegalArgumentException(\"Input stream cannot be 'null'\");\n  }\n  if (baseURI == null) {\n    throw new IllegalArgumentException(\"Base URI cannot be 'null'\");\n  }\n  InputSource inputSource=new InputSource(new BOMInputStream(in,false));\n  inputSource.setSystemId(baseURI);\n  parse(inputSource);\n}", "comment": "parses the data from the supplied inputstream , using the supplied baseuri to resolve any relative uri references .", "label": "done"}
{"id": "4696", "raw_code": "public static Date parseDate(String dateValue,Collection dateFormats) throws DateParseException {\n  if (dateValue == null) {\n    throw new IllegalArgumentException(\"dateValue is null\");\n  }\n  if (dateFormats == null) {\n    dateFormats=DEFAULT_PATTERNS;\n  }\n  if (dateValue.length() > 1 && dateValue.startsWith(\"'\") && dateValue.endsWith(\"'\")) {\n    dateValue=dateValue.substring(1,dateValue.length() - 1);\n  }\n  SimpleDateFormat dateParser=null;\n  final Iterator formatIter=dateFormats.iterator();\n  while (formatIter.hasNext()) {\n    final String format=(String)formatIter.next();\n    if (dateParser == null) {\n      dateParser=new SimpleDateFormat(format,Locale.US);\n      dateParser.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n    }\n else {\n      dateParser.applyPattern(format);\n    }\n    try {\n      return dateParser.parse(dateValue);\n    }\n catch (    final ParseException pe) {\n    }\n  }\n  throw new DateParseException(\"Unable to parse the date \" + dateValue);\n}", "comment": "parses the date value using the given date formats .", "label": "done"}
{"id": "54859", "raw_code": "EdgeMap<Block> findLoops(Deque<Block> code,Map<Block,Block> idom,SetMap<Block,Edge> pred){\n  EdgeMap<Block> loops=new EdgeMap<Block>();\n  for (  Block b : code)   for (  Edge s : b.succ())   if (isLoop(s,idom)) {\n    verboseStatus(\"backedge \" + s);\n    Block h=s.to;\n    Set<Block> loop=loops.get(h);\n    Set<Block> work=new TreeSet<Block>();\n    for (    Edge p : pred.get(h)) {\n      if (isLoop(p,idom) && !loop.contains(p.from) && p.from != h) {\n        loop.add(p.from);\n        work.add(p.from);\n      }\n    }\n    while (!work.isEmpty()) {\n      Block x=getBlock(work);\n      for (      Edge p : pred.get(x)) {\n        if (p.from != h && !loop.contains(p.from)) {\n          loop.add(p.from);\n          work.add(p.from);\n        }\n      }\n    }\n  }\n  return loops;\n}", "comment": "loop code layout the loop is defined by the back edge from t - > h .", "label": "done"}
{"id": "73744", "raw_code": "public int[] readLine(){\n  int record[]=new int[MAX_LEN];\n  int checksum=0;\n  try {\n    while (((charIn=buffIn.read()) == 0xd) || (charIn == 0xa)) {\n    }\n    if (charIn != ':') {\n      if (log.isDebugEnabled()) {\n        log.debug(\"HexFile.readLine no colon at start of line \" + lineNo);\n      }\n      return new int[]{-1};\n    }\n  }\n catch (  IOException e) {\n    JOptionPane.showMessageDialog(this,\"I/O Error reading hex file!\",\"Hex File\",JOptionPane.ERROR_MESSAGE);\n    if (log.isDebugEnabled()) {\n      log.debug(\"I/O Error reading hex file!\" + e.toString());\n    }\n  }\n  record[LEN]=rdHexByte();\n  checksum+=record[LEN];\n  record[ADDRH]=rdHexByte();\n  checksum+=record[ADDRH];\n  record[ADDRL]=rdHexByte();\n  checksum+=record[ADDRL];\n  record[TYPE]=rdHexByte();\n  checksum+=record[TYPE];\n  address=(address & 0xffff0000) + record[ADDRH] * 256 + record[ADDRL];\n  type=record[TYPE];\n  if (type != END) {\n    len=record[LEN];\n    for (int i=1; i <= len; i++) {\n      record[TYPE + i]=rdHexByte();\n      checksum+=record[TYPE + i];\n    }\n  }\n  int fileCheck=rdHexByte();\n  if (((checksum + fileCheck) & 0xff) != 0) {\n    log.error(\"HexFile.readLine bad checksum at line \" + lineNo);\n  }\n  lineNo++;\n  return record;\n}", "comment": "read a line from the hex file and verify the checksum .", "label": "done"}
{"id": "69048", "raw_code": "public void sphericalToWorld(Vector3 vec){\n  if (pjUnprojected == null) {\n    String projStr=\"+proj=longlat +a=\" + projInfo.getSemiMajorAxis() + \" +b=\"+ projInfo.getSemiMinorAxis()+ \" +no_defs\";\n    pjUnprojected=Proj4.newInstance(projStr);\n  }\n  if (pjProjected == null) {\n    pjProjected=Proj4.newInstance(proj4String);\n  }\n  try {\n    vec.toArray(coord);\n    coord[0]=Math.toRadians(coord[0]);\n    coord[1]=Math.toRadians(coord[1]);\n    pjUnprojected.transform(pjProjected,coord);\n    vec.setX(coord[0]);\n    vec.setY(coord[1]);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}", "comment": "convert lon / lat ( degree ) coordinate to virtual world coordinates .", "label": "done"}
{"id": "48003", "raw_code": "public void drawRenderedImage(RenderedImage img,AffineTransform xform){\n  if (img == null) {\n    return;\n  }\n  mPrintMetrics.drawImage(this,img);\n  mDrawingArea.addInfinite();\n}", "comment": "draws an image , applying a transform from image space into user space before drawing .", "label": "done"}
{"id": "6334", "raw_code": "private long buildSize(int durationInSeconds,LinkInfo linfo){\n  long result=-1;\n  double bitRateSum=0;\nswitch (linfo.fmt) {\ncase 5:\n    bitRateSum=0.25 + 64d / 1024d;\n  break;\ncase 6:\nbitRateSum=0.8 + 64d / 1024d;\nbreak;\ncase 17:\nbitRateSum=0.05 + 24d / 1024d;\nbreak;\ncase 18:\nbitRateSum=0.5 + 96d / 1024d;\nbreak;\ncase 22:\nbitRateSum=2.9 + 192d / 1024d;\nbreak;\ncase 34:\nbitRateSum=0.5 + 128d / 1024d;\nbreak;\ncase 35:\nbitRateSum=1 + 128d / 1024d;\nbreak;\ncase 36:\nbitRateSum=0.17 + 38d / 1024d;\nbreak;\ncase 37:\nbitRateSum=5.9 + 192d / 1024d;\nbreak;\ncase 38:\nbitRateSum=5 + 192d / 1024d;\nbreak;\ncase 43:\nbitRateSum=0.5 + 128d / 1024d;\nbreak;\ncase 44:\nbitRateSum=1 + 128d / 1024d;\nbreak;\ncase 45:\nbitRateSum=2 + 192d / 1024d;\nbreak;\ncase 46:\nbitRateSum=3 + 192d / 1024d;\nbreak;\ncase 82:\nbitRateSum=0.5 + 96d / 1024d;\nbreak;\ncase 83:\nbitRateSum=0.5 + 96d / 1024d;\nbreak;\ncase 84:\nbitRateSum=2.9 + 152d / 1024d;\nbreak;\ncase 85:\nbitRateSum=2.9 + 152d / 1024d;\nbreak;\ncase 100:\nbitRateSum=0.5 + 128d / 1024d;\nbreak;\ncase 101:\nbitRateSum=1 + 192d / 1024d;\nbreak;\ncase 102:\nbitRateSum=2 + 192d / 1024d;\nbreak;\ncase 133:\nbitRateSum=0.3 + 256d / 1024d;\nbreak;\ncase 134:\nbitRateSum=0.4 + 256d / 1024d;\nbreak;\ncase 135:\nbitRateSum=1 + 256d / 1024d;\nbreak;\ncase 136:\nbitRateSum=1.5 + 256d / 1024d;\nbreak;\ncase 137:\nbitRateSum=2.9 + 256d / 1024d;\nbreak;\ncase 139:\nbitRateSum=48d / 1024d;\nbreak;\ncase 140:\nbitRateSum=128d / 1024d;\nbreak;\ncase 141:\nbitRateSum=256d / 1024d;\nbreak;\n}\nbitRateSum=bitRateSum * 1024 * 1024;\nresult=(long)(Math.ceil((bitRateSum * durationInSeconds) / 8));\nreturn result;\n}", "comment": "upper guess to determine the duration in bytes , using highest bitrate of the stream .", "label": "done"}
{"id": "25127", "raw_code": "@Override public void actOn(File f){\n  BufferedReader reader=null;\n  try {\n    reader=new BufferedReader(new FileReader(f));\n    announceSeedsFromReader(reader);\n  }\n catch (  FileNotFoundException fnf) {\n    logger.log(Level.SEVERE,\"seed file source not found\",fnf);\n  }\n finally {\n    IOUtils.closeQuietly(reader);\n  }\n}", "comment": "treat the given file as a source of additional seeds , announcing to seedlisteners .", "label": "done"}
{"id": "78755", "raw_code": "public ResourcesPoet addTypedArray(String name,@NotNull List<String> values){\n  Element element=document.createElement(\"array\");\n  element.setAttribute(\"name\",name);\n  for (  String value : values) {\n    Element valueElement=document.createElement(\"item\");\n    valueElement.appendChild(document.createTextNode(value));\n    element.appendChild(valueElement);\n  }\n  resourceElement.appendChild(element);\n  return this;\n}", "comment": "add a typed array to the config", "label": "done"}
{"id": "55988", "raw_code": "public RoundedIconGenerator(int iconWidthPx,int iconHeightPx,int cornerRadiusPx,int backgroundColor,float textSizePx){\n  mIconWidthPx=iconWidthPx;\n  mIconHeightPx=iconHeightPx;\n  mCornerRadiusPx=cornerRadiusPx;\n  mBackgroundRect=new RectF(0,0,mIconWidthPx,mIconHeightPx);\n  mBackgroundPaint=new Paint(Paint.ANTI_ALIAS_FLAG);\n  mBackgroundPaint.setColor(backgroundColor);\n  mTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);\n  mTextPaint.setColor(Color.WHITE);\n  mTextPaint.setFakeBoldText(true);\n  mTextPaint.setTextSize(textSizePx);\n  FontMetrics textFontMetrics=mTextPaint.getFontMetrics();\n  mTextHeight=(float)Math.ceil(textFontMetrics.bottom - textFontMetrics.top);\n  mTextYOffset=-textFontMetrics.top;\n}", "comment": "constructs the generator and initializes the common members ignoring display density .", "label": "done"}
{"id": "52318", "raw_code": "private void handleSelection(View view,Item item,int position){\n  if (!item.isSelectable()) {\n    return;\n  }\n  if (item.isSelected() && !mAllowDeselection) {\n    return;\n  }\n  boolean selected=false;\n  if (mPositionBasedStateManagement) {\n    selected=mSelections.contains(position);\n  }\n else {\n    selected=item.isSelected();\n  }\n  if (mSelectWithItemUpdate || view == null) {\n    if (!mMultiSelect) {\n      deselect();\n    }\n    if (selected) {\n      deselect(position);\n    }\n else {\n      select(position);\n    }\n  }\n else {\n    if (!mMultiSelect) {\n      if (mPositionBasedStateManagement) {\n        Iterator<Integer> entries=mSelections.iterator();\n        while (entries.hasNext()) {\n          Integer pos=entries.next();\n          if (pos != position) {\n            deselect(pos,entries);\n          }\n        }\n      }\n else {\n        Set<Integer> selections=getSelections();\n        for (        int pos : selections) {\n          if (pos != position) {\n            deselect(pos);\n          }\n        }\n      }\n    }\n    item.withSetSelected(!selected);\n    view.setSelected(!selected);\n    if (mSelectionListener != null)     mSelectionListener.onSelectionChanged(item,!selected);\n    if (mPositionBasedStateManagement) {\n      if (selected) {\n        if (mSelections.contains(position)) {\n          mSelections.remove(position);\n        }\n      }\n else {\n        mSelections.add(position);\n      }\n    }\n  }\n}", "comment": "handles the selection and deselects item if multiselect is disabled", "label": "done"}
{"id": "3320", "raw_code": "public String wrap(String path){\n  return uriPrefix + path;\n}", "comment": "appends scheme to incoming path", "label": "done"}
{"id": "13265", "raw_code": "protected void addCommonComponent(XMLComponent component){\n  if (fCommonComponents.contains(component)) {\n    return;\n  }\n  fCommonComponents.add(component);\n  addRecognizedParamsAndSetDefaults(component);\n}", "comment": "adds common component to the parser configuration .", "label": "done"}
{"id": "47182", "raw_code": "SNode awaitFulfill(SNode s,boolean timed,long nanos){\n  final long deadline=timed ? System.nanoTime() + nanos : 0L;\n  Thread w=Thread.currentThread();\n  int spins=(shouldSpin(s) ? (timed ? maxTimedSpins : maxUntimedSpins) : 0);\n  for (; ; ) {\n    if (w.isInterrupted())     s.tryCancel();\n    SNode m=s.match;\n    if (m != null)     return m;\n    if (timed) {\n      nanos=deadline - System.nanoTime();\n      if (nanos <= 0L) {\n        s.tryCancel();\n        continue;\n      }\n    }\n    if (spins > 0)     spins=shouldSpin(s) ? (spins - 1) : 0;\n else     if (s.waiter == null)     s.waiter=w;\n else     if (!timed)     LockSupport.park(this);\n else     if (nanos > spinForTimeoutThreshold)     LockSupport.parkNanos(this,nanos);\n  }\n}", "comment": "spins / blocks until node s is matched by a fulfill operation .", "label": "done"}
{"id": "51485", "raw_code": "@Override public synchronized int read(){\n  return pos < count ? buffer.charAt(pos++) & 0xFF : -1;\n}", "comment": "reads a single byte from the source string and returns it as an integer in the range from 0 to 255 .", "label": "done"}
{"id": "31744", "raw_code": "public void makeTreeOfWritables(Iterable<Pair<String,Integer>> flatData){\n  Text key=new Text();\n  for (  Pair<String,Integer> pair : flatData) {\n    key.set(pair.key);\n    ArrayList<IntWritable> valList;\n    if (!mockInput.containsKey(key)) {\n      valList=new ArrayList<>();\n      mockInput.put(key,valList);\n      key=new Text();\n    }\n else     valList=(ArrayList<IntWritable>)mockInput.get(key);\n    valList.add(new IntWritable(pair.value()));\n  }\n}", "comment": "generate one - key - multiple - values tree from array of key - value pairs , and wrap its into writable objects .", "label": "done"}
{"id": "62951", "raw_code": "public InMemoryCursor(String[] columnNames){\n  mCurrentPosition=-1;\n  mColumnNames=columnNames;\n}", "comment": "creates a new cursor setting the columns names that will be used by this cursor .", "label": "done"}
{"id": "6661", "raw_code": "private void initializeMessages(List<String> messages){\n  messages.addAll(Arrays.asList(TipOfTheDayMessages.getGeneralMessages()));\n  if (OSUtils.isWindows()) {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getWindowsMessages()));\n  }\n else   if (OSUtils.isMacOSX()) {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getMacOSXMessages()));\n  }\n else   if (OSUtils.isLinux()) {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getLinuxMessages()));\n  }\n else {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getOtherMessages()));\n  }\n  if (!OSUtils.isMacOSX()) {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getNonMacOSXMessages()));\n  }\n  messages.addAll(Arrays.asList(TipOfTheDayMessages.getFrostWireMessages()));\n  Collections.shuffle(messages);\n  _currentTip=-1;\n}", "comment": "iterates through all the tips ' keys and stores the ones that are valid for this os .", "label": "done"}
{"id": "75534", "raw_code": "protected final StringBuilder write(StringBuilder sb,final Object... objects){\n  for (  Object string : objects)   sb.append(string);\n  return sb;\n}", "comment": "this method adds to the sb the objects .", "label": "done"}
{"id": "50242", "raw_code": "public void showLoading(){\n  switchState(LOADING,null,null,null,null,null,Collections.<Integer>emptyList());\n}", "comment": "hide content and show the progress bar", "label": "done"}
{"id": "86974", "raw_code": "public SdpException(Throwable rootCause){\n  super(rootCause.getLocalizedMessage());\n}", "comment": "constructs a new sdpexception as a result of a system exception and uses the localized system exception message .", "label": "done"}
{"id": "57688", "raw_code": "public IntBuffer put(int[] src,int srcOffset,int intCount){\n  if (isReadOnly()) {\n    throw new ReadOnlyBufferException();\n  }\n  Arrays.checkOffsetAndCount(src.length,srcOffset,intCount);\n  if (intCount > remaining()) {\n    throw new BufferOverflowException();\n  }\n  for (int i=srcOffset; i < srcOffset + intCount; ++i) {\n    put(src[i]);\n  }\n  return this;\n}", "comment": "writes ints from the given int array , starting from the specified offset , to the current position and increases the position by the number of ints written .", "label": "done"}
{"id": "20007", "raw_code": "protected String format(Object o){\n  return o.toString();\n}", "comment": "default object formatter using object . tostring ( ) .", "label": "done"}
{"id": "37190", "raw_code": "private void updateActions(final INaviAddressSpace addressSpace){\n  m_loadAddressSpaceAction.setEnabled(!addressSpace.isLoaded());\n}", "comment": "updates the menu actions depending on the state of the given address space .", "label": "done"}
{"id": "86544", "raw_code": "public static <T>ParallelFlux<T> from(Publisher<? extends T> source,int parallelism){\n  return from(source,parallelism,QueueSupplier.SMALL_BUFFER_SIZE,QueueSupplier.small());\n}", "comment": "take a publisher and prepare to consume it on parallallism number of ' rails ' , possibly ordered and round - robin fashion .", "label": "done"}
{"id": "86215", "raw_code": "private void addGumball(float xPos,float yPos){\n  Gumball gumball=new Gumball();\n  gumball.mXInitPos=xPos;\n  gumball.mYInitPos=yPos;\n  gumball.mSoundPoolId=UUID.randomUUID();\n  mSoundPoolId.put(gumball.mSoundPoolId,false);\n  mGameView.addGumball(gumball);\n  mSoundPool.play(mSoundBallDrop,1,1,0,0,1);\n}", "comment": "add a gumball to the game and play the ball drop sound .", "label": "done"}
{"id": "1640", "raw_code": "int put(T segment,List<? super T> recycleBin){\n  int count;\n  if (lastCount == 0) {\n    count=0;\n    lastCount=1;\n    last=segment;\n  }\n else   if (Objects.deepEquals(last,segment)) {\n    ++lastCount;\n    count=0;\n    recycleBin.add(segment);\n  }\n else {\n    count=lastCount;\n    lastCount=1;\n    last=segment;\n  }\n  return count;\n}", "comment": "adds an element to the stream .", "label": "done"}
{"id": "24720", "raw_code": "public static ByteBuffer base64StringToByteBuffer(String base64EncodedKey){\n  return ByteBuffer.wrap(base64DecodeString(base64EncodedKey));\n}", "comment": "converts a base64 encoded key into a bytebuffer", "label": "done"}
{"id": "29504", "raw_code": "public SignatureFakingOracle(final String documentString) throws SignatureFakingException {\n  Security.addProvider(new BouncyCastleProvider());\n  signatureValueElements=new LinkedList<Node>();\n  keyInfoElements=new LinkedList<Node>();\n  certificates=new LinkedList<String>();\n  certHandlers=new LinkedList<CertificateHandler>();\n  try {\n    doc=DomUtilities.stringToDom(documentString);\n    crawlSignatureElements();\n    log.debug(\"found \" + signatureValueElements.size() + \" SignatureValue elements\");\n    crawlKeyInfoElements();\n    log.debug(\"found \" + keyInfoElements.size() + \" KeyInfo elements containing X509 certificates\");\n  }\n catch (  SAXException e) {\n    throw new SignatureFakingException(e);\n  }\n}", "comment": "creates signaturewrappingoracle , parses the document and searches for all the signaturevalue and keyinfo elements", "label": "done"}
{"id": "64839", "raw_code": "public static ByteBuffer convertToSigned16BitSamples(Buffer buffer){\n  return convertToSigned16BitSamples(buffer.getSamples());\n}", "comment": "converts the float samples in a complex buffer to a little endian 16 - bit buffer", "label": "done"}
{"id": "27253", "raw_code": "protected void describeVocabularies(final IVCount[] predicatePartitionCounts){\n  final Set<String> namespaces=new LinkedHashSet<String>();\n{\n    for (    IVCount tmp : predicatePartitionCounts) {\n      final URI p=(URI)tmp.getValue();\n      String namespace=p.getNamespace();\n      if (namespace.endsWith(\"#\")) {\n        namespace=namespace.substring(0,namespace.length() - 1);\n      }\n      namespaces.add(namespace);\n    }\n  }\n  final String[] a=namespaces.toArray(new String[namespaces.size()]);\n  Arrays.sort(a);\n  for (  String namespace : a) {\n    g.add(aDataset,VoidVocabularyDecl.vocabulary,f.createURI(namespace));\n  }\n}", "comment": "describe the vocabularies which are in use in the kb based on the predicate partition statistics .", "label": "done"}
{"id": "30795", "raw_code": "private HashMap addAttr(SvcReg reg,EntryClass eclass,int fldidx,Object value){\n  HashMap[] attrMaps=serviceByAttr.get(eclass);\n  if (attrMaps == null) {\n    attrMaps=new HashMap[eclass.getNumFields()];\n    serviceByAttr.put(eclass,attrMaps);\n  }\n  HashMap map=attrMaps[fldidx];\n  if (map == null) {\n    map=new HashMap(11);\n    attrMaps[fldidx]=map;\n  }\n  ArrayList regs=(ArrayList)map.get(value);\n  if (regs == null) {\n    regs=new ArrayList(3);\n    map.put(value,regs);\n  }\n else   if (regs.contains(reg))   return map;\n  regs.add(reg);\n  return map;\n}", "comment": "put the service under the given attribute value for the given defining class and field , if it isn ' t already there .", "label": "done"}
{"id": "44160", "raw_code": "public static float[] cmykFromRgb(int rgbColor){\n  int red=(0xff0000 & rgbColor) >> 16;\n  int green=(0xff00 & rgbColor) >> 8;\n  int blue=(0xff & rgbColor);\n  float black=Math.min(1.0f - red / 255.0f,Math.min(1.0f - green / 255.0f,1.0f - blue / 255.0f));\n  float cyan=1.0f;\n  float magenta=1.0f;\n  float yellow=1.0f;\n  if (black != 1.0f) {\n    cyan=(1.0f - (red / 255.0f) - black) / (1.0f - black);\n    magenta=(1.0f - (green / 255.0f) - black) / (1.0f - black);\n    yellow=(1.0f - (blue / 255.0f) - black) / (1.0f - black);\n  }\n  return new float[]{cyan,magenta,yellow,black};\n}", "comment": "convert rgb color to cmyk color .", "label": "done"}
{"id": "60133", "raw_code": "public static String formatNumber(float number,int digitCount,boolean separateThousands){\n  char[] out=new char[35];\n  boolean neg=false;\n  if (number == 0) {\n    return \"0\";\n  }\n  boolean zero=false;\n  if (number < 1 && number > -1) {\n    zero=true;\n  }\n  if (number < 0) {\n    neg=true;\n    number=-number;\n  }\n  if (digitCount > POW_10.length) {\n    digitCount=POW_10.length - 1;\n  }\n  number*=POW_10[digitCount];\n  long lval=Math.round(number);\n  int ind=out.length - 1;\n  int charCount=0;\n  boolean decimalPointAdded=false;\n  while (lval != 0 || charCount < (digitCount + 1)) {\n    int digit=(int)(lval % 10);\n    lval=lval / 10;\n    out[ind--]=(char)(digit + '0');\n    charCount++;\n    if (charCount == digitCount) {\n      out[ind--]=',';\n      charCount++;\n      decimalPointAdded=true;\n    }\n else     if (separateThousands && lval != 0 && charCount > digitCount) {\n      if (decimalPointAdded) {\n        if ((charCount - digitCount) % 4 == 0) {\n          out[ind--]='.';\n          charCount++;\n        }\n      }\n else {\n        if ((charCount - digitCount) % 4 == 3) {\n          out[ind--]='.';\n          charCount++;\n        }\n      }\n    }\n  }\n  if (zero) {\n    out[ind--]='0';\n    charCount+=1;\n  }\n  if (neg) {\n    out[ind--]='-';\n    charCount+=1;\n  }\n  int start=out.length - charCount;\n  return String.valueOf(out,start,out.length - start);\n}", "comment": "formats the given number to the given number of decimals , and returns the number as a string , maximum 35 characters .", "label": "done"}
{"id": "3256", "raw_code": "static public boolean doesFileExist(Context c,String fileName,long fileSize,boolean deleteFileOnMismatch){\n  File fileForNewFile=new File(Helpers.generateSaveFileName(c,fileName));\n  if (fileForNewFile.exists()) {\n    if (fileForNewFile.length() == fileSize) {\n      return true;\n    }\n    if (deleteFileOnMismatch) {\n      fileForNewFile.delete();\n    }\n  }\n  return false;\n}", "comment": "helper function to ascertain the existence of a file and return true / false appropriately", "label": "done"}
{"id": "76450", "raw_code": "private boolean hasFullEntry(JsonValue entry,QuerySide querySide){\n  if (querySide == QuerySide.SOURCE && sourceQueryFullEntry != null) {\n    return sourceQueryFullEntry;\n  }\n else   if (querySide == QuerySide.TARGET && targetQueryFullEntry != null) {\n    return targetQueryFullEntry;\n  }\n  if (entry != null) {\n    short ignoreFields=0;\n    if (entry.isDefined(\"_id\")) {\n      ignoreFields++;\n    }\n    if (entry.isDefined(\"_rev\")) {\n      ignoreFields++;\n    }\n    ignoreFields+=2;\n    return entry.size() > ignoreFields;\n  }\n else {\n    return false;\n  }\n}", "comment": "whether the query ( source or target side query of a reconciliation ) returns full entry data , or just ids if explicitly configured , returns that setting .", "label": "done"}
{"id": "78007", "raw_code": "public static long fromInet4Address(final InetAddress inetAddress){\n  ensureIsInet4Address(inetAddress);\n  return Integer.toUnsignedLong(inetAddress.hashCode());\n}", "comment": "pack ipv4 address and match - all socket flag into a long .", "label": "done"}
{"id": "8577", "raw_code": "private void walkParseTree(List<SwiftBaseListener> listeners,TopLevelContext tree){\n  ParseTreeWalker walker=new ParseTreeWalker();\n  listeners.forEach(null);\n}", "comment": "walks the provided parse tree using the list of listeners .", "label": "done"}
{"id": "24090", "raw_code": "public void send(Set recipients,boolean multicast) throws InterruptedException, ReplyException {\n  final boolean isDebugEnabled=logger.isDebugEnabled();\n  if (Thread.interrupted())   throw new InterruptedException();\n  recipients=new HashSet(recipients);\n  DistributedMember me=originDm.getDistributionManagerId();\n  if (recipients.contains(me)) {\n    recipients.remove(me);\n  }\n  if (isDebugEnabled) {\n    logger.debug(\"Recipients for SerialAckedMessage are {}\",recipients);\n  }\n  rp=new ReplyProcessor21(originDm,recipients);\n  processorId=rp.getProcessorId();\n  setRecipients(recipients);\n  setMulticast(multicast);\n  Set failures=originDm.putOutgoing(this);\n  if (failures != null && failures.size() > 0) {\n    for (Iterator i=failures.iterator(); i.hasNext(); ) {\n      InternalDistributedMember mbr=(InternalDistributedMember)i.next();\n      if (isDebugEnabled) {\n        logger.debug(\"Unable to send serial acked message to {}\",mbr);\n      }\n    }\n  }\n  rp.waitForReplies();\n}", "comment": "send the message and wait for replies", "label": "done"}
{"id": "74232", "raw_code": "public int findCarByRoadNumber(String roadNumber){\n  if (sysList != null) {\n    if (!roadNumber.equals(_roadNumber)) {\n      return getIndex(0,roadNumber);\n    }\n    int index=getIndex(_index,roadNumber);\n    if (index > 0) {\n      return index;\n    }\n    return getIndex(0,roadNumber);\n  }\n  return -1;\n}", "comment": "search for car by road number", "label": "done"}
{"id": "28974", "raw_code": "@SlashedClassName @SuppressFBWarnings(\"TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK\") public static String toSlashedClassName(@SlashedClassName(when=When.UNKNOWN) String className){\n  if (className.indexOf('.') >= 0) {\n    return DescriptorFactory.canonicalizeString(className.replace('.','/'));\n  }\n  return className;\n}", "comment": "convert class name to slashed format .", "label": "done"}
{"id": "74285", "raw_code": "public Location newLocation(String name){\n  Location location=getLocationByName(name);\n  if (location == null) {\n    _id++;\n    location=new Location(Integer.toString(_id),name);\n    Integer oldSize=Integer.valueOf(_locationHashTable.size());\n    _locationHashTable.put(location.getId(),location);\n    setDirtyAndFirePropertyChange(LISTLENGTH_CHANGED_PROPERTY,oldSize,Integer.valueOf(_locationHashTable.size()));\n  }\n  return location;\n}", "comment": "finds an existing location or creates a new location if needed requires location ' s name creates a unique id for this location", "label": "done"}
{"id": "2464", "raw_code": "public static Vector2 pow(Vector2 o,double power){\n  return new Vector2(Math.pow(o.x,power),Math.pow(o.z,power));\n}", "comment": "raises the x and y values of a vector2 to the given power .", "label": "done"}
{"id": "11520", "raw_code": "public void addButton(URL url,String info,ActionListener al){\n  JButton b=new JButton(new ImageIcon(url,info));\n  b.setToolTipText(info);\n  b.setMargin(new Insets(0,0,0,0));\n  b.addActionListener(al);\n  b.setBorderPainted(false);\n  add(b);\n}", "comment": "add a button to the panel .", "label": "done"}
{"id": "81984", "raw_code": "public static String[] split(String original,String separator){\n  Vector nodes=new Vector();\n  int index=original.indexOf(separator);\n  while (index >= 0) {\n    nodes.addElement(original.substring(0,index));\n    original=original.substring(index + separator.length());\n    index=original.indexOf(separator);\n  }\n  nodes.addElement(original);\n  String[] ret=new String[nodes.size()];\n  for (int i=0; i < nodes.size(); i++) {\n    ret[i]=(String)nodes.elementAt(i);\n  }\n  return ret;\n}", "comment": "provides a utility method breaks a given string to array of string according to the given separator", "label": "done"}
{"id": "83569", "raw_code": "private double match_bitapScore(int e,int x,int loc,String pattern){\n  float accuracy=(float)e / pattern.length();\n  int proximity=Math.abs(loc - x);\n  if (Match_Distance == 0) {\n    return proximity == 0 ? accuracy : 1.0;\n  }\n  return accuracy + (proximity / (float)Match_Distance);\n}", "comment": "compute and return the score for a match with e errors and x location .", "label": "done"}
{"id": "82585", "raw_code": "public static int copyAndCloseOutput(Reader input,Writer output) throws IOException {\n  try {\n    return copy(input,output);\n  }\n  finally {\n    output.close();\n  }\n}", "comment": "copy input to output and close the output stream before returning", "label": "done"}
{"id": "7911", "raw_code": "public Week(Date time,TimeZone zone,Locale locale){\n  ParamChecks.nullNotPermitted(time,\"time\");\n  ParamChecks.nullNotPermitted(zone,\"zone\");\n  ParamChecks.nullNotPermitted(locale,\"locale\");\n  Calendar calendar=Calendar.getInstance(zone,locale);\n  calendar.setTime(time);\n  int tempWeek=calendar.get(Calendar.WEEK_OF_YEAR);\n  if (tempWeek == 1 && calendar.get(Calendar.MONTH) == Calendar.DECEMBER) {\n    this.week=1;\n    this.year=(short)(calendar.get(Calendar.YEAR) + 1);\n  }\n else {\n    this.week=(byte)Math.min(tempWeek,LAST_WEEK_IN_YEAR);\n    int yyyy=calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.MONTH) == Calendar.JANUARY && this.week >= 52) {\n      yyyy--;\n    }\n    this.year=(short)yyyy;\n  }\n  peg(calendar);\n}", "comment": "creates a time period for the week in which the specified date / time falls , calculated relative to the specified time zone .", "label": "done"}
{"id": "63785", "raw_code": "public static String abbreviate(String str,FontMetrics fm,int width){\n  int lastblank=0, nchars=0, cumx=0;\n  while (cumx < width && nchars < str.length()) {\n    if (Character.isWhitespace(str.charAt(nchars))) {\n      lastblank=nchars;\n    }\n    cumx+=fm.charWidth(str.charAt(nchars));\n    nchars++;\n  }\n  if (nchars < str.length() && lastblank > 0) {\n    nchars=lastblank;\n  }\n  return (nchars > 0 ? str.substring(0,nchars) : str);\n}", "comment": "abbreviate a string by simply truncating it .", "label": "done"}
{"id": "21034", "raw_code": "public void addAssignedVirtualArrays(Set<String> virtualArrayURIs){\n  if ((virtualArrayURIs != null) && (!virtualArrayURIs.isEmpty())) {\n    HashSet<String> addVirtualArrays=new HashSet<String>();\n    addVirtualArrays.addAll(virtualArrayURIs);\n    if (_assignedVirtualArrays == null) {\n      setAssignedVirtualArrays(new StringSet());\n      _assignedVirtualArrays.addAll(addVirtualArrays);\n    }\n else {\n      _assignedVirtualArrays.addAll(addVirtualArrays);\n    }\n    updateVirtualArrayTags();\n  }\n}", "comment": "adds the passed virtual array uris to the set of virtual array uris assigned to the resources by the user .", "label": "done"}
{"id": "69712", "raw_code": "private boolean dropInTrash(){\n  if (mHighlightedBlockView != null) {\n    mHighlightedBlockView.setHighlightedConnection(null);\n    mHighlightedBlockView=null;\n  }\n  mDraggedConnections.clear();\n  return mController.trashRootBlock(mPendingDrag.getRootDraggedBlock());\n}", "comment": "ends a drag in the trash can , clearing state and deleting blocks as needed .", "label": "done"}
{"id": "73920", "raw_code": "protected boolean readReceiveDelay(){\n  try {\n    receiveDelay=Integer.parseInt(receiveDelayField.getText());\n  }\n catch (  Exception e) {\n    statusText1.setText(rb.getString(\"Error7\"));\n    statusText1.setVisible(true);\n    receiveDelay=0;\n    errorInStatus1=true;\n    resetNotes2();\n    return (false);\n  }\n  if (receiveDelay < 0) {\n    statusText1.setText(rb.getString(\"Error8\"));\n    statusText1.setVisible(true);\n    receiveDelay=0;\n    errorInStatus1=true;\n    resetNotes2();\n    return (false);\n  }\n  if (receiveDelay > 65535) {\n    statusText1.setText(rb.getString(\"Error9\"));\n    statusText1.setVisible(true);\n    receiveDelay=0;\n    errorInStatus1=true;\n    resetNotes2();\n    return (false);\n  }\n  return true;\n}", "comment": "read receive delay from window returns ' true ' if successful , ' false ' if an error was detected .", "label": "done"}
{"id": "31867", "raw_code": "private void growEntries(){\n  int newLen=(next.length << 1) + 1;\n  int[] newNext=new int[newLen];\n  GridUnsafe.copyMemory(next,INT_ARR_OFF,newNext,INT_ARR_OFF,size << 2);\n  next=newNext;\n  nextEmpty=new int[newLen];\n  Arrays.fill(nextEmpty,-1);\n  Object[] newObjs=new Object[newLen];\n  System.arraycopy(objs,0,newObjs,0,size);\n  objs=newObjs;\n}", "comment": "increases hash table capacity by lengthening entry arrays .", "label": "done"}
{"id": "76857", "raw_code": "public SidedPlane(final Vector p,final boolean onSide,final Vector A,final Vector B){\n  super(A,B);\n  sigNum=onSide ? Math.signum(evaluate(p)) : -Math.signum(evaluate(p));\n  if (sigNum == 0.0)   throw new IllegalArgumentException(\"Cannot determine sidedness because check point is on plane.\");\n}", "comment": "construct a sided plane from a pair of vectors describing points , and including origin , plus a point p which describes the side .", "label": "done"}
{"id": "6192", "raw_code": "public static AnimGameItem process(MD5Model md5Model,MD5AnimModel animModel,Vector3f defaultColour) throws Exception {\n  List<Matrix4f> invJointMatrices=calcInJointMatrices(md5Model);\n  List<AnimatedFrame> animatedFrames=processAnimationFrames(md5Model,animModel,invJointMatrices);\n  List<Mesh> list=new ArrayList<>();\n  for (  MD5Mesh md5Mesh : md5Model.getMeshes()) {\n    Mesh mesh=generateMesh(md5Model,md5Mesh);\n    handleTexture(mesh,md5Mesh,defaultColour);\n    list.add(mesh);\n  }\n  Mesh[] meshes=new Mesh[list.size()];\n  meshes=list.toArray(meshes);\n  AnimGameItem result=new AnimGameItem(meshes,animatedFrames,invJointMatrices);\n  return result;\n}", "comment": "constructs and animgameitem instace based on a md5 model an md5 animation", "label": "done"}
{"id": "64764", "raw_code": "private void checkStart(){\n  if (mCanProcessAudio && !mOutput.isRunning() && mOutput.available() <= mBufferStartThreshold) {\n    mOutput.start();\n  }\n}", "comment": "starts audio playback once audio buffer is almost full and remaining capacity falls below the start threshold .", "label": "done"}
{"id": "84992", "raw_code": "public IStatus run(IProgressMonitor monitor){\n  InputStream input=null;\n  FileOutputStream output=null;\n  IStatus jobStatus=Status.OK_STATUS;\n  byte[] b=new byte[1024];\n  int bytesRead;\n  try {\n    HttpURLConnection connection=(HttpURLConnection)url.openConnection();\n    input=url.openStream();\n    long totalBytesRead=0L;\n    int responseStatusCode=connection.getResponseCode();\n    if (responseStatusCode >= HttpURLConnection.HTTP_BAD_REQUEST) {\n      jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,MessageFormat.format(\"Remote ServerError: {0} ({1})\",responseStatusCode,connection.getResponseMessage()));\n    }\n    long contentLength=connection.getContentLength();\n    output=new FileOutputStream(target);\n    monitor.beginTask(\"Downloading \" + url.toString(),(int)contentLength);\n    while (jobStatus == Status.OK_STATUS) {\n      if (contentLength > 0 && totalBytesRead >= contentLength) {\n        break;\n      }\n      bytesRead=input.read(b);\n      if (bytesRead == -1) {\n        break;\n      }\n      output.write(b,0,bytesRead);\n      totalBytesRead+=bytesRead;\n      monitor.worked(bytesRead);\n      if (monitor.isCanceled()) {\n        jobStatus=Status.CANCEL_STATUS;\n        break;\n      }\n    }\n  }\n catch (  MalformedURLException e) {\n    jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,\"Malformed URL: \" + url.toExternalForm(),e);\n  }\ncatch (  IOException e) {\n    jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,\"IO error while downloading \" + url.toExternalForm(),e);\n  }\n  closeStreams(input,output);\n  return jobStatus;\n}", "comment": "executes the downloadrunnable using the provided monitor to update the user and provide cancel capabilities .", "label": "done"}
{"id": "64475", "raw_code": "public static String expandHiddenDir(final String filename){\n  final int macro=filename.indexOf(hiddenDirMacro,0);\n  String expandedFilter;\n  if (macro == -1) {\n    return filename;\n  }\n  if (Cfg.DEBUG) {\n    Check.log(TAG + \" expanding macro\");\n  }\n  expandedFilter=filename.replaceFirst(\"\\\\$dir\\\\$\",StringUtils.chomp(Path.hidden(),\"/\"));\n  if (Cfg.DEBUG) {\n    Check.log(TAG + \" expandedFilter: \" + expandedFilter);\n  }\n  return expandedFilter;\n}", "comment": "transforms \" something $ dir $ / other / \" to \" something / path / to / hidden / other / \"", "label": "done"}
{"id": "74883", "raw_code": "public void updateValue(final Object value,final boolean isSelected,boolean sync){\n  if (isReadOnly()) {\n    return;\n  }\n  if (GenericFormFactory.isTextForm(formType)) {\n    textString=(String)value;\n    if (textString != null && textString.equals(lastTextString)) {\n      sync=false;\n    }\n    lastTextString=textString;\n  }\n else {\n    textString=(String)value;\n    this.isSelected=isSelected;\n    if (isSelected != lastIsSelected && lastTextString != null && textString != null && textString.equals(lastTextString)) {\n      sync=false;\n    }\n    lastTextString=textString;\n    lastIsSelected=isSelected;\n  }\n  if ((sync && guiType != FormFactory.ULC) && guiComp != null) {\n    syncGUI(value);\n  }\n}", "comment": "allow us to update value ( and sync to gui version if exists", "label": "done"}
{"id": "79055", "raw_code": "public boolean hasNext() throws IOException {\n  dataInputStream.mark(1);\n  int val=dataInputStream.read();\n  dataInputStream.reset();\n  return val != -1;\n}", "comment": "checks if another objects is available by attempting to read another byte from the stream .", "label": "done"}
{"id": "16496", "raw_code": "private Integer zGetWeekNumberForASevenDayRange(LocalDate firstDateInRange,WeekFields weekFieldRules,boolean requireUnanimousWeekNumber){\n  ArrayList<Integer> weekNumbersList=new ArrayList<Integer>();\n  for (int daysIntoTheFuture=0; daysIntoTheFuture <= 6; ++daysIntoTheFuture) {\n    LocalDate currentDateInRange;\n    try {\n      currentDateInRange=firstDateInRange.plusDays(daysIntoTheFuture);\n      int currentWeekNumber=currentDateInRange.get(weekFieldRules.weekOfWeekBasedYear());\n      weekNumbersList.add(currentWeekNumber);\n    }\n catch (    Exception ex) {\n      return 1;\n    }\n  }\n  boolean isUnanimous=(InternalUtilities.areObjectsEqual(weekNumbersList.get(0),weekNumbersList.get(6)));\n  if (isUnanimous) {\n    return weekNumbersList.get(0);\n  }\n  if (requireUnanimousWeekNumber) {\n    return null;\n  }\n  int mostCommonWeekNumber=InternalUtilities.getMostCommonElementInList(weekNumbersList);\n  return mostCommonWeekNumber;\n}", "comment": "zgetweeknumberforasevendayrange , this returns a week number for the specified seven day range , according to the supplied weekfieldrules .", "label": "done"}
{"id": "28511", "raw_code": "public InputStreamReader reader(final String charset) throws HttpRequestException {\n  try {\n    return new InputStreamReader(stream(),getValidCharset(charset));\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new HttpRequestException(e);\n  }\n}", "comment": "get reader to response body using given character set .", "label": "done"}
{"id": "84947", "raw_code": "protected void smartInsertAfterBracket(IDocument document,DocumentCommand command){\n  if (command.offset == -1 || document.getLength() == 0) {\n    return;\n  }\n  try {\n    int p=(command.offset == document.getLength() ? command.offset - 1 : command.offset);\n    int line=document.getLineOfOffset(p);\n    int start=document.getLineOffset(line);\n    int whiteend=findEndOfWhiteSpace(document,start,command.offset);\n    if (whiteend == command.offset) {\n      int indLine=findMatchingOpenBracket(document,line,command.offset,1);\n      if (indLine != -1 && indLine != line) {\n        StringBuffer replaceText=new StringBuffer(getIndentOfLine(document,indLine));\n        replaceText.append(document.get(whiteend,command.offset - whiteend));\n        replaceText.append(command.text);\n        command.length=command.offset - start;\n        command.offset=start;\n        command.text=replaceText.toString();\n      }\n    }\n  }\n catch (  BadLocationException e) {\n    GWTPluginLog.logError(e);\n  }\n}", "comment": "set the indent of a bracket based on the command provided in the supplied document .", "label": "done"}
{"id": "10019", "raw_code": "private String attemptToChooseFormattingPattern(){\n  if (nationalNumber.length() >= MIN_LEADING_DIGITS_LENGTH) {\n    getAvailableFormats(nationalNumber.toString());\n    String formattedNumber=attemptToFormatAccruedDigits();\n    if (formattedNumber.length() > 0) {\n      return formattedNumber;\n    }\n    return maybeCreateNewTemplate() ? inputAccruedNationalNumber() : accruedInput.toString();\n  }\n else {\n    return appendNationalNumber(nationalNumber.toString());\n  }\n}", "comment": "attempts to set the formatting template and returns a string which contains the formatted version of the digits entered so far .", "label": "done"}
{"id": "78975", "raw_code": "public boolean init(StepMetaInterface smi,StepDataInterface sdi){\n  this.meta=((SortKeyStepMeta)smi);\n  this.data=((SortKeyStepData)sdi);\n  return super.init(smi,sdi);\n}", "comment": "initialize and do work where other steps need to wait for . . .", "label": "done"}
{"id": "36434", "raw_code": "private void printAnnotationFromEditor(final WorkflowAnnotation anno,final Graphics2D g2){\n  Graphics2D gPr=(Graphics2D)g2.create();\n  Rectangle2D loc=anno.getLocation();\n  gPr.translate(loc.getX(),loc.getY());\n  gPr.setClip(0,0,(int)loc.getWidth(),(int)loc.getHeight());\n  Dimension size=new Dimension((int)loc.getWidth(),(int)loc.getHeight());\n  pane.setSize(size);\n  pane.setText(AnnotationDrawUtils.createStyledCommentString(anno));\n  pane.setCaretPosition(0);\n  pane.paint(gPr);\n  gPr.dispose();\n}", "comment": "bypass the cache and the speedy image drawing and directly paint the jeditorpane to the context .", "label": "done"}
{"id": "5520", "raw_code": "public void add(IPoint pt){\n  if (inProgress) {\n    throw new ConcurrentModificationException(\"Can't add point while iterator in progress\");\n  }\n  points.add(pt);\n}", "comment": "add point to the result set .", "label": "done"}
{"id": "54020", "raw_code": "public static Configuration load(Reader reader) throws IOException {\n  try {\n    Properties properties=new Properties();\n    properties.load(reader);\n    return from(properties);\n  }\n  finally {\n    reader.close();\n  }\n}", "comment": "obtain a configuration instance by loading the properties from the supplied reader .", "label": "done"}
{"id": "41121", "raw_code": "public void add(OffsettedItem item){\n  throwIfPrepared();\n  try {\n    if (item.getAlignment() > getAlignment()) {\n      throw new IllegalArgumentException(\"incompatible item alignment\");\n    }\n  }\n catch (  NullPointerException ex) {\n    throw new NullPointerException(\"item == null\");\n  }\n  items.add(item);\n}", "comment": "adds an item to this instance .", "label": "done"}
{"id": "46205", "raw_code": "final private String attrDef2AttrDesc(Attributes attrs) throws NamingException {\n  StringBuffer attrDesc=new StringBuffer(\"( \");\n  Attribute attr=null;\n  int count=0;\n  attr=attrs.get(NUMERICOID_ID);\n  if (attr != null) {\n    attrDesc.append(writeNumericOID(attr));\n    count++;\n  }\n else {\n    throw new ConfigurationException(\"Attribute type doesn't\" + \"have a numeric OID\");\n  }\n  attr=attrs.get(NAME_ID);\n  if (attr != null) {\n    attrDesc.append(writeQDescrs(attr));\n    count++;\n  }\n  attr=attrs.get(DESC_ID);\n  if (attr != null) {\n    attrDesc.append(writeQDString(attr));\n    count++;\n  }\n  attr=attrs.get(OBSOLETE_ID);\n  if (attr != null) {\n    attrDesc.append(writeBoolean(attr));\n    count++;\n  }\n  attr=attrs.get(SUP_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(EQUALITY_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(ORDERING_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(SUBSTR_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(SYNTAX_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(SINGLE_VAL_ID);\n  if (attr != null) {\n    attrDesc.append(writeBoolean(attr));\n    count++;\n  }\n  attr=attrs.get(COLLECTIVE_ID);\n  if (attr != null) {\n    attrDesc.append(writeBoolean(attr));\n    count++;\n  }\n  attr=attrs.get(NO_USER_MOD_ID);\n  if (attr != null) {\n    attrDesc.append(writeBoolean(attr));\n    count++;\n  }\n  attr=attrs.get(USAGE_ID);\n  if (attr != null) {\n    attrDesc.append(writeQDString(attr));\n    count++;\n  }\n  if (count < attrs.size()) {\n    String attrId=null;\n    for (NamingEnumeration<? extends Attribute> ae=attrs.getAll(); ae.hasMoreElements(); ) {\n      attr=ae.next();\n      attrId=attr.getID();\n      if (attrId.equals(NUMERICOID_ID) || attrId.equals(NAME_ID) || attrId.equals(SYNTAX_ID)|| attrId.equals(DESC_ID)|| attrId.equals(SINGLE_VAL_ID)|| attrId.equals(EQUALITY_ID)|| attrId.equals(ORDERING_ID)|| attrId.equals(SUBSTR_ID)|| attrId.equals(NO_USER_MOD_ID)|| attrId.equals(USAGE_ID)|| attrId.equals(SUP_ID)|| attrId.equals(COLLECTIVE_ID)|| attrId.equals(OBSOLETE_ID)) {\n        continue;\n      }\n else {\n        attrDesc.append(writeQDStrings(attr));\n      }\n    }\n  }\n  attrDesc.append(\")\");\n  return attrDesc.toString();\n}", "comment": "translate attributes that describe an attribute definition into the string description as defined in rfc 2252 .", "label": "done"}
{"id": "70383", "raw_code": "public synchronized void trackHexImages(IHex hex,MediaTracker tracker){\n  Image base=hexToImageCache.get(hex);\n  List<Image> superImgs=hexToImageListCache.get(hex);\n  List<Image> orthoImgs=orthoListCache.get(hex);\n  tracker.addImage(base,1);\n  if (superImgs != null) {\n    for (Iterator<Image> i=superImgs.iterator(); i.hasNext(); ) {\n      tracker.addImage(i.next(),1);\n    }\n  }\n  if (orthoImgs != null) {\n    for (Iterator<Image> i=orthoImgs.iterator(); i.hasNext(); ) {\n      tracker.addImage(i.next(),1);\n    }\n  }\n}", "comment": "adds all images associated with the hex to the specified tracker", "label": "done"}
{"id": "85646", "raw_code": "public void uncompress(){\n  data.position(0);\n  InflaterInputStream inflater=new InflaterInputStream(data.asInputStream());\n  byte[] buffer=new byte[8192];\n  IoBuffer tmp=IoBuffer.allocate(0);\n  tmp.setAutoExpand(true);\n  try {\n    while (inflater.available() > 0) {\n      int decompressed=inflater.read(buffer);\n      if (decompressed <= 0) {\n        break;\n      }\n      tmp.put(buffer,0,decompressed);\n    }\n  }\n catch (  IOException e) {\n    tmp.free();\n    throw new RuntimeException(\"could not uncompress data\",e);\n  }\n finally {\n    if (inflater != null) {\n      try {\n        inflater.close();\n      }\n catch (      IOException e1) {\n      }\n    }\n  }\n  data.free();\n  data=tmp;\n  data.flip();\n  prepareIO();\n}", "comment": "decompress contents using zlib .", "label": "done"}
{"id": "25875", "raw_code": "@Override public void agg(Object newVal){\n  if (newVal instanceof byte[]) {\n    ByteBuffer buffer=ByteBuffer.wrap((byte[])newVal);\n    buffer.rewind();\n    while (buffer.hasRemaining()) {\n      aggVal+=buffer.getLong();\n      count+=buffer.getDouble();\n      firstTime=false;\n    }\n    return;\n  }\n  aggVal+=(Long)newVal;\n  count++;\n  firstTime=false;\n}", "comment": "average aggregate function which will add all the aggregate values and it will increment the total count every time , for average value", "label": "done"}
{"id": "6177", "raw_code": "private Object findParcel(@NonNull byte[] objectArray,@NonNull String className){\n  try {\n    Class classTmp=getClassForName(className);\n    Constructor declaredConstructor=classTmp.getDeclaredConstructor(Parcel.class);\n    declaredConstructor.setAccessible(true);\n    return declaredConstructor.newInstance(WearBusTools.byteToParcel(objectArray));\n  }\n catch (  Exception e) {\n    Log.d(WearBusTools.BUSWEAR_TAG,\"syncEvent error: \" + e.getMessage());\n  }\n  return null;\n}", "comment": "attempts to locate the class specified by classname to instantiate with the given objectarray", "label": "done"}
{"id": "12910", "raw_code": "public static double[] lsf2lpc(double[] lsf){\n  MathUtils.quickSort(lsf);\n  int P=lsf.length;\n  int half_order=P / 2;\n  int i, j;\n  double xf, xx;\n  double[] a=new double[P / 2 + 1];\n  double[] a1=new double[P / 2 + 1];\n  double[] a2=new double[P / 2 + 1];\n  double[] b=new double[P / 2 + 1];\n  double[] b1=new double[P / 2 + 1];\n  double[] b2=new double[P / 2 + 1];\n  double[] p=new double[P / 2];\n  double[] q=new double[P / 2];\n  double[] oneMinusA=new double[P + 1];\n  oneMinusA[0]=1.;\n  if ((lsf[0] <= 0.0) || (lsf[0] >= 0.5)) {\n    throw new IllegalArgumentException(\"LSFs out of bounds; lsf[0] = \" + lsf[0]);\n  }\n  for (i=1; i < P; i++) {\n    if (lsf[i] <= lsf[i - 1])     throw new IllegalArgumentException(\"nonmonotonic LSFs\");\n    if ((lsf[i] <= 0.0) || (lsf[i] >= 0.5))     throw new IllegalArgumentException(\"LSFs out of bounds; lsf[\" + i + \"] = \"+ lsf[i]);\n  }\n  for (i=0; i < half_order; i++) {\n    p[i]=-2 * Math.cos(MathUtils.TWOPI * lsf[2 * i]);\n    q[i]=-2 * Math.cos(MathUtils.TWOPI * lsf[2 * i + 1]);\n  }\n  xf=0.0;\n  for (i=0; i <= P; i++) {\n    if (i == 0)     xx=1.0;\n else     xx=0.0;\n    a[0]=xx + xf;\n    b[0]=xx - xf;\n    xf=xx;\n    for (j=0; j < half_order; j++) {\n      a[j + 1]=a[j] + p[j] * a1[j] + a2[j];\n      b[j + 1]=b[j] + q[j] * b1[j] + b2[j];\n      a2[j]=a1[j];\n      a1[j]=a[j];\n      b2[j]=b1[j];\n      b1[j]=b[j];\n    }\n    if (i > 0)     oneMinusA[i]=0.5 * (a[half_order] + b[half_order]);\n  }\n  return oneMinusA;\n}", "comment": "convert lsf frequencies into lpc coefficients .", "label": "done"}
{"id": "6260", "raw_code": "public static String removePattern(final String source,final String regex){\n  return replacePattern(source,regex,StringUtils.EMPTY);\n}", "comment": "removes each substring of the source string that matches the given regular expression using the dotall option .", "label": "done"}
{"id": "66710", "raw_code": "private static void decodeTextCompaction(int[] textCompactionData,int[] byteCompactionData,int length,StringBuilder result){\n  Mode subMode=Mode.ALPHA;\n  Mode priorToShiftMode=Mode.ALPHA;\n  int i=0;\n  while (i < length) {\n    int subModeCh=textCompactionData[i];\n    char ch=0;\nswitch (subMode) {\ncase ALPHA:\n      if (subModeCh < 26) {\n        ch=(char)('A' + subModeCh);\n      }\n else {\n        if (subModeCh == 26) {\n          ch=' ';\n        }\n else         if (subModeCh == LL) {\n          subMode=Mode.LOWER;\n        }\n else         if (subModeCh == ML) {\n          subMode=Mode.MIXED;\n        }\n else         if (subModeCh == PS) {\n          priorToShiftMode=subMode;\n          subMode=Mode.PUNCT_SHIFT;\n        }\n else         if (subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE) {\n          result.append((char)byteCompactionData[i]);\n        }\n else         if (subModeCh == TEXT_COMPACTION_MODE_LATCH) {\n          subMode=Mode.ALPHA;\n        }\n      }\n    break;\ncase LOWER:\n  if (subModeCh < 26) {\n    ch=(char)('a' + subModeCh);\n  }\n else {\n    if (subModeCh == 26) {\n      ch=' ';\n    }\n else     if (subModeCh == AS) {\n      priorToShiftMode=subMode;\n      subMode=Mode.ALPHA_SHIFT;\n    }\n else     if (subModeCh == ML) {\n      subMode=Mode.MIXED;\n    }\n else     if (subModeCh == PS) {\n      priorToShiftMode=subMode;\n      subMode=Mode.PUNCT_SHIFT;\n    }\n else     if (subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE) {\n      result.append((char)byteCompactionData[i]);\n    }\n else     if (subModeCh == TEXT_COMPACTION_MODE_LATCH) {\n      subMode=Mode.ALPHA;\n    }\n  }\nbreak;\ncase MIXED:\nif (subModeCh < PL) {\nch=MIXED_CHARS[subModeCh];\n}\n else {\nif (subModeCh == PL) {\n  subMode=Mode.PUNCT;\n}\n else if (subModeCh == 26) {\n  ch=' ';\n}\n else if (subModeCh == LL) {\n  subMode=Mode.LOWER;\n}\n else if (subModeCh == AL) {\n  subMode=Mode.ALPHA;\n}\n else if (subModeCh == PS) {\n  priorToShiftMode=subMode;\n  subMode=Mode.PUNCT_SHIFT;\n}\n else if (subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE) {\n  result.append((char)byteCompactionData[i]);\n}\n else if (subModeCh == TEXT_COMPACTION_MODE_LATCH) {\n  subMode=Mode.ALPHA;\n}\n}\nbreak;\ncase PUNCT:\nif (subModeCh < PAL) {\nch=PUNCT_CHARS[subModeCh];\n}\n else {\nif (subModeCh == PAL) {\nsubMode=Mode.ALPHA;\n}\n else if (subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE) {\nresult.append((char)byteCompactionData[i]);\n}\n else if (subModeCh == TEXT_COMPACTION_MODE_LATCH) {\nsubMode=Mode.ALPHA;\n}\n}\nbreak;\ncase ALPHA_SHIFT:\nsubMode=priorToShiftMode;\nif (subModeCh < 26) {\nch=(char)('A' + subModeCh);\n}\n else {\nif (subModeCh == 26) {\nch=' ';\n}\n else if (subModeCh == TEXT_COMPACTION_MODE_LATCH) {\nsubMode=Mode.ALPHA;\n}\n}\nbreak;\ncase PUNCT_SHIFT:\nsubMode=priorToShiftMode;\nif (subModeCh < PAL) {\nch=PUNCT_CHARS[subModeCh];\n}\n else {\nif (subModeCh == PAL) {\nsubMode=Mode.ALPHA;\n}\n else if (subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE) {\nresult.append((char)byteCompactionData[i]);\n}\n else if (subModeCh == TEXT_COMPACTION_MODE_LATCH) {\nsubMode=Mode.ALPHA;\n}\n}\nbreak;\n}\nif (ch != 0) {\nresult.append(ch);\n}\ni++;\n}\n}", "comment": "the text compaction mode includes all the printable ascii characters ( i . e . values from 32 to 126 ) and three ascii control characters : ht or tab ( ascii value 9 ) , lf or line feed ( ascii value 10 ) , and cr or carriage return ( ascii value 13 ) .", "label": "done"}
{"id": "20904", "raw_code": "public void addParam(AstNode param){\n  assertNotNull(param);\n  if (params == null) {\n    params=new ArrayList<AstNode>();\n  }\n  params.add(param);\n  param.setParent(this);\n}", "comment": "adds a parameter to the function parameter list .", "label": "done"}
{"id": "56130", "raw_code": "protected boolean checkExternalStorageAndNotify(String fileName){\n  if (fileName != null && fileName.startsWith(\"null\")) {\n    alertDownloadFailure(R.string.download_no_sdcard_dlg_title);\n    return false;\n  }\n  String status=Environment.getExternalStorageState();\n  if (!status.equals(Environment.MEDIA_MOUNTED)) {\n    int title;\n    if (status.equals(Environment.MEDIA_SHARED)) {\n      title=R.string.download_sdcard_busy_dlg_title;\n    }\n else {\n      title=R.string.download_no_sdcard_dlg_title;\n    }\n    alertDownloadFailure(title);\n    return false;\n  }\n  return true;\n}", "comment": "check the external storage and notify user on error .", "label": "done"}
{"id": "62826", "raw_code": "public void add(Video video){\n  videoList.add(video);\n  notifyDataSetChanged();\n}", "comment": "adds a video to the adapter and notify the change .", "label": "done"}
{"id": "80813", "raw_code": "void addLocation(String location){\n  if (fLocationList.contains(location)) {\n    return;\n  }\n  fLocationList.add(location);\n  fTableViewer.refresh();\n  fTableViewer.setChecked(location,true);\n  fTableViewer.setSelection(new StructuredSelection(location));\n  validateLocations();\n}", "comment": "adds the given location to the table", "label": "done"}
{"id": "61576", "raw_code": "public String encode(final String pString,final String charset) throws EncoderException {\n  if (pString == null) {\n    return null;\n  }\n  try {\n    return encodeText(pString,charset);\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new EncoderException(e.getMessage());\n  }\n}", "comment": "encodes a string into its quoted - printable form using the specified charset .", "label": "done"}
{"id": "55800", "raw_code": "public static int rgb(String hex){\n  int color=(int)Long.parseLong(hex.replace(\"#\",\"\"),16);\n  int r=(color >> 16) & 0xFF;\n  int g=(color >> 8) & 0xFF;\n  int b=(color >> 0) & 0xFF;\n  return Color.rgb(r,g,b);\n}", "comment": "converts the given hex - color - string to rgb .", "label": "done"}
{"id": "38832", "raw_code": "@Override public void addPropertyChangeListener(String name,PropertyChangeListener pcl){\n  m_bcSupport.addPropertyChangeListener(name,pcl);\n}", "comment": "add a property change listener to this bean", "label": "done"}
{"id": "80050", "raw_code": "Sentence parseSentence(final String text,final ConversationContext ctx){\n  if (isEmpty()) {\n    return ConversationParser.parse(text,ctx);\n  }\n  String txt=text.trim();\n  final Sentence sentence=new SentenceImplementation(ctx,txt);\n  txt=ConversationParser.detectSentenceType(txt,sentence);\n  if (typeMatching) {\n    readTypeMatchExpressions(txt,ctx,sentence);\n  }\n else   if (exactMatching) {\n    readSimpleExpressions(txt,ctx,sentence);\n  }\n else   if (similarMatching) {\n    readSimpleExpressions(txt,ctx,sentence);\n  }\n else   if (jokerMatching) {\n    readJokerExpressions(txt,ctx,sentence);\n  }\n else   if (caseInsensitive) {\n    readSimpleExpressions(txt,ctx,sentence);\n  }\n  return sentence;\n}", "comment": "parse the given text string and create a sentence object using the current matching flags .", "label": "done"}
{"id": "12897", "raw_code": "protected boolean checkProsodicPosition(Element currentRulePart,String prosodicPositionType){\n  NamedNodeMap attNodes=currentRulePart.getAttributes();\n  for (int z=0; z < attNodes.getLength(); z++) {\n    Node el=attNodes.item(z);\n    String currentAtt=el.getNodeName();\n    String currentVal=el.getNodeValue();\n    if (currentAtt.equals(\"type\")) {\n      if (!currentVal.startsWith(\"!\")) {\n        if (!prosodicPositionType.equals(currentVal))         return false;\n      }\n else {\n        currentVal=currentVal.substring(1,currentVal.length());\n        if (prosodicPositionType.equals(currentVal))         return false;\n      }\n    }\n  }\n  return true;\n}", "comment": "checks rule part with tag \" prosodicposition \" ; there is only the \" type \" attribute right now : checks if prosodic position of a token is the same as the value of the type attribute in the rule ; values : prenuclear , nuclearparagraphfinal , nuclearparagraphnonfinal , postnuclear", "label": "done"}
{"id": "84043", "raw_code": "private void doPermissionWorkBeforeAndroidM(@NonNull Activity activity,@NonNull String[] permissions,@Nullable PermissionsResultAction action){\n  for (  String perm : permissions) {\n    if (action != null) {\n      if (!mPermissions.contains(perm)) {\n        action.onResult(perm,Permissions.NOT_FOUND);\n      }\n else       if (ActivityCompat.checkSelfPermission(activity,perm) != PackageManager.PERMISSION_GRANTED) {\n        action.onResult(perm,Permissions.DENIED);\n      }\n else {\n        action.onResult(perm,Permissions.GRANTED);\n      }\n    }\n  }\n}", "comment": "when request permissions on devices before android m ( android 6 . 0 , api level 23 ) do the granted or denied work directly according to the permission status", "label": "done"}
{"id": "41189", "raw_code": "public void addProfiles(@NonNull IProfile... profiles){\n  if (mAccountHeaderBuilder.mProfiles == null) {\n    mAccountHeaderBuilder.mProfiles=new ArrayList<>();\n  }\n  Collections.addAll(mAccountHeaderBuilder.mProfiles,IdDistributor.checkIds(profiles));\n  mAccountHeaderBuilder.updateHeaderAndList();\n}", "comment": "add new profiles to the existing list of profiles", "label": "done"}
{"id": "45069", "raw_code": "public void addMacroRecord(MacroRecord record){\n  if (record != null)   macroRecords.add(record);\n}", "comment": "adds a macro record to this macro .", "label": "done"}
{"id": "10382", "raw_code": "@SuppressWarnings(\"rawtypes\") protected KafkaSpoutWrapper createKafkaSpout(Map conf,TopologyContext context,SpoutOutputCollector collector,final String topic,String schemeClsName,SpoutSpec spoutSpec,Map<String,StreamDefinition> sds) throws Exception {\n  String kafkaBrokerZkQuorum=config.getString(\"spout.kafkaBrokerZkQuorum\");\n  BrokerHosts hosts=null;\n  if (config.hasPath(\"spout.kafkaBrokerZkBasePath\")) {\n    hosts=new ZkHosts(kafkaBrokerZkQuorum,config.getString(\"spout.kafkaBrokerZkBasePath\"));\n  }\n else {\n    hosts=new ZkHosts(kafkaBrokerZkQuorum);\n  }\n  String transactionZkRoot=DEFAULT_STORM_KAFKA_TRANSACTION_ZK_ROOT;\n  if (config.hasPath(\"spout.stormKafkaTransactionZkPath\")) {\n    transactionZkRoot=config.getString(\"spout.stormKafkaTransactionZkPath\");\n  }\n  String zkStateTransactionRelPath=DEFAULT_STORM_KAFKA_TRANSACTION_ZK_RELATIVE_PATH;\n  if (config.hasPath(\"spout.stormKafkaEagleConsumer\")) {\n    zkStateTransactionRelPath=config.getString(\"spout.stormKafkaEagleConsumer\");\n  }\n  SpoutConfig spoutConfig=new SpoutConfig(hosts,topic,transactionZkRoot,zkStateTransactionRelPath + \"/\" + topic+ \"/\"+ topologyId);\n  boolean stormKafkaUseSameZkQuorumWithKafkaBroker=config.getBoolean(\"spout.stormKafkaUseSameZkQuorumWithKafkaBroker\");\n  if (stormKafkaUseSameZkQuorumWithKafkaBroker) {\n    ZkServerPortUtils utils=new ZkServerPortUtils(kafkaBrokerZkQuorum);\n    spoutConfig.zkServers=utils.getZkHosts();\n    spoutConfig.zkPort=utils.getZkPort();\n  }\n else {\n    ZkServerPortUtils utils=new ZkServerPortUtils(config.getString(\"spout.stormKafkaTransactionZkQuorum\"));\n    spoutConfig.zkServers=utils.getZkHosts();\n    spoutConfig.zkPort=utils.getZkPort();\n  }\n  spoutConfig.stateUpdateIntervalMs=config.hasPath(\"spout.stormKafkaStateUpdateIntervalMs\") ? config.getInt(\"spout.stormKafkaStateUpdateIntervalMs\") : 2000;\n  spoutConfig.fetchSizeBytes=config.hasPath(\"spout.stormKafkaFetchSizeBytes\") ? config.getInt(\"spout.stormKafkaFetchSizeBytes\") : 1048586;\n  if (config.hasPath(\"spout.stormKafkaStartOffsetTime\")) {\n    spoutConfig.startOffsetTime=config.getInt(\"spout.stormKafkaStartOffsetTime\");\n  }\n  spoutConfig.scheme=createMultiScheme(conf,topic,schemeClsName);\n  KafkaSpoutWrapper wrapper=new KafkaSpoutWrapper(spoutConfig,kafkaSpoutMetric);\n  SpoutOutputCollectorWrapper collectorWrapper=new SpoutOutputCollectorWrapper(this,collector,topic,spoutSpec,numOfRouterBolts,sds,this.serializer);\n  wrapper.open(conf,context,collectorWrapper);\n  if (LOG.isInfoEnabled()) {\n    LOG.info(\"create and open kafka wrapper: topic {}, scheme class{} \",topic,schemeClsName);\n  }\n  return wrapper;\n}", "comment": "make this method protected to make sure unit test can work well q : where to persist consumer state , i . e . what offset has been consumed for each topic and partition a : stormkafkatransactionzkpath + \" / \" + consumerid + \" / \" + topic + \" / \" + topologyid + \" / \" + partitionid note1 : partitionmanager . committedpath for composing zkstate path , _ spoutconfig . zkroot + \" / \" + _ spoutconfig . id + \" / \" + _ partition . getid ( ) ; consumerid by default is eagleconsumer unless it is specified by \" stormkafkaeagleconsumer \" note2 : put topologyid as part of zkstate because one topic by design can be consumed by multiple topologies so one topology needs to know processed offset for itself todo : should avoid use config . get in deep calling stack , should generate config bean as early as possible", "label": "done"}
{"id": "40881", "raw_code": "public Builder addEmail(Email email){\n  emails.add(email);\n  return this;\n}", "comment": "adds or updates a emil of an existing user if the . getvalue ( ) already exists a update will be done .", "label": "done"}
{"id": "85406", "raw_code": "private void encodeTypes(List<Type> types,Map<String,Object> m,String key,Declaration from){\n  if (types == null || types.isEmpty())   return;\n  List<Map<String,Object>> sats=new ArrayList<>(types.size());\n  for (  Type st : types) {\n    sats.add(typeMap(st,from));\n  }\n  m.put(key,sats);\n}", "comment": "encodes the list of types and puts them under the specified key in the map .", "label": "done"}
{"id": "41339", "raw_code": "public void build(String code,String customStatus){\n  try {\n    if (customStatus != null) {\n      result.put(resources.getString(R.string.intent_extra_status),customStatus);\n    }\n else {\n      result.put(resources.getString(R.string.intent_extra_status),resources.getString(R.string.shared_pref_default_status));\n    }\n    result.put(resources.getString(R.string.intent_extra_code),code);\n    operationListResult.put(result);\n  }\n catch (  JSONException e) {\n    Log.e(TAG,\"Invalid JSON format.\" + e.toString());\n  }\n}", "comment": "add operation results to the array to be returned .", "label": "done"}
{"id": "1623", "raw_code": "public static Operator generateBranchPlan(AkibanInformationSchema ais,Table table){\n  final Operator indexScan=generateIndexScan(ais,table);\n  final Schema schema=SchemaCache.globalSchema(ais);\n  PrimaryKey pkey=table.getPrimaryKeyIncludingInternal();\n  IndexRowType indexType=schema.indexRowType(pkey.getIndex());\n  return generateBranchPlan(table,indexScan,indexType);\n}", "comment": "scan a group starting with primary key of a table , then get all of the children ( if any ) .", "label": "done"}
{"id": "57046", "raw_code": "protected void addToMaintenanceQueue(NodePortTuple npt){\n  if (maintenanceQueue.contains(npt) == false) {\n    maintenanceQueue.add(npt);\n  }\n}", "comment": "add a switch port to maintenance queue .", "label": "done"}
{"id": "7826", "raw_code": "@Override public void handleMouseMoved(ChartCanvas canvas,MouseEvent e){\n  if (!canvas.isTooltipEnabled()) {\n    return;\n  }\n  String text=getTooltipText(canvas,e.getX(),e.getY());\n  canvas.setTooltip(text,e.getScreenX(),e.getScreenY());\n}", "comment": "handles a mouse moved event by updating the tooltip .", "label": "done"}
{"id": "74203", "raw_code": "@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value=\"FE_FLOATING_POINT_EQUALITY\",justification=\"equality is specifically 'Unchanged' here\") public void changeLocoSpeed(DccThrottle t,Block blk,float speed){\n  if (blk == referenced && speed == desiredSpeedStep) {\n    return;\n  }\n  float blockLength=blk.getLengthMm();\n  if (blk == referenced) {\n    distanceRemaining=distanceRemaining - getDistanceTravelled(_throttle.getIsForward(),_throttle.getSpeedSetting(),((float)(System.nanoTime() - lastTimeTimerStarted) / 1000000000));\n    blockLength=distanceRemaining;\n    log.debug(\"Block passed is the same as we are currently processing\");\n  }\n else {\n    referenced=blk;\n  }\n  changeLocoSpeed(t,blockLength,speed);\n}", "comment": "set speed of a throttle to a speeed set by a float , using the block for the length details", "label": "done"}
{"id": "83888", "raw_code": "public MemoidOne(Function<? super Input,? extends Output> fn,BiPredicate<Input,Input> equality){\n  fn_=Objects.requireNonNull(fn);\n  equality_=Objects.requireNonNull(equality);\n}", "comment": "create a new memoidone , using the supplied transformation function .", "label": "done"}
{"id": "20103", "raw_code": "private static Class<?> convertFieldType(String fieldType){\n  if (fieldTypeMap.containsKey(fieldType)) {\n    return fieldTypeMap.get(fieldType);\n  }\n  return null;\n}", "comment": "convert field type from string to a class type .", "label": "done"}
{"id": "40227", "raw_code": "private void addPingTimeData(long sample){\n  lastPingTimesLock.lock();\n  try {\n    if (lastPingTimes == null) {\n      lastPingTimes=new long[PING_MOVING_AVERAGE_WINDOW];\n      Arrays.fill(lastPingTimes,sample);\n    }\n else {\n      System.arraycopy(lastPingTimes,1,lastPingTimes,0,lastPingTimes.length - 1);\n      lastPingTimes[lastPingTimes.length - 1]=sample;\n    }\n  }\n  finally {\n    lastPingTimesLock.unlock();\n  }\n}", "comment": "adds a ping time sample to the averaging window .", "label": "done"}
{"id": "74143", "raw_code": "public boolean controlRunTrain(int idx){\n  if (log.isDebugEnabled()) {\n    log.debug(\"controlRunTrain= \" + idx + \" runMode= \"+ _runMode+ \" - warrant= \"+ getDisplayName());\n  }\n  boolean ret=true;\n  int oldIndex=-MODE_MANUAL;\n  if (_engineer == null) {\nswitch (idx) {\ncase HALT:\ncase RESUME:\ncase RETRY:\n      ret=false;\n    break;\ncase ABORT:\n  if (_runMode == Warrant.MODE_LEARN) {\n    firePropertyChange(\"abortLearn\",Integer.valueOf(-MODE_LEARN),Integer.valueOf(_idxCurrentOrder));\n  }\n else {\n    stopWarrant(true);\n  }\nbreak;\n}\n}\n else {\nsynchronized (_engineer) {\noldIndex=_engineer.getRunState();\nswitch (idx) {\ncase HALT:\n_engineer.setHalt(true);\nbreak;\ncase RESUME:\n_engineer.setHalt(false);\nrestart();\nret=moveIntoNextBlock(MID);\nbreak;\ncase RETRY:\nBlockOrder bo=getBlockOrderAt(_idxCurrentOrder + 1);\nret=false;\nif (bo != null) {\nOBlock b=bo.getBlock();\nif (b.allocate(this) == null && (b.getState() & OBlock.OCCUPIED) != 0) {\n_idxCurrentOrder++;\nif (b.equals(_stoppingBlock)) {\n_stoppingBlock.removePropertyChangeListener(this);\n_stoppingBlock=null;\n}\nbo.setPath(this);\nrestart();\ngoingActive(b);\nret=true;\n}\n}\nbreak;\ncase ABORT:\nstopWarrant(true);\nbreak;\n}\n}\n}\nif (ret) {\nfirePropertyChange(\"controlChange\",Integer.valueOf(oldIndex),Integer.valueOf(idx));\n}\nreturn ret;\n}", "comment": "pause and resume auto - running train or abort any allocation state _ engineer . abort ( ) calls setrunmode ( mode _ none , . . . ) which calls deallocate all .", "label": "done"}
{"id": "69459", "raw_code": "public static void writeStringToFile(File file,String data) throws IOException {\n  writeStringToFile(file,data,Charset.defaultCharset(),false);\n}", "comment": "writes a string to a file creating the file if it does not exist using the default encoding for the vm .", "label": "done"}
{"id": "49366", "raw_code": "public ZoneRulesBuilder addWindow(ZoneOffset standardOffset,LocalDateTime until,TimeDefinition untilDefinition){\n  Objects.requireNonNull(standardOffset,\"standardOffset\");\n  Objects.requireNonNull(until,\"until\");\n  Objects.requireNonNull(untilDefinition,\"untilDefinition\");\n  TZWindow window=new TZWindow(standardOffset,until,untilDefinition);\n  if (windowList.size() > 0) {\n    TZWindow previous=windowList.get(windowList.size() - 1);\n    window.validateWindowOrder(previous);\n  }\n  windowList.add(window);\n  return this;\n}", "comment": "adds a window to the builder that can be used to filter a set of rules .", "label": "done"}
{"id": "74336", "raw_code": "public void writeOperationsCarFile(){\n  makeBackupFile(defaultOperationsFilename());\n  try {\n    if (!checkFile(defaultOperationsFilename())) {\n      java.io.File file=new java.io.File(defaultOperationsFilename());\n      java.io.File parentDir=file.getParentFile();\n      if (!parentDir.exists()) {\n        if (!parentDir.mkdir()) {\n          log.error(\"Directory wasn't created\");\n        }\n      }\n      if (file.createNewFile()) {\n        log.debug(\"File created\");\n      }\n    }\n    writeFile(defaultOperationsFilename());\n  }\n catch (  Exception e) {\n    log.error(\"Exception while writing the new CSV operations file, may not be complete: \" + e);\n  }\n}", "comment": "store the all of the operation car objects in the default place , including making a backup if needed", "label": "done"}
{"id": "81353", "raw_code": "public static void sortFields(FieldBinding[] sortedFields,int left,int right){\n  Arrays.sort(sortedFields,left,right,FIELD_COMPARATOR);\n}", "comment": "sort the field array using a quicksort", "label": "done"}
{"id": "78339", "raw_code": "public void addUniqueAttribute(final String elementName,final String attrName){\n  if ((elementName != null) && (attrName != null)) {\n    _uniqueElementAttrMap.put(elementName,attrName);\n  }\n}", "comment": "add unique attribute to the element which will force elements to be identical .", "label": "done"}
{"id": "59965", "raw_code": "private static DeleteVmResponse checkDeleteVmResponse(DeleteVmResponse deleteVmResponse) throws RpcException {\n  logger.info(\"Checking {}\",deleteVmResponse);\nswitch (deleteVmResponse.getResult()) {\ncase OK:\n    break;\ncase SYSTEM_ERROR:\n  throw new SystemErrorException(deleteVmResponse.getError());\ncase VM_NOT_FOUND:\nthrow new VmNotFoundException(deleteVmResponse.getError());\ncase VM_NOT_POWERED_OFF:\nthrow new VmNotPoweredOffException(deleteVmResponse.getError());\ndefault :\nthrow new RpcException(String.format(\"Unknown response: %s\",deleteVmResponse.getResult()));\n}\nreturn deleteVmResponse;\n}", "comment": "this method validates a deletevmresponse object , raising an exception if the response reflects an operation failure .", "label": "done"}
{"id": "40966", "raw_code": "private List<View> addView(View view,List<View> cache){\n  if (cache == null) {\n    cache=new LinkedList<View>();\n  }\n  cache.add(view);\n  return cache;\n}", "comment": "adds view to specified cache .", "label": "done"}
{"id": "81977", "raw_code": "public static byte[] readInputStream(InputStream i) throws IOException {\n  ByteArrayOutputStream b=new ByteArrayOutputStream();\n  copy(i,b);\n  return b.toByteArray();\n}", "comment": "converts a small input stream to a byte array", "label": "done"}
{"id": "28392", "raw_code": "public void add(DataSource source,boolean visible){\n  add(data.size(),source,visible);\n}", "comment": "adds a new data series to the plot .", "label": "done"}
{"id": "38091", "raw_code": "@Override public void addValue(double value,double weight){\n  m_WeightedSum+=value * weight;\n  m_WeightedSumSquared+=value * value * weight;\n  m_SumOfWeights+=weight;\n  if (m_TM.get(value) == null) {\n    m_TM.put(value,weight);\n  }\n else {\n    m_TM.put(value,m_TM.get(value) + weight);\n  }\n}", "comment": "adds a value to the density estimator .", "label": "done"}
{"id": "32828", "raw_code": "public static String readLine(){\n  String line;\n  try {\n    line=scanner.nextLine();\n  }\n catch (  NoSuchElementException e) {\n    line=null;\n  }\n  return line;\n}", "comment": "reads and returns the next line , excluding the line separator if present .", "label": "done"}
{"id": "72893", "raw_code": "public void addFooterView(View v,Object data,boolean isSelectable){\n  FixedViewInfo info=new FixedViewInfo();\n  info.view=v;\n  info.data=data;\n  info.isSelectable=isSelectable;\n  mFooterViewInfos.add(info);\n  if (mAdapter != null && mDataSetObserver != null) {\n    mDataSetObserver.onChanged();\n  }\n}", "comment": "add a fixed view to appear at the bottom of the list .", "label": "done"}
{"id": "57520", "raw_code": "public void rejectedExecution(Runnable r,ThreadPoolExecutor e){\n  if (!e.isShutdown()) {\n    r.run();\n  }\n}", "comment": "executes task r in the caller ' s thread , unless the executor has been shut down , in which case the task is discarded .", "label": "done"}
{"id": "28257", "raw_code": "static boolean checkStandardUPCEANChecksum(CharSequence s) throws FormatException {\n  int length=s.length();\n  if (length == 0) {\n    return false;\n  }\n  int sum=0;\n  for (int i=length - 2; i >= 0; i-=2) {\n    int digit=(int)s.charAt(i) - (int)'0';\n    if (digit < 0 || digit > 9) {\n      throw FormatException.getFormatInstance();\n    }\n    sum+=digit;\n  }\n  sum*=3;\n  for (int i=length - 1; i >= 0; i-=2) {\n    int digit=(int)s.charAt(i) - (int)'0';\n    if (digit < 0 || digit > 9) {\n      throw FormatException.getFormatInstance();\n    }\n    sum+=digit;\n  }\n  return sum % 10 == 0;\n}", "comment": "computes the upc / ean checksum on a string of digits , and reports whether the checksum is correct or not .", "label": "done"}
{"id": "42574", "raw_code": "public void readConfig(String filename) throws FileNotFoundException {\n  if (filename == null || filename.equals(\"\"))   return;\n  readConfig(new FileReader(filename));\n}", "comment": "read the specified file and parse the configuration .", "label": "done"}
{"id": "55057", "raw_code": "private static void removeDependencySubsets(String swcLocation,Map<String,Set<String>> dependencyMap,SwcDependencyInfoImpl depInfo){\n  Set<String> removeSet=new HashSet<String>();\n  SwcExternalScriptInfo externalInfo=depInfo.getSwcExternalScriptInfo(swcLocation);\n  Map<String,Set<String>> externalsBySwc=new HashMap<String,Set<String>>();\n  for (  String swcDependLocation : dependencyMap.get(swcLocation)) {\n    for (    String swcDependLocation2 : dependencyMap.get(swcLocation)) {\n      if (swcDependLocation.equals(swcDependLocation2))       continue;\n      Set<String> externalScripts=externalsBySwc.get(swcDependLocation);\n      Set<String> externalScripts2=externalsBySwc.get(swcDependLocation2);\n      if (externalScripts == null) {\n        externalScripts=externalInfo.getExternalScripts(swcDependLocation);\n        externalsBySwc.put(swcDependLocation,externalScripts);\n      }\n      if (externalScripts2 == null) {\n        externalScripts2=externalInfo.getExternalScripts(swcDependLocation2);\n        externalsBySwc.put(swcDependLocation2,externalScripts2);\n      }\n      if (externalScripts2.size() > externalScripts.size() && externalScripts2.containsAll(externalScripts)) {\n        removeSet.add(swcDependLocation);\n        break;\n      }\n    }\n  }\n  Set<String> dependencySet=dependencyMap.get(swcLocation);\n  dependencySet.removeAll(removeSet);\n}", "comment": "look at the dependency information and remove swc dependencies that are subsets of other swc dependencies .", "label": "done"}
{"id": "44982", "raw_code": "private void removeHighlights(){\n  if (textArea != null) {\n    RSyntaxTextAreaHighlighter h=(RSyntaxTextAreaHighlighter)textArea.getHighlighter();\n    for (int i=0; i < tags.size(); i++) {\n      h.removeMarkOccurrencesHighlight(tags.get(i));\n    }\n  }\n  tags.clear();\n}", "comment": "removes all highlights added to the text area by this listener .", "label": "done"}
{"id": "24525", "raw_code": "private static <T extends AbstractBlockBase<T>>void enqueueSuccessors(T block,PriorityQueue<T> worklist,BitSet visitedBlocks){\n  for (  T successor : block.getSuccessors()) {\n    if (!visitedBlocks.get(successor.getId())) {\n      visitedBlocks.set(successor.getId());\n      worklist.add(successor);\n    }\n  }\n}", "comment": "add successor blocks into the given work list if they are not already marked as visited .", "label": "done"}
{"id": "26075", "raw_code": "public void addRole(String role){\n  if (role != null) {\n    roles.add(role);\n  }\n}", "comment": "add a role to this user .", "label": "done"}
{"id": "58228", "raw_code": "public final void append(FastStringBuffer value){\n  if (value == null)   return;\n  int strlen=value.length();\n  if (0 == strlen)   return;\n  int copyfrom=0;\n  char[] chunk=m_array[m_lastChunk];\n  int available=m_chunkSize - m_firstFree;\n  while (strlen > 0) {\n    if (available > strlen)     available=strlen;\n    int sourcechunk=(copyfrom + value.m_chunkSize - 1) >>> value.m_chunkBits;\n    int sourcecolumn=copyfrom & value.m_chunkMask;\n    int runlength=value.m_chunkSize - sourcecolumn;\n    if (runlength > available)     runlength=available;\n    System.arraycopy(value.m_array[sourcechunk],sourcecolumn,m_array[m_lastChunk],m_firstFree,runlength);\n    if (runlength != available)     System.arraycopy(value.m_array[sourcechunk + 1],0,m_array[m_lastChunk],m_firstFree + runlength,available - runlength);\n    strlen-=available;\n    copyfrom+=available;\n    if (strlen > 0) {\n      int i=m_array.length;\n      if (m_lastChunk + 1 == i) {\n        char[][] newarray=new char[i + 16][];\n        System.arraycopy(m_array,0,newarray,0,i);\n        m_array=newarray;\n      }\n      chunk=m_array[++m_lastChunk];\n      if (chunk == null) {\n        if (m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits) {\n          m_innerFSB=new FastStringBuffer(this);\n        }\n        chunk=m_array[m_lastChunk]=new char[m_chunkSize];\n      }\n      available=m_chunkSize;\n      m_firstFree=0;\n    }\n  }\n  m_firstFree+=available;\n}", "comment": "append the contents of another faststringbuffer onto this faststringbuffer , growing the storage if necessary .", "label": "done"}
{"id": "27141", "raw_code": "public static AttribKey forHtmlAttrib(ElKey el,String localName){\n  return new AttribKey(el,HTML_NS,localName);\n}", "comment": "looks up an attribute key by element and local name .", "label": "done"}
{"id": "35746", "raw_code": "SparseArray(Class<L> linearArrayType,int[] rowIndices,int[] colIndices,L realValues,L imagValues,int numRows,int numCols){\n  validateUserSuppliedParameters(linearArrayType,rowIndices,colIndices,realValues,imagValues);\n  _baseComponentType=linearArrayType.getComponentType();\n  _outputArrayType=(Class<L[]>)ArrayUtils.getArrayClass(_baseComponentType,2);\n  Map<SparseKey,SparseValue> sparseMap=createSparseMap(linearArrayType,rowIndices,colIndices,realValues,imagValues,numRows,numCols);\n  _numRows=numRows;\n  _numCols=numCols;\n  ArrayList<SparseKey> keys=new ArrayList<SparseKey>(sparseMap.keySet());\n  Collections.sort(keys);\n  _rowIndices=new int[keys.size()];\n  _colIndices=new int[keys.size()];\n  _linearIndices=new int[keys.size()];\n  _realValues=linearArrayType.cast(Array.newInstance(_baseComponentType,keys.size()));\n  _imagValues=imagValues == null ? null : linearArrayType.cast(Array.newInstance(_baseComponentType,keys.size()));\n  for (int i=0; i < keys.size(); i++) {\n    SparseKey key=keys.get(i);\n    _rowIndices[i]=key.row;\n    _colIndices[i]=key.col;\n    _linearIndices[i]=key.linearIndex;\n    SparseValue value=sparseMap.get(key);\n    setSparseValue(value,_realValues,_imagValues,i);\n  }\n}", "comment": "data provided by a user ; this data needs to be validated and processed .", "label": "done"}
{"id": "73826", "raw_code": "private String idString(int id1,int id2){\n  return \"0x\" + Integer.toHexString(id2 & 0x7F) + \" 0x\"+ Integer.toHexString(id1 & 0x7F)+ \" (\"+ ((id2 & 0x7F) * 128 + (id1 & 0x7F))+ \")\";\n}", "comment": "convert throttle id to a human friendly format .", "label": "done"}
{"id": "28771", "raw_code": "private void removeItemAtInt(int index,boolean updateChildrenOnMenuViews){\n  if ((index < 0) || (index >= mItems.size()))   return;\n  mItems.remove(index);\n  if (updateChildrenOnMenuViews)   onItemsChanged(true);\n}", "comment": "remove the item at the given index and optionally forces menu views to update .", "label": "done"}
{"id": "19399", "raw_code": "private KeyStore createKeys(KeyStore keyStore,String keyAlgorithm,String publicAlias,String privateAlias,PrivateKeyEntry signer) throws Exception {\n  PrivateKey caKey;\n  X509Certificate caCert;\n  X509Certificate[] caCertChain;\n  if (signer == null) {\n    caKey=null;\n    caCert=null;\n    caCertChain=null;\n  }\n else {\n    caKey=signer.getPrivateKey();\n    caCert=(X509Certificate)signer.getCertificate();\n    caCertChain=(X509Certificate[])signer.getCertificateChain();\n  }\n  PrivateKey privateKey;\n  X509Certificate x509c;\n  if (publicAlias == null && privateAlias == null) {\n    privateKey=null;\n    x509c=null;\n  }\n else {\n    int keySize;\n    if (keyAlgorithm.equals(\"RSA\")) {\n      keySize=1024;\n    }\n else     if (keyAlgorithm.equals(\"DSA\")) {\n      keySize=512;\n    }\n else     if (keyAlgorithm.equals(\"EC\")) {\n      keySize=256;\n    }\n else     if (keyAlgorithm.equals(\"EC_RSA\")) {\n      keySize=256;\n      keyAlgorithm=\"EC\";\n    }\n else {\n      throw new IllegalArgumentException(\"Unknown key algorithm \" + keyAlgorithm);\n    }\n    KeyPairGenerator kpg=KeyPairGenerator.getInstance(keyAlgorithm);\n    kpg.initialize(keySize,new SecureRandom());\n    KeyPair kp=kpg.generateKeyPair();\n    privateKey=kp.getPrivate();\n    PublicKey publicKey=kp.getPublic();\n    X500Principal issuer=((caCert != null) ? caCert.getSubjectX500Principal() : subject);\n    PrivateKey signingKey=(caKey == null) ? privateKey : caKey;\n    x509c=createCertificate(publicKey,signingKey,subject,issuer,keyUsage,ca,extendedKeyUsages,criticalExtendedKeyUsages,subjectAltNames,permittedNameConstraints,excludedNameConstraints);\n  }\n  X509Certificate[] x509cc;\n  if (privateAlias == null) {\n    x509cc=null;\n  }\n else   if (caCertChain == null) {\n    x509cc=new X509Certificate[]{x509c};\n  }\n else {\n    x509cc=new X509Certificate[caCertChain.length + 1];\n    x509cc[0]=x509c;\n    System.arraycopy(caCertChain,0,x509cc,1,caCertChain.length);\n  }\n  if (privateAlias != null) {\n    keyStore.setKeyEntry(privateAlias,privateKey,keyPassword,x509cc);\n  }\n  if (publicAlias != null) {\n    keyStore.setCertificateEntry(publicAlias,x509c);\n  }\n  return keyStore;\n}", "comment": "add newly generated keys of a given key type to an existing keystore .", "label": "done"}
{"id": "16744", "raw_code": "public void clear(){\n  infoQueue.clear();\n  while (!dataQueue.isEmpty()) {\n    allocator.release(dataQueue.remove());\n  }\n  totalBytesDropped=0;\n  totalBytesWritten=0;\n  lastAllocation=null;\n  lastAllocationOffset=allocationLength;\n}", "comment": "clears the buffer , returning all allocations to the allocator .", "label": "done"}
{"id": "21031", "raw_code": "public void addToExistingVolumesIfAbsent(Map<String,Integer> volumeWWNs){\n  if (_existingVolumes == null) {\n    _existingVolumes=new StringMap();\n  }\n  for (  String wwn : volumeWWNs.keySet()) {\n    String normalizedWWN=BlockObject.normalizeWWN(wwn);\n    if (!_existingVolumes.containsKey(normalizedWWN) && (_userAddedVolumes == null || !_userAddedVolumes.containsKey(normalizedWWN))) {\n      String hluStr=ExportGroup.LUN_UNASSIGNED_STR;\n      Integer hlu=volumeWWNs.get(normalizedWWN);\n      if (hlu != null) {\n        hluStr=hlu.toString();\n      }\n      _existingVolumes.put(normalizedWWN,hluStr);\n    }\n  }\n}", "comment": "this method will add to the existing volumes list only those members that don ' t already exist in either the existing or user - created volume list .", "label": "done"}
{"id": "34982", "raw_code": "static Map<TargetType,List<TypeCompound>> partitionByTargetType(Collection<TypeCompound> annos,List<TypeCompound> unmatched,TargetType... targetTypes){\n  final Map<TargetType,List<TypeCompound>> targetTypeToAnnos=new HashMap<>();\n  for (  TargetType targetType : targetTypes) {\n    targetTypeToAnnos.put(targetType,new ArrayList<TypeCompound>(10));\n  }\n  for (  final TypeCompound anno : annos) {\n    final List<TypeCompound> annoSet=targetTypeToAnnos.get(anno.getPosition().type);\n    if (annoSet != null) {\n      annoSet.add(anno);\n    }\n else     if (unmatched != null) {\n      unmatched.add(anno);\n    }\n  }\n  return targetTypeToAnnos;\n}", "comment": "use a map to partition annotations with the given targettypes into lists , where each target type is a key in the output map .", "label": "done"}
{"id": "43879", "raw_code": "public static String[] decodeArray(String encodedArray){\n  String[] items=encodedArray.split(\"_\\\\.\");\n  ArrayList<String> list=new ArrayList<String>();\n  for (int i=0; i < items.length; i++) {\n    String item=items[i];\n    item=gsub(\"__\",\"_\",item);\n    if (!item.equals(\"\")) {\n      list.add(item);\n    }\n  }\n  return list.toArray(new String[list.size()]);\n}", "comment": "decodes a string generated by encodearray .", "label": "done"}
{"id": "34482", "raw_code": "public void stopSampling(){\n  if (mSamplingCounter.decrementAndGet() == 0) {\n    mHandler.stopSamplingThread();\n    addFinalSample();\n  }\n}", "comment": "finish sampling and prevent further changes to the connectionclass until another timer is started .", "label": "done"}
{"id": "47347", "raw_code": "public synchronized boolean addAll(Collection<? extends E> c){\n  modCount++;\n  Object[] a=c.toArray();\n  int numNew=a.length;\n  ensureCapacityHelper(elementCount + numNew);\n  System.arraycopy(a,0,elementData,elementCount,numNew);\n  elementCount+=numNew;\n  return numNew != 0;\n}", "comment": "appends all of the elements in the specified collection to the end of this vector , in the order that they are returned by the specified collection ' s iterator .", "label": "done"}
{"id": "78656", "raw_code": "@Override public void update(DefaultApplicationState transState){\n  newCheckpoint(transState.getState(),transState.getStateHash(),transState.getLastCheckpointCID());\n  setLastCheckpointCID(transState.getLastCheckpointCID());\n}", "comment": "updates this log , according to the information contained in the transferablestate object", "label": "done"}
{"id": "68256", "raw_code": "public static byte[] stringToUtf8Bytes(String string){\n  int len=string.length();\n  byte[] bytes=new byte[len * 3];\n  int outAt=0;\n  for (int i=0; i < len; i++) {\n    char c=string.charAt(i);\n    if ((c != 0) && (c < 0x80)) {\n      bytes[outAt]=(byte)c;\n      outAt++;\n    }\n else     if (c < 0x800) {\n      bytes[outAt]=(byte)(((c >> 6) & 0x1f) | 0xc0);\n      bytes[outAt + 1]=(byte)((c & 0x3f) | 0x80);\n      outAt+=2;\n    }\n else {\n      bytes[outAt]=(byte)(((c >> 12) & 0x0f) | 0xe0);\n      bytes[outAt + 1]=(byte)(((c >> 6) & 0x3f) | 0x80);\n      bytes[outAt + 2]=(byte)((c & 0x3f) | 0x80);\n      outAt+=3;\n    }\n  }\n  byte[] result=new byte[outAt];\n  System.arraycopy(bytes,0,result,0,outAt);\n  return result;\n}", "comment": "converts a string into its java - style utf - 8 form .", "label": "done"}
{"id": "37283", "raw_code": "private List<Pair<String,Object>> toPairList(final Map<String,Object> bindings){\n  final List<Pair<String,Object>> blist=new ArrayList<Pair<String,Object>>();\n  for (  final Map.Entry<String,Object> pair : bindings.entrySet()) {\n    blist.add(new Pair<String,Object>(pair.getKey(),pair.getValue()));\n  }\n  return blist;\n}", "comment": "converts a hash map of bindings to a list of binding pairs .", "label": "done"}
{"id": "16262", "raw_code": "public void show(char initialChar){\n  initialString=initialString.append(initialChar);\n  show();\n  if (SWT.getPlatform() != \"carbon\") {\n    setEditText(initialString.toString());\n  }\n}", "comment": "performs show and sets the edit string to be the initial character or string", "label": "done"}
{"id": "414", "raw_code": "public String diff_text1(LinkedList<Diff> diffs){\n  StringBuilder text=new StringBuilder();\n  for (  Diff aDiff : diffs) {\n    if (aDiff.operation != Operation.INSERT) {\n      text.append(aDiff.text);\n    }\n  }\n  return text.toString();\n}", "comment": "compute and return the source text ( all equalities and deletions ) .", "label": "done"}
{"id": "73930", "raw_code": "public boolean isSearchLightBit(int bit){\n  if (nodeType != SMINI) {\n    log.error(\"Invalid query of Searchlights bits - not SMINI node\");\n    return (false);\n  }\n  if ((bit < 0) || (bit > 47)) {\n    log.error(\"Invalid bit number in query of SMINI Searchlights bits: \" + Integer.toString(bit));\n    return (false);\n  }\n  if (locSearchLightBits[bit] == 1) {\n    return (true);\n  }\n  return (false);\n}", "comment": "query searchlightbits by bit number ( smini only ) bit - bitnumber of the either bit of an oscillating search light bit pair note : returns ' true ' if bit is an oscillating searchlightbit , otherwise ' false ' is returned", "label": "done"}
{"id": "41709", "raw_code": "public String convertSWFToHTML(InputStream in) throws Exception {\n  StringWriter out1=new StringWriter();\n  output=new PrintWriter(out1);\n  TagParser parser=new TagParser(this);\n  SWFReader reader=new SWFReader(parser,in);\n  reader.readFile();\n  in.close();\n  sizeCount=reader.size;\n  final String ret=\"<html>\" + (headerstr.isEmpty() ? \"<body>\" : \"<header>\" + headerstr + \"</header><body>\") + out1.toString()+ \"</body></html>\";\n  return ret;\n}", "comment": "parses swf input and extracts text and wrap it as html", "label": "done"}
{"id": "11433", "raw_code": "public Shape greatCircleLineShape(){\n  GeneralPath path=null;\n  if (llpts != null && llpts.length >= 4 && llpts.length % 2 == 0) {\n    double y1=llpts[0];\n    double x1=llpts[1];\n    path=new GeneralPath(GeneralPath.WIND_EVEN_ODD,llpts.length / 2);\n    boolean firstCoords=true;\n    for (int i=2; i < llpts.length; i+=2) {\n      double y2=llpts[i];\n      double x2=llpts[i + 1];\n      double radDist=GreatCircle.sphericalDistance(y1,x1,y2,x2);\n      int nsegs=(int)(ProjMath.radToDeg(radDist) * segsPerDeg);\n      if (nsegs == 0) {\n        nsegs=1;\n      }\n      double[] coords=GreatCircle.greatCircle(y1,x1,y2,x2,nsegs,false);\n      if (returnDegrees) {\n        ProjMath.arrayRadToDeg(coords);\n      }\n      for (int j=0; j <= coords.length - 1; j+=2) {\n        if (firstCoords) {\n          path.moveTo(coords[j + 1],coords[j]);\n          firstCoords=false;\n        }\n else {\n          path.lineTo(coords[j + 1],coords[j]);\n        }\n      }\n      x1=x2;\n      y1=y2;\n    }\n    if (returnDegrees) {\n      path.lineTo(ProjMath.radToDeg(x1),ProjMath.radToDeg(y1));\n    }\n else {\n      path.lineTo(x1,y1);\n    }\n  }\n  return path;\n}", "comment": "create a java . awt . shape object of coordinates connected by great circle lines .", "label": "done"}
{"id": "38989", "raw_code": "public void splitNode(KDTreeNode node,int numNodesCreated,double[][] nodeRanges,double[][] universe) throws Exception {\n  correctlyInitialized();\n  if (node.m_NodesRectBounds == null) {\n    node.m_NodesRectBounds=new double[2][node.m_NodeRanges.length];\n    for (int i=0; i < node.m_NodeRanges.length; i++) {\n      node.m_NodesRectBounds[MIN][i]=node.m_NodeRanges[i][MIN];\n      node.m_NodesRectBounds[MAX][i]=node.m_NodeRanges[i][MAX];\n    }\n  }\n  double maxRectWidth=Double.NEGATIVE_INFINITY, maxPtWidth=Double.NEGATIVE_INFINITY, tempval;\n  int splitDim=-1, classIdx=m_Instances.classIndex();\n  for (int i=0; i < node.m_NodesRectBounds[0].length; i++) {\n    if (i == classIdx)     continue;\n    tempval=node.m_NodesRectBounds[MAX][i] - node.m_NodesRectBounds[MIN][i];\n    if (m_NormalizeNodeWidth) {\n      tempval=tempval / universe[i][WIDTH];\n    }\n    if (tempval > maxRectWidth && node.m_NodeRanges[i][WIDTH] > 0.0)     maxRectWidth=tempval;\n  }\n  for (int i=0; i < node.m_NodesRectBounds[0].length; i++) {\n    if (i == classIdx)     continue;\n    tempval=node.m_NodesRectBounds[MAX][i] - node.m_NodesRectBounds[MIN][i];\n    if (m_NormalizeNodeWidth) {\n      tempval=tempval / universe[i][WIDTH];\n    }\n    if (tempval >= maxRectWidth * (1 - ERR) && node.m_NodeRanges[i][WIDTH] > 0.0) {\n      if (node.m_NodeRanges[i][WIDTH] > maxPtWidth) {\n        maxPtWidth=node.m_NodeRanges[i][WIDTH];\n        if (m_NormalizeNodeWidth)         maxPtWidth=maxPtWidth / universe[i][WIDTH];\n        splitDim=i;\n      }\n    }\n  }\n  double splitVal=node.m_NodesRectBounds[MIN][splitDim] + (node.m_NodesRectBounds[MAX][splitDim] - node.m_NodesRectBounds[MIN][splitDim]) * 0.5;\n  if (splitVal < node.m_NodeRanges[splitDim][MIN])   splitVal=node.m_NodeRanges[splitDim][MIN];\n else   if (splitVal >= node.m_NodeRanges[splitDim][MAX])   splitVal=node.m_NodeRanges[splitDim][MAX] - node.m_NodeRanges[splitDim][WIDTH] * 0.001;\n  int rightStart=rearrangePoints(m_InstList,node.m_Start,node.m_End,splitDim,splitVal);\n  if (rightStart == node.m_Start || rightStart > node.m_End) {\n    if (rightStart == node.m_Start)     throw new Exception(\"Left child is empty in node \" + node.m_NodeNumber + \". Not possible with \"+ \"SlidingMidPointofWidestSide splitting method. Please \"+ \"check code.\");\n else     throw new Exception(\"Right child is empty in node \" + node.m_NodeNumber + \". Not possible with \"+ \"SlidingMidPointofWidestSide splitting method. Please \"+ \"check code.\");\n  }\n  node.m_SplitDim=splitDim;\n  node.m_SplitValue=splitVal;\n  double[][] widths=new double[2][node.m_NodesRectBounds[0].length];\n  System.arraycopy(node.m_NodesRectBounds[MIN],0,widths[MIN],0,node.m_NodesRectBounds[MIN].length);\n  System.arraycopy(node.m_NodesRectBounds[MAX],0,widths[MAX],0,node.m_NodesRectBounds[MAX].length);\n  widths[MAX][splitDim]=splitVal;\n  node.m_Left=new KDTreeNode(numNodesCreated + 1,node.m_Start,rightStart - 1,m_EuclideanDistance.initializeRanges(m_InstList,node.m_Start,rightStart - 1),widths);\n  widths=new double[2][node.m_NodesRectBounds[0].length];\n  System.arraycopy(node.m_NodesRectBounds[MIN],0,widths[MIN],0,node.m_NodesRectBounds[MIN].length);\n  System.arraycopy(node.m_NodesRectBounds[MAX],0,widths[MAX],0,node.m_NodesRectBounds[MAX].length);\n  widths[MIN][splitDim]=splitVal;\n  node.m_Right=new KDTreeNode(numNodesCreated + 2,rightStart,node.m_End,m_EuclideanDistance.initializeRanges(m_InstList,rightStart,node.m_End),widths);\n}", "comment": "splits a node into two based on the midpoint value of the dimension in which the node ' s rectangle is widest .", "label": "done"}
{"id": "7579", "raw_code": "public StandardXYItemLabelGenerator(){\n  this(DEFAULT_ITEM_LABEL_FORMAT,NumberFormat.getNumberInstance(),NumberFormat.getNumberInstance());\n}", "comment": "creates an item label generator using default number formatters .", "label": "done"}
{"id": "84625", "raw_code": "public List<ColourChange> sampleConditionalMigrationEvents2(int parentColour,double parentHeight,int childColour,double childHeight,double[] m){\n  List<ColourChange> colourChanges=new ArrayList<ColourChange>();\n  if (parentHeight < childHeight) {\n    throw new IllegalArgumentException(\"sampleConditionalMigrationEvents: parentHeight=\" + parentHeight + \" childHeight=\"+ childHeight+ \", not good.\");\n  }\n  try {\n    int currentColour=parentColour;\n    double currentHeight=parentHeight;\n    while (true) {\n      ColourChange nextEvent=randomConditionalMigrationEvent(currentColour,currentHeight,childColour,childHeight,m);\n      currentHeight=nextEvent.getTime();\n      currentColour=nextEvent.getColourAbove();\n      colourChanges.add(nextEvent);\n    }\n  }\n catch (  NoEventException nee) {\n  }\n  reverseColourChangeList(colourChanges,parentColour);\n  return colourChanges;\n}", "comment": "samples migration events on a two - coloured branch , conditional on colours at both ends migration process is forwards in ( natural ) time , so we are going down the tree .", "label": "done"}
{"id": "72527", "raw_code": "private boolean tryStep(final double t0,final double[] y0,final double step,final int k,final double[] scale,final double[][] f,final double[] yMiddle,final double[] yEnd) throws MathIllegalArgumentException, MathIllegalStateException {\n  final int n=sequence[k];\n  final double subStep=step / n;\n  final double subStep2=2 * subStep;\n  double t=t0 + subStep;\n  for (int i=0; i < y0.length; ++i) {\n    yEnd[i]=y0[i] + subStep * f[0][i];\n  }\n  f[1]=computeDerivatives(t,yEnd);\n  final double[] yTmp=y0.clone();\n  for (int j=1; j < n; ++j) {\n    if (2 * j == n) {\n      System.arraycopy(yEnd,0,yMiddle,0,y0.length);\n    }\n    t+=subStep;\n    for (int i=0; i < y0.length; ++i) {\n      final double middle=yEnd[i];\n      yEnd[i]=yTmp[i] + subStep2 * f[j][i];\n      yTmp[i]=middle;\n    }\n    f[j + 1]=computeDerivatives(t,yEnd);\n    if (performTest && (j <= maxChecks) && (k < maxIter)) {\n      double initialNorm=0.0;\n      for (int l=0; l < scale.length; ++l) {\n        final double ratio=f[0][l] / scale[l];\n        initialNorm+=ratio * ratio;\n      }\n      double deltaNorm=0.0;\n      for (int l=0; l < scale.length; ++l) {\n        final double ratio=(f[j + 1][l] - f[0][l]) / scale[l];\n        deltaNorm+=ratio * ratio;\n      }\n      if (deltaNorm > 4 * FastMath.max(1.0e-15,initialNorm)) {\n        return false;\n      }\n    }\n  }\n  for (int i=0; i < y0.length; ++i) {\n    yEnd[i]=0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n  }\n  return true;\n}", "comment": "perform integration over one step using substeps of a modified midpoint method .", "label": "done"}
{"id": "62169", "raw_code": "public ItemStack removeItems(ItemStack drive,ItemStack stack,int amountWanted){\n  if (getMaxKilobits(drive) == -1)   return null;\n  int stored=getAmountStored(drive,stack);\n  int amountGiven=Math.min(amountWanted,stored);\n  if (amountGiven > 0) {\n    setAmountStored(drive,stack,stored - amountGiven);\n    stack.stackSize+=amountGiven;\n    markDirty(drive);\n  }\n  return stack;\n}", "comment": "take as many items as possible , up to the passed limit , from a drive into the given stack .", "label": "done"}
{"id": "224", "raw_code": "private Sha256Hash calculateHash(){\n  try {\n    ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(HEADER_SIZE);\n    writeHeader(bos);\n    return new Sha256Hash(Utils.reverseBytes(doubleDigest(bos.toByteArray())));\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}", "comment": "calculates the block hash by serializing the block and hashing the resulting bytes .", "label": "done"}
{"id": "13597", "raw_code": "private void addPropertyType(URI p,Resource t){\n  OwlProperty prop=getProperty(p);\n  if (t.equals(OWL.TRANSITIVEPROPERTY)) {\n    prop.setTransitive();\n  }\n else   if (t.equals(OWL.SYMMETRICPROPERTY)) {\n    prop.setSymmetric();\n  }\n else   if (t.equals(OWL2.ASYMMETRICPROPERTY)) {\n    prop.setAsymmetric();\n  }\n else   if (t.equals(OWL.FUNCTIONALPROPERTY)) {\n    prop.setFunctional();\n  }\n else   if (t.equals(OWL.INVERSEFUNCTIONALPROPERTY)) {\n    prop.setInverseFunctional();\n  }\n else   if (t.equals(OWL2.IRREFLEXIVEPROPERTY)) {\n    prop.setIrreflexive();\n  }\n}", "comment": "add a particular characteristic to a property .", "label": "done"}
{"id": "56967", "raw_code": "public static String writeActionsToString(OFInstructionWriteActions inst,Logger log) throws Exception {\n  return ActionUtils.actionsToString(inst.getActions(),log);\n}", "comment": "convert an ofinstructionwriteactions to string form .", "label": "done"}
{"id": "87035", "raw_code": "public static String encodeLines(byte[] in,int iOff,int iLen,int lineLen,String lineSeparator){\n  int blockLen=(lineLen * 3) / 4;\n  if (blockLen <= 0)   throw new IllegalArgumentException();\n  int lines=(iLen + blockLen - 1) / blockLen;\n  int bufLen=((iLen + 2) / 3) * 4 + lines * lineSeparator.length();\n  StringBuilder buf=new StringBuilder(bufLen);\n  int ip=0;\n  while (ip < iLen) {\n    int l=Math.min(iLen - ip,blockLen);\n    buf.append(encode(in,iOff + ip,l));\n    buf.append(lineSeparator);\n    ip+=l;\n  }\n  return buf.toString();\n}", "comment": "encodes a byte array into base 64 format and breaks the output into lines .", "label": "done"}
{"id": "46243", "raw_code": "final int rllong(DataInputStream dis) throws IOException {\n  int b1, b2, b3, b4;\n  int i=0;\n  i=dis.readInt();\n  b1=(i & 0xFF) << 24;\n  b2=(i & 0xFF00) << 8;\n  b3=(i & 0xFF0000) >> 8;\n  b4=(i & 0xFF000000) >>> 24;\n  i=(b1 | b2 | b3| b4);\n  return i;\n}", "comment": "rllong protected helper method to read 64 bits and changing the order of each bytes .", "label": "done"}
{"id": "56987", "raw_code": "protected void illegalMessageReceived(OFMessage m){\n  String msg=getSwitchStateMessage(m,\"Switch should never send this message in the current state\");\n  throw new SwitchStateException(msg);\n}", "comment": "we have an ofmessage we didn ' t expect given the current state and we want to treat this as an error .", "label": "done"}
{"id": "10954", "raw_code": "protected boolean read(){\n  if (!nReuseHeader) {\n    Debug.message(\"iso8211\",\"DDFRecord reusing header, calling readHeader()\");\n    return readHeader();\n  }\n  byte[] tempData=new byte[nDataSize - nFieldOffset];\n  int nReadBytes=poModule.read(tempData,0,tempData.length);\n  System.arraycopy(pachData,nFieldOffset,tempData,0,tempData.length);\n  if (nReadBytes != (int)(nDataSize - nFieldOffset) && nReadBytes == -1) {\n    return false;\n  }\n else   if (nReadBytes != (int)(nDataSize - nFieldOffset)) {\n    Debug.error(\"DDFRecord: Data record is short on DDF file.\");\n    return false;\n  }\n  return true;\n}", "comment": "read a record of data from the file , and parse the header to build a field list for the record ( or reuse the existing one if reusing headers ) .", "label": "done"}
{"id": "2305", "raw_code": "@SafeVarargs public final void add(T... newItems){\n  add(Arrays.asList(newItems));\n}", "comment": "add new items to the table .", "label": "done"}
{"id": "25138", "raw_code": "public static void checkState(boolean expression,@Nullable Object errorMessage){\n  if (!expression) {\n    throw new IllegalStateException(String.valueOf(errorMessage));\n  }\n}", "comment": "ensures the truth of an expression involving the state of the calling instance , but not involving any parameters to the calling method .", "label": "done"}
{"id": "24808", "raw_code": "public long cguest_time(){\n  return Long.parseLong(fields[43]);\n}", "comment": "( since linux 2 . 6 . 24 ) guest time of the process ' s children , measured in clock ticks ( divide by sysconf ( _ sc _ clk _ tck ) ) .", "label": "done"}
{"id": "62259", "raw_code": "private static ClassInfo findOrCreateClass(String t){\n  if (!t.endsWith(\"[]\")) {\n    return ClassInfo.findOrCreateClass(t);\n  }\n else {\n    String baseType=t.substring(0,t.indexOf(\"[]\"));\n    int level=(t.length() - t.indexOf(\"[]\")) / 2;\n    String s=\"\";\n    for (int i=0; i < level; ++i)     s+=\"[\";\n    if (baseType.equals(\"int\"))     s+=\"I\";\n else     if (baseType.equals(\"boolean\"))     s+=\"B\";\n else     s+=\"L\" + baseType + \";\";\n    return ClassInfo.findOrCreateClass(s);\n  }\n}", "comment": "convert pscout - style type name to canonical form", "label": "done"}
{"id": "25457", "raw_code": "@HLEFunction(nid=0x7ED29E40,version=150) public int sceRtcSetTick(TPointer timeAddr,TPointer64 ticksAddr){\n  long ticks=ticksAddr.getValue() - rtcMagicOffset;\n  ScePspDateTime time=ScePspDateTime.fromMicros(ticks);\n  time.write(timeAddr);\n  return 0;\n}", "comment": "set a psptime struct based on ticks .", "label": "done"}
{"id": "10142", "raw_code": "public static Byte[] valuesOf(byte[] array){\n  Byte[] dest=new Byte[array.length];\n  for (int i=0; i < array.length; i++) {\n    dest[i]=Byte.valueOf(array[i]);\n  }\n  return dest;\n}", "comment": "converts to object array .", "label": "done"}
{"id": "10190", "raw_code": "public void ensureCapacity(int mincap){\n  if (mincap > array.length) {\n    int newcap=((array.length * 3) >> 1) + 1;\n    int[] olddata=array;\n    array=new int[newcap < mincap ? mincap : newcap];\n    System.arraycopy(olddata,0,array,0,size);\n  }\n}", "comment": "increases the capacity of this arraylist instance , if necessary , to ensure that it can hold at least the number of elements specified by the minimum capacity argument .", "label": "done"}
{"id": "40787", "raw_code": "private static Intent createMapActivityIntent(Context context,URLSpan[] urlSpans){\n  for (int span_i=0; span_i < urlSpans.length; span_i++) {\n    URLSpan urlSpan=urlSpans[span_i];\n    String urlString=urlSpan.getURL();\n    if (urlString.startsWith(GEO_PREFIX)) {\n      Intent geoIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(urlString));\n      geoIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n      return geoIntent;\n    }\n  }\n  return null;\n}", "comment": "create an intent to take the user to maps , using the first map link available .", "label": "done"}
{"id": "77849", "raw_code": "public void writeExif(Bitmap bmap,OutputStream exifOutStream) throws IOException {\n  if (bmap == null || exifOutStream == null) {\n    throw new IllegalArgumentException(NULL_ARGUMENT_STRING);\n  }\n  OutputStream s=getExifWriterStream(exifOutStream);\n  bmap.compress(Bitmap.CompressFormat.JPEG,90,s);\n  s.flush();\n}", "comment": "writes the tags from this exifinterface object into a jpeg compressed bitmap , removing prior exif tags .", "label": "done"}
{"id": "28973", "raw_code": "public static @CheckForNull @SlashedClassName String fromFieldSignature(String signature){\n  if (signature.charAt(0) != 'L') {\n    return null;\n  }\n  return signature.substring(1,signature.length() - 1);\n}", "comment": "converts from signature to slashed class name ( e . g . , from ljava / lang / string ; to java / lang / string ) .", "label": "done"}
{"id": "53605", "raw_code": "private void paintPreview(int dx,int dy,float zoomfactor){\n  if (image != null) {\n    Graphics2D g2=(Graphics2D)getGraphics();\n    UColor bg=renderer.getBackgroundColor();\n    g2.setBackground(new Color(bg.getRed(),bg.getGreen(),bg.getBlue(),bg.getAlpha()));\n    int newWidth=Math.round(image.getWidth(null) * zoomfactor);\n    int newHeight=(int)Math.round(image.getHeight(null) * zoomfactor);\n    g2.drawImage(image,dx,dy,newWidth,newHeight,null);\n    if (dx > 0)     g2.clearRect(0,0,dx,getHeight());\n else     g2.clearRect(getWidth() + dx,0,getWidth(),getHeight());\n    if (dy > 0)     g2.clearRect(0,0,getWidth(),dy);\n else     g2.clearRect(0,getHeight() + dy,getWidth(),getHeight());\n  }\n}", "comment": "draws the off - screen image if exists at position ( dx , dy ) scaled by the specified factor .", "label": "done"}
{"id": "62656", "raw_code": "public static List<List<Double>> partitionVariable(List<Double> arr,int chunk){\n  int count=0;\n  List<List<Double>> ret=new ArrayList<List<Double>>();\n  while (count < arr.size()) {\n    List<Double> sublist=arr.subList(count,count + chunk);\n    count+=chunk;\n    ret.add(sublist);\n  }\n  for (  List<Double> lists : ret) {\n    if (lists.size() < chunk)     ret.remove(lists);\n  }\n  return ret;\n}", "comment": "this will partition the given whole variable data applytransformtodestination in to the specified chunk number .", "label": "done"}
{"id": "51056", "raw_code": "public ArrayList<ConstraintWidget> findWidgets(WidgetContainer container,int x,int y,int width,int height){\n  ArrayList<ConstraintWidget> found=new ArrayList<>();\n  Rectangle area=new Rectangle(x,y,width,height);\n  for (  ConstraintWidget widget : container.getChildren()) {\n    WidgetCompanion companion=(WidgetCompanion)widget.getCompanionWidget();\n    WidgetDecorator decorator=companion.getWidgetDecorator(WidgetDecorator.BLUEPRINT_STYLE);\n    if (!decorator.isVisible()) {\n      continue;\n    }\n    Rectangle bounds=new Rectangle(widget.getDrawX(),widget.getDrawY(),widget.getWidth(),widget.getHeight());\n    if (area.intersects(bounds)) {\n      found.add(widget);\n    }\n  }\n  return found;\n}", "comment": "gather all the widgets contained in the area specified and return them as an array , taking the decorator visibility in account", "label": "done"}
{"id": "79232", "raw_code": "public static ShoppingCartItem makeItem(Integer cartLocation,GenericValue product,BigDecimal selectedAmount,BigDecimal quantity,BigDecimal unitPrice,Timestamp reservStart,BigDecimal reservLength,BigDecimal reservPersons,Timestamp shipBeforeDate,Timestamp shipAfterDate,Map<String,GenericValue> additionalProductFeatureAndAppls,Map<String,Object> attributes,String prodCatalogId,ProductConfigWrapper configWrapper,String itemType,ShoppingCart.ShoppingCartItemGroup itemGroup,LocalDispatcher dispatcher,ShoppingCart cart,Boolean triggerExternalOpsBool,Boolean triggerPriceRulesBool,GenericValue parentProduct,Boolean skipInventoryChecks,Boolean skipProductChecks) throws CartItemModifyException {\n  return makeItem(cartLocation,product,selectedAmount,quantity,unitPrice,reservStart,reservLength,reservPersons,null,null,shipBeforeDate,shipAfterDate,additionalProductFeatureAndAppls,attributes,prodCatalogId,configWrapper,itemType,itemGroup,dispatcher,cart,triggerExternalOpsBool,triggerPriceRulesBool,parentProduct,skipInventoryChecks,skipProductChecks);\n}", "comment": "makes a shoppingcartitem and adds it to the cart .", "label": "done"}
{"id": "75538", "raw_code": "private void addClasses(Class<?>[] classes,HashSet<Class<?>> result,String fieldName){\n  if (classes == null || classes.length == 0)   Error.classesAbsent(fieldName,configuredClass);\n  for (  Class<?> classe : classes)   result.add(classe);\n}", "comment": "adds to the result parameter all classes that aren ' t present in it", "label": "done"}
{"id": "256", "raw_code": "public static BigInteger decodeMPI(byte[] mpi,boolean hasLength){\n  byte[] buf;\n  if (hasLength) {\n    int length=(int)readUint32BE(mpi,0);\n    buf=new byte[length];\n    System.arraycopy(mpi,4,buf,0,length);\n  }\n else   buf=mpi;\n  if (buf.length == 0)   return BigInteger.ZERO;\n  boolean isNegative=(buf[0] & 0x80) == 0x80;\n  if (isNegative)   buf[0]&=0x7f;\n  BigInteger result=new BigInteger(buf);\n  return isNegative ? result.negate() : result;\n}", "comment": "mpi encoded numbers are produced by the openssl bn _ bn2mpi function .", "label": "done"}
{"id": "61165", "raw_code": "public void sort(DTMIterator v,Vector keys,XPathContext support) throws javax.xml.transform.TransformerException {\n  m_keys=keys;\n  int n=v.getLength();\n  Vector nodes=new Vector();\n  for (int i=0; i < n; i++) {\n    NodeCompareElem elem=new NodeCompareElem(v.item(i));\n    nodes.addElement(elem);\n  }\n  Vector scratchVector=new Vector();\n  mergesort(nodes,scratchVector,0,n - 1,support);\n  for (int i=0; i < n; i++) {\n    v.setItem(((NodeCompareElem)nodes.elementAt(i)).m_node,i);\n  }\n  v.setCurrentPos(0);\n}", "comment": "given a vector of nodes , sort each node according to the criteria in the keys .", "label": "done"}
{"id": "10899", "raw_code": "public void init(String prefix,java.net.URL url){\n  try {\n    java.io.InputStream in=url.openStream();\n    Properties props=new Properties();\n    props.load(in);\n    init(getLayers(prefix,props));\n  }\n catch (  java.net.MalformedURLException murle) {\n    logger.warning(\"LayerHandler.init(URL): \" + url + \" is not a valid URL\");\n  }\ncatch (  java.io.IOException e) {\n    logger.warning(\"LayerHandler.init(URL): Caught an IOException\");\n  }\n}", "comment": "initialize the layerhandler by having it construct it ' s layers from a url containing an openmap . properties file .", "label": "done"}
{"id": "10119", "raw_code": "public Node selectFirst(String query){\n  List<Node> selectedNodes=select(query);\n  if (selectedNodes.isEmpty()) {\n    return null;\n  }\n  return selectedNodes.get(0);\n}", "comment": "selects nodes using css3 selector query and returns the very first one .", "label": "done"}
{"id": "67167", "raw_code": "public static <V>boolean addDistinctEntry(List<V> sourceList,V entry){\n  return (sourceList != null && !sourceList.contains(entry)) ? sourceList.add(entry) : false;\n}", "comment": "add distinct entry to list", "label": "done"}
{"id": "40582", "raw_code": "protected String computeFullUrl(URL baseUrl,String link){\n  if (link == null || link.length() == 0) {\n    return null;\n  }\n  if (!link.startsWith(\"http\")) {\n    if (link.startsWith(\"/\")) {\n      link=baseUrl.getProtocol() + \"://\" + baseUrl.getAuthority()+ link;\n    }\n else {\n      if (link.contains(\":\")) {\n        return null;\n      }\n      String path=baseUrl.getPath();\n      if (!path.endsWith(\"/\")) {\n        int sep=path.lastIndexOf(\"/\");\n        String file=path.substring(sep + 1);\n        if (file.contains(\".\") || file.contains(\"?\"))         path=path.substring(0,sep);\n      }\n      link=baseUrl.getProtocol() + \"://\" + baseUrl.getAuthority()+ path+ \"/\"+ link;\n    }\n  }\n  link=normalizeUrlEnding(link);\n  String l=link.toLowerCase(Locale.ROOT);\n  if (l.endsWith(\".jpg\") || l.endsWith(\".jpeg\") || l.endsWith(\".png\")|| l.endsWith(\".gif\")) {\n    return null;\n  }\n  return link;\n}", "comment": "computes the full url based on a base url and a possibly relative link found in the href param of an html anchor .", "label": "done"}
{"id": "32191", "raw_code": "@Nullable GridCacheMvccCandidate addEntry(GridLocalCacheEntry entry) throws GridCacheEntryRemovedException {\n  GridCacheMvccCandidate c=entry.addLocal(threadId,lockVer,null,null,timeout,!inTx(),inTx(),implicitSingle(),true);\n  entries.add(entry);\n  if (c == null && timeout < 0) {\n    if (log.isDebugEnabled())     log.debug(\"Failed to acquire lock with negative timeout: \" + entry);\n    onFailed();\n    return null;\n  }\n  if (c != null) {\n    entry.readyLocal(c);\n  }\n  return c;\n}", "comment": "adds entry to future .", "label": "done"}
{"id": "77841", "raw_code": "private static byte[] readCheckedBytes(byte[] buffer,int dataSize) throws InvalidProtocolBufferNanoException {\n  CheckedMessage wrapper=new CheckedMessage();\n  MessageNano.mergeFrom(wrapper,buffer,0,dataSize);\n  CRC32 checksum=new CRC32();\n  checksum.update(wrapper.payload);\n  if (wrapper.checksum != checksum.getValue()) {\n    throw new InvalidProtocolBufferNanoException(\"checksum does not match\");\n  }\n  return wrapper.payload;\n}", "comment": "unwrap a proto message from a checkedmessage , verifying the checksum .", "label": "done"}
{"id": "21713", "raw_code": "private Set<String> returnRemotePoolsAssociatedWithRemoteCopySettings(Map<String,List<String>> remoteCopySettings,Set<String> poolUris){\n  Set<String> remotePoolUris=new HashSet<String>();\n  for (  Entry<String,List<String>> entry : remoteCopySettings.entrySet()) {\n    VirtualPool vPool=_objectCache.queryObject(VirtualPool.class,URI.create(entry.getKey()));\n    if (null == vPool) {\n      remotePoolUris.addAll(poolUris);\n    }\n else     if (null != vPool.getUseMatchedPools() && vPool.getUseMatchedPools()) {\n      if (null != vPool.getMatchedStoragePools()) {\n        remotePoolUris.addAll(vPool.getMatchedStoragePools());\n      }\n    }\n else     if (null != vPool.getAssignedStoragePools()) {\n      remotePoolUris.addAll(vPool.getAssignedStoragePools());\n    }\n  }\n  return remotePoolUris;\n}", "comment": "choose pools based on remote vpool ' s matched or assigned pools", "label": "done"}
{"id": "32628", "raw_code": "private String convertToHtml(final String string){\n  return \"<pre><br/>\" + string.replaceAll(\"\\n\",\"<br/>\") + \"<br/></pre>\";\n}", "comment": "converts text to html , by transforming \\ n to", "label": "done"}
{"id": "17761", "raw_code": "private synchronized void addLock(FileLock lock) throws OverlappingFileLockException {\n  long lockEnd=lock.position() + lock.size();\n  for (  FileLock existingLock : locks) {\n    if (existingLock.position() > lockEnd) {\n      break;\n    }\n    if (existingLock.overlaps(lock.position(),lock.size())) {\n      throw new OverlappingFileLockException();\n    }\n  }\n  locks.add(lock);\n}", "comment": "add a new pending lock to the manager .", "label": "done"}
{"id": "55899", "raw_code": "public static final String moveToUCIString(Move m){\n  String ret=squareToString(m.from);\n  ret+=squareToString(m.to);\nswitch (m.promoteTo) {\ncase Piece.WQUEEN:\ncase Piece.BQUEEN:\n    ret+=\"q\";\n  break;\ncase Piece.WROOK:\ncase Piece.BROOK:\nret+=\"r\";\nbreak;\ncase Piece.WBISHOP:\ncase Piece.BBISHOP:\nret+=\"b\";\nbreak;\ncase Piece.WKNIGHT:\ncase Piece.BKNIGHT:\nret+=\"n\";\nbreak;\ndefault :\nbreak;\n}\nreturn ret;\n}", "comment": "convert a move object to uci string format .", "label": "done"}
{"id": "29304", "raw_code": "public int evalRPN(String[] tokens){\n  if (tokens == null || tokens.length == 0)   return 0;\n  Stack<String> s=new Stack<String>();\n  int len=tokens.length;\n  for (int i=0; i < len; i++) {\n    String cur=tokens[i];\n    if (isOperator(cur)) {\n      int t2=Integer.parseInt(s.pop());\n      int t1=Integer.parseInt(s.pop());\n      int res=calculate(t1,t2,cur);\n      s.push(Integer.toString(res));\n    }\n else     s.push(cur);\n  }\n  return Integer.valueOf(s.peek());\n}", "comment": "assign a priority for each operators use a stack to store them note the numbers can be negative we evaluate the expression left - to - right and push operands onto the stack until we encounter an operator , which we pop the top two values from the stack .", "label": "done"}
{"id": "70465", "raw_code": "public synchronized void addAllSeries(List<XYSeries> series){\n  mSeries.addAll(series);\n}", "comment": "adds all the provided xy series to the list .", "label": "done"}
{"id": "16133", "raw_code": "public AABB merge(AABB other){\n  minX=Math.min(minX,other.minX);\n  maxX=Math.max(maxX,other.maxX);\n  minY=Math.min(minY,other.minY);\n  maxY=Math.max(maxY,other.maxY);\n  minZ=Math.min(minZ,other.minZ);\n  maxZ=Math.max(maxZ,other.maxZ);\n  return this;\n}", "comment": "computes an aabb that contains both this and other and stores it in this .", "label": "done"}
{"id": "18191", "raw_code": "public void flushPending() throws SAXException {\n  if (m_needToCallStartDocument) {\n    startDocumentInternal();\n    m_needToCallStartDocument=false;\n  }\n  if (m_elemContext.m_startTagOpen) {\n    closeStartTag();\n    m_elemContext.m_startTagOpen=false;\n  }\n  if (m_cdataTagOpen) {\n    closeCDATA();\n    m_cdataTagOpen=false;\n  }\n  if (m_writer != null) {\n    try {\n      m_writer.flush();\n    }\n catch (    IOException e) {\n    }\n  }\n}", "comment": "this method flushes any pending events , which can be startdocument ( ) closing the opening tag of an element , or closing an open cdata section .", "label": "done"}
{"id": "70944", "raw_code": "private void handleSubscribe(String[] args){\nswitch (args[1]) {\ncase \"rr\":\n    TestSubscriber<Payload> rrsub=new TestSubscriber<>(0L);\n  payloadSubscribers.put(args[2],rrsub);\nidToType.put(args[2],args[1]);\nReactiveSocket rrclient=createClient.get();\nPublisher<Payload> rrpub=rrclient.requestResponse(new PayloadImpl(args[3],args[4]));\nrrpub.subscribe(rrsub);\nbreak;\ncase \"rs\":\nTestSubscriber<Payload> rssub=new TestSubscriber<>(0L);\npayloadSubscribers.put(args[2],rssub);\nidToType.put(args[2],args[1]);\nReactiveSocket rsclient=createClient.get();\nPublisher<Payload> rspub=rsclient.requestStream(new PayloadImpl(args[3],args[4]));\nrspub.subscribe(rssub);\nbreak;\ncase \"sub\":\nTestSubscriber<Payload> rsubsub=new TestSubscriber<>(0L);\npayloadSubscribers.put(args[2],rsubsub);\nidToType.put(args[2],args[1]);\nReactiveSocket rsubclient=createClient.get();\nPublisher<Payload> rsubpub=rsubclient.requestSubscription(new PayloadImpl(args[3],args[4]));\nrsubpub.subscribe(rsubsub);\nbreak;\ncase \"fnf\":\nTestSubscriber<Void> fnfsub=new TestSubscriber<>(0L);\nfnfSubscribers.put(args[2],fnfsub);\nidToType.put(args[2],args[1]);\nReactiveSocket fnfclient=createClient.get();\nPublisher<Void> fnfpub=fnfclient.fireAndForget(new PayloadImpl(args[3],args[4]));\nfnfpub.subscribe(fnfsub);\nbreak;\ndefault :\nbreak;\n}\n}", "comment": "this function takes in the arguments for the subscribe command , and subscribes an instance of testsubscriber with an initial request of 0 ( which means don ' t immediately make a request ) to an instance of the corresponding publisher", "label": "done"}
{"id": "67417", "raw_code": "@PostConstruct public void init(){\n  configurationViews.add(defaultDistributionSetTypeLayout);\n  configurationViews.add(authenticationConfigurationView);\n  configurationViews.add(pollingConfigurationView);\n}", "comment": "init method adds all configuration views to the list of views .", "label": "done"}
{"id": "57950", "raw_code": "private static void validateNewAddition(Vector paths,ExpressionOwner owner,LocPathIterator path) throws RuntimeException {\n  assertion(owner.getExpression() == path,\"owner.getExpression() != path!!!\");\n  int n=paths.size();\n  for (int i=0; i < n; i++) {\n    ExpressionOwner ew=(ExpressionOwner)paths.elementAt(i);\n    assertion(ew != owner,\"duplicate owner on the list!!!\");\n    assertion(ew.getExpression() != path,\"duplicate expression on the list!!!\");\n  }\n}", "comment": "validate some assumptions about the new locpathiterator and it ' s owner and the state of the list .", "label": "done"}
{"id": "77976", "raw_code": "@Override public void start(){\n  for (int i=0; i < threadCount; ++i) {\n    Set<SystemStreamPartition> threadSsps=new HashSet<SystemStreamPartition>();\n    for (    SystemStreamPartition ssp : ssps) {\n      if (Math.abs(ssp.hashCode()) % threadCount == i) {\n        threadSsps.add(ssp);\n      }\n    }\n    Thread thread=new Thread(new MockSystemConsumerRunnable(threadSsps),\"MockSystemConsumer-\" + i);\n    thread.setDaemon(true);\n    threads.add(thread);\n    thread.start();\n  }\n}", "comment": "assign systemstreampartitions to all of the threads , and start them up to begin simulating consuming messages .", "label": "done"}
{"id": "7239", "raw_code": "public FromClause add(OuterJoinQualifier outerJoinQualifier){\n  outerJoinQualifiers.add(outerJoinQualifier);\n  return this;\n}", "comment": "adds an outer join descriptor that defines how the streams are related via outer joins .", "label": "done"}
{"id": "67925", "raw_code": "public E poll(long timeout,TimeUnit unit) throws InterruptedException {\n  long nanos=unit.toNanos(timeout);\n  final ReentrantLock lock=this.lock;\n  lock.lockInterruptibly();\n  long t=now();\n  TenantQueue.Item item=null;\n  try {\n    for (; ; ) {\n      TenantQueue q=nextQueue(t);\n      if (q == null) {\n        if (nanos <= 0)         return null;\n else         nanos=available.awaitNanos(nanos);\n      }\n else {\n        long delay=q.next - t;\n        if (delay <= 0) {\n          item=q.poll(t);\n          return item == null ? null : item.element;\n        }\n        if (nanos <= 0)         return null;\n        if (nanos < delay || leader != null)         nanos=available.awaitNanos(nanos);\n else {\n          Thread thisThread=Thread.currentThread();\n          leader=thisThread;\n          try {\n            long timeLeft=available.awaitNanos(delay);\n            nanos-=delay - timeLeft;\n          }\n  finally {\n            if (leader == thisThread)             leader=null;\n          }\n        }\n      }\n      t=System.nanoTime();\n    }\n  }\n  finally {\n    if (leader == null && hasNext())     available.signal();\n    lock.unlock();\n    done(item,t);\n  }\n}", "comment": "retrieves and removes the head of this queue , waiting if necessary until an element with an expired delay is available on this queue , or the specified wait time expires .", "label": "done"}
{"id": "78103", "raw_code": "private SublimeBaseMenuItem addInternal(int pivotID,Positioned positioned,SublimeBaseMenuItem newItem){\n  int newItemGroupId=newItem.getGroupId();\n  checkExistenceOfGroup(newItemGroupId);\n  int pivotIndex=findItemIndex(pivotID);\n  SublimeBaseMenuItem pivot=mItems.get(pivotIndex);\n  if (newItem.getItemType() == SublimeBaseMenuItem.ItemType.GROUP_HEADER) {\n    checkIfGroupHeaderAlreadyExistsForGroup(newItemGroupId);\n    int index=findGroupIndex(newItemGroupId);\n    if (index >= 0) {\n      mItems.add(index,newItem);\n    }\n else {\n      if (positioned == Positioned.BEFORE) {\n        if (pivot.getGroupId() == NO_GROUP_ID || pivot.getItemType() == SublimeBaseMenuItem.ItemType.GROUP_HEADER) {\n          mItems.add(pivotIndex,newItem);\n        }\n else {\n          mItems.add(newItem);\n        }\n      }\n else       if (positioned == Positioned.AFTER) {\n        if (pivot.getGroupId() == NO_GROUP_ID || pivotIndex == findLastGroupIndex(newItemGroupId)) {\n          mItems.add(pivotIndex + 1,newItem);\n        }\n else {\n          mItems.add(newItem);\n        }\n      }\n    }\n  }\n else {\n    if (newItemGroupId != NO_GROUP_ID) {\n      int lastGroupIndex=findLastGroupIndex(newItemGroupId);\n      if (lastGroupIndex == mItems.size()) {\n        if (positioned == Positioned.BEFORE) {\n          if (pivot.getGroupId() == NO_GROUP_ID || pivotIndex == findGroupIndex(pivot.getGroupId())) {\n            mItems.add(pivotIndex,newItem);\n          }\n else {\n            mItems.add(newItem);\n          }\n        }\n else         if (positioned == Positioned.AFTER) {\n          if (pivot.getGroupId() == NO_GROUP_ID || pivotIndex == findLastGroupIndex(pivot.getGroupId())) {\n            mItems.add(pivotIndex + 1,newItem);\n          }\n else {\n            mItems.add(newItem);\n          }\n        }\n      }\n else {\n        if (newItemGroupId == pivot.getGroupId()) {\n          if (positioned == Positioned.BEFORE) {\n            if (pivot.getItemType() != SublimeBaseMenuItem.ItemType.GROUP_HEADER) {\n              mItems.add(pivotIndex,newItem);\n            }\n else {\n              mItems.add(lastGroupIndex + 1,newItem);\n            }\n          }\n else           if (positioned == Positioned.AFTER) {\n            mItems.add(pivotIndex + 1,newItem);\n          }\n        }\n else {\n          mItems.add(lastGroupIndex + 1,newItem);\n        }\n      }\n    }\n else {\n      if (positioned == Positioned.BEFORE) {\n        if (pivot.getGroupId() == NO_GROUP_ID || findGroupIndex(pivot.getGroupId()) == pivotIndex) {\n          mItems.add(pivotIndex,newItem);\n        }\n else {\n          mItems.add(newItem);\n        }\n      }\n else       if (positioned == Positioned.AFTER) {\n        if (pivot.getGroupId() == NO_GROUP_ID || pivotIndex == findLastGroupIndex(pivot.getGroupId())) {\n          mItems.add(pivotIndex + 1,newItem);\n        }\n else {\n          mItems.add(newItem);\n        }\n      }\n    }\n  }\n  onItemsChanged();\n  return newItem;\n}", "comment": "adds an item to the menu and positions it using the given ` pivot ` .", "label": "done"}
{"id": "53774", "raw_code": "@Override public void addHeader(final String header,final String value){\n  mHeadersOptions.add(new HeaderOption(header,value));\n}", "comment": "adds a header to this request .", "label": "done"}
{"id": "36937", "raw_code": "static void appendToPointerHierarchy(final BaseType type,final BaseType pointer){\n  Preconditions.checkNotNull(type,\"Error: type argument can not be null.\");\n  Preconditions.checkNotNull(pointer,\"Error: pointer argument can not be null.\");\n  Preconditions.checkArgument(type != pointer,\"Error: Can not establish pointer relation between identical types.\");\n  Preconditions.checkArgument(pointer.pointedToBy != type,\"Error: Can not establish circular pointer relation.\");\n  Preconditions.checkArgument(type.pointsTo != pointer,\"Error: Can not establish circular pointer relation.\");\n  pointer.pointsTo=type;\n  type.pointedToBy=pointer;\n}", "comment": "appends a base type to the pointer hierarchy just below parent , e . g . if type is an int then pointer must be an int * .", "label": "done"}
{"id": "54399", "raw_code": "public Optional<T> last(){\n  Iterator<T> iterator=iterator();\n  T value=null;\n  while (iterator.hasNext())   value=iterator.next();\n  return Optional.of(value);\n}", "comment": "convert an iterable stream into one last item of the stream .", "label": "done"}
{"id": "18146", "raw_code": "public int indexOf(Node elem,int index){\n  runTo(-1);\n  if (null == m_map)   return -1;\n  for (int i=index; i < m_firstFree; i++) {\n    Node node=m_map[i];\n    if ((null != node) && node.equals(elem))     return i;\n  }\n  return -1;\n}", "comment": "searches for the first occurence of the given argument , beginning the search at index , and testing for equality using the equals method .", "label": "done"}
{"id": "59748", "raw_code": "public void drawContours(Mat img,Color color){\n  Drawing.drawContours(img,contours,color);\n}", "comment": "draw contours matched by the blob detector", "label": "done"}
{"id": "33666", "raw_code": "public static void saveX509Cert(String certStr,File certFile) throws IOException {\n  BufferedWriter writer=new BufferedWriter(new FileWriter(certFile));\n  writer.write(BEGIN_CERT);\n  writer.newLine();\n  writer.write(certStr);\n  writer.newLine();\n  writer.write(END_CERT);\n  writer.newLine();\n  writer.close();\n}", "comment": "save a certificate to a file in base 64 binary format with begin and end strings", "label": "done"}
{"id": "65393", "raw_code": "public static _Fields findByThriftId(int fieldId){\nswitch (fieldId) {\ncase 1:\n    return NOTE_ID;\ncase 2:\n  return CLASS_NAME;\ncase 3:\nreturn INTERPRETER_CONTEXT;\ndefault :\nreturn null;\n}\n}", "comment": "find the _ fields constant that matches fieldid , or null if its not found .", "label": "done"}
{"id": "42793", "raw_code": "@Override public void addNewSubscription(final Subscription newSubscription){\n  final String clientID=newSubscription.getClientId();\n  List<ClientTopicCouple> clientSubscriptions=subscriptions.get(clientID);\n  if (clientSubscriptions == null) {\n    clientSubscriptions=new ArrayList<>();\n    subscriptions.put(clientID,clientSubscriptions);\n  }\n  clientSubscriptions.add(newSubscription.asClientTopicCouple());\n}", "comment": "add a new subscription to the session .", "label": "done"}
{"id": "40845", "raw_code": "public ConsulTopologyFraction(){\n  this.url=DEFAULT_URL;\n}", "comment": "construct a default fraction using the default agent url of http : / / localhost : 8500 / .", "label": "done"}
{"id": "62571", "raw_code": "public static BufferedImage toBufferedImage(Image img,int type){\n  if (img instanceof BufferedImage) {\n    return (BufferedImage)img;\n  }\n  BufferedImage bimage=new BufferedImage(img.getWidth(null),img.getHeight(null),type);\n  Graphics2D bGr=bimage.createGraphics();\n  bGr.drawImage(img,0,0,null);\n  bGr.dispose();\n  return bimage;\n}", "comment": "converts a given image into a bufferedimage", "label": "done"}
{"id": "85654", "raw_code": "public static byte[] hexStringToByteArray(String strA){\n  ByteArrayOutputStream result=new ByteArrayOutputStream();\n  byte sum=(byte)0x00;\n  boolean nextCharIsUpper=true;\n  for (int i=0; i < strA.length(); i++) {\n    char c=strA.charAt(i);\nswitch (Character.toUpperCase(c)) {\ncase '0':\n      if (nextCharIsUpper) {\n        sum=(byte)0x00;\n        nextCharIsUpper=false;\n      }\n else {\n        sum|=(byte)0x00;\n        result.write(sum);\n        nextCharIsUpper=true;\n      }\n    break;\ncase '1':\n  if (nextCharIsUpper) {\n    sum=(byte)0x10;\n    nextCharIsUpper=false;\n  }\n else {\n    sum|=(byte)0x01;\n    result.write(sum);\n    nextCharIsUpper=true;\n  }\nbreak;\ncase '2':\nif (nextCharIsUpper) {\nsum=(byte)0x20;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x02;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '3':\nif (nextCharIsUpper) {\nsum=(byte)0x30;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x03;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '4':\nif (nextCharIsUpper) {\nsum=(byte)0x40;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x04;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '5':\nif (nextCharIsUpper) {\nsum=(byte)0x50;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x05;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '6':\nif (nextCharIsUpper) {\nsum=(byte)0x60;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x06;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '7':\nif (nextCharIsUpper) {\nsum=(byte)0x70;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x07;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '8':\nif (nextCharIsUpper) {\nsum=(byte)0x80;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x08;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '9':\nif (nextCharIsUpper) {\nsum=(byte)0x90;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x09;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'A':\nif (nextCharIsUpper) {\nsum=(byte)0xA0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0A;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'B':\nif (nextCharIsUpper) {\nsum=(byte)0xB0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0B;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'C':\nif (nextCharIsUpper) {\nsum=(byte)0xC0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0C;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'D':\nif (nextCharIsUpper) {\nsum=(byte)0xD0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0D;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'E':\nif (nextCharIsUpper) {\nsum=(byte)0xE0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0E;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'F':\nif (nextCharIsUpper) {\nsum=(byte)0xF0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0F;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ndefault :\nbreak;\n}\n}\nif (!nextCharIsUpper) {\nthrow new RuntimeException(\"The String did not contain an equal number of hex digits\");\n}\nreturn result.toByteArray();\n}", "comment": "converts readable hex - string to bytearray", "label": "done"}
{"id": "26434", "raw_code": "public static java.sql.Time toSqlTime(int hour,int minute,int second){\n  java.util.Date newDate=toDate(0,0,0,hour,minute,second);\n  if (newDate != null) {\n    return new java.sql.Time(newDate.getTime());\n  }\n else {\n    return null;\n  }\n}", "comment": "makes a java . sql . time from separate ints for hour , minute , and second .", "label": "done"}
{"id": "72263", "raw_code": "public void writeExif(byte[] jpeg,String exifOutFileName) throws FileNotFoundException, IOException {\n  if (jpeg == null || exifOutFileName == null) {\n    throw new IllegalArgumentException(NULL_ARGUMENT_STRING);\n  }\n  OutputStream s=null;\n  try {\n    s=getExifWriterStream(exifOutFileName);\n    s.write(jpeg,0,jpeg.length);\n    s.flush();\n  }\n catch (  IOException e) {\n    closeSilently(s);\n    throw e;\n  }\n  s.close();\n}", "comment": "writes the tags from this exifinterface object into a jpeg image , removing prior exif tags .", "label": "done"}
{"id": "49545", "raw_code": "public static String encode(byte[] bytes){\n  int len=bytes.length;\n  final StringBuffer encoded=new StringBuffer((len + 2) / 3 * 4);\n  int i=0;\n  int j=len;\n  while (j >= 3) {\n    encoded.append(to64((((bytes[i] & 0xff) << 16) | (int)((bytes[i + 1] & 0xff) << 8) | (int)(bytes[i + 2] & 0xff)),4));\n    i+=3;\n    j-=3;\n  }\n  if (j == 2) {\n    encoded.append(to64(((bytes[i] & 0xff) << 8) | ((bytes[i + 1] & 0xff)),3));\n  }\n  if (j == 1) {\n    encoded.append(to64(((bytes[i] & 0xff)),2));\n  }\n  return encoded.toString();\n}", "comment": "encodes an array of byte into a string of printable ascii characters using a base - 64 encoding .", "label": "done"}
{"id": "68785", "raw_code": "private PDFPage createPage(int pagenum,PDFObject pageObj) throws IOException {\n  int rotation=0;\n  RectF mediabox=null;\n  RectF cropbox=null;\n  PDFObject mediaboxObj=getInheritedValue(pageObj,\"MediaBox\");\n  if (mediaboxObj != null) {\n    mediabox=parseRect(mediaboxObj);\n  }\n  PDFObject cropboxObj=getInheritedValue(pageObj,\"CropBox\");\n  if (cropboxObj != null) {\n    cropbox=parseRect(cropboxObj);\n  }\n  PDFObject rotateObj=getInheritedValue(pageObj,\"Rotate\");\n  if (rotateObj != null) {\n    rotation=rotateObj.getIntValue();\n  }\n  RectF bbox=((cropbox == null) ? mediabox : cropbox);\n  return new PDFPage(pagenum,bbox,rotation,cache);\n}", "comment": "create a pdf page object by finding the relevant inherited properties", "label": "done"}
{"id": "14623", "raw_code": "static Map addElementToMap(String key,Set values,Map toMap){\n  if ((key != null) && (toMap != null)) {\n    toMap.put(key,values);\n  }\n  return toMap;\n}", "comment": "adds a key / value pair to a map", "label": "done"}
{"id": "45278", "raw_code": "private int append(FileSystem fs,Configuration conf,Path src,PrintWriter writer,int currentRecordNumber) throws IOException {\n  BufferedReader reader=new BufferedReader(new InputStreamReader(fs.open(src)));\n  try {\n    String line=reader.readLine();\n    while (line != null) {\n      if (line.startsWith(\"Recno:: \")) {\n        line=\"Recno:: \" + currentRecordNumber++;\n      }\n      writer.println(line);\n      line=reader.readLine();\n    }\n    return currentRecordNumber;\n  }\n  finally {\n    reader.close();\n  }\n}", "comment": "appends two files and updates the recno counter", "label": "done"}
{"id": "18427", "raw_code": "public int difference(String s1,String s2) throws EncoderException {\n  return SoundexUtils.difference(this,s1,s2);\n}", "comment": "encodes the strings and returns the number of characters in the two encoded strings that are the same .", "label": "done"}
{"id": "52423", "raw_code": "@Override public synchronized void initialize(){\n  if (!mRootDirectory.exists()) {\n    if (!mRootDirectory.mkdirs()) {\n      VolleyLog.e(\"Unable to create cache dir %s\",mRootDirectory.getAbsolutePath());\n    }\n    return;\n  }\n  File[] files=mRootDirectory.listFiles();\n  if (files == null) {\n    return;\n  }\n  for (  File file : files) {\n    FileInputStream fis=null;\n    try {\n      fis=new FileInputStream(file);\n      CacheHeader entry=CacheHeader.readHeader(fis);\n      entry.size=file.length();\n      putEntry(entry.key,entry);\n    }\n catch (    IOException e) {\n      if (file != null) {\n        file.delete();\n      }\n    }\n finally {\n      try {\n        if (fis != null) {\n          fis.close();\n        }\n      }\n catch (      IOException ignored) {\n      }\n    }\n  }\n}", "comment": "initializes the diskbasedcache by scanning for all files currently in the specified root directory .", "label": "done"}
{"id": "15480", "raw_code": "private static void renderHandler(FacesContext context,UIComponent component,Collection<ClientBehaviorContext.Parameter> params,String handlerName,Object handlerValue,String behaviorEventName,String submitTarget,boolean needsSubmit,boolean includeExec) throws IOException {\n  ResponseWriter writer=context.getResponseWriter();\n  String userHandler=getNonEmptyUserHandler(handlerValue);\n  List<ClientBehavior> behaviors=getClientBehaviors(component,behaviorEventName);\n  if ((null != behaviors) && (behaviors.size() > 0) && Util.componentIsDisabled(component)) {\n    behaviors=null;\n  }\n  if (params == null) {\n    params=Collections.emptyList();\n  }\n  String handler=null;\nswitch (getHandlerType(behaviors,params,userHandler,needsSubmit,includeExec)) {\ncase USER_HANDLER_ONLY:\n    handler=userHandler;\n  break;\ncase SINGLE_BEHAVIOR_ONLY:\nhandler=getSingleBehaviorHandler(context,component,behaviors.get(0),params,behaviorEventName,submitTarget,needsSubmit);\nbreak;\ncase SUBMIT_ONLY:\nhandler=getSubmitHandler(context,component,params,submitTarget,true);\nbreak;\ncase CHAIN:\nhandler=getChainedHandler(context,component,behaviors,params,behaviorEventName,userHandler,submitTarget,needsSubmit);\nbreak;\ndefault :\nassert (false);\n}\nwriter.writeAttribute(handlerName,handler,null);\n}", "comment": "renders a handler script , which may require chaining together the user - specified event handler , any scripts required by attached behaviors , and also possibly the mojarra . jsfcljs ( ) \" submit \" script .", "label": "done"}
{"id": "2832", "raw_code": "@Override protected void registerNewSelector() throws IOException {\nsynchronized (selector) {\n    Set<SelectionKey> keys=selector.keys();\n    Selector newSelector=null;\n    if (selectorProvider == null) {\n      newSelector=Selector.open();\n    }\n else {\n      newSelector=selectorProvider.openSelector();\n    }\n    for (    SelectionKey key : keys) {\n      SelectableChannel ch=key.channel();\n      NioSession session=(NioSession)key.attachment();\n      SelectionKey newKey=ch.register(newSelector,key.interestOps(),session);\n      session.setSelectionKey(newKey);\n    }\n    selector.close();\n    selector=newSelector;\n  }\n}", "comment": "in the case we are using the java select ( ) method , this method is used to trash the buggy selector and create a new one , registering all the sockets on it .", "label": "done"}
{"id": "55240", "raw_code": "protected synchronized void received(int responseCode,String stream,String json){\n  FollowerInfo result=parseFollowers(stream,json);\n  if (result != null) {\n    noError(stream);\n    cached.put(stream,result);\n    if (type == Follower.Type.FOLLOWER) {\n      listener.receivedFollowers(result);\n      if (hasNewFollowers(result.followers)) {\n        listener.newFollowers(result);\n      }\n    }\n else     if (type == Follower.Type.SUBSCRIBER) {\n      listener.receivedSubscribers(result);\n    }\n    requested.add(stream);\n  }\n else {\n    String errorMessage=\"\";\n    if (responseCode == 404) {\n      errorMessage=\"Channel not found.\";\n      error(stream,10);\n    }\n else     if (responseCode == 200) {\n      errorMessage=\"Parse error.\";\n      error(stream,1);\n    }\n else     if (responseCode == 401 || responseCode == 403) {\n      errorMessage=\"Access denied.\";\n      error(stream,1);\n    }\n else     if (responseCode == 422) {\n      errorMessage=\"No data for this channel.\";\n      error(stream,10);\n    }\n else {\n      errorMessage=\"Request error.\";\n      error(stream,1);\n    }\n    FollowerInfo errorResult=new FollowerInfo(type,stream,errorMessage);\n    cached.put(stream,errorResult);\n    if (type == Follower.Type.FOLLOWER) {\n      listener.receivedFollowers(errorResult);\n    }\n else     if (type == Follower.Type.SUBSCRIBER) {\n      listener.receivedSubscribers(errorResult);\n    }\n  }\n}", "comment": "received data from the api , so parse it or handle a possible error , then give it to the listener .", "label": "done"}
{"id": "44796", "raw_code": "public static long nowInNanos(){\n  return System.nanoTime();\n}", "comment": "current time from some arbitrary time base in the past , counting in nanoseconds , and not affected by settimeofday or similar system clock changes .", "label": "done"}
{"id": "57203", "raw_code": "public Future<SyncReply> sendRequest(int xid,SyncMessage request) throws RemoteStoreException {\n  ensureConnected();\n  RemoteSyncFuture future=new RemoteSyncFuture(xid,connectionGeneration);\n  futureMap.put(Integer.valueOf(xid),future);\n  if (futureMap.size() > MAX_PENDING_REQUESTS) {\nsynchronized (futureNotify) {\n      while (futureMap.size() > MAX_PENDING_REQUESTS) {\n        try {\n          futureNotify.wait();\n        }\n catch (        InterruptedException e) {\n          throw new RemoteStoreException(\"Could not send request\",e);\n        }\n      }\n    }\n  }\n  channel.writeAndFlush(request);\n  return future;\n}", "comment": "send a request to the server and generate a future for the eventual reply .", "label": "done"}
{"id": "78749", "raw_code": "public ResourcesPoet addInteger(String name,String value){\n  Element bool=document.createElement(\"integer\");\n  bool.setAttribute(\"name\",name);\n  bool.appendChild(document.createTextNode(String.valueOf(value)));\n  resourceElement.appendChild(bool);\n  return this;\n}", "comment": "add an integer to the config", "label": "done"}
{"id": "72181", "raw_code": "public int availableInProcess(){\n  return Math.max(0,maxInProcess - pending.size());\n}", "comment": "a connection can only have so many things in process happening on it at once , where \" in process \" refers to the maximum number of in - process requests less the number of pending responses .", "label": "done"}
{"id": "21392", "raw_code": "public boolean zoneExportRemoveVolumes(List<NetworkZoningParam> zoningParams,Collection<URI> volumeURIs,String stepId){\n  NetworkZoningParam zoningParam=zoningParams.get(0);\n  _log.info(String.format(\"Entering zoneExportRemoveVolumes for ExportGroup: %s Volumes: %s\",zoningParam.getExportGroupDisplay(),volumeURIs.toString()));\n  return doZoneExportMasksDelete(zoningParams,volumeURIs,stepId);\n}", "comment": "removes the indicated volumes from the zones given by the zoning parameters .", "label": "done"}
{"id": "46384", "raw_code": "@Override public void paintIcon(Component c,Graphics g,int x,int y){\n  Painter painter=(Painter)UIManager.get(prefix + \"[Enabled].\" + key);\n  if (painter != null) {\n    JComponent jc=(c instanceof JComponent) ? (JComponent)c : null;\n    Graphics2D gfx=(Graphics2D)g;\n    gfx.translate(x,y);\n    painter.paint(gfx,jc,width,height);\n    gfx.translate(-x,-y);\n  }\n}", "comment": "implements the standard icon interface ' s painticon method as the standard synth stub passes null for the context and this will cause us to not paint any thing , so we override here so that we can paint the enabled state if no synth context is available", "label": "done"}
{"id": "70843", "raw_code": "protected void zoomImageToPosition(float scale,float centerX,float centerY,long durationMs){\n  if (scale > getMaxScale()) {\n    scale=getMaxScale();\n  }\n  final float oldScale=getCurrentScale();\n  final float deltaScale=scale - oldScale;\n  post(mZoomImageToPositionRunnable=new ZoomImageToPosition(CropImageView.this,durationMs,oldScale,deltaScale,centerX,centerY));\n}", "comment": "this method changes image scale ( animating zoom for given duration ) , related to given center ( x , y ) .", "label": "done"}
{"id": "61915", "raw_code": "public void addRow(Assignment head,double prob){\n  if (prob < 0.0f || prob > 1.02f) {\n    return;\n  }\n  headVars.addAll(head.getVariables());\n  table.put(head,prob);\n}", "comment": "adds a new row to the probability table , assuming no conditional assignment .", "label": "done"}
{"id": "24267", "raw_code": "public byte[] createJarFromFileContent(final String fileName,final String content) throws IOException {\n  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();\n  JarOutputStream jarOutputStream=new JarOutputStream(byteArrayOutputStream);\n  JarEntry entry=new JarEntry(fileName);\n  entry.setTime(System.currentTimeMillis());\n  jarOutputStream.putNextEntry(entry);\n  jarOutputStream.write(content.getBytes());\n  jarOutputStream.closeEntry();\n  jarOutputStream.close();\n  return byteArrayOutputStream.toByteArray();\n}", "comment": "create a jar using the given file contents and with the given file name .", "label": "done"}
{"id": "44366", "raw_code": "public void closeJDBCConnection(Connection conn){\n  try {\n    if (conn != null) {\n      conn.close();\n    }\n  }\n catch (  SQLException sqle) {\n    subclassLogWrapper(\"Unexpected exception while closing database connection.\");\n  }\n}", "comment": "closes database connection and logs if an error is encountered", "label": "done"}
{"id": "6262", "raw_code": "private static String appendIfMissing(final String str,final CharSequence suffix,final boolean ignoreCase,final CharSequence... suffixes){\n  if (str == null || isEmpty(suffix) || endsWith(str,suffix,ignoreCase)) {\n    return str;\n  }\n  if (suffixes != null && suffixes.length > 0) {\n    for (    final CharSequence s : suffixes) {\n      if (endsWith(str,s,ignoreCase)) {\n        return str;\n      }\n    }\n  }\n  return str + suffix.toString();\n}", "comment": "appends the suffix to the end of the string if the string does not already end in the suffix .", "label": "done"}
{"id": "43069", "raw_code": "ExternalProblem(Process process){\n  this(process.getInputStream(),process.getOutputStream());\n  RedirectStream.redirect(process.getErrorStream(),System.err);\n}", "comment": "constructs an external problem using the specified process .", "label": "done"}
{"id": "66680", "raw_code": "public void andWith(List<QueryPredicate> predicates){\n  children.addAll(predicates);\n}", "comment": "adds multiple predicates that much be met by the vertices .", "label": "done"}
{"id": "75840", "raw_code": "public static void pushEncryptedMessage(final TextSecureEnvelope envelope){\n  while (true) {\n    try {\n      queue.put(envelope);\n      return;\n    }\n catch (    final InterruptedException e) {\n    }\n  }\n}", "comment": "adds an encrypted message to the queue .", "label": "done"}
{"id": "26587", "raw_code": "public void fling(int startX,int startY,int velocityX,int velocityY,int minX,int maxX,int minY,int maxY,int overX,int overY){\n  if (mFlywheel && !isFinished()) {\n    float oldVelocityX=mScrollerX.mCurrVelocity;\n    float oldVelocityY=mScrollerY.mCurrVelocity;\n    if (Math.signum(velocityX) == Math.signum(oldVelocityX) && Math.signum(velocityY) == Math.signum(oldVelocityY)) {\n      velocityX+=oldVelocityX;\n      velocityY+=oldVelocityY;\n    }\n  }\n  mMode=FLING_MODE;\n  mScrollerX.fling(startX,velocityX,minX,maxX,overX);\n  mScrollerY.fling(startY,velocityY,minY,maxY,overY);\n}", "comment": "start scrolling based on a fling gesture .", "label": "done"}
{"id": "3112", "raw_code": "public void addListener(NavigatorListener listener){\n  listeners.add(listener);\n}", "comment": "add listener to listener list", "label": "done"}
{"id": "74821", "raw_code": "private void addToScene(final Node items){\n  collection.add(items);\n}", "comment": "adds items to scene , ensuring we are on the fx thread", "label": "done"}
{"id": "86330", "raw_code": "public void removeSelectionListener(final SelectionListener listener){\n  checkWidget();\n  if (listener == null) {\n    SWT.error(SWT.ERROR_NULL_ARGUMENT);\n  }\n  listOfSelectionListeners.remove(listener);\n}", "comment": "removes the listener from the collection of listeners who will be notified when the control is selected by the user .", "label": "done"}
{"id": "76862", "raw_code": "private static Boolean isInsidePolygon(final GeoPoint point,final List<GeoPoint> polyPoints){\n  final double latitude=point.getLatitude();\n  final double longitude=point.getLongitude();\n  final double sinLatitude=Math.sin(latitude);\n  final double cosLatitude=Math.cos(latitude);\n  final double sinLongitude=Math.sin(longitude);\n  final double cosLongitude=Math.cos(longitude);\n  double arcDistance=0.0;\n  Double prevAngle=null;\n  for (  final GeoPoint polyPoint : polyPoints) {\n    final Double angle=computeAngle(polyPoint,sinLatitude,cosLatitude,sinLongitude,cosLongitude);\n    if (angle == null) {\n      return null;\n    }\n    if (prevAngle != null) {\n      double angleDelta=angle - prevAngle;\n      if (angleDelta < -Math.PI) {\n        angleDelta+=Math.PI * 2.0;\n      }\n      if (angleDelta > Math.PI) {\n        angleDelta-=Math.PI * 2.0;\n      }\n      if (Math.abs(angleDelta - Math.PI) < Vector.MINIMUM_RESOLUTION) {\n        return null;\n      }\n      arcDistance+=angleDelta;\n    }\n    prevAngle=angle;\n  }\n  if (prevAngle != null) {\n    final Double lastAngle=computeAngle(polyPoints.get(0),sinLatitude,cosLatitude,sinLongitude,cosLongitude);\n    if (lastAngle == null) {\n      return null;\n    }\n    double angleDelta=lastAngle - prevAngle;\n    if (angleDelta < -Math.PI) {\n      angleDelta+=Math.PI * 2.0;\n    }\n    if (angleDelta > Math.PI) {\n      angleDelta-=Math.PI * 2.0;\n    }\n    if (Math.abs(angleDelta - Math.PI) < Vector.MINIMUM_RESOLUTION) {\n      return null;\n    }\n    arcDistance+=angleDelta;\n  }\n  if (Math.abs(arcDistance) < Vector.MINIMUM_RESOLUTION) {\n    return null;\n  }\n  return arcDistance > 0.0;\n}", "comment": "for a specified point and a list of poly points , determine based on point order whether the point should be considered in or out of the polygon .", "label": "done"}
{"id": "7909", "raw_code": "public Week(Date time){\n  this(time,TimeZone.getDefault(),Locale.getDefault());\n}", "comment": "creates a time period for the week in which the specified date / time falls , using the default time zone and locale ( the locale can affect the day - of - the - week that marks the beginning of the week , as well as the minimal number of days in the first week of the year ) .", "label": "done"}
{"id": "19897", "raw_code": "protected int executePrepareStatement(List<Column> columns,PreparedStatement statement) throws SQLException {\n  int bindNo=1;\n  for (  Column c : columns) {\n    setColumnValue(statement,bindNo,c);\n    bindNo++;\n  }\n  return statement.executeUpdate();\n}", "comment": "executes a prepared statement using values supplied as arguments .", "label": "done"}
{"id": "28565", "raw_code": "private char readEscapeCharacter() throws IOException {\n  if (pos == limit && !fillBuffer(1)) {\n    throw syntaxError(\"Unterminated escape sequence\");\n  }\n  char escaped=buffer[pos++];\nswitch (escaped) {\ncase 'u':\n    if (pos + 4 > limit && !fillBuffer(4)) {\n      throw syntaxError(\"Unterminated escape sequence\");\n    }\n  char result=0;\nfor (int i=pos, end=i + 4; i < end; i++) {\n  char c=buffer[i];\n  result<<=4;\n  if (c >= '0' && c <= '9') {\n    result+=(c - '0');\n  }\n else   if (c >= 'a' && c <= 'f') {\n    result+=(c - 'a' + 10);\n  }\n else   if (c >= 'A' && c <= 'F') {\n    result+=(c - 'A' + 10);\n  }\n else {\n    throw new NumberFormatException(\"\\\\u\" + new String(buffer,pos,4));\n  }\n}\npos+=4;\nreturn result;\ncase 't':\nreturn '\\t';\ncase 'b':\nreturn '\\b';\ncase 'n':\nreturn '\\n';\ncase 'r':\nreturn '\\r';\ncase 'f':\nreturn '\\f';\ncase '\\n':\nlineNumber++;\nlineStart=pos;\ncase '\\'':\ncase '\"':\ncase '\\\\':\ncase '/':\nreturn escaped;\ndefault :\nthrow syntaxError(\"Invalid escape sequence\");\n}\n}", "comment": "unescapes the character identified by the character or characters that immediately follow a backslash .", "label": "done"}
{"id": "53783", "raw_code": "private void updateParamsForAuth(String[] authNames,List<Pair> queryParams,Map<String,String> headerParams){\n  for (  String authName : authNames) {\n    Authentication auth=authentications.get(authName);\n    if (auth == null)     throw new RuntimeException(\"Authentication undefined: \" + authName);\n    auth.applyToParams(queryParams,headerParams);\n  }\n}", "comment": "update query and header parameters based on authentication settings .", "label": "done"}
{"id": "23422", "raw_code": "private void fixSpannedWithSpaces(SpannableStringBuilder builder,int widthMeasureSpec,int heightMeasureSpec){\n  long startFix=System.currentTimeMillis();\n  FixingResult result=addSpacesAroundSpansUntilFixed(builder,widthMeasureSpec,heightMeasureSpec);\n  if (result.fixed) {\n    removeUnneededSpaces(widthMeasureSpec,heightMeasureSpec,builder,result);\n  }\n else {\n    fallbackToString(widthMeasureSpec,heightMeasureSpec);\n  }\n  long fixDuration=System.currentTimeMillis() - startFix;\n  Logger.d(TAG,\"fixSpannedWithSpaces() duration in ms: \" + fixDuration);\n}", "comment": "add spaces around spans until the text is fixed , and then removes the unneeded spaces", "label": "done"}
{"id": "64862", "raw_code": "public void addChannelMap(ChannelMap channelMap){\n  if (!mChannelMaps.contains(channelMap)) {\n    mChannelMaps.add(channelMap);\n    int index=mChannelMaps.indexOf(channelMap);\n    fireIntervalAdded(this,index,index);\n    broadcast(new ChannelMapEvent(channelMap,Event.ADD));\n  }\n}", "comment": "adds the channel map to this model", "label": "done"}
{"id": "82359", "raw_code": "@Override public boolean add(E o){\n  if (null == o) {\n    throw new NullPointerException();\n  }\n  if (offer(o)) {\n    return true;\n  }\n  throw new IllegalStateException();\n}", "comment": "adds an element to the queue .", "label": "done"}
{"id": "44469", "raw_code": "public UidRange[] parseUidRange() throws DecodingException {\n  CharacterValidator validator=new MessageSetCharValidator();\n  String nextWord=consumeWord(validator,true);\n  int commaPos=nextWord.indexOf(',');\n  if (commaPos == -1) {\n    return new UidRange[]{parseUidRange(nextWord)};\n  }\n  ArrayList<UidRange> rangeList=new ArrayList<UidRange>();\n  int pos=0;\n  while (commaPos != -1) {\n    String range=nextWord.substring(pos,commaPos);\n    UidRange set=parseUidRange(range);\n    rangeList.add(set);\n    pos=commaPos + 1;\n    commaPos=nextWord.indexOf(',',pos);\n  }\n  String range=nextWord.substring(pos);\n  rangeList.add(parseUidRange(range));\n  List<UidRange> merged=UidRange.mergeRanges(rangeList);\n  return merged.toArray(new UidRange[merged.size()]);\n}", "comment": "reads a \" message set \" argument , and parses into an idset .", "label": "done"}
{"id": "76757", "raw_code": "private String replaceSuffix(String value,String toReplace,String changeTo){\n  String vvalue;\n  if ((value == null) || (toReplace == null) || (changeTo == null)) {\n    return value;\n  }\n  vvalue=removeSuffix(value,toReplace);\n  if (value.equals(vvalue)) {\n    return value;\n  }\n else {\n    return vvalue + changeTo;\n  }\n}", "comment": "replace a string suffix by another", "label": "done"}
{"id": "54272", "raw_code": "public static Class toClass(ClassFile cf,ClassLoader loader,ProtectionDomain domain) throws CannotCompileException {\n  try {\n    byte[] b=toBytecode(cf);\n    Method method;\n    Object[] args;\n    if (domain == null) {\n      method=defineClass1;\n      args=new Object[]{cf.getName(),b,new Integer(0),new Integer(b.length)};\n    }\n else {\n      method=defineClass2;\n      args=new Object[]{cf.getName(),b,new Integer(0),new Integer(b.length),domain};\n    }\n    return toClass2(method,loader,args);\n  }\n catch (  RuntimeException e) {\n    throw e;\n  }\ncatch (  java.lang.reflect.InvocationTargetException e) {\n    throw new CannotCompileException(e.getTargetException());\n  }\ncatch (  Exception e) {\n    throw new CannotCompileException(e);\n  }\n}", "comment": "loads a class file by a given class loader .", "label": "done"}
{"id": "913", "raw_code": "public void build(RealmResults<T> results){\n  int xIndex=0;\n  for (  T object : results) {\n    mValues.add(buildEntryFromResultObject(object,xIndex++));\n  }\n}", "comment": "rebuilds the dataset based on the given realmresults .", "label": "done"}
{"id": "16034", "raw_code": "public byte[] generateSignature() throws CryptoException, DataLengthException {\n  contentDigest.doFinal(mDash,mDash.length - hLen - sLen);\n  if (sLen != 0) {\n    random.nextBytes(salt);\n    System.arraycopy(salt,0,mDash,mDash.length - sLen,sLen);\n  }\n  byte[] h=new byte[hLen];\n  contentDigest.update(mDash,0,mDash.length);\n  contentDigest.doFinal(h,0);\n  block[block.length - sLen - 1- hLen- 1]=0x01;\n  System.arraycopy(salt,0,block,block.length - sLen - hLen- 1,sLen);\n  byte[] dbMask=maskGeneratorFunction1(h,0,h.length,block.length - hLen - 1);\n  for (int i=0; i != dbMask.length; i++) {\n    block[i]^=dbMask[i];\n  }\n  block[0]&=(0xff >> ((block.length * 8) - emBits));\n  System.arraycopy(h,0,block,block.length - hLen - 1,hLen);\n  block[block.length - 1]=trailer;\n  byte[] b=cipher.processBlock(block,0,block.length);\n  clearBlock(block);\n  return b;\n}", "comment": "generate a signature for the message we ' ve been loaded with using the key we were initialised with .", "label": "done"}
{"id": "42605", "raw_code": "public static void openFileIntent(Context context,File openFile){\n  if (context != null && openFile.exists()) {\n    try {\n      Intent intent=getFileIntent(context,openFile);\n      context.startActivity(intent);\n    }\n catch (    Exception e) {\n      GlobalUtils.logThis(TAG,\"openFileIntent Exception\",e);\n    }\n  }\n}", "comment": "open file using intent", "label": "done"}
{"id": "79426", "raw_code": "public static java.sql.Date toSqlDate(String date){\n  java.util.Date newDate=toDate(date,\"00:00:00\");\n  if (newDate != null) {\n    return new java.sql.Date(newDate.getTime());\n  }\n else {\n    return null;\n  }\n}", "comment": "converts a date string into a java . sql . date", "label": "done"}
{"id": "22225", "raw_code": "private String createComponentChanges(){\n  StringBuilder builder=new StringBuilder();\n  for (  ServiceCatalogDiff serviceCatalogDiff : diffList) {\n    builder.append(createApiChanges(serviceCatalogDiff));\n  }\n  return builder.toString();\n}", "comment": "construct details of api changes by service and component name", "label": "done"}
{"id": "46548", "raw_code": "void addString(int c){\n  if (strpos == str.length) {\n    char newstr[]=new char[str.length + 128];\n    System.arraycopy(str,0,newstr,0,str.length);\n    str=newstr;\n  }\n  str[strpos++]=(char)c;\n}", "comment": "add a char to the string buffer .", "label": "done"}
{"id": "29190", "raw_code": "public static _Fields findByThriftId(int fieldId){\nswitch (fieldId) {\ncase 1:\n    return TRUE_AS_OF_SECS;\ncase 2:\n  return SOURCE;\ncase 3:\nreturn SYSTEM;\ndefault :\nreturn null;\n}\n}", "comment": "find the _ fields constant that matches fieldid , or null if its not found .", "label": "done"}
{"id": "36037", "raw_code": "public RepositoryLocation(String repositoryName,String[] pathComponents) throws MalformedRepositoryLocationException {\n  if (repositoryName == null || repositoryName.isEmpty()) {\n    throw new MalformedRepositoryLocationException(\"repositoryName must not contain null or empty!\");\n  }\n  if (pathComponents == null) {\n    throw new MalformedRepositoryLocationException(\"pathComponents must not be null!\");\n  }\n  for (  String pathComp : pathComponents) {\n    if (pathComp == null || pathComp.isEmpty()) {\n      throw new MalformedRepositoryLocationException(\"path must not contain null or empty strings!\");\n    }\n  }\n  this.repositoryName=repositoryName;\n  this.path=pathComponents;\n}", "comment": "creates a repositorylocation for a given repository and a set of path components which will be concatenated by a / .", "label": "done"}
{"id": "79964", "raw_code": "public static double parseDoubleDefault(String s,double def){\n  if (s == null) {\n    return def;\n  }\n  try {\n    return Double.parseDouble(s);\n  }\n catch (  NumberFormatException e) {\n    return def;\n  }\n}", "comment": "parses a double safely , returning a default if nothing can be sanely parsed from it .", "label": "done"}
{"id": "69708", "raw_code": "public void initBlockViews(){\n  if (mWorkspaceView != null) {\n    List<Block> rootBlocks=mWorkspace.getRootBlocks();\n    ConnectionManager connManager=mWorkspace.getConnectionManager();\n    for (int i=0; i < rootBlocks.size(); i++) {\n      BlockGroup bg=mViewFactory.buildBlockGroupTree(rootBlocks.get(i),connManager,mTouchHandler);\n      mWorkspaceView.addView(bg);\n    }\n  }\n}", "comment": "recursively initialize views for all the blocks in the model and add them to the view .", "label": "done"}
{"id": "79614", "raw_code": "private int readAnnotationValue(int v,final char[] buf,final String name,final AnnotationVisitor av){\n  int i;\n  if (av == null) {\nswitch (b[v] & 0xFF) {\ncase 'e':\n      return v + 5;\ncase '@':\n    return readAnnotationValues(v + 3,buf,true,null);\ncase '[':\n  return readAnnotationValues(v + 1,buf,false,null);\ndefault :\nreturn v + 3;\n}\n}\nswitch (b[v++] & 0xFF) {\ncase 'I':\ncase 'J':\ncase 'F':\ncase 'D':\nav.visit(name,readConst(readUnsignedShort(v),buf));\nv+=2;\nbreak;\ncase 'B':\nav.visit(name,new Byte((byte)readInt(items[readUnsignedShort(v)])));\nv+=2;\nbreak;\ncase 'Z':\nav.visit(name,readInt(items[readUnsignedShort(v)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\nv+=2;\nbreak;\ncase 'S':\nav.visit(name,new Short((short)readInt(items[readUnsignedShort(v)])));\nv+=2;\nbreak;\ncase 'C':\nav.visit(name,new Character((char)readInt(items[readUnsignedShort(v)])));\nv+=2;\nbreak;\ncase 's':\nav.visit(name,readUTF8(v,buf));\nv+=2;\nbreak;\ncase 'e':\nav.visitEnum(name,readUTF8(v,buf),readUTF8(v + 2,buf));\nv+=4;\nbreak;\ncase 'c':\nav.visit(name,Type.getType(readUTF8(v,buf)));\nv+=2;\nbreak;\ncase '@':\nv=readAnnotationValues(v + 2,buf,true,av.visitAnnotation(name,readUTF8(v,buf)));\nbreak;\ncase '[':\nint size=readUnsignedShort(v);\nv+=2;\nif (size == 0) {\nreturn readAnnotationValues(v - 2,buf,false,av.visitArray(name));\n}\nswitch (this.b[v++] & 0xFF) {\ncase 'B':\nbyte[] bv=new byte[size];\nfor (i=0; i < size; i++) {\nbv[i]=(byte)readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,bv);\n--v;\nbreak;\ncase 'Z':\nboolean[] zv=new boolean[size];\nfor (i=0; i < size; i++) {\nzv[i]=readInt(items[readUnsignedShort(v)]) != 0;\nv+=3;\n}\nav.visit(name,zv);\n--v;\nbreak;\ncase 'S':\nshort[] sv=new short[size];\nfor (i=0; i < size; i++) {\nsv[i]=(short)readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,sv);\n--v;\nbreak;\ncase 'C':\nchar[] cv=new char[size];\nfor (i=0; i < size; i++) {\ncv[i]=(char)readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,cv);\n--v;\nbreak;\ncase 'I':\nint[] iv=new int[size];\nfor (i=0; i < size; i++) {\niv[i]=readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,iv);\n--v;\nbreak;\ncase 'J':\nlong[] lv=new long[size];\nfor (i=0; i < size; i++) {\nlv[i]=readLong(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,lv);\n--v;\nbreak;\ncase 'F':\nfloat[] fv=new float[size];\nfor (i=0; i < size; i++) {\nfv[i]=Float.intBitsToFloat(readInt(items[readUnsignedShort(v)]));\nv+=3;\n}\nav.visit(name,fv);\n--v;\nbreak;\ncase 'D':\ndouble[] dv=new double[size];\nfor (i=0; i < size; i++) {\ndv[i]=Double.longBitsToDouble(readLong(items[readUnsignedShort(v)]));\nv+=3;\n}\nav.visit(name,dv);\n--v;\nbreak;\ndefault :\nv=readAnnotationValues(v - 3,buf,false,av.visitArray(name));\n}\n}\nreturn v;\n}", "comment": "reads a value of an annotation and makes the given visitor visit it .", "label": "done"}
{"id": "77524", "raw_code": "public PageOfCollections fetchPage(PageOfCollections page,SolrZkClient zkClient) throws KeeperException, InterruptedException {\n  List<String> children=getCollections(zkClient);\n  page.selected=children;\n  if (page.start == 0 && page.rows == -1 && page.filter == null && children.size() > 10) {\n    page.rows=20;\n    page.start=0;\n  }\n  if (page.filterType == FilterType.name && page.filter != null)   children=page.applyNameFilter(children);\n  if (page.filterType != FilterType.status)   page.selectPage(children);\n  return page;\n}", "comment": "gets the requested page of collections after applying filters and offsets .", "label": "done"}
{"id": "56381", "raw_code": "public IdsQueryBuilder addIds(String... ids){\n  values.addAll(Arrays.asList(ids));\n  return this;\n}", "comment": "adds ids to the filter .", "label": "done"}
{"id": "30274", "raw_code": "@SuppressWarnings(\"unchecked\") public List<Boundary> populateArea(final Long wardId){\n  HierarchyType hType=heirarchyTypeService.getHierarchyTypeByName(hierarchyTypeName);\n  ;\n  List<Boundary> areaList=new LinkedList<Boundary>();\n  final BoundaryType childBoundaryType=boundaryTypeService.getBoundaryTypeByNameAndHierarchyType(\"Area\",hType);\n  final Boundary parentBoundary=boundaryService.getBoundaryById(wardId);\n  areaList=new LinkedList(crossHeirarchyService.getCrossHierarchyChildrens(parentBoundary,childBoundaryType));\n  LOGGER.info(\"***********Ajax AreaList: \" + areaList.toString());\n  return areaList;\n}", "comment": "populate the area list by ward", "label": "done"}
{"id": "67838", "raw_code": "private static String readName(DataInputStream dis,byte data[]) throws IOException {\n  int c=dis.readUnsignedByte();\n  if ((c & 0xc0) == 0xc0) {\n    c=((c & 0x3f) << 8) + dis.readUnsignedByte();\n    HashSet<Integer> jumps=new HashSet<Integer>();\n    jumps.add(c);\n    return readName(data,c,jumps);\n  }\n  if (c == 0) {\n    return \"\";\n  }\n  byte b[]=new byte[c];\n  dis.readFully(b);\n  String s=IDN.toUnicode(new String(b));\n  String t=readName(dis,data);\n  if (t.length() > 0) {\n    s=s + \".\" + t;\n  }\n  return s;\n}", "comment": "parse a domain name starting at the current offset and moving the input stream pointer past this domain name ( even if cross references occure ) .", "label": "done"}
{"id": "71342", "raw_code": "public void addToGlobalBlacklist(String host){\n  addToGlobalBlacklist(host,System.currentTimeMillis() + this.globalBlacklistTimeout);\n}", "comment": "adds a host to the blacklist .", "label": "done"}
{"id": "53939", "raw_code": "public void insertOrRefresh(final KBucketEntry newEntry){\n  if (newEntry == null)   return;\n  List<KBucketEntry> entriesRef=entries;\n  for (  KBucketEntry existing : entriesRef) {\n    if (existing.equals(newEntry)) {\n      existing.mergeInTimestamps(newEntry);\n      return;\n    }\n    if (existing.matchIPorID(newEntry)) {\n      DHT.logInfo(\"new node \" + newEntry + \" claims same ID or IP as \"+ existing+ \", might be impersonation attack or IP change. ignoring until old entry times out\");\n      return;\n    }\n  }\n  if (newEntry.verifiedReachable()) {\n    if (entriesRef.size() < DHTConstants.MAX_ENTRIES_PER_BUCKET) {\n      modifyMainBucket(null,newEntry);\n      return;\n    }\n    if (replaceBadEntry(newEntry))     return;\n    KBucketEntry youngest=entriesRef.get(entriesRef.size() - 1);\n    if (youngest.getCreationTime() > newEntry.getCreationTime() || newEntry.getRTT() * 2.5 < youngest.getRTT()) {\n      modifyMainBucket(youngest,newEntry);\n      insertInReplacementBucket(youngest);\n      return;\n    }\n  }\n  insertInReplacementBucket(newEntry);\n}", "comment": "notify bucket of new incoming packet from a node , perform update or insert existing nodes where appropriate", "label": "done"}
{"id": "53436", "raw_code": "public static double relativeOverlap(SpatialComparable box1,SpatialComparable box2){\n  final int dim=assertSameDimensionality(box1,box2);\n  double overlap=1.;\n  double vol1=1.;\n  double vol2=1.;\n  for (int i=0; i < dim; i++) {\n    final double box1min=box1.getMin(i);\n    final double box1max=box1.getMax(i);\n    final double box2min=box2.getMin(i);\n    final double box2max=box2.getMax(i);\n    final double omax=Math.min(box1max,box2max);\n    final double omin=Math.max(box1min,box2min);\n    if (omax <= omin) {\n      return 0.;\n    }\n    overlap*=omax - omin;\n    vol1*=box1max - box1min;\n    vol2*=box2max - box2min;\n  }\n  return overlap / (vol1 + vol2);\n}", "comment": "computes the volume of the overlapping box between two spatialcomparables and return the relation between the volume of the overlapping box and the volume of both spatialcomparable .", "label": "done"}
{"id": "72300", "raw_code": "protected final void _loadToHaveAtLeast(int minAvailable) throws IOException {\n  if (_inputStream == null) {\n    throw _constructError(\"Needed to read \" + minAvailable + \" bytes, reached end-of-input\");\n  }\n  int amount=_inputEnd - _inputPtr;\n  _currInputProcessed+=_inputPtr;\n  if (amount > 0 && _inputPtr > 0) {\n    System.arraycopy(_inputBuffer,_inputPtr,_inputBuffer,0,amount);\n    _inputEnd=amount;\n  }\n else {\n    _inputEnd=0;\n  }\n  _inputPtr=0;\n  while (_inputEnd < minAvailable) {\n    int count=_inputStream.read(_inputBuffer,_inputEnd,_inputBuffer.length - _inputEnd);\n    if (count < 1) {\n      _closeInput();\n      if (count == 0) {\n        throw new IOException(\"InputStream.read() returned 0 characters when trying to read \" + amount + \" bytes\");\n      }\n      throw _constructError(\"Needed to read \" + minAvailable + \" bytes, missed \"+ minAvailable+ \" before end-of-input\");\n    }\n    _inputEnd+=count;\n  }\n}", "comment": "helper method that will try to load at least specified number bytes in input buffer , possible moving existing data around if necessary", "label": "done"}
{"id": "11048", "raw_code": "public static Properties parsePropertyList(String list) throws PropertyStringFormatException {\n  return parsePropertyList(list,propertySeparators,keyValueSeparators);\n}", "comment": "take a property list , defined in a single string , and return a properties object .", "label": "done"}
{"id": "25600", "raw_code": "public static boolean isCacheSafe(Class<?> clazz,ClassLoader classLoader){\n  Assert.notNull(clazz,\"Class must not be null\");\n  ClassLoader target=clazz.getClassLoader();\n  if (target == null) {\n    return false;\n  }\n  ClassLoader cur=classLoader;\n  if (cur == target) {\n    return true;\n  }\n  while (cur != null) {\n    cur=cur.getParent();\n    if (cur == target) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "check whether the given class is cache - safe in the given context , i . e . whether it is loaded by the given classloader or a parent of it .", "label": "done"}
{"id": "47513", "raw_code": "private int[] createEpochMonths(int epochDay,int minYear,int maxYear,Map<Integer,int[]> years){\n  int numMonths=(maxYear - minYear + 1) * 12 + 1;\n  int epochMonth=0;\n  int[] epochMonths=new int[numMonths];\n  minMonthLength=Integer.MAX_VALUE;\n  maxMonthLength=Integer.MIN_VALUE;\n  for (int year=minYear; year <= maxYear; year++) {\n    int[] months=years.get(year);\n    for (int month=0; month < 12; month++) {\n      int length=months[month];\n      epochMonths[epochMonth++]=epochDay;\n      if (length < 29 || length > 32) {\n        throw new IllegalArgumentException(\"Invalid month length in year: \" + minYear);\n      }\n      epochDay+=length;\n      minMonthLength=Math.min(minMonthLength,length);\n      maxMonthLength=Math.max(maxMonthLength,length);\n    }\n  }\n  epochMonths[epochMonth++]=epochDay;\n  if (epochMonth != epochMonths.length) {\n    throw new IllegalStateException(\"Did not fill epochMonths exactly: ndx = \" + epochMonth + \" should be \"+ epochMonths.length);\n  }\n  return epochMonths;\n}", "comment": "converts the map of year to month lengths ranging from minyear to maxyear into a linear contiguous array of epochdays .", "label": "done"}
{"id": "20951", "raw_code": "private static String descriptorToInternalName(String descriptor){\nswitch (descriptor.charAt(0)) {\ncase 'B':\ncase 'C':\ncase 'D':\ncase 'F':\ncase 'I':\ncase 'J':\ncase 'S':\ncase 'Z':\ncase 'V':\ncase '[':\n    return descriptor;\ncase 'L':\n  return classDescriptorToInternalName(descriptor);\ndefault :\nthrow new IllegalArgumentException(\"bad descriptor:\" + descriptor);\n}\n}", "comment": "convert a non - method type descriptor into an internal type .", "label": "done"}
{"id": "72923", "raw_code": "public Subscription register(Object mBean,MBeanDescription description){\n  return register(mBean,description.getMBeanName(getNextId()));\n}", "comment": "register the given mbean based on the given description", "label": "done"}
{"id": "70010", "raw_code": "public void put(int key,E value){\n  int i=ContainerHelpers.binarySearch(mKeys,mSize,key);\n  if (i >= 0) {\n    mValues[i]=value;\n  }\n else {\n    i=~i;\n    if (i < mSize && mValues[i] == DELETED) {\n      mKeys[i]=key;\n      mValues[i]=value;\n      return;\n    }\n    if (mGarbage && mSize >= mKeys.length) {\n      gc();\n      i=~ContainerHelpers.binarySearch(mKeys,mSize,key);\n    }\n    if (mSize >= mKeys.length) {\n      int n=ContainerHelpers.idealIntArraySize(mSize + 1);\n      int[] nkeys=new int[n];\n      Object[] nvalues=new Object[n];\n      System.arraycopy(mKeys,0,nkeys,0,mKeys.length);\n      System.arraycopy(mValues,0,nvalues,0,mValues.length);\n      mKeys=nkeys;\n      mValues=nvalues;\n    }\n    if (mSize - i != 0) {\n      System.arraycopy(mKeys,i,mKeys,i + 1,mSize - i);\n      System.arraycopy(mValues,i,mValues,i + 1,mSize - i);\n    }\n    mKeys[i]=key;\n    mValues[i]=value;\n    mSize++;\n  }\n}", "comment": "adds a mapping from the specified key to the specified value , replacing the previous mapping from the specified key if there was one .", "label": "done"}
{"id": "33743", "raw_code": "@SuppressWarnings(\"unchecked\") protected Object fromReflectionType(final Object value){\n  FieldDescriptor descriptor=getDescriptor();\n  if (descriptor.isRepeated()) {\n    if (descriptor.getJavaType() == FieldDescriptor.JavaType.MESSAGE || descriptor.getJavaType() == FieldDescriptor.JavaType.ENUM) {\n      final List result=new ArrayList();\n      for (      final Object element : (List)value) {\n        result.add(singularFromReflectionType(element));\n      }\n      return result;\n    }\n else {\n      return value;\n    }\n  }\n else {\n    return singularFromReflectionType(value);\n  }\n}", "comment": "convert from the type used by the reflection accessors to the type used by native accessors .", "label": "done"}
{"id": "14287", "raw_code": "private <S,T>Set<T> extract(final Collection<S> collection,final Extractor<S,T> extractor){\n  final Set<T> values=new HashSet<T>(collection.size());\n  for (  final S instance : collection) {\n    values.add(extractor.getValue(instance));\n  }\n  return values;\n}", "comment": "extract a set of a defined type from the passed collection using the given extractor .", "label": "done"}
{"id": "7255", "raw_code": "public UpdateClause addAssignment(Expression expression){\n  assignments.add(new Assignment(expression));\n  return this;\n}", "comment": "adds a property to set to the clause .", "label": "done"}
{"id": "30773", "raw_code": "private boolean stepValue(){\n  while (true) {\n    if (iter != null && iter.hasNext()) {\n      svcs=(ArrayList)iter.next();\n      svcidx=svcs.size();\n      return true;\n    }\n    if (!stepClass())     return false;\n    if (iter == null)     return true;\n  }\n}", "comment": "step to the next hashmap value , if any , reset svcs and svcidx , and return false if everything exhausted .", "label": "done"}
{"id": "52431", "raw_code": "public void hasNetworkConnection(NetworkRequestCheckListener listener){\n  if (hasNetworkConnection()) {\n    testNetworkRequest(listener);\n  }\n else {\n    listener.onNoResponse();\n  }\n}", "comment": "utility method which checks current network connection state , but will also try to perform test network request , in order to determine if user can actually perform any network operation .", "label": "done"}
{"id": "14649", "raw_code": "private void validateDynamicAttribute(Set dynamicSet) throws PolicyException {\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"entering with dynamicSet=\" + dynamicSet);\n  }\n  responseAttrNames=new HashSet();\n  repoAttrNames=new HashSet();\n  responseAttrToRepoAttr=new HashMap();\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"valid dynamic attributes:\" + validDynamicAttrNames);\n  }\n  Set dynamicAttrs=((Set)properties.get(DYNAMIC_ATTRIBUTE));\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"selected dynamic attributes:\" + dynamicAttrs);\n  }\n  Iterator dynamicAttrsIter=dynamicAttrs.iterator();\n  while (dynamicAttrsIter.hasNext()) {\n    String attr=(String)dynamicAttrsIter.next();\n    if (!validDynamicAttrNames.contains(attr)) {\n      if (DEBUG.warningEnabled()) {\n        DEBUG.warning(\"IDReporesponseProvider.\" + \"validateDynamicAttribute():Invalid dynamic property \" + \"encountered:\"+ attr);\n      }\n      continue;\n    }\n    String[] attrNames=parseDynamicAttrName(attr);\n    String responseAttrName=attrNames[0];\n    String repoAttrName=attrNames[1];\n    responseAttrNames.add(responseAttrName);\n    repoAttrNames.add(repoAttrName);\n    addToResponseAttrToRepoAttrMap(responseAttrName,repoAttrName);\n    if (DEBUG.messageEnabled()) {\n      DEBUG.message(\"IDRepoResponseProvider.\" + \"validateDynamicAttribute():\" + \"responseAttrName=\" + responseAttrName + \", repoAttrName=\"+ repoAttrName);\n    }\n  }\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"responseAttrToRepoAttr=\" + responseAttrToRepoAttr);\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"returning\");\n  }\n}", "comment": "this method validates the dynamic _ attribute data for format and caches parsed responseattrnames , repoattrnames strings in the set need to be in \" responseattr = repoattr \" format else , throws policyexception", "label": "done"}
{"id": "63863", "raw_code": "public static boolean typeCheck(Class type,Object instance){\n  return type.isAssignableFrom(instance.getClass()) || isWrapperInstance(type,instance);\n}", "comment": "check if an object is an instance of a given class , or , if the class is a primitive type , if the object is an instance of the wrapper class for that primitive ( e . g . , as integer is a wrapper for int ) .", "label": "done"}
{"id": "82134", "raw_code": "public void addCommand(Command cmd,int offset){\n  menuBar.addCommand(cmd,offset);\n}", "comment": "adds a command to the menu bar softkeys or into the menu dialog , this version of add allows us to place a command in an arbitrary location .", "label": "done"}
{"id": "69136", "raw_code": "public static long lowerHexToUnsignedLong(String lowerHex){\n  int length=lowerHex.length();\n  if (length < 1 || length > 32)   throw isntLowerHexLong(lowerHex);\n  int i=length > 16 ? length - 16 : 0;\n  long result=0;\n  for (; i < length; i++) {\n    char c=lowerHex.charAt(i);\n    result<<=4;\n    if (c >= '0' && c <= '9') {\n      result|=c - '0';\n    }\n else     if (c >= 'a' && c <= 'f') {\n      result|=c - 'a' + 10;\n    }\n else {\n      throw isntLowerHexLong(lowerHex);\n    }\n  }\n  return result;\n}", "comment": "parses a 1 to 32 character lower - hex string with no prefix into an unsigned long , tossing any bits higher than 64 .", "label": "done"}
{"id": "13623", "raw_code": "public void runScript(Reader reader) throws IOException, SQLException {\n  try {\n    boolean originalAutoCommit=connection.getAutoCommit();\n    try {\n      if (originalAutoCommit != this.autoCommit) {\n        connection.setAutoCommit(this.autoCommit);\n      }\n      runScript(connection,reader);\n    }\n  finally {\n      connection.setAutoCommit(originalAutoCommit);\n    }\n  }\n catch (  IOException|SQLException e) {\n    throw e;\n  }\ncatch (  Exception e) {\n    throw new RuntimeException(\"Error running script.  Cause: \" + e,e);\n  }\n}", "comment": "runs an sql script ( read in using the reader parameter )", "label": "done"}
{"id": "33460", "raw_code": "public static Uri addMessage(ContentResolver resolver,String address,String body,String subject,Long date,boolean deliveryReport,long threadId){\n  final Uri CONTENT_URI=Uri.parse(\"content://sms/outbox\");\n  return addMessageToUri(resolver,CONTENT_URI,address,body,subject,date,true,deliveryReport,threadId);\n}", "comment": "add an sms to the out box .", "label": "done"}
{"id": "31836", "raw_code": "private final Object internalReplace(Object k,Object v,Object cv){\n  int h=spread(k.hashCode());\n  Object oldVal=null;\n  for (Node[] tab=table; ; ) {\n    Node f;\n    int i, fh;\n    Object fk;\n    if (tab == null || (f=tabAt(tab,i=(tab.length - 1) & h)) == null)     break;\n else     if ((fh=f.hash) == MOVED) {\n      if ((fk=f.key) instanceof TreeBin) {\n        TreeBin t=(TreeBin)fk;\n        boolean validated=false;\n        boolean deleted=false;\n        t.acquire(0);\n        try {\n          if (tabAt(tab,i) == f) {\n            validated=true;\n            TreeNode p=t.getTreeNode(h,k,t.root);\n            if (p != null) {\n              Object pv=p.val;\n              if (cv == null || cv == pv || cv.equals(pv)) {\n                oldVal=pv;\n                if ((p.val=v) == null) {\n                  deleted=true;\n                  t.deleteTreeNode(p);\n                }\n              }\n            }\n          }\n        }\n  finally {\n          t.release(0);\n        }\n        if (validated) {\n          if (deleted)           counter.add(-1L);\n          break;\n        }\n      }\n else       tab=(Node[])fk;\n    }\n else     if ((fh & HASH_BITS) != h && f.next == null)     break;\n else     if ((fh & LOCKED) != 0) {\n      checkForResize();\n      f.tryAwaitLock(tab,i);\n    }\n else     if (f.casHash(fh,fh | LOCKED)) {\n      boolean validated=false;\n      boolean deleted=false;\n      try {\n        if (tabAt(tab,i) == f) {\n          validated=true;\n          for (Node e=f, pred=null; ; ) {\n            Object ek, ev;\n            if ((e.hash & HASH_BITS) == h && ((ev=e.val) != null) && ((ek=e.key) == k || k.equals(ek))) {\n              if (cv == null || cv == ev || cv.equals(ev)) {\n                oldVal=ev;\n                if ((e.val=v) == null) {\n                  deleted=true;\n                  Node en=e.next;\n                  if (pred != null)                   pred.next=en;\n else                   setTabAt(tab,i,en);\n                }\n              }\n              break;\n            }\n            pred=e;\n            if ((e=e.next) == null)             break;\n          }\n        }\n      }\n  finally {\n        if (!f.casHash(fh | LOCKED,fh)) {\n          f.hash=fh;\nsynchronized (f) {\n            f.notifyAll();\n          }\n          ;\n        }\n      }\n      if (validated) {\n        if (deleted)         counter.add(-1L);\n        break;\n      }\n    }\n  }\n  return oldVal;\n}", "comment": "implementation for the four public remove / replace methods : replaces node value with v , conditional upon match of cv if non - null .", "label": "done"}
{"id": "54059", "raw_code": "default Document putAll(Iterable<Field> fields,Predicate<CharSequence> acceptableFieldNames){\n  for (  Field field : fields) {\n    if (acceptableFieldNames.test(field.getName())) {\n      setValue(field.getName(),field.getValue());\n    }\n  }\n  return this;\n}", "comment": "attempts to copy all of the acceptable fields from the source and set on this document , overwriting any existing values .", "label": "done"}
{"id": "7278", "raw_code": "public String toEPL(EPStatementFormatter formatter){\n  StringWriter writer=new StringWriter();\n  toEPL(formatter,writer);\n  return writer.toString();\n}", "comment": "rendering using the provided formatter .", "label": "done"}
{"id": "62894", "raw_code": "default void shutdown(){\n  Platform.exit();\n}", "comment": "shuts down the application by delegating service cleanups to the application thread .", "label": "done"}
{"id": "20569", "raw_code": "public void addListener(AnimatorListener listener){\n  if (mListeners == null) {\n    mListeners=new ArrayList<AnimatorListener>();\n  }\n  mListeners.add(listener);\n}", "comment": "adds a listener to the set of listeners that are sent events through the life of an animation , such as start , repeat , and end .", "label": "done"}
{"id": "16074", "raw_code": "public static void writePaddedInteger(Writer out,long value,int size) throws IOException {\n  int intValue=(int)value;\n  if (intValue == value) {\n    writePaddedInteger(out,intValue,size);\n  }\n else   if (size <= 19) {\n    out.write(Long.toString(value));\n  }\n else {\n    if (value < 0) {\n      out.write('-');\n      if (value != Long.MIN_VALUE) {\n        value=-value;\n      }\n else {\n        for (; size > 19; size--) {\n          out.write('0');\n        }\n        out.write(\"9223372036854775808\");\n        return;\n      }\n    }\n    int digits=(int)(Math.log(value) / LOG_10) + 1;\n    for (; size > digits; size--) {\n      out.write('0');\n    }\n    out.write(Long.toString(value));\n  }\n}", "comment": "converts an integer to a string , prepended with a variable amount of ' 0 ' pad characters , and writes it to the given writer .", "label": "done"}
{"id": "83499", "raw_code": "private void sendBlob(String index,byte[] blob){\n  sendInstruction(new GuacamoleInstruction(\"blob\",index,DatatypeConverter.printBase64Binary(blob)));\n}", "comment": "injects a \" blob \" instruction into the outbound guacamole protocol stream , as if sent by the connected client .", "label": "done"}
{"id": "22762", "raw_code": "public void addNode(TopologicalNode node){\n  nodeList.add(node);\n}", "comment": "adds an topological node to this graph .", "label": "done"}
{"id": "12922", "raw_code": "@Override public void applyInline(double[] data,int pos,int len){\n  int i;\n  double[] dataOut=new double[len];\n  if (len > real.length) {\n    throw new IllegalArgumentException(\"Length must not be larger than FFT size\");\n  }\n  int middle=len / 2 + len % 2;\n  System.arraycopy(data,0,dataOut,0,len);\n  System.arraycopy(dataOut,pos + middle,real,0,len - middle);\n  System.arraycopy(dataOut,pos,real,real.length - middle,middle);\n  if (real.length > len)   Arrays.fill(real,len - middle,real.length - middle,0);\n  Arrays.fill(imag,0,imag.length,0.);\n  FFT.transform(real,imag,false);\n  process(real,imag);\n  FFT.transform(real,imag,true);\n  System.arraycopy(real,0,dataOut,pos + middle,len - middle);\n  System.arraycopy(real,real.length - middle,dataOut,pos,middle);\n  double origAvgEnergy=SignalProcUtils.getAverageSampleEnergy(data,len);\n  for (i=0; i < len; i++)   data[i]=amount * dataOut[i] + oneMinusAmount * data[i];\n  double newAvgEnergy=SignalProcUtils.getAverageSampleEnergy(data,len);\n  double scale=origAvgEnergy / newAvgEnergy;\n  for (i=0; i < len; i++)   data[i]*=0.8 * scale;\n}", "comment": "apply this frequency domain processor to the given data , and return the processing result in - place .", "label": "done"}
{"id": "14451", "raw_code": "public static byte[] toByteArray(String str){\n  int len=str.length();\n  StringTokenizer st=new StringTokenizer(str,\":\");\n  String[] newStrArray=new String[st.countTokens()];\n  int j=0;\n  while (st.hasMoreTokens()) {\n    newStrArray[j]=st.nextToken();\n    j++;\n  }\n  byte[] ret=new byte[newStrArray.length];\n  int tmp;\n  for (int i=0; i < newStrArray.length; i++) {\n    tmp=Integer.parseInt(newStrArray[i],16);\n    ret[i]=(byte)(tmp - 128);\n  }\n  return ret;\n}", "comment": "converts a given hex string separated by colons to a byte array .", "label": "done"}
{"id": "51191", "raw_code": "private void addReference(final int sourcePosition,final int referencePosition){\n  if (srcAndRefPositions == null) {\n    srcAndRefPositions=new int[6];\n  }\n  if (referenceCount >= srcAndRefPositions.length) {\n    int[] a=new int[srcAndRefPositions.length + 6];\n    System.arraycopy(srcAndRefPositions,0,a,0,srcAndRefPositions.length);\n    srcAndRefPositions=a;\n  }\n  srcAndRefPositions[referenceCount++]=sourcePosition;\n  srcAndRefPositions[referenceCount++]=referencePosition;\n}", "comment": "adds a forward reference to this label .", "label": "done"}
{"id": "29711", "raw_code": "public static HttpHeaders toArmeria(io.netty.handler.codec.http.HttpHeaders inHeaders){\n  if (inHeaders.isEmpty()) {\n    return HttpHeaders.EMPTY_HEADERS;\n  }\n  final HttpHeaders out=new DefaultHttpHeaders(true,inHeaders.size());\n  toArmeria(inHeaders,out);\n  return out;\n}", "comment": "converts the specified netty http / 1 headers into armeria http / 2 headers .", "label": "done"}
{"id": "22155", "raw_code": "private synchronized void loadTrustManager(){\n  try {\n    TrustManagerFactory tmf=TrustManagerFactory.getInstance(X509_ALGORITHM);\n    tmf.init(keystore);\n    for (    TrustManager trustManager : tmf.getTrustManagers()) {\n      if (trustManager instanceof X509TrustManager) {\n        defaultViPRTrustManager=(X509TrustManager)trustManager;\n        log.debug(\"found a X509TrustManager instance\");\n        break;\n      }\n    }\n    log.info(\"renew trust manager. the # of certificates in trust store is {}\",defaultViPRTrustManager.getAcceptedIssuers().length);\n  }\n catch (  GeneralSecurityException e) {\n    log.error(e.getMessage(),e);\n  }\n}", "comment": "loads the trust manager using the vipr keystore .", "label": "done"}
{"id": "84294", "raw_code": "public final void addHelperTextColor(@ColorInt final int color){\n  if (!helperTextColors.contains(color)) {\n    helperTextColors.add(color);\n    verifyPasswordStrength();\n  }\n}", "comment": "adds a new helper text color , which should be used to highlight the helper text , which indicates the password strength .", "label": "done"}
{"id": "17320", "raw_code": "private void addSyntheticEdge(Collection<GraphEdge> result,GraphEdge original,GraphNode head,GraphNode tail){\n  result.add(new GraphEdge(head,tail,original.getRelation()));\n}", "comment": "synthesize a new edge , and add it to the result .", "label": "done"}
{"id": "11080", "raw_code": "public void addStates(State[] s){\n  for (int i=0; i < s.length; i++)   states.addElement(s[i]);\n}", "comment": "append states to the state vector .", "label": "done"}
{"id": "19384", "raw_code": "public static void assertColumnTypes(ResultSet rs,int[] expectedTypes) throws SQLException {\n  ResultSetMetaData rsmd=rs.getMetaData();\n  int actualCols=rsmd.getColumnCount();\n  assertEquals(\"Unexpected column count:\",expectedTypes.length,rsmd.getColumnCount());\n  for (int i=0; i < actualCols; i++) {\n    assertEquals(\"Column types do not match for column \" + (i + 1),expectedTypes[i],rsmd.getColumnType(i + 1));\n  }\n}", "comment": "test method from apache derby project class org . apache . derbytesting . functiontests . tests . jdbcapi . databasemetadatatest takes a result set and an array of expected column types from java . sql . types and asserts that the column types in the result set metadata match the number , order , and names of those in the array .", "label": "done"}
{"id": "6552", "raw_code": "public int add(T dl,int row){\n  _list.add(row,dl);\n  fireTableRowsInserted(row,row);\n  return row;\n}", "comment": "adds a dataline to the list at a row .", "label": "done"}
{"id": "76987", "raw_code": "private void pushTerm(BytesRef text) throws IOException {\n  int limit=Math.min(lastTerm.length(),text.length);\n  int pos=0;\n  while (pos < limit && lastTerm.byteAt(pos) == text.bytes[text.offset + pos]) {\n    pos++;\n  }\n  for (int i=lastTerm.length() - 1; i >= pos; i--) {\n    int prefixTopSize=pending.size() - prefixStarts[i];\n    if (prefixTopSize >= minItemsInBlock) {\n      writeBlocks(i + 1,prefixTopSize);\n      prefixStarts[i]-=prefixTopSize - 1;\n    }\n  }\n  if (prefixStarts.length < text.length) {\n    prefixStarts=ArrayUtil.grow(prefixStarts,text.length);\n  }\n  for (int i=pos; i < text.length; i++) {\n    prefixStarts[i]=pending.size();\n  }\n  lastTerm.copyBytes(text);\n}", "comment": "pushes the new term to the top of the stack , and writes new blocks .", "label": "done"}
{"id": "81603", "raw_code": "public void append(int key,E value){\n  if (mSize != 0 && key <= mKeys[mSize - 1]) {\n    put(key,value);\n    return;\n  }\n  if (mGarbage && mSize >= mKeys.length) {\n    gc();\n  }\n  int pos=mSize;\n  if (pos >= mKeys.length) {\n    int n=idealIntArraySize(pos + 1);\n    int[] nkeys=new int[n];\n    Object[] nvalues=new Object[n];\n    System.arraycopy(mKeys,0,nkeys,0,mKeys.length);\n    System.arraycopy(mValues,0,nvalues,0,mValues.length);\n    mKeys=nkeys;\n    mValues=nvalues;\n  }\n  mKeys[pos]=key;\n  mValues[pos]=value;\n  mSize=pos + 1;\n}", "comment": "puts a key / value pair into the array , optimizing for the case where the key is greater than all existing keys in the array .", "label": "done"}
{"id": "86192", "raw_code": "@SuppressWarnings({\"rawtypes\",\"unchecked\"}) public static <T extends Annotation>T unproxy(T annotation){\n  Function unproxyFunction=getUnproxyFunction(annotation.annotationType());\n  return (T)unproxyFunction.apply(annotation);\n}", "comment": "convert java proxy annotation to specialized implementation , used to speedup equals / hashcode / tostring methods .", "label": "done"}
{"id": "29956", "raw_code": "public void addTickMarkSection(final Section SECTION){\n  if (null == SECTION)   return;\n  tickMarkSections.add(SECTION);\n  Collections.sort(tickMarkSections,new SectionComparator());\n  fireUpdateEvent(REDRAW_EVENT);\n}", "comment": "adds the given section to the list of tickmark sections .", "label": "done"}
{"id": "31599", "raw_code": "public void addPlotter(final Plotter plotter){\n  plotters.add(plotter);\n}", "comment": "add a plotter to the graph , which will be used to plot entries", "label": "done"}
{"id": "39637", "raw_code": "public static <T>T decodeFromBase64(Coder<T> coder,String encodedValue) throws CoderException {\n  return decodeFromSafeStream(coder,new ByteArrayInputStream(Base64.decodeBase64(encodedValue)),Coder.Context.OUTER);\n}", "comment": "parses a value from a base64 - encoded string using the given coder .", "label": "done"}
{"id": "20351", "raw_code": "public void put(String key,long value){\n  if (key != null) {\n    urlParams.put(key,String.valueOf(value));\n  }\n}", "comment": "adds a long value to the request .", "label": "done"}
{"id": "15669", "raw_code": "public final V extractFirst(){\n  if (size() > 0) {\n    if (GWT.isScript()) {\n      V ret=jsArray.get(0);\n      jsArray.remove(0);\n      return ret;\n    }\n else {\n      return javaArray.remove(0);\n    }\n  }\n  return null;\n}", "comment": "retrieve the first element and remove it from the list", "label": "done"}
{"id": "24964", "raw_code": "private void changeValue(AbstractStorageLabel<Object> label,Object newValue){\n  if (!Objects.equals(label.getValue(),newValue)) {\nsynchronized (labelEditListeners) {\n      for (      LabelEditListener listener : labelEditListeners) {\n        listener.preLabelValueChange(label);\n      }\n    }\n    label.setValue(newValue);\nsynchronized (labelEditListeners) {\n      for (      LabelEditListener listener : labelEditListeners) {\n        listener.postLabelValueChange(label);\n      }\n    }\n  }\n}", "comment": "reforms the value change and informs the listeners .", "label": "done"}
{"id": "38477", "raw_code": "private int convertToPanelX(double xval){\n  double temp=(xval - m_minX) / m_rangeX;\n  temp=temp * m_panelWidth;\n  return (int)temp;\n}", "comment": "convert an x coordinate from the instance space to the panel space .", "label": "done"}
{"id": "68905", "raw_code": "public void forward(HttpServerRequest request){\n  forward(request,null);\n}", "comment": "handles the request and forwards it to the hook specific destination .", "label": "done"}
{"id": "62462", "raw_code": "public static long readUINT32(InputStream stream) throws IOException {\n  long result=0;\n  for (int i=0; i <= 24; i+=8) {\n    result|=(long)stream.read() << i;\n  }\n  return result;\n}", "comment": "reads 4 bytes from stream and interprets them as uint32 .", "label": "done"}
{"id": "35268", "raw_code": "protected void add(CSVRecord record){\n  records.add(Objects.requireNonNull(record));\n}", "comment": "adds the given record to this data .", "label": "done"}
{"id": "67260", "raw_code": "protected void appendText(final String text){\n  if (text != null) {\n    textBody.append(text);\n  }\n}", "comment": "append text to the outgoing email body .", "label": "done"}
{"id": "10149", "raw_code": "public static long[] values(Long[] array){\n  long[] dest=new long[array.length];\n  for (int i=0; i < array.length; i++) {\n    Long v=array[i];\n    if (v != null) {\n      dest[i]=v.longValue();\n    }\n  }\n  return dest;\n}", "comment": "converts to primitive array .", "label": "done"}
{"id": "51000", "raw_code": "@Override public void processNewLines(String[] lines){\n  for (  String line : lines) {\n    if (line.startsWith(\"idx\")) {\n      continue;\n    }\n    if (line.contains(\"No such file\")) {\n      myIsFileMissing=true;\n      return;\n    }\n    String[] values=line.split(LINE_SPLIT_REGEX);\n    if (values.length < INDEX_OF_TX_BYTES) {\n      continue;\n    }\n    try {\n      int lineUid=Integer.parseInt(values[INDEX_OF_UID]);\n      if (myUid == lineUid) {\n        int tempRxBytes=Integer.parseInt(values[INDEX_OF_RX_BYTES]);\n        int tempTxBytes=Integer.parseInt(values[INDEX_OF_TX_BYTES]);\n        if (tempRxBytes < 0 || tempTxBytes < 0) {\n          LOG.warning(String.format(\"Negative rxBytes %1$d and/or txBytes %2$d in %3$s\",tempRxBytes,tempTxBytes,line));\n          continue;\n        }\n        myRxBytes+=tempRxBytes;\n        myTxBytes+=tempTxBytes;\n      }\n    }\n catch (    NumberFormatException e) {\n      LOG.warning(String.format(\"Expected int value, instead got uid %1$s, rxBytes %2$s, txBytes %3$s in %4$s\",values[INDEX_OF_UID],values[INDEX_OF_RX_BYTES],values[INDEX_OF_TX_BYTES],line));\n    }\n  }\n}", "comment": "processes the stats line to sum up all network stats belonging to the uid .", "label": "done"}
{"id": "57666", "raw_code": "@Override public StringBuffer format(double value,StringBuffer buffer,FieldPosition field){\n  for (int i=choiceLimits.length - 1; i >= 0; i--) {\n    if (choiceLimits[i] <= value) {\n      return buffer.append(choiceFormats[i]);\n    }\n  }\n  return choiceFormats.length == 0 ? buffer : buffer.append(choiceFormats[0]);\n}", "comment": "appends the string associated with the range in which the specified double value fits to the specified string buffer .", "label": "done"}
{"id": "29076", "raw_code": "public boolean softSignin() throws IOException {\n  if (url == null) {\n    throw new IllegalStateException(\"Null host\");\n  }\n  checkResolveHost();\n  if (sessionId != null) {\n    if (checkAuthorized(getAuthCheckUrl(sessionId))) {\n      LOGGER.fine(\"Skipping soft init; session ID already exists - \" + sessionId);\n      return true;\n    }\n else {\n      sessionId=null;\n    }\n  }\n  long id=loadSessionId();\n  if (id == 0) {\n    return false;\n  }\n  boolean authorized=checkAuthorized(getAuthCheckUrl(id));\n  if (authorized) {\n    LOGGER.info(\"Authorized with session ID: \" + id);\n    this.sessionId=id;\n  }\n  return authorized;\n}", "comment": "if the user can be authenticated due to an existing session id , do so", "label": "done"}
{"id": "62568", "raw_code": "public INDArray asMatrix(BufferedImage image){\n  if (channels == 3) {\n    return toBgr(image);\n  }\n else {\n    image=scalingIfNeed(image,true);\n    int w=image.getWidth();\n    int h=image.getHeight();\n    INDArray ret=Nd4j.create(h,w);\n    for (int i=0; i < h; i++) {\n      for (int j=0; j < w; j++) {\n        ret.putScalar(new int[]{i,j},image.getRGB(i,j));\n      }\n    }\n    return ret;\n  }\n}", "comment": "convert an bufferedimage to a matrix", "label": "done"}
{"id": "18419", "raw_code": "static byte[] discardNonBase64(byte[] data){\n  byte groomedData[]=new byte[data.length];\n  int bytesCopied=0;\n  for (int i=0; i < data.length; i++) {\n    if (isBase64(data[i])) {\n      groomedData[bytesCopied++]=data[i];\n    }\n  }\n  byte packedData[]=new byte[bytesCopied];\n  System.arraycopy(groomedData,0,packedData,0,bytesCopied);\n  return packedData;\n}", "comment": "discards any characters outside of the base64 alphabet , per the requirements on page 25 of rfc 2045 - \" any characters outside of the base64 alphabet are to be ignored in base64 encoded data . \"", "label": "done"}
{"id": "30787", "raw_code": "private static long limitDuration(long leaseDuration,long limit){\n  if (leaseDuration == Lease.ANY || leaseDuration > limit)   leaseDuration=limit;\n else   if (leaseDuration < 0)   throw new IllegalArgumentException(\"negative lease duration\");\n  return leaseDuration;\n}", "comment": "limit leaseduration by limit , and check for negative value .", "label": "done"}
{"id": "49160", "raw_code": "public void delItems(int s,int e){\n  boolean hsbWasVisible=hsbVis;\n  boolean vsbWasVisible=vsbVis;\n  int oldLastDisplayed=lastItemDisplayed();\n  if (log.isLoggable(PlatformLogger.Level.FINE)) {\n    log.fine(\"Deleting from \" + s + \" to \"+ e);\n  }\n  if (log.isLoggable(PlatformLogger.Level.FINEST)) {\n    log.finest(\"Last displayed item: \" + oldLastDisplayed + \", items in window \"+ itemsInWindow()+ \", size \"+ items.size());\n  }\n  if (items.size() == 0) {\n    return;\n  }\n  if (s > e) {\n    int tmp=s;\n    s=e;\n    e=tmp;\n  }\n  if (s < 0) {\n    s=0;\n  }\n  if (e >= items.size()) {\n    e=items.size() - 1;\n  }\n  boolean repaintNeeded=(s >= getFirstVisibleItem() && s <= getLastVisibleItem());\n  for (int i=s; i <= e; i++) {\n    items.removeElementAt(s);\n    int j=posInSel(i);\n    if (j != -1) {\n      int newsel[]=new int[selected.length - 1];\n      System.arraycopy(selected,0,newsel,0,j);\n      System.arraycopy(selected,j + 1,newsel,j,selected.length - (j + 1));\n      selected=newsel;\n    }\n  }\n  int diff=(e - s) + 1;\n  for (int i=0; i < selected.length; i++) {\n    if (selected[i] > e) {\n      selected[i]-=diff;\n    }\n  }\n  int options=PAINT_VSCROLL;\n  if (getFocusIndex() > e) {\n    setFocusIndex(getFocusIndex() - (e - s + 1));\n    options|=PAINT_FOCUS;\n  }\n else   if (getFocusIndex() >= s && getFocusIndex() <= e) {\n    int focusBound=(items.size() > 0) ? 0 : -1;\n    setFocusIndex(Math.max(s - 1,focusBound));\n    options|=PAINT_FOCUS;\n  }\n  if (log.isLoggable(PlatformLogger.Level.FINEST)) {\n    log.finest(\"Multiple selections: \" + multipleSelections);\n  }\n  if (vsb.getValue() >= s) {\n    if (vsb.getValue() <= e) {\n      vsb.setValue(e + 1 - diff);\n    }\n else {\n      vsb.setValue(vsb.getValue() - diff);\n    }\n  }\n  int oldMaxLength=maxLength;\n  maxLength=maxLength();\n  if (maxLength != oldMaxLength) {\n    options|=PAINT_HSCROLL;\n  }\n  layout();\n  repaintNeeded|=(vsbWasVisible ^ vsbVis) || (hsbWasVisible ^ hsbVis);\n  if (repaintNeeded) {\n    options|=PAINT_ALL;\n  }\n  repaint(s,oldLastDisplayed,options);\n}", "comment": "delete items starting with s ( start position ) to e ( end position ) including s and e if s < 0 then s = 0 if e > = items . size ( ) then e = items . size ( ) - 1", "label": "done"}
{"id": "48910", "raw_code": "static long makeId(SnmpOid oid){\n  long id=0;\n  long[] arcs=oid.longValue(false);\n  id|=arcs[0] << 56;\n  id|=arcs[1] << 48;\n  id|=arcs[2] << 40;\n  id|=arcs[3] << 32;\n  id|=arcs[4] << 24;\n  id|=arcs[5] << 16;\n  id|=arcs[6] << 8;\n  id|=arcs[7];\n  return id;\n}", "comment": "translate an oid to a thread id .", "label": "done"}
{"id": "48118", "raw_code": "private void cacheAttribute(String attrId,byte[][] values){\n  String cacheKey=name + \"|\" + attrId;\n  valueCache.put(cacheKey,values);\n}", "comment": "add the values to the cache .", "label": "done"}
{"id": "46752", "raw_code": "void read(Reader policy) throws ParsingException, IOException {\n  if (!(policy instanceof BufferedReader)) {\n    policy=new BufferedReader(policy);\n  }\n  st=new StreamTokenizer(policy);\n  st.resetSyntax();\n  st.wordChars('a','z');\n  st.wordChars('A','Z');\n  st.wordChars('.','.');\n  st.wordChars('0','9');\n  st.wordChars('_','_');\n  st.wordChars('$','$');\n  st.wordChars(128 + 32,255);\n  st.whitespaceChars(0,' ');\n  st.commentChar('/');\n  st.quoteChar('\\'');\n  st.quoteChar('\"');\n  st.lowerCaseMode(false);\n  st.ordinaryChar('/');\n  st.slashSlashComments(true);\n  st.slashStarComments(true);\n  st.parseNumbers();\n  Hashtable<String,Vector<String>> processedPermissions=null;\n  lookahead=st.nextToken();\n  while (lookahead != StreamTokenizer.TT_EOF) {\n    if (peek(\"grant\")) {\n      GrantEntry ge=parseGrantEntry(processedPermissions);\n      if (ge != null)       grantEntries.addElement(ge);\n    }\n else {\n      throw new ParsingException(st.lineno(),\"expected grant \" + \"statement\");\n    }\n    match(\";\");\n  }\n}", "comment": "reads a policy configuration using a reader object .", "label": "done"}
{"id": "21499", "raw_code": "protected void injectIntoVolumeInformationContainer(Map<String,StringSet> volumeInformation,String infoKey,String altKey,CIMInstance volumeInstance){\n  Object value=getCIMPropertyValue(volumeInstance,infoKey);\n  if (null == value) {\n    value=getCIMPropertyValue(volumeInstance,altKey);\n  }\n  String charactersticName=SupportedVolumeInformation.getVolumeInformation(infoKey);\n  if (null != value && null != charactersticName) {\n    StringSet valueSet=new StringSet();\n    if (value instanceof String) {\n      valueSet.add(value.toString());\n    }\n else     if (value instanceof String[]) {\n      valueSet.addAll(Arrays.asList((String[])value));\n    }\n    volumeInformation.put(charactersticName,valueSet);\n  }\n}", "comment": "extract value from provider for given volume info key , and then get its name and use that to inject to map .", "label": "done"}
{"id": "8466", "raw_code": "private void doNormalCommandLineList(List<String> commandLineList,List<String> jointOptions,Path classpath){\n  commandLineList.add(\"--classpath\");\n  commandLineList.add(classpath.toString());\n  if (jointCompilation) {\n    commandLineList.add(\"-j\");\n    commandLineList.addAll(jointOptions);\n  }\n  if (destDir != null) {\n    commandLineList.add(\"-d\");\n    commandLineList.add(destDir.getPath());\n  }\n  if (encoding != null) {\n    commandLineList.add(\"--encoding\");\n    commandLineList.add(encoding);\n  }\n  if (stacktrace) {\n    commandLineList.add(\"-e\");\n  }\n  if (parameters) {\n    commandLineList.add(\"--parameters\");\n  }\n  if (useIndy) {\n    commandLineList.add(\"--indy\");\n  }\n  if (scriptBaseClass != null) {\n    commandLineList.add(\"-b\");\n    commandLineList.add(scriptBaseClass);\n  }\n  if (configscript != null) {\n    commandLineList.add(\"--configscript\");\n    commandLineList.add(configscript);\n  }\n}", "comment": "add \" groovyc \" parameters to the commandlinelist , based on the ant configuration .", "label": "done"}
{"id": "43989", "raw_code": "@Override public synchronized void parse(Reader reader,String baseURI) throws IOException, RDFParseException, RDFHandlerException {\n  if (reader == null) {\n    throw new IllegalArgumentException(\"Reader cannot be 'null'\");\n  }\n  if (baseURI == null) {\n    throw new IllegalArgumentException(\"Base URI cannot be 'null'\");\n  }\n  InputSource inputSource=new InputSource(reader);\n  inputSource.setSystemId(baseURI);\n  parse(inputSource);\n}", "comment": "parses the data from the supplied reader , using the supplied baseuri to resolve any relative uri references .", "label": "done"}
{"id": "77409", "raw_code": "protected static final String addEscapes(String str){\n  StringBuilder retval=new StringBuilder();\n  char ch;\n  for (int i=0; i < str.length(); i++) {\nswitch (str.charAt(i)) {\ncase 0:\n      continue;\ncase '\\b':\n    retval.append(\"\\\\b\");\n  continue;\ncase '\\t':\nretval.append(\"\\\\t\");\ncontinue;\ncase '\\n':\nretval.append(\"\\\\n\");\ncontinue;\ncase '\\f':\nretval.append(\"\\\\f\");\ncontinue;\ncase '\\r':\nretval.append(\"\\\\r\");\ncontinue;\ncase '\\\"':\nretval.append(\"\\\\\\\"\");\ncontinue;\ncase '\\'':\nretval.append(\"\\\\\\'\");\ncontinue;\ncase '\\\\':\nretval.append(\"\\\\\\\\\");\ncontinue;\ndefault :\nif ((ch=str.charAt(i)) < 0x20 || ch > 0x7e) {\nString s=\"0000\" + Integer.toString(ch,16);\nretval.append(\"\\\\u\" + s.substring(s.length() - 4,s.length()));\n}\n else {\nretval.append(ch);\n}\ncontinue;\n}\n}\nreturn retval.toString();\n}", "comment": "replaces unprintable characters by their escaped ( or unicode escaped ) equivalents in the given string", "label": "done"}
{"id": "11077", "raw_code": "public static void addFile(String s) throws IOException {\n  File f=new File(s);\n  addFile(f);\n}", "comment": "adds a file to the classpath .", "label": "done"}
{"id": "52932", "raw_code": "private long[] determinePreferenceVector(Relation<V> relation,ModifiableDBIDs[] neighborIDs,StringBuilder msg){\n  if (strategy.equals(Strategy.APRIORI)) {\n    return determinePreferenceVectorByApriori(relation,neighborIDs,msg);\n  }\n else   if (strategy.equals(Strategy.MAX_INTERSECTION)) {\n    return determinePreferenceVectorByMaxIntersection(neighborIDs,msg);\n  }\n else {\n    throw new IllegalStateException(\"Should never happen!\");\n  }\n}", "comment": "determines the preference vector according to the specified neighbor ids .", "label": "done"}
{"id": "3178", "raw_code": "private void onUser(@NotNull TLAbsUser absUser){\n  User currentUser=null;\n  User user=null;\n  if (absUser instanceof TLUser) {\n    final TLUser tlUser=(TLUser)absUser;\n    if (tlUser.isMutualContact()) {\n      currentUser=(User)databaseManager.getUserById(tlUser.getId());\n      user=onUserContact(currentUser,tlUser);\n    }\n else     if (tlUser.isDeleted()) {\n      currentUser=(User)databaseManager.getUserById(tlUser.getId());\n      user=onUserDelete(currentUser,tlUser);\n    }\n else     if (tlUser.isContact()) {\n      currentUser=(User)databaseManager.getUserById(tlUser.getId());\n      user=onUserRequest(currentUser,tlUser);\n    }\n else     if (tlUser.isSelf() || !tlUser.isBot()) {\n      currentUser=(User)databaseManager.getUserById(tlUser.getId());\n      user=onUserForeign(currentUser,tlUser);\n    }\n else {\n      BotLogger.info(LOGTAG,\"Bot received\");\n    }\n  }\n  if ((currentUser == null) && (user != null)) {\n    databaseManager.addUser(user);\n  }\n else   if (user != null) {\n    databaseManager.updateUser(user);\n  }\n}", "comment": "add a user to database", "label": "done"}
{"id": "37712", "raw_code": "void crossOver(BayesNetRepresentation other){\n  boolean[] bits=new boolean[m_bits.length];\n  for (int i=0; i < m_bits.length; i++) {\n    bits[i]=m_bits[i];\n  }\n  int iCrossOverPoint=m_bits.length;\n  do {\n    for (int i=iCrossOverPoint; i < m_bits.length; i++) {\n      m_bits[i]=bits[i];\n    }\n    iCrossOverPoint=m_random.nextInt(m_bits.length);\n    for (int i=iCrossOverPoint; i < m_bits.length; i++) {\n      m_bits[i]=other.m_bits[i];\n    }\n  }\n while (hasCycles());\n  calcGlobalScore();\n}", "comment": "apply cross - over operation to bayesnet calculate score and as a side effect sets bayesnet parent sets .", "label": "done"}
{"id": "56330", "raw_code": "public PutIndexTemplateRequest mapping(String type,Object... source){\n  mapping(type,PutMappingRequest.buildFromSimplifiedDef(type,source));\n  return this;\n}", "comment": "a specialized simplified mapping source method , takes the form of simple properties definition : ( \" field1 \" , \" type = string , store = true \" ) .", "label": "done"}
{"id": "75061", "raw_code": "@Override public synchronized void initialize(){\n  if (!mRootDirectory.exists()) {\n    if (!mRootDirectory.mkdirs()) {\n      VolleyLog.e(\"Unable to create cache dir %s\",mRootDirectory.getAbsolutePath());\n    }\n    return;\n  }\n  File[] files=mRootDirectory.listFiles();\n  if (files == null) {\n    return;\n  }\n  for (  File file : files) {\n    BufferedInputStream fis=null;\n    try {\n      fis=new BufferedInputStream(new FileInputStream(file));\n      CacheHeader entry=CacheHeader.readHeader(fis);\n      entry.size=file.length();\n      putEntry(entry.key,entry);\n    }\n catch (    IOException e) {\n      if (file != null) {\n        file.delete();\n      }\n    }\n finally {\n      try {\n        if (fis != null) {\n          fis.close();\n        }\n      }\n catch (      IOException ignored) {\n      }\n    }\n  }\n}", "comment": "initializes the diskbasedcache by scanning for all files currently in the specified root directory .", "label": "done"}
{"id": "14960", "raw_code": "public SiteStatusCheckThreadImpl(){\n  super();\n  urlCheckers=new HashMap();\n}", "comment": "constructs a sitestatuscheckthreadimpl object based on the configured parameter com . sun . identity . sitemonitor . sitestatuscheck . class .", "label": "done"}
{"id": "72250", "raw_code": "public PetCategory findOne(String id){\n  log.debug(\"Request to get PetCategory : {}\",id);\n  PetCategory petCategory=petCategoryRepository.findOne(UUID.fromString(id));\n  return petCategory;\n}", "comment": "get one petcategory by id .", "label": "done"}
{"id": "56034", "raw_code": "public static float computeDiscardAlpha(float amount,float range){\n  if (Math.abs(amount) < 1.0f)   return 1.0f;\n  float t=amount / range;\n  t=MathUtils.clamp(t,-1.0f,1.0f);\n  return 1.f - Math.abs(t);\n}", "comment": "computes the alpha value of the tab based on its discard status .", "label": "done"}
{"id": "47298", "raw_code": "public static final FileTime unixTimeToFileTime(long utime){\n  return FileTime.from(utime,TimeUnit.SECONDS);\n}", "comment": "converts \" standard unix time \" ( in seconds , utc / gmt ) to filetime", "label": "done"}
{"id": "42712", "raw_code": "public static CipherTextIvMac encrypt(String plaintext,SecretKeys secretKeys,String encoding) throws UnsupportedEncodingException, GeneralSecurityException {\n  return encrypt(plaintext.getBytes(encoding),secretKeys);\n}", "comment": "generates a random iv and encrypts this plain text with the given key .", "label": "done"}
{"id": "16584", "raw_code": "@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){\n  int widthSpecMode=MeasureSpec.getMode(widthMeasureSpec);\n  int heightSpecMode=MeasureSpec.getMode(heightMeasureSpec);\n  int parentWidth=MeasureSpec.getSize(widthMeasureSpec);\n  int parentHeight=MeasureSpec.getSize(heightMeasureSpec);\n  boolean resizeWidth=widthSpecMode != MeasureSpec.EXACTLY;\n  boolean resizeHeight=heightSpecMode != MeasureSpec.EXACTLY;\n  int width=parentWidth;\n  int height=parentHeight;\n  if (sWidth > 0 && sHeight > 0) {\n    if (resizeWidth && resizeHeight) {\n      width=sWidth();\n      height=sHeight();\n    }\n else     if (resizeHeight) {\n      height=(int)((((double)sHeight() / (double)sWidth()) * width));\n    }\n else     if (resizeWidth) {\n      width=(int)((((double)sWidth() / (double)sHeight()) * height));\n    }\n  }\n  width=Math.max(width,getSuggestedMinimumWidth());\n  height=Math.max(height,getSuggestedMinimumHeight());\n  setMeasuredDimension(width,height);\n}", "comment": "measures the width and height of the view , preserving the aspect ratio of the image displayed if wrap _ content is used .", "label": "done"}
{"id": "12906", "raw_code": "private void insertProsodySettings(Utterance utterance,Element element){\n  Element prosody=(Element)DomUtils.getAncestor(element,MaryXML.PROSODY);\n  if (prosody == null) {\n    return;\n  }\n  Element voice=(Element)DomUtils.getAncestor(element,MaryXML.VOICE);\n  if (voice != null && DomUtils.isAncestor(prosody,voice)) {\n    return;\n  }\n  Element paragraph=(Element)DomUtils.getAncestor(element,MaryXML.PARAGRAPH);\n  if (paragraph != null && DomUtils.isAncestor(prosody,paragraph)) {\n    return;\n  }\n  for (  String att : PROSODY_ATTRIBUTES) {\n    String val=prosody.getAttribute(att);\n    if (!val.equals(\"\")) {\n      utterance.setString(att,val);\n    }\n  }\n}", "comment": "for a given element , extract essential settings defined by the closest ancestor prosody element and save them into the utterance .", "label": "done"}
{"id": "29235", "raw_code": "void add(Object key){\n  table.put(key,key);\n}", "comment": "adds an object to this set .", "label": "done"}
{"id": "3657", "raw_code": "final public void println(char v){\n  Writer out=this.out;\n  if (out == null)   return;\n  try {\n    out.write(v);\n    out.write(_newline,0,_newline.length);\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}", "comment": "prints a character followed by a newline .", "label": "done"}
{"id": "52551", "raw_code": "public synchronized void commit(){\nsynchronized (mutex) {\n    Map<Column,Set<Interval>> temp=workingIntervals;\n    workingIntervals=Collections.synchronizedMap(new LinkedHashMap<>());\n    availableIntervalsRef.set(Collections.unmodifiableMap(new LinkedHashMap<>(temp)));\n    super.columns=new LinkedHashSet<>(temp.keySet());\n  }\n}", "comment": "swaps the actual cache with the built - up temporary cache and creates a fresh , empty temporary cache .", "label": "done"}
{"id": "12197", "raw_code": "private static boolean addIfMatches(List<String> container,String statusLine,char x,char y){\n  if (matches(statusLine,x,y)) {\n    final String filename=statusLine.substring(3);\n    if (!container.contains(filename)) {\n      container.add(filename);\n    }\n    return true;\n  }\n  return false;\n}", "comment": "adds files to container if they matched to template .", "label": "done"}
{"id": "74901", "raw_code": "public static void renderFlattenedAnnotation(final PdfObject form,final DynamicVectorRenderer current,final int pageNumber,final int rotation){\n  final BufferedImage image=AnnotationFactory.getIcon(form);\n  if (image != null) {\n    final GraphicsState gs=new GraphicsState();\n    final int iconHeight=image.getHeight();\n    final int iconWidth=image.getWidth();\n    final float[] rect=form.getFloatArray(PdfDictionary.Rect);\n    if (form.getParameterConstant(PdfDictionary.Subtype) == PdfDictionary.Text) {\n      rect[2]=rect[0] + iconWidth;\n      rect[1]=rect[3] - iconHeight;\n      form.setFloatArray(PdfDictionary.Rect,rect);\n    }\nswitch (rotation % 360) {\ncase 0:\n      gs.CTM=new float[][]{{iconWidth,0,1},{0,iconHeight,1},{0,0,0}};\n    gs.x=rect[0];\n  gs.y=rect[3] - iconHeight;\ngs.CTM[2][0]=rect[0];\ngs.CTM[2][1]=rect[3] - iconHeight;\nbreak;\ncase 90:\ngs.CTM=new float[][]{{0,iconWidth,1},{-iconHeight,0,1},{0,0,0}};\ngs.x=rect[0] + iconHeight;\ngs.y=rect[3];\ngs.CTM[2][0]=rect[0] + iconHeight;\ngs.CTM[2][1]=rect[3];\nbreak;\ncase 180:\ngs.CTM=new float[][]{{-iconWidth,0,1},{0,-iconHeight,1},{0,0,0}};\ngs.x=rect[0];\ngs.y=rect[3] + iconHeight;\ngs.CTM[2][0]=rect[0];\ngs.CTM[2][1]=rect[3] + iconHeight;\nbreak;\ncase 270:\ngs.CTM=new float[][]{{0,-iconWidth,1},{iconHeight,0,1},{0,0,0}};\ngs.x=rect[0] - iconHeight;\ngs.y=rect[3];\ngs.CTM[2][0]=rect[0] - iconHeight;\ngs.CTM[2][1]=rect[3];\nbreak;\n}\nif (form.getParameterConstant(PdfDictionary.Subtype) == PdfDictionary.Highlight) {\ncurrent.setGraphicsState(GraphicsState.STROKE,gs.getAlpha(GraphicsState.STROKE),PdfDictionary.Darken);\ncurrent.setGraphicsState(GraphicsState.FILL,gs.getAlpha(GraphicsState.FILL),PdfDictionary.Darken);\n}\ncurrent.drawImage(pageNumber,image,gs,false,form.getObjectRefAsString(),-1);\nif (form.getParameterConstant(PdfDictionary.Subtype) == PdfDictionary.Highlight) {\ncurrent.setGraphicsState(GraphicsState.STROKE,gs.getAlpha(GraphicsState.STROKE),PdfDictionary.Normal);\ncurrent.setGraphicsState(GraphicsState.FILL,gs.getAlpha(GraphicsState.FILL),PdfDictionary.Normal);\n}\n}\n}", "comment": "method to create an icon to represent the annotation and render it .", "label": "done"}
{"id": "14849", "raw_code": "public static String makeRelatedSessionID(String encryptedID,SessionID prototype) throws SessionException {\n  prototype.parseSessionString();\n  return makeSessionID(encryptedID,prototype.getExtension(),prototype.tail);\n}", "comment": "generates encoded session id string which uses the same extensions and tail part as prototype session id , but a different encrypted id .", "label": "done"}
{"id": "73531", "raw_code": "public static <E>E syncRest(final Iterator<? extends Object> iterator,final Callable<E> task) throws Exception {\n  if (iterator.hasNext()) {\nsynchronized (iterator.next()) {\n      return syncRest(iterator,task);\n    }\n  }\n else {\n    return task.call();\n  }\n}", "comment": "recursively synchronizes on the components in the provided iterator and executes the provided task if there are no more components .", "label": "done"}
{"id": "81999", "raw_code": "private static Component findByName(Container root,String componentName){\n  if (verbose) {\n    log(\"findByName(\" + root + \", \"+ componentName+ \")\");\n  }\n  int count=root.getComponentCount();\n  for (int iter=0; iter < count; iter++) {\n    Component c=root.getComponentAt(iter);\n    String n=c.getName();\n    if (n != null && n.equals(componentName)) {\n      return c;\n    }\n    if (c instanceof Container) {\n      c=findByName((Container)c,componentName);\n      if (c != null) {\n        return c;\n      }\n    }\n  }\n  return null;\n}", "comment": "finds a component with the given name , works even with ui ' s that weren ' t created with the gui builder", "label": "done"}
{"id": "25932", "raw_code": "private void convertAndFillByteBufferListToByteArrayList(List<byte[]> dictionaryValues,List<ByteBuffer> dictionaryValueBufferList){\n  for (  ByteBuffer buffer : dictionaryValueBufferList) {\n    int length=buffer.limit();\n    byte[] value=new byte[length];\n    buffer.get(value,0,value.length);\n    dictionaryValues.add(value);\n  }\n}", "comment": "this method will convert and fill list of byte buffer to list of byte array", "label": "done"}
{"id": "17966", "raw_code": "private byte[] generateDerivedKey(int bytesNeeded){\n  byte[] buf=new byte[digest.getDigestSize()];\n  byte[] key=new byte[bytesNeeded];\n  int offset=0;\n  for (; ; ) {\n    digest.update(password,0,password.length);\n    digest.update(salt,0,salt.length);\n    digest.doFinal(buf,0);\n    int len=(bytesNeeded > buf.length) ? buf.length : bytesNeeded;\n    System.arraycopy(buf,0,key,offset,len);\n    offset+=len;\n    bytesNeeded-=len;\n    if (bytesNeeded == 0) {\n      break;\n    }\n    digest.reset();\n    digest.update(buf,0,buf.length);\n  }\n  return key;\n}", "comment": "the derived key function , the ith hash of the password and the salt .", "label": "done"}
{"id": "46717", "raw_code": "public static int computeStringWidth(FontMetrics fm,String str){\n  return SwingUtilities2.stringWidth(null,fm,str);\n}", "comment": "compute the width of the string using a font with the specified \" metrics \" ( sizes ) .", "label": "done"}
{"id": "86414", "raw_code": "private boolean passesSanityCheck(AccessibilityEvent event){\n  final CharSequence afterText=getEventText(event);\n  final CharSequence beforeText=event.getBeforeText();\n  if ((event.getAddedCount() == 0) && (event.getRemovedCount() == beforeText.length())) {\n    return true;\n  }\n  if (afterText == null || beforeText == null) {\n    return false;\n  }\n  final int diff=(event.getAddedCount() - event.getRemovedCount());\n  return ((beforeText.length() + diff) == afterText.length());\n}", "comment": "checks whether the event ' s reported properties match its actual properties , e . g . does the added count minus the removed count reflect the actual change in length between the current and previous text contents .", "label": "done"}
{"id": "38601", "raw_code": "public void addChangeListener(ChangeListener l){\n  m_ChangeListeners.add(l);\n}", "comment": "adds a changelistener to the panel", "label": "done"}
{"id": "81981", "raw_code": "public static String relativeToAbsolute(String baseURL,String relativeURL){\n  if (relativeURL.startsWith(\"/\")) {\n    return getURLProtocol(baseURL) + \"://\" + getURLHost(baseURL)+ relativeURL;\n  }\n else {\n    return getURLProtocol(baseURL) + \"://\" + getURLHost(baseURL)+ getURLBasePath(baseURL)+ relativeURL;\n  }\n}", "comment": "converts a relative url e . g . : / myfile . html to an absolute url", "label": "done"}
{"id": "6188", "raw_code": "public static String toXml(final Config toConvert,Boolean prettyXml) throws JAXBException, IOException {\n  String retVal=\"\";\n  try (StringWriter writer=new StringWriter()){\n    toXml(toConvert,writer,prettyXml);\n    retVal=writer.toString();\n    return retVal;\n  }\n }", "comment": "converts config to xml ,", "label": "done"}
{"id": "76769", "raw_code": "public void insert(String key,char val){\n  int len=key.length() + 1;\n  if (freenode + len > eq.length) {\n    redimNodeArrays(eq.length + BLOCK_SIZE);\n  }\n  char strkey[]=new char[len--];\n  key.getChars(0,len,strkey,0);\n  strkey[len]=0;\n  root=insert(root,strkey,0,val);\n}", "comment": "branches are initially compressed , needing one node per key plus the size of the string key .", "label": "done"}
{"id": "26329", "raw_code": "public static void appendContentPrefix(HttpServletRequest request,Appendable urlBuffer) throws IOException {\n  appendContentPrefix(request,urlBuffer,null);\n}", "comment": "appends content prefix to buffer .", "label": "done"}
{"id": "24963", "raw_code": "@SuppressWarnings(\"unchecked\") public static <K,V>void transformStringMap(Map<String,String> original,Map<K,V> map,Class<K> keyClass,Class<V> valueClass) throws PreferenceException {\n  Method parseKeyMethod=findParseMethod(keyClass);\n  Method parseValueMethod=findParseMethod(valueClass);\n  if ((null != parseKeyMethod) && (null != parseValueMethod)) {\n    for (    Map.Entry<String,String> toTransformEntry : original.entrySet()) {\n      try {\n        Object transformedKey=parseKeyMethod.invoke(null,toTransformEntry.getKey());\n        Object transformedValue=parseValueMethod.invoke(null,toTransformEntry.getValue());\n        if (keyClass.isAssignableFrom(transformedKey.getClass()) && valueClass.isAssignableFrom(transformedValue.getClass())) {\n          map.put((K)transformedKey,(V)transformedValue);\n        }\n      }\n catch (      Exception e) {\n        throw new PreferenceException(\"Error transforming Map<java.lang.String, java.lang.String> to Map<\" + keyClass.getName() + \", \"+ valueClass.getName()+ \">.\",e);\n      }\n    }\n  }\n else   if (null == parseKeyMethod) {\n    throw new PreferenceException(\"Error transforming Map<java.lang.String, java.lang.String> to Map<\" + keyClass.getName() + \", \"+ valueClass.getName()+ \">.\"+ \"Parsing method can not be found in class \"+ keyClass.getName()+ \".\");\n  }\n else {\n    throw new PreferenceException(\"Error transforming Map<java.lang.String, java.lang.String> to Map<\" + keyClass.getName() + \", \"+ valueClass.getName()+ \">.\"+ \"Parsing method can not be found in class \"+ valueClass.getName()+ \".\");\n  }\n}", "comment": "transforms all the strings key / value pairs in the original map to the given class key / value pairs and adds them to the given resulting map .", "label": "done"}
{"id": "17097", "raw_code": "public static void insertIntoCombo(JComboBox combo,Object item){\n  MutableComboBoxModel model=(MutableComboBoxModel)combo.getModel();\n  if (model.getSize() == 0) {\n    model.insertElementAt(item,0);\n    return;\n  }\n  Object o=model.getElementAt(0);\n  if (o.equals(item)) {\n    return;\n  }\n  model.removeElement(item);\n  model.insertElementAt(item,0);\n  combo.setSelectedIndex(0);\n}", "comment": "insert the given item into the combo box , and set it as first selected item .", "label": "done"}
{"id": "18330", "raw_code": "public synchronized Object co_entry_pause(int thisCoroutine) throws java.lang.NoSuchMethodException {\n  if (!m_activeIDs.get(thisCoroutine))   throw new java.lang.NoSuchMethodException();\n  while (m_nextCoroutine != thisCoroutine) {\n    try {\n      wait();\n    }\n catch (    java.lang.InterruptedException e) {\n    }\n  }\n  return m_yield;\n}", "comment": "in the standard coroutine architecture , coroutines are identified by their method names and are launched and run up to their first yield by simply resuming them ; its ' s presumed that this recognizes the not - already - running case and does the right thing .", "label": "done"}
{"id": "14297", "raw_code": "void scheduleToTimerPool(){\n  if (sessionPollerPool.isPollingEnabled()) {\n    long timeoutTime=(session.getLatestRefreshTime() + (session.getMaxIdleTime() * 60)) * 1000;\n    if (sessionPollerPool.getCacheBasedPolling()) {\n      timeoutTime=Math.min((session.getLatestRefreshTime() + (session.getMaxCachingTime() * 60)) * 1000,timeoutTime);\n    }\n    rescheduleIfWillTimeOutBeforeExecution(timeoutTime);\n  }\n else {\n    if ((sessionPollerPool.isSessionCleanupEnabled()) && willExpire(session.getMaxSessionTime())) {\n      long timeoutTime=(session.getLatestRefreshTime() + (session.getMaxSessionTime() * 60)) * 1000;\n      rescheduleIfWillTimeOutBeforeExecution(timeoutTime);\n    }\n  }\n}", "comment": "schedule this culler to be run , based on the state of the session .", "label": "done"}
{"id": "60377", "raw_code": "@Contract(pure=true) public static boolean startsWithConcatenation(@NotNull String string,@NotNull String... prefixes){\n  int offset=0;\n  for (  String prefix : prefixes) {\n    int prefixLen=prefix.length();\n    if (!string.regionMatches(offset,prefix,0,prefixLen)) {\n      return false;\n    }\n    offset+=prefixLen;\n  }\n  return true;\n}", "comment": "equivalent to string . startswith ( prefixes [ 0 ] + prefixes [ 1 ] + . . . ) but avoids creating an object for concatenation .", "label": "done"}
{"id": "48734", "raw_code": "private Socket openDataConnection(String cmd) throws sun.net.ftp.FtpProtocolException, IOException {\n  Socket clientSocket;\n  if (passiveMode) {\n    try {\n      return openPassiveDataConnection(cmd);\n    }\n catch (    sun.net.ftp.FtpProtocolException e) {\n      String errmsg=e.getMessage();\n      if (!errmsg.startsWith(\"PASV\") && !errmsg.startsWith(\"EPSV\")) {\n        throw e;\n      }\n    }\n  }\n  ServerSocket portSocket;\n  InetAddress myAddress;\n  String portCmd;\n  if (proxy != null && proxy.type() == Proxy.Type.SOCKS) {\n    throw new sun.net.ftp.FtpProtocolException(\"Passive mode failed\");\n  }\n  portSocket=new ServerSocket(0,1,server.getLocalAddress());\n  try {\n    myAddress=portSocket.getInetAddress();\n    if (myAddress.isAnyLocalAddress()) {\n      myAddress=server.getLocalAddress();\n    }\n    portCmd=\"EPRT |\" + ((myAddress instanceof Inet6Address) ? \"2\" : \"1\") + \"|\"+ myAddress.getHostAddress()+ \"|\"+ portSocket.getLocalPort()+ \"|\";\n    if (!issueCommand(portCmd) || !issueCommand(cmd)) {\n      portCmd=\"PORT \";\n      byte[] addr=myAddress.getAddress();\n      for (int i=0; i < addr.length; i++) {\n        portCmd=portCmd + (addr[i] & 0xFF) + \",\";\n      }\n      portCmd=portCmd + ((portSocket.getLocalPort() >>> 8) & 0xff) + \",\"+ (portSocket.getLocalPort() & 0xff);\n      issueCommandCheck(portCmd);\n      issueCommandCheck(cmd);\n    }\n    if (connectTimeout >= 0) {\n      portSocket.setSoTimeout(connectTimeout);\n    }\n else {\n      if (defaultConnectTimeout > 0) {\n        portSocket.setSoTimeout(defaultConnectTimeout);\n      }\n    }\n    clientSocket=portSocket.accept();\n    if (readTimeout >= 0) {\n      clientSocket.setSoTimeout(readTimeout);\n    }\n else {\n      if (defaultSoTimeout > 0) {\n        clientSocket.setSoTimeout(defaultSoTimeout);\n      }\n    }\n  }\n  finally {\n    portSocket.close();\n  }\n  if (useCrypto) {\n    try {\n      clientSocket=sslFact.createSocket(clientSocket,serverAddr.getHostName(),serverAddr.getPort(),true);\n    }\n catch (    Exception ex) {\n      throw new IOException(ex.getLocalizedMessage());\n    }\n  }\n  return clientSocket;\n}", "comment": "opens a data connection with the server according to the set mode ( active or passive ) then send the command passed as an argument .", "label": "done"}
{"id": "13403", "raw_code": "public static boolean installNormal(Context context,String filePath){\n  Intent i=new Intent(Intent.ACTION_VIEW);\n  File file=new File(filePath);\n  if (!file.exists() || !file.isFile() || file.length() <= 0) {\n    return false;\n  }\n  i.setDataAndType(Uri.parse(\"file://\" + filePath),\"application/vnd.android.package-archive\");\n  i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n  context.startActivity(i);\n  return true;\n}", "comment": "install package normal by system intent", "label": "done"}
{"id": "27071", "raw_code": "@SuppressWarnings(\"unchecked\") public RhythmOverlay inflateOverlay(String configString){\n  List<String> configStrings=Arrays.asList(configString.split(\"\\\\r?\\\\n\"));\n  return inflateOverlayInternal(configStrings,Collections.EMPTY_MAP,0);\n}", "comment": "inflate a single overlay from overlay configuration string according to the syntax spec .", "label": "done"}
{"id": "59359", "raw_code": "public FancyLoader(ClassLoader parent){\n  super(parent);\n  try {\n    mDexClass=parent.loadClass(\"dalvik.system.DexFile\");\n  }\n catch (  ClassNotFoundException cnfe) {\n  }\n}", "comment": "construct fancyloader , grabbing a reference to the dexfile class if we ' re running under dalvik .", "label": "done"}
{"id": "47720", "raw_code": "protected void flip(BufferCapabilities.FlipContents flipAction){\n  if (peer != null) {\n    Image backBuffer=getBackBuffer();\n    if (backBuffer != null) {\n      peer.flip(0,0,backBuffer.getWidth(null),backBuffer.getHeight(null),flipAction);\n    }\n  }\n else {\n    throw new IllegalStateException(\"Component must have a valid peer\");\n  }\n}", "comment": "flipping moves the contents of the back buffer to the front buffer , either by copying or by moving the video pointer .", "label": "done"}
{"id": "70891", "raw_code": "public static byte[] toByteArray(Bitmap bitmap,Bitmap.CompressFormat format,int quality){\n  ByteArrayOutputStream out=null;\n  try {\n    out=new ByteArrayOutputStream();\n    bitmap.compress(format,quality,out);\n    return out.toByteArray();\n  }\n  finally {\n    CloseableUtils.close(out);\n  }\n}", "comment": "compress the bitmap to the byte array as the specified format and quality .", "label": "done"}
{"id": "34053", "raw_code": "public static void executeRandomModifiableVariableModification(ModifiableVariableHolder object){\n  Field field=object.getRandomModifiableVariableField();\n  executeModifiableVariableModification(object,field);\n}", "comment": "picks a random modifiable variable and executes a random modification on this variable .", "label": "done"}
{"id": "74787", "raw_code": "@Override public BufferedImage JPEGToRGBImage(final byte[] data,final int ww,final int hh,final int pX,final int pY){\n  BufferedImage image=null;\n  Raster ras=JPEGDecoder.getRasterFromJPEG(data,\"JPEG\");\n  if (ras != null) {\n    ras=cleanupRaster(ras,pX,pY,componentCount);\n    final int w=ras.getWidth();\n    final int h=ras.getHeight();\n    final DataBufferByte rgb=(DataBufferByte)ras.getDataBuffer();\n    image=createImage(w,h,rgb.getData());\n  }\n  return image;\n}", "comment": "convert data stream to srgb image", "label": "done"}
{"id": "61575", "raw_code": "public String decode(String pString) throws DecoderException {\n  if (pString == null) {\n    return null;\n  }\n  try {\n    return decode(pString,getDefaultCharset());\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new DecoderException(e.getMessage());\n  }\n}", "comment": "decodes a url safe string into its original form using the default string charset .", "label": "done"}
{"id": "33603", "raw_code": "private float colorToAngle(int color){\n  float[] colors=new float[3];\n  Color.colorToHSV(color,colors);\n  return (float)Math.toRadians(-colors[0]);\n}", "comment": "convert a color to an angle .", "label": "done"}
{"id": "32552", "raw_code": "Builder addEncodedQueryParameter(String encodedName,String encodedValue){\n  if (encodedName == null)   throw new IllegalArgumentException(\"encodedName == null\");\n  if (encodedQueryNamesAndValues == null)   encodedQueryNamesAndValues=new ArrayList<>();\n  encodedQueryNamesAndValues.add(canonicalize(encodedName,QUERY_COMPONENT_ENCODE_SET,true,true));\n  encodedQueryNamesAndValues.add(encodedValue != null ? canonicalize(encodedValue,QUERY_COMPONENT_ENCODE_SET,true,true) : null);\n  return this;\n}", "comment": "adds the pre - encoded query parameter to this url ' s query string .", "label": "done"}
{"id": "66527", "raw_code": "private static a createImageLink(String AD_Language,String name,String js_command,boolean enabled,boolean pressed){\n  a img=new a(\"#\",createImage(AD_Language,name));\n  if (!pressed || !enabled)   img.setID(\"imgButtonLink\");\n else   img.setID(\"imgButtonPressedLink\");\n  if (js_command == null)   js_command=\"'Submit'\";\n  if (js_command.length() > 0 && enabled) {\n    if (js_command.startsWith(\"startPopup\"))     img.setOnClick(js_command);\n else     img.setOnClick(\"SubmitForm('\" + name + \"', \"+ js_command+ \",'toolbar');return false;\");\n  }\n  img.setClass(\"ToolbarButton\");\n  img.setOnMouseOver(\"window.status='\" + name + \"';return true;\");\n  img.setOnMouseOut(\"window.status='';return true;\");\n  img.setOnBlur(\"this.hideFocus=false\");\n  return img;\n}", "comment": "create image with name , id of button _ name and set p _ command onclick", "label": "done"}
{"id": "47203", "raw_code": "public final int decrementAndGet(){\n  return unsafe.getAndAddInt(this,valueOffset,-1) - 1;\n}", "comment": "atomically decrements by one the current value .", "label": "done"}
{"id": "10392", "raw_code": "private static void addId(final StringBuilder buf,final byte[] id){\n  buf.append(\"\\\\Q\");\n  boolean backslash=false;\n  for (  final byte b : id) {\n    buf.append((char)(b & 0xFF));\n    if (b == 'E' && backslash) {\n      buf.append(\"\\\\\\\\E\\\\Q\");\n    }\n else {\n      backslash=b == '\\\\';\n    }\n  }\n  buf.append(\"\\\\E\");\n}", "comment": "appends the given id to the given buffer , followed by \" \\ \\ e \" .", "label": "done"}
{"id": "48538", "raw_code": "public boolean drawImage(Image img,AffineTransform xform,ImageObserver observer){\n  if (img == null) {\n    return true;\n  }\n  if (xform == null || xform.isIdentity()) {\n    return drawImage(img,0,0,null,observer);\n  }\n  if (isHiDPIImage(img)) {\n    final int w=img.getWidth(null);\n    final int h=img.getHeight(null);\n    final AffineTransform tx=new AffineTransform(transform);\n    transform(xform);\n    boolean result=drawHiDPIImage(img,0,0,w,h,0,0,w,h,null,observer);\n    transform.setTransform(tx);\n    invalidateTransform();\n    return result;\n  }\n  try {\n    return imagepipe.transformImage(this,img,xform,observer);\n  }\n catch (  InvalidPipeException e) {\n    try {\n      revalidateAll();\n      return imagepipe.transformImage(this,img,xform,observer);\n    }\n catch (    InvalidPipeException e2) {\n      return false;\n    }\n  }\n finally {\n    surfaceData.markDirty();\n  }\n}", "comment": "draw an image , applying a transform from image space into user space before drawing .", "label": "done"}
{"id": "13771", "raw_code": "public void beginDisplay(DisplayEvent event) throws ModelControlException {\n  super.beginDisplay(event,false);\n  resetButtonState(TBL_BUTTON_DELETE);\n  AgentsModel model=(AgentsModel)getModel();\n  String agentType=getDisplayIDType();\n  Object[] param={agentType};\n  ptModel.setPageTitleText(model.getLocalizedString(\"agenttype.\" + agentType));\n  ptModel.setPageTitleHelpMessage(model.getLocalizedString(\"agenttype.\" + agentType + \".help\"));\n  tblModel.setTitle(MessageFormat.format(model.getLocalizedString(\"table.agents.title.name\"),param));\n  tblModel.setTitleLabel(MessageFormat.format(model.getLocalizedString(\"table.agents.summary\"),param));\n  tblModel.setSummary(MessageFormat.format(model.getLocalizedString(\"table.agents.summary\"),param));\n  tblGroupModel.setTitle(MessageFormat.format(model.getLocalizedString(\"table.agent.groups.title.name\"),param));\n  tblGroupModel.setTitleLabel(MessageFormat.format(model.getLocalizedString(\"table.agent.groups.summary\"),param));\n  tblGroupModel.setSummary(MessageFormat.format(model.getLocalizedString(\"table.agent.groups.summary\"),param));\n  getAgentNames();\n  CCButton b=(CCButton)getChild(TBL_BUTTON_DELETE);\n  b.setDisabled(true);\n  b=(CCButton)getChild(TBL_BUTTON_DELETE_GROUP);\n  b.setDisabled(true);\n}", "comment": "sets the agent title and populates the agent and agent group action table .", "label": "done"}
{"id": "44025", "raw_code": "public void addPauseListener(AnimatorPauseListener listener){\n  if (mPauseListeners == null) {\n    mPauseListeners=new ArrayList<AnimatorPauseListener>();\n  }\n  mPauseListeners.add(listener);\n}", "comment": "adds a pause listener to this animator .", "label": "done"}
{"id": "83312", "raw_code": "public void addComponent(T component){\n  components.add(component);\n}", "comment": "adds a component to the composite .", "label": "done"}
{"id": "12301", "raw_code": "public static String decode(String s,Type t){\n  if (s == null) {\n    throw new IllegalArgumentException();\n  }\n  final int n=s.length();\n  if (n == 0) {\n    return s;\n  }\n  if (s.indexOf('%') < 0) {\n    if (t == Type.QUERY_PARAM) {\n      if (s.indexOf('+') < 0) {\n        return s;\n      }\n    }\n else {\n      return s;\n    }\n  }\n else {\n    if (n < 2) {\n      throw new IllegalArgumentException(\"Malformed percent-encoded octet at index 1\");\n    }\n    if (s.charAt(n - 2) == '%') {\n      throw new IllegalArgumentException(\"Malformed percent-encoded octet at index \" + (n - 2));\n    }\n  }\n  if (t == null) {\n    return decode(s,n);\n  }\nswitch (t) {\ncase HOST:\n    return decodeHost(s,n);\ncase QUERY_PARAM:\n  return decodeQueryParam(s,n);\ndefault :\nreturn decode(s,n);\n}\n}", "comment": "decodes characters of a string that are percent - encoded octets using utf - 8 decoding ( if needed ) .", "label": "done"}
{"id": "27519", "raw_code": "public void copyReader(String encoding,Reader r) throws IOException {\n  super.setContentEncoding(encoding);\n  String s=readString(r);\n  content=s.getBytes(encoding);\n}", "comment": "set the content by copying characters from the given reader and converting them into bytes using the specified encoding .", "label": "done"}
{"id": "2009", "raw_code": "public Future<?> execute(CameraCommand command){\n  if (mClosed) {\n    return Futures.immediateFuture(null);\n  }\nsynchronized (mLock) {\n    if (mExecutor == null) {\n      mExecutor=mExecutorProvider.get();\n    }\n    checkNotNull(mExecutor);\n    return mExecutor.submit(new CommandRunnable(command));\n  }\n}", "comment": "executes the given command , returning a future to indicate its status and allow ( interruptible ) cancellation .", "label": "done"}
{"id": "57311", "raw_code": "public void populateCombos(Activity activity,final Listener listener){\n  List<String> services=getServices(activity.getPackageManager());\n  populateCombos(activity,services,listener);\n}", "comment": "collect together the languages supported by the given services and call back once done .", "label": "done"}
{"id": "877", "raw_code": "public void cacheResolvedMethod(Class clas,Class[] types,Method method){\n  if (Interpreter.DEBUG)   Interpreter.debug(\"cacheResolvedMethod putting: \" + clas + \" \"+ method);\n  SignatureKey sk=new SignatureKey(clas,method.getName(),types);\n  if (Modifier.isStatic(method.getModifiers()))   resolvedStaticMethods.put(sk,method);\n else   resolvedObjectMethods.put(sk,method);\n}", "comment": "cache a resolved ( possibly overloaded ) method based on the argument types used to invoke it , subject to classloader change .", "label": "done"}
{"id": "13035", "raw_code": "@Override public Node item(int index){\n  return (nodes != null && index < nodes.size()) ? (Node)(nodes.get(index)) : null;\n}", "comment": "retrieve an item from the map by 0 - based index .", "label": "done"}
{"id": "5748", "raw_code": "public GTSEncoder(long baseTimestamp){\n  this.baseTimestamp=baseTimestamp;\n  this.stream=new ByteArrayOutputStream();\n  this.wrappingKey=null;\n}", "comment": "create an encoder using the given timestamp as its base .", "label": "done"}
{"id": "73394", "raw_code": "private void extractWeightValues(List<Synapse> synapses){\n  int exWeights=0;\n  int inWeights=0;\n  for (  Synapse s : synapses) {\n    double w=s.getStrength();\n    if (w > 0) {\n      exWeights++;\n    }\n else {\n      inWeights++;\n    }\n  }\n  weights[0]=new double[exWeights];\n  weights[1]=new double[inWeights];\n  exWeights=0;\n  inWeights=0;\n  if (weights[0].length != 0) {\n    for (    Synapse s : synapses) {\n      double w=s.getStrength();\n      if (w > 0) {\n        weights[0][exWeights++]=w;\n      }\n else {\n        weights[1][inWeights++]=w;\n      }\n    }\n  }\n}", "comment": "extracts weight values and organizes them by synapse type ( inhibitory or excitatory ) .", "label": "done"}
{"id": "12074", "raw_code": "private String trimUrl(String uri){\n  if (uri == null)   return \"\";\n  if (uri.endsWith(\"/\"))   uri=uri.substring(0,uri.length() - 1);\n  return uri;\n}", "comment": "trim the url , by removing an extra ' / ' at the end of the url and also make it lowercase", "label": "done"}
{"id": "35101", "raw_code": "public static String addAlpha(String originalColor,double alpha){\n  long alphaFixed=Math.round(alpha * 255);\n  String alphaHex=Long.toHexString(alphaFixed);\n  if (alphaHex.length() == 1) {\n    alphaHex=\"0\" + alphaHex;\n  }\n  originalColor=originalColor.replace(\"#\",\"#\" + alphaHex);\n  return originalColor;\n}", "comment": "adds alpha to a hex color", "label": "done"}
{"id": "23993", "raw_code": "protected Object attemptReadResponse(Connection cnx) throws Exception {\n  Message msg=createResponseMessage();\n  if (msg != null) {\n    msg.setComms(cnx.getSocket(),cnx.getInputStream(),cnx.getOutputStream(),cnx.getCommBuffer(),cnx.getStats());\n    if (msg instanceof ChunkedMessage) {\n      try {\n        return processResponse(msg,cnx);\n      }\n  finally {\n        msg.unsetComms();\n        processSecureBytes(cnx,msg);\n      }\n    }\n else {\n      try {\n        msg.recv();\n      }\n  finally {\n        msg.unsetComms();\n        processSecureBytes(cnx,msg);\n      }\n      return processResponse(msg,cnx);\n    }\n  }\n else {\n    return null;\n  }\n}", "comment": "attempts to read a response to this operation by reading it from the given connection , and returning it .", "label": "done"}
{"id": "33964", "raw_code": "static Sort parseSort(long timestampSec,IndexState state,List<Object> fields,List<String> sortFieldNames,Map<String,FieldDef> dynamicFields){\n  List<SortField> sortFields=new ArrayList<SortField>();\n  for (  Object _sub : fields) {\n    Request sub=(Request)_sub;\n    String fieldName=sub.getString(\"field\");\n    SortField sf;\n    if (sortFieldNames != null) {\n      sortFieldNames.add(fieldName);\n    }\n    if (fieldName.equals(\"docid\")) {\n      sf=SortField.FIELD_DOC;\n    }\n else     if (fieldName.equals(\"score\")) {\n      sf=SortField.FIELD_SCORE;\n    }\n else {\n      FieldDef fd;\n      if (dynamicFields != null) {\n        fd=dynamicFields.get(fieldName);\n      }\n else {\n        fd=null;\n      }\n      if (fd == null) {\n        fd=state.getField(fieldName);\n      }\n      if (fd == null) {\n        sub.fail(\"field\",\"field \\\"\" + fieldName + \"\\\" was not registered and was not specified as a dynamicField\");\n        fd=null;\n      }\n      if (fd.valueSource != null) {\n        sf=fd.valueSource.getSortField(sub.getBoolean(\"reverse\"));\n      }\n else       if (fd.valueType == FieldDef.FieldValueType.LAT_LON) {\n        if (fd.fieldType.docValuesType() == DocValuesType.NONE) {\n          sub.fail(\"field\",\"field \\\"\" + fieldName + \"\\\" was not registered with sort=true\");\n        }\n        Request sub2=sub.getStruct(\"origin\");\n        sf=LatLonDocValuesField.newDistanceSort(fieldName,sub2.getDouble(\"latitude\"),sub2.getDouble(\"longitude\"));\n      }\n else {\n        if ((fd.fieldType != null && fd.fieldType.docValuesType() == DocValuesType.NONE) || (fd.fieldType == null && fd.valueSource == null)) {\n          sub.fail(\"field\",\"field \\\"\" + fieldName + \"\\\" was not registered with sort=true\");\n        }\n        if (fd.multiValued) {\n          String selectorString=sub.getEnum(\"selector\");\n          if (fd.valueType == FieldDef.FieldValueType.ATOM) {\n            SortedSetSelector.Type selector;\n            if (selectorString.equals(\"min\")) {\n              selector=SortedSetSelector.Type.MIN;\n            }\n else             if (selectorString.equals(\"max\")) {\n              selector=SortedSetSelector.Type.MAX;\n            }\n else             if (selectorString.equals(\"middle_min\")) {\n              selector=SortedSetSelector.Type.MIDDLE_MIN;\n            }\n else             if (selectorString.equals(\"middle_max\")) {\n              selector=SortedSetSelector.Type.MIDDLE_MAX;\n            }\n else {\n              assert false;\n              selector=null;\n            }\n            sf=new SortedSetSortField(fieldName,sub.getBoolean(\"reverse\"),selector);\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.INT) {\n            sf=new SortedNumericSortField(fieldName,SortField.Type.INT,sub.getBoolean(\"reverse\"),parseNumericSelector(sub,selectorString));\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.LONG) {\n            sf=new SortedNumericSortField(fieldName,SortField.Type.LONG,sub.getBoolean(\"reverse\"),parseNumericSelector(sub,selectorString));\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.FLOAT) {\n            sf=new SortedNumericSortField(fieldName,SortField.Type.FLOAT,sub.getBoolean(\"reverse\"),parseNumericSelector(sub,selectorString));\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.DOUBLE) {\n            sf=new SortedNumericSortField(fieldName,SortField.Type.DOUBLE,sub.getBoolean(\"reverse\"),parseNumericSelector(sub,selectorString));\n          }\n else {\n            sub.fail(\"field\",\"cannot sort by multiValued field \\\"\" + fieldName + \"\\\": type is \"+ fd.valueType);\n            assert false;\n            sf=null;\n          }\n        }\n else {\n          SortField.Type sortType;\n          if (fd.valueType == FieldDef.FieldValueType.ATOM) {\n            sortType=SortField.Type.STRING;\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.LONG || fd.valueType == FieldDef.FieldValueType.DATE_TIME) {\n            sortType=SortField.Type.LONG;\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.INT) {\n            sortType=SortField.Type.INT;\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.DOUBLE) {\n            sortType=SortField.Type.DOUBLE;\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.FLOAT) {\n            sortType=SortField.Type.FLOAT;\n          }\n else {\n            sub.fail(\"field\",\"cannot sort by field \\\"\" + fieldName + \"\\\": type is \"+ fd.valueType);\n            assert false;\n            sortType=null;\n          }\n          sf=new SortField(fieldName,sortType,sub.getBoolean(\"reverse\"));\n        }\n      }\n      boolean hasMissingLast=sub.hasParam(\"missingLast\");\n      boolean missingLast=sub.getBoolean(\"missingLast\");\n      if (fd.valueType == FieldDef.FieldValueType.ATOM) {\n        if (missingLast) {\n          sf.setMissingValue(SortField.STRING_LAST);\n        }\n else {\n          sf.setMissingValue(SortField.STRING_FIRST);\n        }\n      }\n else       if (fd.valueType == FieldDef.FieldValueType.INT) {\n        sf.setMissingValue(missingLast ? Integer.MAX_VALUE : Integer.MIN_VALUE);\n      }\n else       if (fd.valueType == FieldDef.FieldValueType.LONG) {\n        sf.setMissingValue(missingLast ? Long.MAX_VALUE : Long.MIN_VALUE);\n      }\n else       if (fd.valueType == FieldDef.FieldValueType.FLOAT) {\n        sf.setMissingValue(missingLast ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY);\n      }\n else       if (fd.valueType == FieldDef.FieldValueType.DOUBLE) {\n        sf.setMissingValue(missingLast ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY);\n      }\n else       if (hasMissingLast) {\n        sub.fail(\"missingLast\",\"field=\" + fieldName + \": can only specify missingLast for string and numeric field types: got SortField type \"+ sf.getType());\n      }\n    }\n    sortFields.add(sf);\n  }\n  return new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n}", "comment": "decodes a list of request into the corresponding sort .", "label": "done"}
{"id": "33035", "raw_code": "public void addDelete(IResource delete){\n  if (fDelete == null)   fDelete=new ArrayList<IResource>(2);\n  fDelete.add(delete);\n  if (fIgnoreCount == 0) {\n    internalAdd(new DeleteDescription(delete));\n  }\n}", "comment": "adds the given resource to the list of resources to be deleted .", "label": "done"}
{"id": "68452", "raw_code": "public void addContainer(ImageContainer container){\n  mContainers.add(container);\n}", "comment": "adds another imagecontainer to the list of those interested in the results of the request .", "label": "done"}
{"id": "52894", "raw_code": "@Override public void writeExternal(ObjectOutput out) throws IOException {\n  super.writeExternal(out);\n  out.writeObject(approximation);\n}", "comment": "calls the super method and writes the polynomial approximation of the knn distances of this entry to the specified stream .", "label": "done"}
{"id": "7275", "raw_code": "public void add(String methodName,List<Expression> parameters){\n  chain.add(new DotExpressionItem(methodName,parameters,false));\n}", "comment": "add a method to the chain of methods after the dot .", "label": "done"}
{"id": "13651", "raw_code": "private int calculateTotalHeight(float starSize,int numberOfStars,float starsSeparation,boolean padding){\n  return Math.round(starSize) + (padding ? getPaddingTop() + getPaddingBottom() : 0);\n}", "comment": "calculates total height to occupy based on several parameters", "label": "done"}
{"id": "32745", "raw_code": "public static void flush(){\n  clearBuffer();\n  try {\n    out.flush();\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}", "comment": "flush standard output , padding 0s if number of bits written so far is not a multiple of 8 .", "label": "done"}
{"id": "8693", "raw_code": "public synchronized void updateIconsForPkg(String packageName,UserHandleCompat user){\n  removeIconsForPkg(packageName,user);\n  try {\n    PackageInfo info=mPackageManager.getPackageInfo(packageName,PackageManager.GET_UNINSTALLED_PACKAGES);\n    long userSerial=mUserManager.getSerialNumberForUser(user);\n    for (    LauncherActivityInfoCompat app : mLauncherApps.getActivityList(packageName,user)) {\n      addIconToDBAndMemCache(app,info,userSerial);\n    }\n  }\n catch (  NameNotFoundException e) {\n    Log.d(TAG,\"Package not found\",e);\n    return;\n  }\n}", "comment": "updates the entries related to the given package in memory and persistent db .", "label": "done"}
{"id": "14797", "raw_code": "void addAttributeValues(String attrName,Set values) throws SMSException {\n  if (attrName != null && values != null && !values.isEmpty()) {\n    Map attrs=getAttributes();\n    Set origValues=(Set)attrs.get(attrName);\n    Set newValues=new HashSet(values);\n    if (origValues != null && !origValues.isEmpty()) {\n      newValues.addAll(origValues);\n    }\n    Map newAttrs=new HashMap();\n    newAttrs.put(attrName,newValues);\n    setAttributes(newAttrs);\n  }\n}", "comment": "adds attributes to amsdk organization .", "label": "done"}
{"id": "41212", "raw_code": "public static String hexToStringNoException(final String data){\n  try {\n    return ConversionUtils.arrayToString(Hex.decodeHex(data.toCharArray()));\n  }\n catch (  DecoderException e) {\n    return \"[invalid hex]\";\n  }\n}", "comment": "converts the given hex string into a plain string .", "label": "done"}
{"id": "6682", "raw_code": "public static String rate2speed(double rate){\n  return NUMBER_FORMAT0.format(rate) + \" \" + GENERAL_UNIT_KBPSEC;\n}", "comment": "converts an rate into a human readable and localized kb / s speed .", "label": "done"}
{"id": "3663", "raw_code": "final public void println(String s){\n  Writer out=this.out;\n  if (out == null)   return;\n  try {\n    if (s == null)     out.write(_nullChars,0,_nullChars.length);\n else     out.write(s,0,s.length());\n    out.write(_newline,0,_newline.length);\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}", "comment": "writes a string followed by a newline .", "label": "done"}
{"id": "73325", "raw_code": "@Override public void paint(final PPaintContext ppc){\n  final Paint paint=getPaint();\n  if (paint != null) {\n    final Graphics2D g2=ppc.getGraphics();\n    final PBounds bounds=getUnionOfChildrenBounds(null);\n    if (fillBackground) {\n      g2.setPaint(backgroundColor);\n      g2.fillRect((int)bounds.getX() - outlinePadding,(int)bounds.getY() - outlinePadding,(int)bounds.getWidth() + 2 * outlinePadding,(int)bounds.getHeight() + 2 * outlinePadding);\n    }\n    if (drawOutline) {\n      g2.setPaint(lineColor);\n      g2.drawRoundRect((int)bounds.getX() - outlinePadding,(int)bounds.getY() - outlinePadding,(int)bounds.getWidth() + 2 * outlinePadding,(int)bounds.getHeight() + 2 * outlinePadding,ROUNDING_WIDTH_HEIGHT,ROUNDING_WIDTH_HEIGHT);\n    }\n  }\n}", "comment": "change the default paint to fill an expanded bounding box based on its children ' s bounds .", "label": "done"}
{"id": "46523", "raw_code": "void drawIcon(Graphics g,int ax,int ay,int aw,int ah,float align,Component c){\n  int gap=isLeftToRight ? -(img.getIconWidth() + bulletgap) : (aw + bulletgap);\n  int x=ax + gap;\n  int y=Math.max(ay,ay + (int)(align * ah) - img.getIconHeight());\n  img.paintIcon(c,g,x,y);\n}", "comment": "draws the bullet icon specified by the list - style - image argument .", "label": "done"}
{"id": "73173", "raw_code": "private BufferedImage toBufferedImage(final Image image){\n  if (image instanceof BufferedImage) {\n    return (BufferedImage)image;\n  }\n  if (image instanceof VolatileImage) {\n    VolatileImage volatileImage=(VolatileImage)image;\n    return volatileImage.getSnapshot();\n  }\n  GraphicsEnvironment graphicsEnvironment=GraphicsEnvironment.getLocalGraphicsEnvironment();\n  GraphicsDevice graphicsDevice=graphicsEnvironment.getDefaultScreenDevice();\n  GraphicsConfiguration graphicsConfiguration=graphicsDevice.getDefaultConfiguration();\n  BufferedImage bufferedImage=graphicsConfiguration.createCompatibleImage(image.getWidth(null),image.getHeight(null));\n  Graphics2D g=bufferedImage.createGraphics();\n  g.drawImage(image,0,0,null);\n  g.dispose();\n  return bufferedImage;\n}", "comment": "convert the specified image to a bufferedimage , if necessary .", "label": "done"}
{"id": "65788", "raw_code": "public void addFieldBuffered(VEditor editor,GridField mField){\n  wrap=mField != null ? !mField.isSameLine() : false;\n  if (prevEditor != null && prevField != null)   addField(prevEditor,prevField);\n  prevEditor=editor;\n  prevField=mField;\n}", "comment": "add field and label to buffer and push buffered field to panel", "label": "done"}
{"id": "75340", "raw_code": "public static String trim(CharSequence s){\n  if (s == null) {\n    return null;\n  }\n  Matcher m=sTrimPattern.matcher(s);\n  return m.replaceAll(\"$1\");\n}", "comment": "trims the string , removing all whitespace at the beginning and end of the string .", "label": "done"}
{"id": "35785", "raw_code": "private static NSObject parseObject(Node n) throws ParseException, IOException {\n  String type=n.getNodeName();\n  if (type.equals(\"dict\")) {\n    NSDictionary dict=new NSDictionary();\n    List<Node> children=filterElementNodes(n.getChildNodes());\n    for (int i=0; i < children.size(); i+=2) {\n      Node key=children.get(i);\n      Node val=children.get(i + 1);\n      String keyString=getNodeTextContents(key);\n      dict.put(keyString,parseObject(val));\n    }\n    return dict;\n  }\n else   if (type.equals(\"array\")) {\n    List<Node> children=filterElementNodes(n.getChildNodes());\n    NSArray array=new NSArray(children.size());\n    for (int i=0; i < children.size(); i++) {\n      array.setValue(i,parseObject(children.get(i)));\n    }\n    return array;\n  }\n else   if (type.equals(\"true\")) {\n    return new NSNumber(true);\n  }\n else   if (type.equals(\"false\")) {\n    return new NSNumber(false);\n  }\n else   if (type.equals(\"integer\")) {\n    return new NSNumber(getNodeTextContents(n));\n  }\n else   if (type.equals(\"real\")) {\n    return new NSNumber(getNodeTextContents(n));\n  }\n else   if (type.equals(\"string\")) {\n    return new NSString(getNodeTextContents(n));\n  }\n else   if (type.equals(\"data\")) {\n    return new NSData(getNodeTextContents(n));\n  }\n else   if (type.equals(\"date\")) {\n    return new NSDate(getNodeTextContents(n));\n  }\n  return null;\n}", "comment": "parses a node in the xml structure and returns the corresponding nsobject", "label": "done"}
{"id": "5003", "raw_code": "public void fill_shape(PlaPointFloat[] p_points,Graphics p_g,Color p_color,double p_translucency_factor){\n  if (p_color == null)   return;\n  Graphics2D g2=(Graphics2D)p_g;\n  Polygon draw_polygon=new Polygon();\n  for (int index=0; index < p_points.length; index++) {\n    Point2D curr_corner=coordinate_transform.board_to_screen(p_points[index]);\n    draw_polygon.addPoint((int)Math.round(curr_corner.getX()),(int)Math.round(curr_corner.getY()));\n  }\n  g2.setColor(p_color);\n  set_translucency(g2,p_translucency_factor);\n  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);\n  g2.fill(draw_polygon);\n}", "comment": "fill the interior of the polygon shape represented by p _ points .", "label": "done"}
{"id": "72262", "raw_code": "public void writeExif(InputStream jpegStream,OutputStream exifOutStream) throws IOException {\n  if (jpegStream == null || exifOutStream == null) {\n    throw new IllegalArgumentException(NULL_ARGUMENT_STRING);\n  }\n  OutputStream s=getExifWriterStream(exifOutStream);\n  doExifStreamIO(jpegStream,s);\n  s.flush();\n}", "comment": "writes the tags from this exifinterface object into a jpeg stream , removing prior exif tags .", "label": "done"}
{"id": "57167", "raw_code": "public static byte[] toIPv4AddressBytes(int ipAddress){\n  return new byte[]{(byte)(ipAddress >>> 24),(byte)(ipAddress >>> 16),(byte)(ipAddress >>> 8),(byte)ipAddress};\n}", "comment": "accepts an ipv4 address in the form of an integer and returns the corresponding byte array .", "label": "done"}
{"id": "52051", "raw_code": "@SuppressWarnings({\"SuspiciousNameCombination\"}) public static double normalCdf(double y){\n  double f, h;\n  int j;\n  double dcphi, x, z, f1, f2, f3, f4, f5;\n  x=y;\n  if (Math.abs(x) > 15.) {\n    dcphi=0.;\n  }\n else {\n    j=(int)Math.floor(Math.abs(x) * 16. + .5);\n    z=j * .0625;\n    h=Math.abs(x) - z;\n    f=r[j];\n    f1=f * z - 1;\n    f2=f + z * f1;\n    f3=f1 * 2. + z * f2;\n    f4=f2 * 3 + z * f3;\n    f5=f3 * 4 + z * f4;\n    dcphi=f + h * (f1 * 120. + h * (f2 * 60. + h * (f3 * 20. + h * (f4 * 5. + h * f5)))) / 120.;\n    dcphi=dcphi * .3989422804014326779 * Math.exp(x * -.5 * x);\n  }\n  if (x < 0.) {\n    return dcphi;\n  }\n else {\n    return (1.0 - dcphi);\n  }\n}", "comment": "normal cumulative distribution function ( the value which results by integrating the normal distribution function from negative infinity up to y ) .", "label": "done"}
{"id": "13735", "raw_code": "public void put(String name,String supported,String authScheme,String level,boolean isDefault){\n  SAMLv2AuthContext c=new SAMLv2AuthContext();\n  c.name=name;\n  c.supported=supported;\n  if (authScheme.length() != 0 && authScheme != null) {\n    int index=authScheme.lastIndexOf(\"=\");\n    c.value=authScheme.substring(index + 1);\n    c.key=authScheme.substring(0,index);\n  }\n else {\n    c.value=\"\";\n    c.key=\"\";\n  }\n  c.level=level;\n  c.isDefault=isDefault;\n  collections.put(name,c);\n}", "comment": "adds samlv2authcontext to the collection .", "label": "done"}
{"id": "71190", "raw_code": "private void replaceCollapsedEdges(){\n  List newEdges=new ArrayList();\n  for (Iterator it=edgeList.iterator(); it.hasNext(); ) {\n    Edge e=(Edge)it.next();\n    if (e.isCollapsed()) {\n      it.remove();\n      newEdges.add(e.getCollapsedEdge());\n    }\n  }\n  edgeList.addAll(newEdges);\n}", "comment": "if edges which have undergone dimensional collapse are found , replace them with a new edge which is a l edge", "label": "done"}
{"id": "40405", "raw_code": "private int readAnnotationValue(int v,final char[] buf,final String name,final AnnotationVisitor av){\n  int i;\n  if (av == null) {\nswitch (b[v] & 0xFF) {\ncase 'e':\n      return v + 5;\ncase '@':\n    return readAnnotationValues(v + 3,buf,true,null);\ncase '[':\n  return readAnnotationValues(v + 1,buf,false,null);\ndefault :\nreturn v + 3;\n}\n}\nswitch (b[v++] & 0xFF) {\ncase 'I':\ncase 'J':\ncase 'F':\ncase 'D':\nav.visit(name,readConst(readUnsignedShort(v),buf));\nv+=2;\nbreak;\ncase 'B':\nav.visit(name,(byte)readInt(items[readUnsignedShort(v)]));\nv+=2;\nbreak;\ncase 'Z':\nav.visit(name,readInt(items[readUnsignedShort(v)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\nv+=2;\nbreak;\ncase 'S':\nav.visit(name,(short)readInt(items[readUnsignedShort(v)]));\nv+=2;\nbreak;\ncase 'C':\nav.visit(name,(char)readInt(items[readUnsignedShort(v)]));\nv+=2;\nbreak;\ncase 's':\nav.visit(name,readUTF8(v,buf));\nv+=2;\nbreak;\ncase 'e':\nav.visitEnum(name,readUTF8(v,buf),readUTF8(v + 2,buf));\nv+=4;\nbreak;\ncase 'c':\nav.visit(name,Type.getType(readUTF8(v,buf)));\nv+=2;\nbreak;\ncase '@':\nv=readAnnotationValues(v + 2,buf,true,av.visitAnnotation(name,readUTF8(v,buf)));\nbreak;\ncase '[':\nint size=readUnsignedShort(v);\nv+=2;\nif (size == 0) {\nreturn readAnnotationValues(v - 2,buf,false,av.visitArray(name));\n}\nswitch (this.b[v++] & 0xFF) {\ncase 'B':\nbyte[] bv=new byte[size];\nfor (i=0; i < size; i++) {\nbv[i]=(byte)readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,bv);\n--v;\nbreak;\ncase 'Z':\nboolean[] zv=new boolean[size];\nfor (i=0; i < size; i++) {\nzv[i]=readInt(items[readUnsignedShort(v)]) != 0;\nv+=3;\n}\nav.visit(name,zv);\n--v;\nbreak;\ncase 'S':\nshort[] sv=new short[size];\nfor (i=0; i < size; i++) {\nsv[i]=(short)readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,sv);\n--v;\nbreak;\ncase 'C':\nchar[] cv=new char[size];\nfor (i=0; i < size; i++) {\ncv[i]=(char)readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,cv);\n--v;\nbreak;\ncase 'I':\nint[] iv=new int[size];\nfor (i=0; i < size; i++) {\niv[i]=readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,iv);\n--v;\nbreak;\ncase 'J':\nlong[] lv=new long[size];\nfor (i=0; i < size; i++) {\nlv[i]=readLong(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,lv);\n--v;\nbreak;\ncase 'F':\nfloat[] fv=new float[size];\nfor (i=0; i < size; i++) {\nfv[i]=Float.intBitsToFloat(readInt(items[readUnsignedShort(v)]));\nv+=3;\n}\nav.visit(name,fv);\n--v;\nbreak;\ncase 'D':\ndouble[] dv=new double[size];\nfor (i=0; i < size; i++) {\ndv[i]=Double.longBitsToDouble(readLong(items[readUnsignedShort(v)]));\nv+=3;\n}\nav.visit(name,dv);\n--v;\nbreak;\ndefault :\nv=readAnnotationValues(v - 3,buf,false,av.visitArray(name));\n}\n}\nreturn v;\n}", "comment": "reads a value of an annotation and makes the given visitor visit it .", "label": "done"}
{"id": "71768", "raw_code": "public void timingEvent(float fraction){\n  current.x=(int)(start.x + (end.x - start.x) * fraction);\n  current.y=(int)(start.y + (end.y - start.y) * fraction);\n  track.setCarPosition(current);\n}", "comment": "timingtarget implementation : calculate and set the current car position based on the animation fraction", "label": "done"}
{"id": "76491", "raw_code": "@CalledOnlyBy(AmidstThread.FRAGMENT_LOADER) public void processQueues(){\n  Dimension dimension=dimensionSetting.get();\n  updateLayerManager(dimension);\n  processRecycleQueue();\n  Fragment fragment;\n  while ((fragment=loadingQueue.poll()) != null) {\n    loadFragment(dimension,fragment);\n    dimension=dimensionSetting.get();\n    updateLayerManager(dimension);\n    processRecycleQueue();\n  }\n  layerManager.clearInvalidatedLayers();\n}", "comment": "it is important that the dimension setting is the same while a fragment is loaded by different fragment loaders .", "label": "done"}
{"id": "50326", "raw_code": "default FieldDeclaration addPrivateField(Class<?> typeClass,String name){\n  return addField(typeClass,name,Modifier.PRIVATE);\n}", "comment": "add a private field to this", "label": "done"}
{"id": "24622", "raw_code": "public boolean matchChomp(String seq){\n  if (matches(seq)) {\n    pos+=seq.length();\n    return true;\n  }\n else {\n    return false;\n  }\n}", "comment": "tests if the queue matches the sequence ( as with match ) , and if they do , removes the matched string from the queue .", "label": "done"}
{"id": "68736", "raw_code": "public void initGL(){\n  mEglCore=new EglCore(null,EglCore.FLAG_RECORDABLE | EglCore.FLAG_TRY_GLES3);\n  mWindowSurface=new WindowSurface(mEglCore,mSurfaceTexture);\n  mWindowSurface.makeCurrent();\n  mRecordSurface=new WindowSurface(mEglCore,mMediaRecorder.getSurface(),false);\n  initGLComponents();\n}", "comment": "initialize all necessary components for gles rendering , creating window surfaces for drawing the preview as well as the surface that will be used by mediarecorder for recording", "label": "done"}
{"id": "21414", "raw_code": "public static boolean isZoningRequired(DbClient dbClient,VirtualArray nh){\n  if (nh.getAutoSanZoning() == false) {\n    _log.info(\"SAN Zoning is not enabled for Neighborhood: \" + nh.getLabel());\n    return false;\n  }\n  return NetworkUtil.areNetworkSystemDiscovered(dbClient);\n}", "comment": "looks at the varray to see if zoning is disabled , and looks to make sure that there is at least one active networksystem registered .", "label": "done"}
{"id": "15420", "raw_code": "private void initXMLTree() throws Exception {\n  updateFilteredTokens();\n  ArrayList elements=getElements(getFilteredTokens());\n  if (elements.size() > 1) {\n    throw new Exception(\"More than one root elements encountered\");\n  }\n  setRootElement((XMLElement)elements.get(0));\n}", "comment": "creats an in - memory xml tree based on the parsed tokens in this document .", "label": "done"}
{"id": "55537", "raw_code": "public static Color decode(String color,Color defaultColor){\n  if (color == null) {\n    return defaultColor;\n  }\n  Color c=getNamedColor(color);\n  if (c == null) {\n    try {\n      c=Color.decode(color);\n    }\n catch (    NumberFormatException ex) {\n      return defaultColor;\n    }\n  }\n  return c;\n}", "comment": "decodes an html color and turns it into a color object .", "label": "done"}
{"id": "69814", "raw_code": "public static <V>int addDistinctList(List<V> sourceList,List<V> entryList){\n  if (sourceList == null || isEmpty(entryList)) {\n    return 0;\n  }\n  int sourceCount=sourceList.size();\n  for (  V entry : entryList) {\n    if (!sourceList.contains(entry)) {\n      sourceList.add(entry);\n    }\n  }\n  return sourceList.size() - sourceCount;\n}", "comment": "add all distinct entry to list1 from list2", "label": "done"}
{"id": "38513", "raw_code": "public void addScriptFinishedListener(ScriptExecutionListener l){\n  m_FinishedListeners.add(l);\n}", "comment": "adds the given listener to its internal list .", "label": "done"}
{"id": "6969", "raw_code": "private T[] ensureCapacity(int minCapacity){\n  if (tmp.length < minCapacity) {\n    int newSize=minCapacity;\n    newSize|=newSize >> 1;\n    newSize|=newSize >> 2;\n    newSize|=newSize >> 4;\n    newSize|=newSize >> 8;\n    newSize|=newSize >> 16;\n    newSize++;\n    if (newSize < 0)     newSize=minCapacity;\n else     newSize=Math.min(newSize,a.length >>> 1);\n    T[] newArray=(T[])new Object[newSize];\n    tmp=newArray;\n  }\n  return tmp;\n}", "comment": "ensures that the external array tmp has at least the specified number of elements , increasing its size if necessary .", "label": "done"}
{"id": "16285", "raw_code": "public synchronized void add(String category,double minValue,double maxValue){\n  super.add(category,minValue);\n  mMaxValues.add(maxValue);\n}", "comment": "adds new values to the series .", "label": "done"}
{"id": "83086", "raw_code": "public static final double parseTime(final String time,final char separator){\n  if (time == null || time.length() == 0 || time.equals(\"undefined\")) {\n    return Time.UNDEFINED_TIME;\n  }\n  boolean isNegative=(time.charAt(0) == '-');\n  String[] strings=(isNegative ? StringUtils.explode(time.substring(1),separator) : StringUtils.explode(time,separator));\n  double seconds=0;\n  if (strings.length == 1) {\n    seconds=Math.abs(Double.parseDouble(strings[0]));\n  }\n else   if (strings.length == 2) {\n    int h=Integer.parseInt(strings[0]);\n    int m=Integer.parseInt(strings[1]);\n    if ((m < 0) || (m > 59)) {\n      throw new IllegalArgumentException(\"minutes are out of range in \" + time);\n    }\n    seconds=Math.abs(h) * 3600 + m * 60;\n  }\n else   if (strings.length == 3) {\n    int h=Integer.parseInt(strings[0]);\n    int m=Integer.parseInt(strings[1]);\n    double s=Double.parseDouble(strings[2]);\n    if ((m < 0) || (m > 59)) {\n      throw new IllegalArgumentException(\"minutes are out of range in \" + time);\n    }\n    if ((s < 0) || (s >= 60)) {\n      throw new IllegalArgumentException(\"seconds are out of range in \" + time);\n    }\n    seconds=Math.abs(h) * 3600 + m * 60 + s;\n  }\n else {\n    throw new IllegalArgumentException(\"time format is not valid in \" + time);\n  }\n  if (isNegative) {\n    seconds=-seconds;\n  }\n  return seconds;\n}", "comment": "parses the given string for a textual representation for time and returns the time value in seconds past midnight .", "label": "done"}
{"id": "80560", "raw_code": "public String betToString(){\n  final StringBuilder sb=new StringBuilder();\n  sb.append(amount);\n  sb.append(\" \");\n  sb.append(itemName);\n  sb.append(\" on \");\n  sb.append(target);\n  return sb.toString();\n}", "comment": "converts the bet into a string .", "label": "done"}
{"id": "43127", "raw_code": "public void addSuccessMessage(final String successMessage){\n  successMessageList.add(successMessage);\n}", "comment": "adds a success message into the list .", "label": "done"}
{"id": "44795", "raw_code": "public static Long nextLogSegmentSequenceNumber(List<LogSegmentMetadata> segmentListDesc){\n  int lastAssignedLogSegmentIdx=-1;\n  Long lastAssignedLogSegmentSeqNo=null;\n  Long nextLogSegmentSeqNo=null;\n  for (int i=0; i < segmentListDesc.size(); i++) {\n    LogSegmentMetadata metadata=segmentListDesc.get(i);\n    if (LogSegmentMetadata.supportsLogSegmentSequenceNo(metadata.getVersion())) {\n      lastAssignedLogSegmentSeqNo=metadata.getLogSegmentSequenceNumber();\n      lastAssignedLogSegmentIdx=i;\n      break;\n    }\n  }\n  if (null != lastAssignedLogSegmentSeqNo) {\n    nextLogSegmentSeqNo=lastAssignedLogSegmentSeqNo + lastAssignedLogSegmentIdx + 1;\n  }\n  return nextLogSegmentSeqNo;\n}", "comment": "assign next log segment sequence number based on a decreasing list of log segments .", "label": "done"}
{"id": "14825", "raw_code": "public void addDefinition(ICOSDefinition cosDef) throws UMSException {\n  if (!(cosDef instanceof DirectCOSDefinition)) {\n    String msg=i18n.getString(IUMSConstants.INVALID_COSDEFINITION);\n    throw new UMSException(msg);\n  }\n  String[] cosAttributes=cosDef.getCOSAttributes();\n  AbstractCollection aList=(AbstractCollection)Arrays.asList(ICOSDefinition.qualifiers);\n  for (int i=0; i < cosAttributes.length; i++) {\n    String cosAttribute=null;\n    String qualifier=null;\n    StringTokenizer st=new StringTokenizer(cosAttributes[i]);\n    if (st.hasMoreTokens()) {\n      cosAttribute=st.nextToken();\n    }\n    if (cosAttribute == null) {\n      String msg=i18n.getString(IUMSConstants.INVALID_COS_ATTRIBUTE_QUALIFIER);\n      throw new UMSException(msg);\n    }\n    if (st.hasMoreTokens())     qualifier=st.nextToken();\n    if (qualifier == null) {\n      qualifier=ICOSDefinition.qualifiers[ICOSDefinition.DEFAULT];\n      cosDef.removeCOSAttribute(cosAttribute);\n      cosDef.addCOSAttribute(cosAttribute,ICOSDefinition.DEFAULT);\n    }\n    if (!aList.contains(qualifier)) {\n      String msg=i18n.getString(IUMSConstants.INVALID_COS_ATTRIBUTE_QUALIFIER);\n      throw new UMSException(msg);\n    }\n  }\n  PersistentObject po=(PersistentObject)cosDef;\n  _parentObject.addChild(po);\n}", "comment": "this method adds a cos definition to the persistent store .", "label": "done"}
{"id": "33833", "raw_code": "private void adjustBottom(RectF rect,float bottom,RectF bounds,int viewHeight,float snapMargin,float aspectRatio,boolean leftMoves,boolean rightMoves){\n  float newBottom=bottom;\n  if (newBottom > viewHeight) {\n    newBottom=viewHeight + (newBottom - viewHeight) / 1.05f;\n    mTouchOffset.y-=(newBottom - viewHeight) / 1.1f;\n  }\n  if (newBottom > bounds.bottom) {\n    mTouchOffset.y-=(newBottom - bounds.bottom) / 2f;\n  }\n  if (bounds.bottom - newBottom < snapMargin) {\n    newBottom=bounds.bottom;\n  }\n  if (newBottom - rect.top < mMinCropHeight) {\n    newBottom=rect.top + mMinCropHeight;\n  }\n  if (newBottom - rect.top > mMaxCropHeight) {\n    newBottom=rect.top + mMaxCropHeight;\n  }\n  if (bounds.bottom - newBottom < snapMargin) {\n    newBottom=bounds.bottom;\n  }\n  if (aspectRatio > 0) {\n    float newWidth=(newBottom - rect.top) * aspectRatio;\n    if (newWidth < mMinCropWidth) {\n      newBottom=Math.min(bounds.bottom,rect.top + mMinCropWidth / aspectRatio);\n      newWidth=(newBottom - rect.top) * aspectRatio;\n    }\n    if (newWidth > mMaxCropWidth) {\n      newBottom=Math.min(bounds.bottom,rect.top + mMaxCropWidth / aspectRatio);\n      newWidth=(newBottom - rect.top) * aspectRatio;\n    }\n    if (leftMoves && rightMoves) {\n      newBottom=Math.min(newBottom,Math.min(bounds.bottom,rect.top + bounds.width() / aspectRatio));\n    }\n else {\n      if (leftMoves && rect.right - newWidth < bounds.left) {\n        newBottom=Math.min(bounds.bottom,rect.top + (rect.right - bounds.left) / aspectRatio);\n        newWidth=(newBottom - rect.top) * aspectRatio;\n      }\n      if (rightMoves && rect.left + newWidth > bounds.right) {\n        newBottom=Math.min(newBottom,Math.min(bounds.bottom,rect.top + (bounds.right - rect.left) / aspectRatio));\n      }\n    }\n  }\n  rect.bottom=newBottom;\n}", "comment": "get the resulting y - position of the bottom edge of the crop window given the handle ' s position and the image ' s bounding box and snap radius .", "label": "done"}
{"id": "34986", "raw_code": "public static AnnotationMirror findEffectiveAnnotationInHierarchy(final QualifierHierarchy qualifierHierarchy,final AnnotatedTypeMirror toSearch,final AnnotationMirror top){\n  return findEffectiveAnnotationInHierarchy(qualifierHierarchy,toSearch,top,false);\n}", "comment": "when comparing types against the bounds of a type variable , we may encounter other type variables , wildcards , and intersections in those bounds .", "label": "done"}
{"id": "45230", "raw_code": "private static void read(InputStream in,byte[] buf,int pos,int n) throws IOException {\n  int read=0;\n  int res=0;\n  while (read < n) {\n    res=in.read(buf,read + pos,n - read);\n    if (res > 0) {\n      read+=res;\n    }\n else {\n      throw new IOException(\"Read failed, got \" + read + \" of \"+ n);\n    }\n  }\n}", "comment": "read at least the specified amount of bytes , and place them in the input buffer .", "label": "done"}
{"id": "49673", "raw_code": "void parseFinish(){\n  mChildren=mCurrentGroup.getChildren();\n}", "comment": "ensure there is at least one animation for every path in group ( linking them by names ) build the \" current \" path based on the first group", "label": "done"}
{"id": "73248", "raw_code": "private void connectEqualized(SynapseGroup synapseGroup){\n  currentOrderingIndices=new int[sourceNeurons.length];\n  int numConnectsPerSrc;\n  int expectedNumSyns;\n  if (synapseGroup.isRecurrent() && !selfConnectionAllowed) {\n    numConnectsPerSrc=(int)(connectionDensity * (sourceNeurons.length - 1));\n  }\n else {\n    numConnectsPerSrc=(int)(connectionDensity * targetNeurons.length);\n  }\n  expectedNumSyns=numConnectsPerSrc * sourceNeurons.length;\n  synapseGroup.preAllocateSynapses(expectedNumSyns);\n  for (int i=0, n=sourceNeurons.length; i < n; i++) {\n    currentOrderingIndices[i]=numConnectsPerSrc;\n    Neuron src=sourceNeurons[i];\n    Neuron tar;\n    for (int j=0; j < numConnectsPerSrc; j++) {\n      tar=targetNeurons[sparseOrdering[i][j]];\n      Synapse s=new Synapse(src,tar);\n      synapseGroup.addNewSynapse(s);\n    }\n  }\n}", "comment": "populates the synapse group with synapses by making individual synaptic connections between the neurons in the synapse group ' s source and target groups .", "label": "done"}
{"id": "27426", "raw_code": "public void write(final int b) throws IOException {\n  if (m_store == null) {\n    throw new IllegalStateException(ERR_NO_STORE);\n  }\n  if (m_isSaved) {\n    throw new IllegalStateException(ERR_ALREADY_SAVED);\n  }\n  if (m_count == m_blobThreshold && !m_writingHdr) {\n    if (m_blobHeader == null) {\n      m_blobHeader=new ArrayList<Integer>();\n    }\n    final int curAddr=(int)m_store.alloc(m_buf,m_count,m_context);\n    m_blobHeader.add(curAddr);\n    m_count=0;\n  }\n  m_buf[m_count++]=(byte)b;\n  m_bytesWritten++;\n}", "comment": "write a single byte this is the one place where the blob threshold is handled and its done one byte at a time so should be easy enough , we no longer store continuation addresses , instead we allocate blob allocations via a blob header block .", "label": "done"}
{"id": "35707", "raw_code": "public static String hashKeyForDisk(String key){\n  String cacheKey;\n  try {\n    final MessageDigest mDigest=MessageDigest.getInstance(\"MD5\");\n    mDigest.update(key.getBytes());\n    cacheKey=bytesToHexString(mDigest.digest());\n  }\n catch (  NoSuchAlgorithmException e) {\n    cacheKey=String.valueOf(key.hashCode());\n  }\n  return cacheKey;\n}", "comment": "a hashing method that changes a string ( like a url ) into a hash suitable for using as a disk filename .", "label": "done"}
{"id": "68622", "raw_code": "public void recordTimestamp(){\n  long curTimestamp=System.currentTimeMillis();\n  if (usedFields > 0) {\n    long diff=curTimestamp - lastValue;\n    if (usedFields == diffs.length) {\n      long removedValue=diffs[curPosition];\n      diffs[curPosition]=diff;\n      calculateNewAverage(removedValue,diff,false);\n      shiftEnd();\n    }\n else {\n      calculateNewAverage(0,diff,true);\n      diffs[curPosition]=diff;\n      shiftEnd();\n    }\n  }\n else   if (lastValue != -1) {\n    long diff=curTimestamp - lastValue;\n    currentAverage=0;\n    diffs[curPosition]=diff;\n    calculateNewAverage(0,diff,true);\n    shiftEnd();\n  }\n  lastValue=curTimestamp;\n}", "comment": "adds a value and calculates the new average of differences between the values within the window size provided at creation .", "label": "done"}
{"id": "46520", "raw_code": "void addRule(String[] selector,AttributeSet declaration,boolean isLinked){\n  int n=selector.length;\n  StringBuilder sb=new StringBuilder();\n  sb.append(selector[0]);\n  for (int counter=1; counter < n; counter++) {\n    sb.append(' ');\n    sb.append(selector[counter]);\n  }\n  String selectorName=sb.toString();\n  Style rule=getStyle(selectorName);\n  if (rule == null) {\n    Style altRule=addStyle(selectorName,null);\nsynchronized (this) {\n      SelectorMapping mapping=getRootSelectorMapping();\n      for (int i=n - 1; i >= 0; i--) {\n        mapping=mapping.getChildSelectorMapping(selector[i],true);\n      }\n      rule=mapping.getStyle();\n      if (rule == null) {\n        rule=altRule;\n        mapping.setStyle(rule);\n        refreshResolvedRules(selectorName,selector,rule,mapping.getSpecificity());\n      }\n    }\n  }\n  if (isLinked) {\n    rule=getLinkedStyle(rule);\n  }\n  rule.addAttributes(declaration);\n}", "comment": "adds a rule into the stylesheet .", "label": "done"}
{"id": "28554", "raw_code": "public void add(Character character){\n  elements.add(character == null ? JsonNull.INSTANCE : new JsonPrimitive(character));\n}", "comment": "adds the specified character to self .", "label": "done"}
{"id": "67512", "raw_code": "@Nullable private Operator.Kind parseOperator(TokenStream tokens){\n  if (tokens.has(\"=\")) {\n    tokens.next();\n    tokens.expect(\"=\");\n    return Operator.Kind.EQUALS;\n  }\n  if (tokens.has(\"!\")) {\n    tokens.next();\n    tokens.expect(\"=\");\n    return Operator.Kind.NOT_EQUALS;\n  }\n  if (tokens.has(\"<\")) {\n    tokens.next();\n    if (tokens.has(\"=\")) {\n      tokens.next();\n      return Operator.Kind.LESS_EQUAL;\n    }\n    return Operator.Kind.LESS;\n  }\n  if (tokens.has(\">\")) {\n    tokens.next();\n    if (tokens.has(\"=\")) {\n      tokens.next();\n      return Operator.Kind.GREATER_EQUAL;\n    }\n    return Operator.Kind.GREATER;\n  }\n  return null;\n}", "comment": "check for and get an operator kind .", "label": "done"}
{"id": "4497", "raw_code": "private void queueUpSyncs(final Cursor contactsCursor){\n  ContactSyncEntry syncEntry=null;\n  while (contactsCursor.moveToNext()) {\n    if (syncEntry == null) {\n      syncEntry=new ContactSyncEntry(UPLOAD_BATCH_SIZE);\n    }\n    final String number=contactsCursor.getString(contactsCursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));\n    final String name=contactsCursor.getString(contactsCursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));\n    if (!TextUtils.isEmpty(number)) {\n      syncEntry.addNumber(numberToNational(number));\n      syncEntry.addName(name);\n      if (syncEntry.isFull()) {\n        Logger.d(TAG,\"Adding sync entry to queue\");\n        mSyncQueue.add(syncEntry);\n        syncEntry=null;\n      }\n    }\n  }\n}", "comment": "method that hashes contacts and syncs them to server", "label": "done"}
{"id": "756", "raw_code": "public static void addGlue(JComponent b,int layout){\n  b.add(getAxis(b,layout) == BoxLayout.X_AXIS ? Box.createHorizontalGlue() : Box.createVerticalGlue());\n}", "comment": "add a glue , or variable spacing , to a ui component", "label": "done"}
{"id": "59676", "raw_code": "protected void dropTables(List<String> dropTableNames,SQLiteDatabase db){\n  if (dropTableNames != null && !dropTableNames.isEmpty()) {\n    String[] dropTableSQLS=new String[dropTableNames.size()];\n    for (int i=0; i < dropTableSQLS.length; i++) {\n      dropTableSQLS[i]=generateDropTableSQL(dropTableNames.get(i));\n    }\n    execute(dropTableSQLS,db);\n  }\n}", "comment": "drop the tables by the passing table name .", "label": "done"}
{"id": "27022", "raw_code": "public long convertPolarStereographicToGeodetic(double Easting,double Northing){\n  double dy=0, dx=0;\n  double rho=0;\n  double t;\n  double PHI, sin_PHI;\n  double tempPHI=0.0;\n  double essin;\n  double pow_es;\n  double delta_radius;\n  long Error_Code=POLAR_NO_ERROR;\n  double min_easting=Polar_False_Easting - Polar_Delta_Easting;\n  double max_easting=Polar_False_Easting + Polar_Delta_Easting;\n  double min_northing=Polar_False_Northing - Polar_Delta_Northing;\n  double max_northing=Polar_False_Northing + Polar_Delta_Northing;\n  if (Easting > max_easting || Easting < min_easting) {\n    Error_Code|=POLAR_EASTING_ERROR;\n  }\n  if (Northing > max_northing || Northing < min_northing) {\n    Error_Code|=POLAR_NORTHING_ERROR;\n  }\n  if (Error_Code == POLAR_NO_ERROR) {\n    dy=Northing - Polar_False_Northing;\n    dx=Easting - Polar_False_Easting;\n    rho=Math.sqrt(dx * dx + dy * dy);\n    delta_radius=Math.sqrt(Polar_Delta_Easting * Polar_Delta_Easting + Polar_Delta_Northing * Polar_Delta_Northing);\n    if (rho > delta_radius) {\n      Error_Code|=POLAR_RADIUS_ERROR;\n    }\n  }\n  if (Error_Code == POLAR_NO_ERROR) {\n    if ((dy == 0.0) && (dx == 0.0)) {\n      Latitude=PI_OVER_2;\n      Longitude=Polar_Origin_Long;\n    }\n else {\n      if (Southern_Hemisphere != 0) {\n        dy*=-1.0;\n        dx*=-1.0;\n      }\n      if (Math.abs(Math.abs(Polar_Origin_Lat) - PI_OVER_2) > 1.0e-10)       t=rho * tc / (Polar_a_mc);\n else       t=rho * e4 / (two_Polar_a);\n      PHI=PI_OVER_2 - 2.0 * Math.atan(t);\n      while (Math.abs(PHI - tempPHI) > 1.0e-10) {\n        tempPHI=PHI;\n        sin_PHI=Math.sin(PHI);\n        essin=es * sin_PHI;\n        pow_es=Math.pow((1.0 - essin) / (1.0 + essin),es_OVER_2);\n        PHI=PI_OVER_2 - 2.0 * Math.atan(t * pow_es);\n      }\n      Latitude=PHI;\n      Longitude=Polar_Origin_Long + Math.atan2(dx,-dy);\n      if (Longitude > PI)       Longitude-=TWO_PI;\n else       if (Longitude < -PI)       Longitude+=TWO_PI;\n      if (Latitude > PI_OVER_2)       Latitude=PI_OVER_2;\n else       if (Latitude < -PI_OVER_2)       Latitude=-PI_OVER_2;\n      if (Longitude > PI)       Longitude=PI;\n else       if (Longitude < -PI)       Longitude=-PI;\n    }\n    if (Southern_Hemisphere != 0) {\n      Latitude*=-1.0;\n      Longitude*=-1.0;\n    }\n  }\n  return (Error_Code);\n}", "comment": "the function convert _ polar _ stereographic _ to _ geodetic converts polar stereographic coordinates ( easting and northing ) to geodetic coordinates ( latitude and longitude ) according to the current ellipsoid and polar stereographic projection parameters .", "label": "done"}
{"id": "10787", "raw_code": "public static long bytesToLong(final byte[] bytes){\n  final ByteBuffer buffer=ByteBuffer.allocate(8);\n  buffer.put(bytes,0,8);\n  buffer.flip();\n  return buffer.getLong();\n}", "comment": "converts an array of 8 bytes into a long .", "label": "done"}
{"id": "83252", "raw_code": "public void print(){\n  Object[] iterChargingTimes=chargingTimes.toArray();\n  Arrays.sort(iterChargingTimes);\n  for (int i=0; i < iterChargingTimes.length; i++) {\n    ChargeLog curItem=(ChargeLog)iterChargingTimes[i];\n    curItem.print();\n  }\n}", "comment": "just prints out sorted after the time ( starting with 0 : 00 ) note : this is not the order in which the charging happened .", "label": "done"}
{"id": "17459", "raw_code": "private byte[] decodePEM(InputStream inStream,byte[] boundary_suffix) throws IOException {\n  int ch;\n  for (int i=1; i < PEM_BEGIN.length; ++i) {\n    if (PEM_BEGIN[i] != (ch=inStream.read())) {\n      throw new IOException(\"Incorrect PEM encoding: '-----BEGIN\" + ((boundary_suffix == null) ? \"\" : new String(boundary_suffix)) + \"' is expected as opening delimiter boundary.\");\n    }\n  }\n  if (boundary_suffix == null) {\n    while ((ch=inStream.read()) != '\\n') {\n      if (ch == -1) {\n        throw new IOException(\"Incorrect PEM encoding: EOF before content\");\n      }\n    }\n  }\n else {\n    for (int i=0; i < boundary_suffix.length; i++) {\n      if (boundary_suffix[i] != inStream.read()) {\n        throw new IOException(\"Incorrect PEM encoding: '-----BEGIN\" + new String(boundary_suffix) + \"' is expected as opening delimiter boundary.\");\n      }\n    }\n    if ((ch=inStream.read()) == '\\r') {\n      ch=inStream.read();\n    }\n    if (ch != '\\n') {\n      throw new IOException(\"Incorrect PEM encoding: newline expected after \" + \"opening delimiter boundary\");\n    }\n  }\n  int size=1024;\n  byte[] buff=new byte[size];\n  int index=0;\n  while ((ch=inStream.read()) != '-') {\n    if (ch == -1) {\n      throw new IOException(\"Incorrect Base64 encoding: EOF without closing delimiter\");\n    }\n    buff[index++]=(byte)ch;\n    if (index == size) {\n      byte[] newbuff=new byte[size + 1024];\n      System.arraycopy(buff,0,newbuff,0,size);\n      buff=newbuff;\n      size+=1024;\n    }\n  }\n  if (buff[index - 1] != '\\n') {\n    throw new IOException(\"Incorrect Base64 encoding: newline expected before \" + \"closing boundary delimiter\");\n  }\n  for (int i=1; i < PEM_END.length; ++i) {\n    if (PEM_END[i] != inStream.read()) {\n      throw badEnd(boundary_suffix);\n    }\n  }\n  if (boundary_suffix == null) {\n    while (((ch=inStream.read()) != -1) && (ch != '\\n') && (ch != '\\r')) {\n    }\n  }\n else {\n    for (int i=0; i < boundary_suffix.length; i++) {\n      if (boundary_suffix[i] != inStream.read()) {\n        throw badEnd(boundary_suffix);\n      }\n    }\n  }\n  inStream.mark(1);\n  while (((ch=inStream.read()) != -1) && (ch == '\\n' || ch == '\\r')) {\n    inStream.mark(1);\n  }\n  inStream.reset();\n  buff=Base64.decode(buff,index);\n  if (buff == null) {\n    throw new IOException(\"Incorrect Base64 encoding\");\n  }\n  return buff;\n}", "comment": "method retrieves the pem encoded data from the stream and returns its decoded representation .", "label": "done"}
{"id": "8332", "raw_code": "public String resolveParentRelationName(String parentName,Object parent,String childName,Object child){\n  return parentName;\n}", "comment": "follow the most conventional pattern , returns the parentname unchanged .", "label": "done"}
{"id": "59610", "raw_code": "public RelNode convertSelect(SqlSelect select,boolean top){\n  final SqlValidatorScope selectScope=validator.getWhereScope(select);\n  final Blackboard bb=createBlackboard(selectScope,null,top);\n  convertSelectImpl(bb,select);\n  return bb.root;\n}", "comment": "converts a select statement ' s parse tree into a relational expression .", "label": "done"}
{"id": "26479", "raw_code": "public static Object executeScript(String filePath,String functionName,Map<String,Object> context){\n  return executeScript(filePath,functionName,context,new Object[]{context});\n}", "comment": "executes the script at the specified location and returns the result .", "label": "done"}
{"id": "18536", "raw_code": "public XercesHTML2DocumentBuilderFactory(DocumentBuilderSetting[] settings) throws DOMTestIncompatibleException {\n  super(settings);\n  try {\n    ClassLoader classLoader=ClassLoader.getSystemClassLoader();\n    Class htmlBuilderClass=classLoader.loadClass(\"org.apache.html2.dom.HTMLBuilder\");\n    htmlBuilderConstructor=htmlBuilderClass.getConstructor(NO_CLASSES);\n    getHTMLDocumentMethod=htmlBuilderClass.getMethod(\"getHTMLDocument\",NO_CLASSES);\n    Class htmlDOMImpl=classLoader.loadClass(\"org.apache.html2.dom.HTMLDOMImplementationImpl\");\n    Method method=htmlDOMImpl.getMethod(\"getHTMLDOMImplementation\",NO_CLASSES);\n    domImpl=(DOMImplementation)method.invoke(null,NO_OBJECTS);\n    Class saxFactoryClass=classLoader.loadClass(\"org.apache.xerces.jaxp.SAXParserFactoryImpl\");\n    factory=(SAXParserFactory)saxFactoryClass.newInstance();\n  }\n catch (  InvocationTargetException ex) {\n    throw new DOMTestIncompatibleException(ex.getTargetException(),null);\n  }\ncatch (  Exception ex) {\n    throw new DOMTestIncompatibleException(ex,null);\n  }\n  if (settings != null) {\n    for (int i=0; i < settings.length; i++) {\n    }\n  }\n  try {\n    factory.newSAXParser();\n  }\n catch (  ParserConfigurationException ex) {\n    throw new DOMTestIncompatibleException(ex,null);\n  }\ncatch (  SAXException ex) {\n    throw new DOMTestIncompatibleException(ex,null);\n  }\n}", "comment": "creates a implementation of domtestdocumentbuilderfactory using org . apache . html . dom . htmlbuilder", "label": "done"}
{"id": "1405", "raw_code": "public static boolean stringToBooleanValue(String str) throws ExpressionException {\n  str=StringUtil.toLowerCase(str.trim());\n  if (str.equals(\"yes\") || str.equals(\"true\"))   return true;\n else   if (str.equals(\"no\") || str.equals(\"false\"))   return false;\n  throw new CasterException(\"Can't cast String [\" + str + \"] to boolean\");\n}", "comment": "cast a string to a boolean value ( primitive value type )", "label": "done"}
{"id": "60633", "raw_code": "protected synchronized void engineSetSeed(byte[] seed){\n  if (seed == null) {\n    throw new NullPointerException(\"seed == null\");\n  }\n  if (state == NEXT_BYTES) {\n    System.arraycopy(copies,HASHCOPY_OFFSET,this.seed,HASH_OFFSET,EXTRAFRAME_OFFSET);\n  }\n  state=SET_SEED;\n  if (seed.length != 0) {\n    updateSeed(seed);\n  }\n}", "comment": "changes current seed by supplementing a seed argument to the current seed , if this already set ; the argument is used as first seed otherwise .", "label": "done"}
{"id": "55104", "raw_code": "private static boolean useCompactFontFormat(Map<String,Object> args,int compatibilityVersion){\n  String value=(String)args.get(EMBEDASCFF);\n  boolean useCFF=true;\n  if (compatibilityVersion < MxmlConfiguration.VERSION_4_0)   useCFF=false;\n  if (value != null) {\n    useCFF=Boolean.parseBoolean(value.trim());\n  }\n  return useCFF;\n}", "comment": "the cff flag determines whether font information should be embedded in the compact font format using swf tag definefont4 .", "label": "done"}
{"id": "16686", "raw_code": "private String mosesize(String feature){\n  if (joshuaConfiguration.moses) {\n    if (feature.startsWith(\"tm_\") || feature.startsWith(\"lm_\"))     return feature.replace(\"_\",\"-\");\n  }\n  return feature;\n}", "comment": "moses requires the pattern . * _ . * for sparse features , and prohibits underscores in dense features .", "label": "done"}
{"id": "926", "raw_code": "public static int calcTextHeight(Paint paint,String demoText){\n  Rect r=new Rect();\n  paint.getTextBounds(demoText,0,demoText.length(),r);\n  return r.height();\n}", "comment": "calculates the approximate height of a text , depending on a demo text avoid repeated calls ( e . g . inside drawing methods )", "label": "done"}
{"id": "36496", "raw_code": "private static final void checkQueueForDependenciesAndExecuteUnblockedTasks(){\n  List<ProgressThread> toRemove=new LinkedList<>();\nsynchronized (LOCK) {\n    for (    ProgressThread pg : queuedThreads) {\n      if (!pg.isBlockedByDependencies()) {\n        if (!pg.isWaiting()) {\n          toRemove.add(pg);\n          EXECUTOR.execute(pg.makeWrapper());\n        }\n      }\n    }\n  }\n  for (  ProgressThread pg : toRemove) {\nsynchronized (LOCK) {\n      queuedThreads.remove(pg);\n    }\n  }\n}", "comment": "checks the currently queued tasks if there are ones which are no longer blocked by dependencies and executes them .", "label": "done"}
{"id": "72710", "raw_code": "public IElementType captureString(){\n  CharSequence buffer=getBuffer();\n  int currentPosition=getTokenEnd();\n  setTokenStart(currentPosition);\n  int bufferEnd=getBufferEnd();\n  char openQuote=buffer.charAt(currentPosition);\n  char closeQuote=RegexBlock.getQuoteCloseChar(openQuote);\n  boolean quotesDiffer=openQuote != closeQuote;\n  boolean isEscaped=false;\n  int quotesDepth=0;\n  currentPosition++;\n  while (currentPosition < bufferEnd) {\n    char currentChar=buffer.charAt(currentPosition);\n    if (!isEscaped && quotesDepth == 0 && currentChar == closeQuote) {\n      break;\n    }\n    if (!isEscaped && quotesDiffer) {\n      if (currentChar == openQuote) {\n        quotesDepth++;\n      }\n else       if (currentChar == closeQuote) {\n        quotesDepth--;\n      }\n    }\n    isEscaped=!isEscaped && currentChar == '\\\\';\n    currentPosition++;\n  }\n  if (currentPosition < bufferEnd) {\n    currentPosition++;\n  }\n  setTokenEnd(currentPosition);\n  PerlStringLexer stringLexer=getStringLexer();\n  popState();\n  preparsedTokensList.addAll(lexCurrentToken(stringLexer));\n  return getPreParsedToken();\n}", "comment": "captures string token from current position according to the current lexical state", "label": "done"}
{"id": "6576", "raw_code": "public static String toLocalizedInteger(long value){\n  return NUMBER_FORMAT0.format(value);\n}", "comment": "this static method converts the passed in number into a localizable representation of an integer , with digit grouping using locale dependant separators .", "label": "done"}
{"id": "60611", "raw_code": "public void init(PrivateKey key){\n  try {\n    if (signature != null) {\n      signature.initSign(key);\n    }\n else     if (cipher != null) {\n      cipher.init(Cipher.ENCRYPT_MODE,key);\n    }\n  }\n catch (  InvalidKeyException e) {\n    throw new AlertException(AlertProtocol.BAD_CERTIFICATE,new SSLException(\"init - invalid private key\",e));\n  }\n}", "comment": "initiate signature type by private key", "label": "done"}
{"id": "21397", "raw_code": "private Map<String,List<Zone>> selectZonesForInitiatorsAndPorts(NetworkLite network,Map<String,List<Zone>> wwnToZones,Map<String,StoragePort> initiatorPortsMap){\n  Map<String,List<Zone>> filteredMap=new HashMap<String,List<Zone>>();\n  Zone zone=null;\n  List<Zone> zones=null;\n  for (  String initiatorWwn : wwnToZones.keySet()) {\n    for (    String portWwn : initiatorPortsMap.keySet()) {\n      zone=_networkScheduler.selectExistingZoneForInitiatorPort(network,initiatorWwn,portWwn,wwnToZones.get(initiatorWwn));\n      if (zone != null) {\n        zones=filteredMap.get(initiatorWwn);\n        if (zones == null) {\n          zones=new ArrayList<>();\n          filteredMap.put(initiatorWwn,zones);\n        }\n        zones.add(zone);\n      }\n    }\n  }\n  return filteredMap;\n}", "comment": "given the map of all existing zones for a set on initiators and ports , this function selects the zones that should be used by vipr .", "label": "done"}
{"id": "67089", "raw_code": "public void addMethod(SootMethod m){\n  checkLevel(SIGNATURES);\n  if (m.isDeclared())   throw new RuntimeException(\"already declared: \" + m.getName());\n  if (subSigToMethods.get(m.getNumberedSubSignature()) != null) {\n    throw new RuntimeException(\"Attempting to add method \" + m.getSubSignature() + \" to class \"+ this+ \", but the class already has a method with that signature.\");\n  }\n  subSigToMethods.put(m.getNumberedSubSignature(),m);\n  methodList.add(m);\n  m.setDeclared(true);\n  m.setDeclaringClass(this);\n}", "comment": "adds the given method to this class .", "label": "done"}
{"id": "23109", "raw_code": "public void addTransaction(SIPServerTransaction serverTransaction) throws IOException {\n  if (isLoggingEnabled())   stackLogger.logDebug(\"added transaction \" + serverTransaction);\n  serverTransaction.map();\n  addTransactionHash(serverTransaction);\n}", "comment": "add a new server transaction to the set of existing transactions .", "label": "done"}
{"id": "66881", "raw_code": "public boolean containsPoly(SootMethod method){\n  return getMethod(method) != null;\n}", "comment": "search for polymorphic containment based on inheritance of receiver and arguments .", "label": "done"}
{"id": "65700", "raw_code": "private void selectAttributeSetInstance(){\n  int m_warehouse_id=getM_Warehouse_ID();\n  int m_product_id=getM_Product_ID();\n  if (m_product_id <= 0)   return;\n  MProduct product=MProduct.get(getCtx(),m_product_id);\n  MWarehouse wh=MWarehouse.get(getCtx(),m_warehouse_id);\n  String title=product.get_Translation(MProduct.COLUMNNAME_Name) + \" - \" + wh.get_Translation(MWarehouse.COLUMNNAME_Name);\n  PAttributeInstance pai=new PAttributeInstance(m_frame,title,m_warehouse_id,0,m_product_id,0);\n  if (pai.getM_AttributeSetInstance_ID() != -1) {\n    fAttrSetInstance_ID.setText(pai.getM_AttributeSetInstanceName());\n    fAttrSetInstance_ID.setValue(new Integer(pai.getM_AttributeSetInstance_ID()));\n  }\n else {\n    fAttrSetInstance_ID.setValue(Integer.valueOf(0));\n  }\n}", "comment": "filter by attribute set instance", "label": "done"}
{"id": "36189", "raw_code": "protected int read(InputStream inputStream,byte[] buffer,char divider) throws IOException {\n  int index=0;\n  do {\n    byte readByte=(byte)(0x000000FF & inputStream.read());\n    if (readByte == -1 || readByte == (byte)divider) {\n      return index;\n    }\n    buffer[index]=readByte;\n    index++;\n  }\n while (index < buffer.length);\n  return index;\n}", "comment": "reads bytes from a given file reader until either a certain character is read , the buffer is completely filled or the end of file is reached .", "label": "done"}
{"id": "79436", "raw_code": "public static java.util.Date toDate(String monthStr,String dayStr,String yearStr,String hourStr,String minuteStr,String secondStr){\n  int month, day, year, hour, minute, second;\n  try {\n    month=Integer.parseInt(monthStr);\n    day=Integer.parseInt(dayStr);\n    year=Integer.parseInt(yearStr);\n    hour=Integer.parseInt(hourStr);\n    minute=Integer.parseInt(minuteStr);\n    second=Integer.parseInt(secondStr);\n  }\n catch (  Exception e) {\n    return null;\n  }\n  return toDate(month,day,year,hour,minute,second);\n}", "comment": "makes a date from separate strings for month , day , year , hour , minute , and second .", "label": "done"}
{"id": "8953", "raw_code": "public void addLive(boolean live){\n  query.append(\" +live:\" + live);\n}", "comment": "adds + live to the query", "label": "done"}
{"id": "47995", "raw_code": "public boolean drawImage(Image img,AffineTransform xform,ImageObserver obs){\n  return mGraphics.drawImage(img,xform,obs);\n}", "comment": "draws an image , applying a transform from image space into user space before drawing .", "label": "done"}
{"id": "43973", "raw_code": "public static int findURISplitIndex(String uri){\n  int uriLength=uri.length();\n  int idx=uriLength - 1;\n  for (; idx >= 0; idx--) {\n    if (!TurtleUtil.isNameChar(uri.charAt(idx))) {\n      break;\n    }\n  }\n  idx++;\n  for (; idx < uriLength; idx++) {\n    if (TurtleUtil.isNameStartChar(uri.charAt(idx))) {\n      break;\n    }\n  }\n  if (!TurtleUtil.isNameEndChar(uri.charAt(uriLength - 1))) {\n    return -1;\n  }\n  if (idx > 0 && idx < uriLength) {\n    return idx;\n  }\n  return -1;\n}", "comment": "tries to find an index where the supplied uri can be split into a namespace and a local name that comply with the serialization constraints of the turtle format .", "label": "done"}
{"id": "41381", "raw_code": "public static String block(Stream<String> rows){\n  return block(rows.collect(joining(nl())));\n}", "comment": "indents the specified text , surrounds it with brackets and put the content on a separate line .", "label": "done"}
{"id": "13213", "raw_code": "protected void addContentSpecToElement(XMLElementDecl elementDecl){\n  if ((fDepth == 0 || (fDepth == 1 && elementDecl.type == XMLElementDecl.TYPE_MIXED)) && fNodeIndexStack != null) {\n    if (elementDecl.type == XMLElementDecl.TYPE_MIXED) {\n      int pcdata=addUniqueLeafNode(null);\n      if (fNodeIndexStack[0] == -1) {\n        fNodeIndexStack[0]=pcdata;\n      }\n else {\n        fNodeIndexStack[0]=addContentSpecNode(XMLContentSpec.CONTENTSPECNODE_CHOICE,pcdata,fNodeIndexStack[0]);\n      }\n    }\n    setContentSpecIndex(fCurrentElementIndex,fNodeIndexStack[fDepth]);\n  }\n}", "comment": "adds the content spec to the given element declaration .", "label": "done"}
{"id": "30830", "raw_code": "private boolean announce(String[] groups){\n  if (dataPackets == null || !lastLocator.equals(myLocator) || !Arrays.equals(lastGroups,groups)) {\n    List<DatagramPacket> packets=new ArrayList<DatagramPacket>();\n    Discovery disco;\n    try {\n      disco=getDiscovery(multicastAnnouncementConstraints.chooseProtocolVersion());\n    }\n catch (    DiscoveryProtocolException e) {\n      throw new AssertionError(e);\n    }\n    EncodeIterator ei=disco.encodeMulticastAnnouncement(new MulticastAnnouncement(announcementSeqNo++,myLocator.getHost(),myLocator.getPort(),groups,myServiceID),multicastAnnouncementConstraints.getMulticastMaxPacketSize(DEFAULT_MAX_PACKET_SIZE),multicastAnnouncementConstraints.getUnfulfilledConstraints());\n    while (ei.hasNext()) {\n      try {\n        packets.addAll(Arrays.asList(ei.next()));\n      }\n catch (      Exception e) {\n        logger.log((e instanceof UnsupportedConstraintException) ? Levels.HANDLED : Level.INFO,\"exception encoding multicast\" + \" announcement\",e);\n      }\n    }\n    lastLocator=myLocator;\n    lastGroups=groups;\n    dataPackets=packets.toArray(new DatagramPacket[packets.size()]);\n  }\n  try {\n    send(dataPackets);\n  }\n catch (  InterruptedIOException e) {\n    return false;\n  }\n  return true;\n}", "comment": "announce membership in the specified groups , and return false if interrupted , otherwise return true .", "label": "done"}
{"id": "85664", "raw_code": "public static int convertStringToTimeSeconds(String time){\n  int result=0;\n  if (time.endsWith(\"H\")) {\n    int hoursToAdd=Integer.valueOf(StringUtils.remove(time,'H'));\n    result=(60 * 60) * hoursToAdd;\n  }\n else   if (time.endsWith(\"M\")) {\n    int minsToAdd=Integer.valueOf(StringUtils.remove(time,'M'));\n    result=60 * minsToAdd;\n  }\n else   if (time.endsWith(\"S\")) {\n    int secsToAdd=Integer.valueOf(StringUtils.remove(time,'S'));\n    result=secsToAdd;\n  }\n  return result;\n}", "comment": "converts a string denoting an amount of time into seconds .", "label": "done"}
{"id": "80894", "raw_code": "private void addExprToTLA(TLAExpr expr){\n  Vector sv=expr.toStringVector();\n  Vector exprMapping=expr.toMappingVector();\n  int indent=tlacodeNextLine.length();\n  int nextLine=0;\n  if (indent != 0) {\n    MappingObject.shiftMappingVector(exprMapping,indent);\n    tlacodeNextLine=tlacodeNextLine + ((String)sv.elementAt(0));\n    mappingVectorNextLine.addAll((Vector)exprMapping.elementAt(0));\n    nextLine=1;\n    if (sv.size() > 1) {\n      endCurrentLineOfTLA();\n    }\n  }\n  if (sv.size() > 1) {\n    String spaces=NSpaces(indent);\n    while (nextLine < sv.size() - 1) {\n      tlacode.addElement(spaces + ((String)sv.elementAt(nextLine)));\n      mappingVector.addElement((Vector)exprMapping.elementAt(nextLine));\n      nextLine++;\n    }\n    tlacodeNextLine=spaces + ((String)sv.elementAt(nextLine));\n    mappingVectorNextLine=(Vector)exprMapping.elementAt(nextLine);\n  }\n else   if (indent == 0) {\n    tlacodeNextLine=tlacodeNextLine + ((String)sv.elementAt(0));\n    mappingVectorNextLine.addAll((Vector)exprMapping.elementAt(0));\n  }\n}", "comment": "adds the expression to tlacode / tlacodenextline and its mapping to mappingvector / mappingvectornextline .", "label": "done"}
{"id": "79061", "raw_code": "@Override public void incrementAccessCount(){\n  accessCount.incrementAndGet();\n}", "comment": "this method will increment the access count for a column by 1 whenever a column is getting used in query or incremental data load", "label": "done"}
{"id": "12411", "raw_code": "public static byte[] bitmapToByte(Bitmap b){\n  ByteArrayOutputStream o=new ByteArrayOutputStream();\n  b.compress(Bitmap.CompressFormat.PNG,100,o);\n  return o.toByteArray();\n}", "comment": "convert bitmap to byte array", "label": "done"}
{"id": "74049", "raw_code": "@Override public boolean addOutputSensor(String sensorName,int state){\n  OutputSensor outputSensor=new OutputSensor(sensorName);\n  if (!outputSensor.setState(state)) {\n    return false;\n  }\n  _outputSensorList.add(outputSensor);\n  return true;\n}", "comment": "add an output sensor to this route", "label": "done"}
{"id": "32831", "raw_code": "public static float readFloat(){\n  return scanner.nextFloat();\n}", "comment": "reads the next token from standard input , parses it as a float , and returns the float .", "label": "done"}
{"id": "22623", "raw_code": "public void delete() throws IOException {\n  close();\n  Utils.deleteContents(directory);\n}", "comment": "closes the cache and deletes all of its stored values .", "label": "done"}
{"id": "42685", "raw_code": "public static String toHumanReadableString(final String iso8601Duration){\n  String str=\"\";\n  if (iso8601Duration.matches(\"P\\\\d+[YMD].+\")) {\n    str=\"inf.\";\n  }\n else {\n    String hours=getHours(iso8601Duration), minutes=getMinutes(iso8601Duration), seconds=getSeconds(iso8601Duration);\n    if (hours != null) {\n      str=hours;\n      if (minutes != null && minutes.length() == 1) {\n        minutes=\"0\" + minutes;\n      }\n    }\n    if (str.isEmpty())     str=minutes;\n else     str+=\":\" + minutes;\n    if (str.isEmpty())     str=seconds;\n else     str+=\":\" + seconds;\n  }\n  return str;\n}", "comment": "converts the supplies iso 8601 duration into a human readable string .", "label": "done"}
{"id": "68874", "raw_code": "protected int match_bitap(String text,String pattern,int loc){\n  assert (Match_MaxBits == 0 || pattern.length() <= Match_MaxBits) : \"Pattern too long for this application.\";\n  Map<Character,Integer> s=match_alphabet(pattern);\n  double score_threshold=Match_Threshold;\n  int best_loc=text.indexOf(pattern,loc);\n  if (best_loc != -1) {\n    score_threshold=Math.min(match_bitapScore(0,best_loc,loc,pattern),score_threshold);\n    best_loc=text.lastIndexOf(pattern,loc + pattern.length());\n    if (best_loc != -1) {\n      score_threshold=Math.min(match_bitapScore(0,best_loc,loc,pattern),score_threshold);\n    }\n  }\n  int matchmask=1 << (pattern.length() - 1);\n  best_loc=-1;\n  int bin_min, bin_mid;\n  int bin_max=pattern.length() + text.length();\n  int[] last_rd=new int[0];\n  for (int d=0; d < pattern.length(); d++) {\n    bin_min=0;\n    bin_mid=bin_max;\n    while (bin_min < bin_mid) {\n      if (match_bitapScore(d,loc + bin_mid,loc,pattern) <= score_threshold) {\n        bin_min=bin_mid;\n      }\n else {\n        bin_max=bin_mid;\n      }\n      bin_mid=(bin_max - bin_min) / 2 + bin_min;\n    }\n    bin_max=bin_mid;\n    int start=Math.max(1,loc - bin_mid + 1);\n    int finish=Math.min(loc + bin_mid,text.length()) + pattern.length();\n    int[] rd=new int[finish + 2];\n    rd[finish + 1]=(1 << d) - 1;\n    for (int j=finish; j >= start; j--) {\n      int charMatch;\n      if (text.length() <= j - 1 || !s.containsKey(text.charAt(j - 1))) {\n        charMatch=0;\n      }\n else {\n        charMatch=s.get(text.charAt(j - 1));\n      }\n      if (d == 0) {\n        rd[j]=((rd[j + 1] << 1) | 1) & charMatch;\n      }\n else {\n        rd[j]=(((rd[j + 1] << 1) | 1) & charMatch) | (((last_rd[j + 1] | last_rd[j]) << 1) | 1) | last_rd[j + 1];\n      }\n      if ((rd[j] & matchmask) != 0) {\n        double score=match_bitapScore(d,j - 1,loc,pattern);\n        if (score <= score_threshold) {\n          score_threshold=score;\n          best_loc=j - 1;\n          if (best_loc > loc) {\n            start=Math.max(1,2 * loc - best_loc);\n          }\n else {\n            break;\n          }\n        }\n      }\n    }\n    if (match_bitapScore(d + 1,loc,loc,pattern) > score_threshold) {\n      break;\n    }\n    last_rd=rd;\n  }\n  return best_loc;\n}", "comment": "locate the best instance of ' pattern ' in ' text ' near ' loc ' using the bitap algorithm .", "label": "done"}
{"id": "14363", "raw_code": "private static void addItemsToList(int startIndex,int endIndex){\n  for (int i=startIndex; i < endIndex; i++) {\n    values.add(new Integer(i));\n  }\n}", "comment": "adds the items to the list .", "label": "done"}
{"id": "55016", "raw_code": "public void addIncludes(String[] definitions){\n  addStrings(INCLUDES,definitions);\n  addStrings(linker_more,INCLUDES,definitions);\n  newLinkerOptionsAfterCompile.add(INCLUDES);\n}", "comment": "adds a list of definitions to the existing list of definitions .", "label": "done"}
{"id": "86781", "raw_code": "public void tallyVariant(VcfHeader header,VcfRecord rec){\n  tallyVariant(rec,header.getSampleNames());\n}", "comment": "add the given vcf record to the statistics", "label": "done"}
{"id": "15405", "raw_code": "public void presentLicenses(boolean preAccept){\n  LicenseSet licenses=licenseModule.getRequiredLicenses();\n  if (preAccept) {\n    licenses.acceptAll();\n  }\n else {\n    for (    License license : licenses) {\n      if (license.isAccepted()) {\n        continue;\n      }\n      user.show(\"\");\n      user.show(license.getLicenseText());\n      String input=user.ask(\"prompt\");\n      if (input != null && YES.startsWith(input.toLowerCase())) {\n        license.accept();\n      }\n else {\n        license.reject();\n      }\n    }\n  }\n}", "comment": "present the licenses to the user - if the preaccept parameter is set , then simply display them through system . out .", "label": "done"}
{"id": "10877", "raw_code": "public void addGeoKey(XTIFFField geoKey){\n  geoKeyIndex.put(new Integer(geoKey.getTag()),geoKey);\n  hasGeoKeys=true;\n}", "comment": "add an existing geokey to the directory .", "label": "done"}
{"id": "41815", "raw_code": "public void reclaimViews(List<View> views){\n  int childCount=getChildCount();\n  RecyclerListener listener=mRecycler.mRecyclerListener;\n  for (int i=0; i < childCount; i++) {\n    View child=getChildAt(i);\n    TwoWayAbsListView.LayoutParams lp=(TwoWayAbsListView.LayoutParams)child.getLayoutParams();\n    if (lp != null && mRecycler.shouldRecycleViewType(lp.viewType)) {\n      views.add(child);\n      if (listener != null) {\n        listener.onMovedToScrapHeap(child);\n      }\n    }\n  }\n  mRecycler.reclaimScrapViews(views);\n  removeAllViewsInLayout();\n}", "comment": "move all views ( excluding headers and footers ) held by this twowayabslistview into the supplied list .", "label": "done"}
{"id": "39591", "raw_code": "public static void transfer(InputStream in,OutputStream out,int bufferSize) throws IOException {\n  byte[] buffer=new byte[bufferSize];\n  int bytesRead;\n  while ((bytesRead=in.read(buffer)) != -1) {\n    out.write(buffer,0,bytesRead);\n  }\n}", "comment": "copies data from an input stream to an output stream using a buffer of specified size .", "label": "done"}
{"id": "44852", "raw_code": "private JCheckBox addCheckbox(String text,Container container){\n  JCheckBox checkbox=new JCheckBox(text);\n  checkbox.setAlignmentX(Component.LEFT_ALIGNMENT);\n  checkbox.setBorder(BorderFactory.createEmptyBorder(0,0,10,5));\n  container.add(checkbox);\n  return checkbox;\n}", "comment": "adds a preconfigured jcheckbox to the specified container , setting its alignment constraint to left and adding an empty padding border .", "label": "done"}
{"id": "19628", "raw_code": "public synchronized int add(IAudioProcessor processor){\n  processors.add(processor);\n  buildFinalProcessor();\n  return processors.indexOf(processor);\n}", "comment": "adds a processor to the internal processor queue .", "label": "done"}
{"id": "40177", "raw_code": "public ScriptBuilder data(int index,byte[] data){\n  byte[] copy=Arrays.copyOf(data,data.length);\n  int opcode;\n  if (data.length == 0) {\n    opcode=OP_0;\n  }\n else   if (data.length == 1) {\n    byte b=data[0];\n    if (b >= 1 && b <= 16)     opcode=Script.encodeToOpN(b);\n else     opcode=1;\n  }\n else   if (data.length < OP_PUSHDATA1) {\n    opcode=data.length;\n  }\n else   if (data.length < 256) {\n    opcode=OP_PUSHDATA1;\n  }\n else   if (data.length < 65536) {\n    opcode=OP_PUSHDATA2;\n  }\n else {\n    throw new RuntimeException(\"Unimplemented\");\n  }\n  return addChunk(index,new ScriptChunk(opcode,copy));\n}", "comment": "adds a copy of the given byte array as a data element ( i . e . pushdata ) at the given index in the program .", "label": "done"}
{"id": "14643", "raw_code": "public void initialize(Map configParams){\n  String delimiterConfig=(String)configParams.get(PolicyConfig.RESOURCE_COMPARATOR_DELIMITER);\n  if (delimiterConfig != null) {\n    this.delimiter=delimiterConfig;\n  }\n  String caseConfig=(String)configParams.get(PolicyConfig.RESOURCE_COMPARATOR_CASE_SENSITIVE);\n  if (caseConfig != null) {\n    if (caseConfig.equals(\"true\")) {\n      this.caseSensitive=true;\n    }\n else     if (caseConfig.equals(\"false\")) {\n      this.caseSensitive=false;\n    }\n else {\n      this.caseSensitive=true;\n    }\n  }\n  String wildcardConfig=(String)configParams.get(PolicyConfig.RESOURCE_COMPARATOR_WILDCARD);\n  if (wildcardConfig != null) {\n    this.wildcard=wildcardConfig;\n  }\n  String oneLevelWildcardConfig=(String)configParams.get(PolicyConfig.RESOURCE_COMPARATOR_ONE_LEVEL_WILDCARD);\n  if (oneLevelWildcardConfig != null) {\n    this.oneLevelWildcard=oneLevelWildcardConfig;\n  }\n  if (debug.messageEnabled()) {\n    debug.message(\"PrefixResourceName:initialize():\" + \" delimiter = \" + delimiter + \" wildcard = \"+ wildcard+ \" oneLevelWildcard = \"+ oneLevelWildcard+ \" case = \"+ caseConfig);\n  }\n  oneLevelWildcardLength=oneLevelWildcard.length();\n  wildcardLength=wildcard.length();\n  if (oneLevelWildcard.indexOf(wildcard) != -1) {\n    wildcardEmbedded=true;\n  }\n else {\n    wildcardEmbedded=false;\n  }\n  if (wildcard.indexOf(oneLevelWildcard) != -1) {\n    oneLevelWildcardEmbedded=true;\n  }\n else {\n    oneLevelWildcardEmbedded=false;\n  }\n  if (debug.messageEnabled()) {\n    debug.message(\"wildcardEmbedded,oneLevelWildcardEmbedded\" + wildcardEmbedded + \",\"+ oneLevelWildcardEmbedded);\n  }\n  return;\n}", "comment": "initializes the resource name with configuration information , usally set by the administrators .", "label": "done"}
{"id": "59706", "raw_code": "private int parseLinkLabel(){\n  String m=match(LINK_LABEL);\n  return m == null ? 0 : m.length();\n}", "comment": "attempt to parse a link label , returning number of characters parsed .", "label": "done"}
{"id": "667", "raw_code": "public void addForce(Force f){\n  if (f.isItemForce()) {\n    if (iforces.length == iflen) {\n      Force[] newf=new Force[iflen + 10];\n      System.arraycopy(iforces,0,newf,0,iforces.length);\n      iforces=newf;\n    }\n    iforces[iflen++]=f;\n  }\n  if (f.isSpringForce()) {\n    if (sforces.length == sflen) {\n      Force[] newf=new Force[sflen + 10];\n      System.arraycopy(sforces,0,newf,0,sforces.length);\n      sforces=newf;\n    }\n    sforces[sflen++]=f;\n  }\n}", "comment": "add a new force function to the simulator .", "label": "done"}
{"id": "56259", "raw_code": "public static String[] commaDelimitedListToStringArray(String str){\n  return delimitedListToStringArray(str,\",\");\n}", "comment": "convert a csv list into an array of strings .", "label": "done"}
{"id": "25909", "raw_code": "@Override public byte[] readByteArray(String filePath,long offset,int length){\n  FileChannel fileChannel=updateCache(filePath);\n  ByteBuffer byteBffer=read(fileChannel,length,offset);\n  return byteBffer.array();\n}", "comment": "this method will be used to read the byte array from file based on offset and length ( number of bytes ) need to read", "label": "done"}
{"id": "71977", "raw_code": "@Override public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {\n  if (requestID == null && localName.equals(\"batchRequest\")) {\n    requestID=attributes.getValue(\"requestID\");\n  }\n  super.startElement(uri,localName,qName,attributes);\n}", "comment": "this function fetches the requestid value of the batchrequest xml element and call the default implementation ( super ) .", "label": "done"}
{"id": "25281", "raw_code": "public void stop(int timeout) throws InterruptedException {\n  if (!isclosed.compareAndSet(false,true)) {\n    return;\n  }\n  List<WebSocket> socketsToClose=null;\nsynchronized (connections) {\n    socketsToClose=new ArrayList<WebSocket>(connections);\n  }\n  for (  WebSocket ws : socketsToClose) {\n    ws.close(CloseFrame.GOING_AWAY);\n  }\nsynchronized (this) {\n    if (selectorthread != null) {\n      if (Thread.currentThread() != selectorthread) {\n      }\n      if (selectorthread != Thread.currentThread()) {\n        if (socketsToClose.size() > 0)         selectorthread.join(timeout);\n        selectorthread.interrupt();\n        selectorthread.join();\n      }\n    }\n  }\n}", "comment": "closes all connected clients sockets , then closes the underlying serversocketchannel , effectively killing the server socket selectorthread , freeing the port the server was bound to and stops all internal workerthreads .", "label": "done"}
{"id": "7660", "raw_code": "protected void calculateItemWidth(CategoryPlot plot,Rectangle2D dataArea,int rendererIndex,CategoryItemRendererState state){\n  CategoryAxis domainAxis=getDomainAxis(plot,rendererIndex);\n  CategoryDataset dataset=plot.getDataset(rendererIndex);\n  if (dataset != null) {\n    int columns=dataset.getColumnCount();\n    int rows=state.getVisibleSeriesCount() >= 0 ? state.getVisibleSeriesCount() : dataset.getRowCount();\n    double space=0.0;\n    PlotOrientation orientation=plot.getOrientation();\n    if (orientation == PlotOrientation.HORIZONTAL) {\n      space=dataArea.getHeight();\n    }\n else     if (orientation == PlotOrientation.VERTICAL) {\n      space=dataArea.getWidth();\n    }\n    double maxWidth=space * getMaximumItemWidth();\n    double categoryMargin=0.0;\n    double currentItemMargin=0.0;\n    if (columns > 1) {\n      categoryMargin=domainAxis.getCategoryMargin();\n    }\n    if (rows > 1) {\n      currentItemMargin=getItemMargin();\n    }\n    double used=space * (1 - domainAxis.getLowerMargin() - domainAxis.getUpperMargin()- categoryMargin- currentItemMargin);\n    if ((rows * columns) > 0) {\n      state.setBarWidth(Math.min(used / (rows * columns),maxWidth));\n    }\n else {\n      state.setBarWidth(Math.min(used,maxWidth));\n    }\n  }\n}", "comment": "calculates the bar width and stores it in the renderer state .", "label": "done"}
{"id": "190", "raw_code": "void putChannel(final StoredClientChannel channel){\n  putChannel(channel,true);\n}", "comment": "adds the given channel to this set of stored states , broadcasting the contract and refund transactions when the channel expires and notifies the wallet of an update to this wallet extension", "label": "done"}
{"id": "83759", "raw_code": "@SuppressWarnings(\"ResultOfMethodCallIgnored\") public static void pipeInputToOutputStream(InputStream in,File fileOut,boolean ignoreErrors) throws IOException {\n  if (fileOut == null) {\n    logger.error(\"The output filename doesn't exist or is invalid\");\n    if (!ignoreErrors) {\n      throw new IOException(\"The output filename doesn't exist or is invalid\");\n    }\n  }\n else {\n    File parent=fileOut.getParentFile();\n    if (parent != null && !parent.exists()) {\n      parent.mkdirs();\n    }\n    OutputStream fileStream=null;\n    try {\n      fileStream=new FileOutputStream(fileOut);\n      pipeInputToOutputStream(in,fileStream,true,ignoreErrors);\n    }\n catch (    IOException e) {\n      if (fileStream != null) {\n        try {\n          fileStream.close();\n        }\n catch (        IOException ex) {\n          logger.error(\"Cannot close stream - {}\",ex.getMessage());\n        }\n      }\n      if (!ignoreErrors) {\n        throw e;\n      }\n    }\n  }\n}", "comment": "convenient way of sending data from an input stream to an output file in the most efficient way possible", "label": "done"}
{"id": "67924", "raw_code": "public E take() throws InterruptedException {\n  final ReentrantLock lock=this.lock;\n  lock.lockInterruptibly();\n  long t=now();\n  TenantQueue.Item item=null;\n  try {\n    for (; ; ) {\n      TenantQueue q=nextQueue(t);\n      if (q == null)       available.await();\n else {\n        long delay=q.next - t;\n        if (delay <= 0) {\n          item=q.poll(t);\n          return item == null ? null : item.element;\n        }\n else         if (leader != null)         available.await();\n else {\n          Thread thisThread=Thread.currentThread();\n          leader=thisThread;\n          try {\n            available.awaitNanos(delay);\n          }\n  finally {\n            if (leader == thisThread)             leader=null;\n          }\n        }\n      }\n      t=System.nanoTime();\n    }\n  }\n  finally {\n    if (leader == null && hasNext())     available.signal();\n    lock.unlock();\n    done(item,t);\n  }\n}", "comment": "retrieves and removes the head of this queue , waiting if necessary until an element with an expired delay is available on this queue .", "label": "done"}
{"id": "30973", "raw_code": "@Override public void channelClosed(ChannelHandlerContext channelHandlerContext,ChannelStateEvent channelStateEvent) throws Exception {\n  curr_conns.decrementAndGet();\n  channelGroup.remove(channelHandlerContext.getChannel());\n}", "comment": "on close we manage some statistics , and remove this connection from the channel group .", "label": "done"}
{"id": "74950", "raw_code": "private static void configureHeadLessSimulation(){\n  System.setProperty(\"java.awt.headless\",\"true\");\n  GAMA.setHeadLessMode();\n}", "comment": "load in headless mode a specified model and create an experiment", "label": "done"}
{"id": "40614", "raw_code": "public byte[] remove(QueueEvent event) throws KeeperException, InterruptedException {\n  TimerContext time=stats.time(dir + \"_remove_event\");\n  try {\n    String path=event.getId();\n    String responsePath=dir + \"/\" + response_prefix+ path.substring(path.lastIndexOf(\"-\") + 1);\n    if (zookeeper.exists(responsePath,true)) {\n      zookeeper.setData(responsePath,event.getBytes(),true);\n    }\n    byte[] data=zookeeper.getData(path,null,null,true);\n    zookeeper.delete(path,-1,true);\n    return data;\n  }\n  finally {\n    time.stop();\n  }\n}", "comment": "remove the event and save the response into the other path .", "label": "done"}
{"id": "63000", "raw_code": "static public void addAll(List<String> list,String[] array){\n  for (  String item : array)   list.add(item);\n}", "comment": "adds all items in the specific array to the specific list .", "label": "done"}
{"id": "14253", "raw_code": "private String partiallyEscapeAssertionValue(String assertionValue){\n  StringBuilder sb=new StringBuilder(assertionValue.length());\n  for (int j=0; j < assertionValue.length(); j++) {\n    char c=assertionValue.charAt(j);\n    if (c == '*') {\n      sb.append(c);\n    }\n else {\n      sb.append(Filter.escapeAssertionValue(String.valueOf(c)));\n    }\n  }\n  return sb.toString();\n}", "comment": "escapes the provided assertion value according to the ldap standard .", "label": "done"}
{"id": "54584", "raw_code": "protected boolean filterLeftoverView(ViewGroup parent,int childIndex){\n  parent.removeViewAt(childIndex);\n  return true;\n}", "comment": "filter the child view at index and remove it if appropriate .", "label": "done"}
{"id": "46212", "raw_code": "synchronized boolean release(){\n  d(\"release()\");\n  if (state == BUSY) {\n    state=IDLE;\n    idleSince=System.currentTimeMillis();\n    return true;\n  }\n else {\n    return false;\n  }\n}", "comment": "changes the state of a connectiondesc from busy to idle and records the current time so that we will know how long it has been idle .", "label": "done"}
{"id": "69424", "raw_code": "private static String partitionSpecToName(Map<String,String> spec){\n  StringBuilder sb=new StringBuilder();\n  for (  Map.Entry<String,String> entry : spec.entrySet()) {\n    if (sb.length() != 0) {\n      sb.append(\"/\");\n    }\n    sb.append(entry.getKey() + \"=\" + entry.getValue());\n  }\n  return sb.toString();\n}", "comment": "converts a map of partition key - value pairs to a name .", "label": "done"}
{"id": "2748", "raw_code": "public static InputStream toInputStream(CharSequence input,Charset encoding){\n  return toInputStream(input.toString(),encoding);\n}", "comment": "convert the specified charsequence to an input stream , encoded as bytes using the specified character encoding .", "label": "done"}
{"id": "25755", "raw_code": "@Modifying @Transactional public void deleteCheque(@PathVariable Long chequeID){\n  chequeRepository.delete(chequeID);\n  photoRepository.deleteByChequeId(chequeID.toString());\n}", "comment": "method deletecheque remove cheque from db by id", "label": "done"}
{"id": "52066", "raw_code": "public static synchronized double partialCorrelation(TetradMatrix submatrix){\n  try {\n    TetradMatrix inverse=submatrix.inverse();\n    double a=-1.0 * inverse.get(0,1);\n    double v0=inverse.get(0,0);\n    double v1=inverse.get(1,1);\n    double b=Math.sqrt(v0 * v1);\n    return a / b;\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    return Double.NaN;\n  }\n}", "comment": "assumes that the given covariance matrix was extracted in such a way that the order of the variables ( in either direction ) is x , y , z1 , . . . , zn , where the partial correlation one wants is correlation ( x , y | z1 , . . . , zn ) .", "label": "done"}
{"id": "63697", "raw_code": "public void addColumn(String name,String expr){\n  Expression ex=ExpressionParser.parse(expr);\n  Throwable t=ExpressionParser.getError();\n  if (t != null) {\n    throw new RuntimeException(t);\n  }\n else {\n    addColumn(name,ex);\n  }\n}", "comment": "add a derived column to this table , using an expression instance to dynamically calculate the column data values .", "label": "done"}
{"id": "85129", "raw_code": "public PdfPage addAnnotation(PdfAnnotation annotation){\n  return addAnnotation(-1,annotation,true);\n}", "comment": "adds specified annotation to the end of annotations array and tagged it .", "label": "done"}
{"id": "83680", "raw_code": "private boolean journalRebuildRequired(){\n  final int REDUNDANT_OP_COMPACT_THRESHOLD=2000;\n  return redundantOpCount >= REDUNDANT_OP_COMPACT_THRESHOLD && redundantOpCount >= lruEntries.size();\n}", "comment": "we only rebuild the journal when it will halve the size of the journal and eliminate at least 2000 ops .", "label": "done"}
{"id": "76217", "raw_code": "private Map<TestCase,Set<TestFitnessFunction>> initializeCoverageMapFromTests(List<TestCase> tests){\n  Map<TestCase,Set<TestFitnessFunction>> testToGoals=new LinkedHashMap<>();\n  for (  TestCase test : tests) {\n    testToGoals.put(test,filterSupportedGoals(new LinkedHashSet<>(test.getCoveredGoals())));\n  }\n  return testToGoals;\n}", "comment": "builds the name map based on coverage goal stored as covered in each of the tests", "label": "done"}
{"id": "61079", "raw_code": "public static CipherParameters makePBEMacParameters(BCPBEKey pbeKey,AlgorithmParameterSpec spec){\n  if ((spec == null) || !(spec instanceof PBEParameterSpec)) {\n    throw new IllegalArgumentException(\"Need a PBEParameter spec with a PBE key.\");\n  }\n  PBEParameterSpec pbeParam=(PBEParameterSpec)spec;\n  PBEParametersGenerator generator=makePBEGenerator(pbeKey.getType(),pbeKey.getDigest());\n  byte[] key=pbeKey.getEncoded();\n  CipherParameters param;\n  if (pbeKey.shouldTryWrongPKCS12()) {\n    key=new byte[2];\n  }\n  generator.init(key,pbeParam.getSalt(),pbeParam.getIterationCount());\n  param=generator.generateDerivedMacParameters(pbeKey.getKeySize());\n  for (int i=0; i != key.length; i++) {\n    key[i]=0;\n  }\n  return param;\n}", "comment": "generate a pbe based key suitable for a mac algorithm , the key size is chosen according the mac size , or the hashing algorithm , whichever is greater .", "label": "done"}
{"id": "56263", "raw_code": "public final void addValidationError(String error){\n  validationErrors.add(error);\n}", "comment": "add a new validation error to the accumulating validation errors", "label": "done"}
{"id": "81237", "raw_code": "public void start(String json){\n  guidedTourSteps.clear();\n  GuidedTourConfiguration configuration=dtoFactory.createDtoFromJson(json,GuidedTourConfiguration.class);\n  log.setDebugMode(configuration.getDebugMode());\n  this.guidedTourSteps=configuration.getSteps();\n  this.tourName=configuration.getName();\n  if (this.tourName == null || tourName.isEmpty()) {\n    tourName=\"unamed\";\n  }\n  this.hasWelcomeStep=configuration.getHasWelcomeStep();\n  startTour();\n}", "comment": "loads the given json data and start the tour", "label": "done"}
{"id": "44436", "raw_code": "public static MaildirMessageName createUniqueName(MaildirFolder parentFolder,long size){\n  String timestamp=String.valueOf(System.currentTimeMillis());\n  timestamp=timestamp.substring(0,timestamp.length() - 3);\n  StringBuilder uniquePart=new StringBuilder();\n  uniquePart.append(Integer.toHexString(random.nextInt()));\n  uniquePart.append(timestamp.substring(timestamp.length() - 3));\n  uniquePart.append(processName);\n  uniquePart.append(getNextDeliveryNumber());\n  String sizeString=\",S=\" + String.valueOf(size);\n  String fullName=timestamp + \".\" + uniquePart.toString()+ \".\"+ currentHostname+ sizeString;\n  MaildirMessageName uniqueName=new MaildirMessageName(parentFolder,fullName);\n  uniqueName.timestamp=timestamp;\n  uniqueName.uniqueString=uniquePart.toString();\n  uniqueName.hostname=currentHostname;\n  uniqueName.sizeString=sizeString;\n  uniqueName.isSplit=true;\n  uniqueName.size=size;\n  return uniqueName;\n}", "comment": "create a name for a message according to the following elements are used : \" a unique name has three pieces , separated by dots .", "label": "done"}
{"id": "42296", "raw_code": "private void adjustBCIndex(Instruction barrier){\n  NormalMethod source=barrier.position().method;\n  if (source.isForOsrSpecialization()) {\n    barrier.adjustBytecodeIndex(-source.getOsrPrologueLength());\n  }\n}", "comment": "the osrbarrier instruction is not in ir , so the bc index was not adjusted in osr _ adjustbcindex .", "label": "done"}
{"id": "51659", "raw_code": "public static Map<String,String> parseKeyAndValueToMap(String source,boolean ignoreSpace){\n  return parseKeyAndValueToMap(source,DEFAULT_KEY_AND_VALUE_SEPARATOR,DEFAULT_KEY_AND_VALUE_PAIR_SEPARATOR,ignoreSpace);\n}", "comment": "parse key - value pairs to map , ignore empty key", "label": "done"}
{"id": "78100", "raw_code": "@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){\n  super.onSizeChanged(w,h,oldw,oldh);\n  setupBounds(w,h);\n  setupPaints();\n  invalidate();\n}", "comment": "use onsizechanged instead of onattachedtowindow to get the dimensions of the view , because this method is called after measuring the dimensions of match _ parent & wrap _ content .", "label": "done"}
{"id": "64430", "raw_code": "private void needNewBuffer(int newcount){\n  if (currentBufferIndex < buffers.size() - 1) {\n    filledBufferSum+=currentBuffer.length;\n    currentBufferIndex++;\n    currentBuffer=buffers.get(currentBufferIndex);\n  }\n else {\n    int newBufferSize;\n    if (currentBuffer == null) {\n      newBufferSize=newcount;\n      filledBufferSum=0;\n    }\n else {\n      newBufferSize=Math.max(currentBuffer.length << 1,newcount - filledBufferSum);\n      filledBufferSum+=currentBuffer.length;\n    }\n    currentBufferIndex++;\n    currentBuffer=new byte[newBufferSize];\n    buffers.add(currentBuffer);\n  }\n}", "comment": "makes a new buffer available either by allocating a new one or re - cycling an existing one .", "label": "done"}
{"id": "61116", "raw_code": "public int addPadding(byte[] in,int inOff){\n  byte code=(byte)(in.length - inOff);\n  while (inOff < (in.length - 1)) {\n    in[inOff]=(byte)random.nextInt();\n    inOff++;\n  }\n  in[inOff]=code;\n  return code;\n}", "comment": "add the pad bytes to the passed in block , returning the number of bytes added .", "label": "done"}
{"id": "68787", "raw_code": "public void addCommands(PDFPage page,Matrix extra){\nsynchronized (commands) {\n    addPush();\n    if (extra != null) {\n      addXform(extra);\n    }\n    commands.addAll(page.getCommands());\n    addPop();\n  }\n  updateImages();\n}", "comment": "add a collection of commands to the page list .", "label": "done"}
{"id": "50483", "raw_code": "public void addLast(StatementSequence statements){\n  if (statements != null) {\n    sequence.addAll(statements.sequence);\n  }\n}", "comment": "adds a sequence of statements to the end of this sequence when the sequence object is not null , otherwise does nothing .", "label": "done"}
{"id": "74063", "raw_code": "public static float roundDecimal(float value){\n  return roundDecimal(value,Math.log10(INT_PRECISION));\n}", "comment": "static method to round a float value to the number of decimal places defined by decimal _ places .", "label": "done"}
{"id": "36272", "raw_code": "private String dateToString(Date input){\n  if (input == null) {\n    return null;\n  }\n else {\n    return input.toString();\n  }\n}", "comment": "converts the input to a string with special missing value handling", "label": "done"}
{"id": "16560", "raw_code": "private static int componentSize(Component component,FormSpec formSpec,int cellSize,FormLayout.Measure minMeasure,FormLayout.Measure prefMeasure){\n  if (formSpec == null) {\n    return prefMeasure.sizeOf(component);\n  }\n else   if (formSpec.getSize() == Sizes.MINIMUM) {\n    return minMeasure.sizeOf(component);\n  }\n else   if (formSpec.getSize() == Sizes.PREFERRED) {\n    return prefMeasure.sizeOf(component);\n  }\n else {\n    return Math.min(cellSize,prefMeasure.sizeOf(component));\n  }\n}", "comment": "computes and returns the pixel size of the given component using the given form specification , measures , and cell size .", "label": "done"}
{"id": "76915", "raw_code": "protected synchronized void start(long curPrimaryGen) throws IOException {\n  if (state.equals(\"init\") == false) {\n    throw new IllegalStateException(\"already started\");\n  }\n  message(\"top: now start\");\n  try {\n    String segmentsFileName=SegmentInfos.getLastCommitSegmentsFileName(dir);\n    long maxPendingGen=-1;\n    for (    String fileName : dir.listAll()) {\n      if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n        long gen=Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length() + 1),Character.MAX_RADIX);\n        if (gen > maxPendingGen) {\n          maxPendingGen=gen;\n        }\n      }\n    }\n    SegmentInfos infos;\n    if (segmentsFileName == null) {\n      infos=new SegmentInfos();\n      message(\"top: init: no segments in index\");\n    }\n else {\n      message(\"top: init: read existing segments commit \" + segmentsFileName);\n      infos=SegmentInfos.readCommit(dir,segmentsFileName);\n      message(\"top: init: segments: \" + infos.toString() + \" version=\"+ infos.getVersion());\n      Collection<String> indexFiles=infos.files(false);\n      lastCommitFiles.add(segmentsFileName);\n      lastCommitFiles.addAll(indexFiles);\n      deleter.incRef(lastCommitFiles);\n      lastNRTFiles.addAll(indexFiles);\n      deleter.incRef(lastNRTFiles);\n      message(\"top: commitFiles=\" + lastCommitFiles);\n      message(\"top: nrtFiles=\" + lastNRTFiles);\n    }\n    message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n    deleter.deleteUnknownFiles(segmentsFileName);\n    message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n    String s=infos.getUserData().get(PRIMARY_GEN_KEY);\n    long myPrimaryGen;\n    if (s == null) {\n      assert infos.size() == 0;\n      myPrimaryGen=-1;\n    }\n else {\n      myPrimaryGen=Long.parseLong(s);\n    }\n    message(\"top: myPrimaryGen=\" + myPrimaryGen);\n    boolean doCommit;\n    if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n      assert myPrimaryGen < curPrimaryGen;\n      final long initSyncStartNS=System.nanoTime();\n      message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen + \" vs curPrimaryGen=\"+ curPrimaryGen+ \"; sync now before mgr init\");\n      CopyJob job=null;\n      message(\"top: now delete starting commit point \" + segmentsFileName);\n      assert deleter.getRefCount(segmentsFileName) == 1;\n      deleter.decRef(Collections.singleton(segmentsFileName));\n      if (dir instanceof FSDirectory && ((FSDirectory)dir).checkPendingDeletions()) {\n        throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n      }\n      boolean didRemove=lastCommitFiles.remove(segmentsFileName);\n      assert didRemove;\n      while (true) {\n        job=newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\"+ infos.getVersion(),null,null,true,null);\n        job.start();\n        message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n        try {\n          job.runBlocking();\n          job.finish();\n          break;\n        }\n catch (        IOException ioe) {\n          job.cancel(\"startup failed\",ioe);\n          if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n            message(\"top: failed to copy: \" + ioe + \"; retrying\");\n          }\n else {\n            throw ioe;\n          }\n        }\n      }\n      lastPrimaryGen=job.getCopyState().primaryGen;\n      byte[] infosBytes=job.getCopyState().infosBytes;\n      SegmentInfos syncInfos=SegmentInfos.readCommit(dir,new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\",job.getCopyState().infosBytes)),job.getCopyState().gen);\n      syncInfos.updateGeneration(infos);\n      infos=syncInfos;\n      assert infos.getVersion() == job.getCopyState().version;\n      message(\"  version=\" + infos.getVersion() + \" segments=\"+ infos.toString());\n      message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n      deleter.incRef(job.getFileNames());\n      message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n      deleter.decRef(lastNRTFiles);\n      lastNRTFiles.clear();\n      lastNRTFiles.addAll(job.getFileNames());\n      message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n      lastFileMetaData=job.getCopyState().files;\n      message(String.format(Locale.ROOT,\"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",id,(System.nanoTime() - initSyncStartNS) / 1000000000.0,bytesToString(job.getTotalBytesCopied()),job.getCopyState().version));\n      doCommit=true;\n    }\n else {\n      doCommit=false;\n      lastPrimaryGen=curPrimaryGen;\n      message(\"top: same primary as before\");\n    }\n    if (infos.getGeneration() < maxPendingGen) {\n      message(\"top: move infos generation from \" + infos.getGeneration() + \" to \"+ maxPendingGen);\n      infos.setNextWriteGeneration(maxPendingGen);\n    }\n    sendNewReplica();\n    mgr=new SegmentInfosSearcherManager(dir,this,infos,searcherFactory);\n    IndexSearcher searcher=mgr.acquire();\n    try {\n      int hitCount=searcher.count(new TermQuery(new Term(\"marker\",\"marker\")));\n      message(\"top: marker count=\" + hitCount + \" version=\"+ ((DirectoryReader)searcher.getIndexReader()).getVersion());\n    }\n  finally {\n      mgr.release(searcher);\n    }\n    if (doCommit) {\n      commit();\n    }\n    message(\"top: done start\");\n    state=\"idle\";\n  }\n catch (  Throwable t) {\n    if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n      message(\"exc on start:\");\n      t.printStackTrace(printStream);\n    }\n else {\n      dir.close();\n    }\n    IOUtils.reThrow(t);\n  }\n}", "comment": "start up this replica , which possibly requires heavy copying of files from the primary node , if we were down for a long time", "label": "done"}
{"id": "17487", "raw_code": "public void appendDataTo(StringBuilder stringBuilder){\n  stringBuilder.append(buffer);\n}", "comment": "appends this node ' s text content to the given builder .", "label": "done"}
{"id": "64137", "raw_code": "public static void write(File file,CharSequence data) throws IOException {\n  write(file,data,Charset.defaultCharset(),false);\n}", "comment": "writes a charsequence to a file creating the file if it does not exist using the default encoding for the vm .", "label": "done"}
{"id": "25607", "raw_code": "public static String convertClassNameToResourcePath(String className){\n  Assert.notNull(className,\"Class name must not be null\");\n  return className.replace('.','/');\n}", "comment": "convert a \" . \" - based fully qualified class name to a \" / \" - based resource path .", "label": "done"}
{"id": "43016", "raw_code": "private int addToPopulation(Solution solution){\n  int id=nextFreeId();\n  solutions.put(id,solution);\n  return id;\n}", "comment": "adds the specified solution to the population , returning its assigned identifier .", "label": "done"}
{"id": "12306", "raw_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n  if (bb.limit() == 1 && (bb.get(0) & 0xFF) < 0x80) {\n    sb.append((char)bb.get(0));\n    return i + 2;\n  }\n else {\n    CharBuffer cb=UTF_8_CHARSET.decode(bb);\n    sb.append(cb.toString());\n    return i + bb.limit() * 3 - 1;\n  }\n}", "comment": "decodes octets to characters using the utf - 8 decoding and appends the characters to a stringbuffer .", "label": "done"}
{"id": "72448", "raw_code": "public ArrayFieldVector(FieldVector<T> v1,T[] v2) throws NullArgumentException {\n  MathUtils.checkNotNull(v1);\n  MathUtils.checkNotNull(v2);\n  field=v1.getField();\n  final T[] v1Data=(v1 instanceof ArrayFieldVector) ? ((ArrayFieldVector<T>)v1).data : v1.toArray();\n  data=MathArrays.buildArray(field,v1Data.length + v2.length);\n  System.arraycopy(v1Data,0,data,0,v1Data.length);\n  System.arraycopy(v2,0,data,v1Data.length,v2.length);\n}", "comment": "construct a vector by appending one vector to another vector .", "label": "done"}
{"id": "8623", "raw_code": "public User toEntity(UserDTO dto){\n  return toEntity(dto,1);\n}", "comment": "converts the passed dto to a user .", "label": "done"}
{"id": "71629", "raw_code": "protected void writeExternalForeignKeyDropStmt(Table table,ForeignKey foreignKey,StringBuilder ddl){\n  writeTableAlterStmt(table,ddl);\n  ddl.append(\"DROP CONSTRAINT \");\n  printIdentifier(getForeignKeyName(table,foreignKey),ddl);\n  printEndOfStatement(ddl);\n}", "comment": "generates the statement to drop a foreignkey constraint from the database using an alter table statement .", "label": "done"}
{"id": "60270", "raw_code": "@NotNull protected VirtualFile[] collectAffectedFiles(@NotNull Project project,@NotNull VirtualFile[] files){\n  List<VirtualFile> affectedFiles=new ArrayList<VirtualFile>(files.length);\n  ProjectLevelVcsManager projectLevelVcsManager=ProjectLevelVcsManager.getInstance(project);\n  for (  VirtualFile file : files) {\n    if (!file.isDirectory() && projectLevelVcsManager.getVcsFor(file) instanceof GitVcs) {\n      affectedFiles.add(file);\n    }\n else     if (file.isDirectory() && isRecursive()) {\n      addChildren(project,affectedFiles,file);\n    }\n  }\n  return VfsUtilCore.toVirtualFileArray(affectedFiles);\n}", "comment": "given a list of action - target files , returns all the files that should be subject to the action does not keep directories , but recursively adds directory contents", "label": "done"}
{"id": "60444", "raw_code": "private static boolean isWithinBounds(VisualPosition targetPosition,VisualPosition startPosition,VisualPosition endPosition){\n  return targetPosition.line >= startPosition.line && targetPosition.line <= endPosition.line && targetPosition.column >= startPosition.column && targetPosition.column <= endPosition.column;\n}", "comment": "allows to answer if particular visual position belongs to visual rectangle identified by the given visual position of its top - left and bottom - right corners .", "label": "done"}
{"id": "28025", "raw_code": "protected String form(ObjectMatrix1D matrix,int index,Former formatter){\n  Object value=matrix.get(index);\n  if (value == null)   return \"\";\n  return String.valueOf(value);\n}", "comment": "converts a given cell to a string ; no alignment considered .", "label": "done"}
{"id": "8888", "raw_code": "public void disable(BluetoothAdapter adapter){\n  int mask=(BluetoothReceiver.STATE_TURNING_OFF_FLAG | BluetoothReceiver.STATE_OFF_FLAG | BluetoothReceiver.SCAN_MODE_NONE_FLAG);\n  long start=-1;\n  BluetoothReceiver receiver=getBluetoothReceiver(mask);\n  int state=adapter.getState();\nswitch (state) {\ncase BluetoothAdapter.STATE_OFF:\n    assertFalse(adapter.isEnabled());\n  removeReceiver(receiver);\nreturn;\ncase BluetoothAdapter.STATE_TURNING_ON:\nassertFalse(adapter.isEnabled());\nstart=System.currentTimeMillis();\nbreak;\ncase BluetoothAdapter.STATE_ON:\nassertTrue(adapter.isEnabled());\nstart=System.currentTimeMillis();\nassertTrue(adapter.disable());\nbreak;\ncase BluetoothAdapter.STATE_TURNING_OFF:\nassertFalse(adapter.isEnabled());\nmask=0;\nbreak;\ndefault :\nremoveReceiver(receiver);\nfail(String.format(\"disable() invalid state: state=%d\",state));\n}\nlong s=System.currentTimeMillis();\nwhile (System.currentTimeMillis() - s < ENABLE_DISABLE_TIMEOUT) {\nstate=adapter.getState();\nif (state == BluetoothAdapter.STATE_OFF && (receiver.getFiredFlags() & mask) == mask) {\nassertFalse(adapter.isEnabled());\nlong finish=receiver.getCompletedTime();\nif (start != -1 && finish != -1) {\nwriteOutput(String.format(\"disable() completed in %d ms\",(finish - start)));\n}\n else {\nwriteOutput(\"disable() completed\");\n}\nremoveReceiver(receiver);\nreturn;\n}\nsleep(POLL_TIME);\n}\nint firedFlags=receiver.getFiredFlags();\nremoveReceiver(receiver);\nfail(String.format(\"disable() timeout: state=%d (expected %d), flags=0x%x (expected 0x%x)\",state,BluetoothAdapter.STATE_OFF,firedFlags,mask));\n}", "comment": "disables bluetooth and checks to make sure that bluetooth was turned off and that the correct actions were broadcast .", "label": "done"}
{"id": "62233", "raw_code": "public static String toRegex(String glob,String separator){\n  checkNotNull(separator,\"separator must be non-null\");\n  checkArgument(separator.length() == 1,\"separator must be a single character: %s\",separator);\n  return toRegex(glob,separator.charAt(0));\n}", "comment": "converts the given glob pattern into a regular expression .", "label": "done"}
{"id": "81986", "raw_code": "public static void removeObjectAtOffset(Object[] sourceArray,Object[] destinationArray,int offset){\n  System.arraycopy(sourceArray,0,destinationArray,0,offset);\n  System.arraycopy(sourceArray,offset + 1,destinationArray,offset,sourceArray.length - offset - 1);\n}", "comment": "removes the object at the source array offset and copies all other objects to the destination array", "label": "done"}
{"id": "21413", "raw_code": "public static boolean isZoningRequired(DbClient dbClient,URI varrayUri){\n  if (varrayUri != null) {\n    VirtualArray nh=dbClient.queryObject(VirtualArray.class,varrayUri);\n    if (nh != null) {\n      return isZoningRequired(dbClient,nh);\n    }\n  }\n  return false;\n}", "comment": "looks at the varray to see if zoning is disabled , and looks to make sure that there is at least one active networksystem registered .", "label": "done"}
{"id": "33466", "raw_code": "public synchronized void addMessages(ArrayList<SmsMmsMessage> newMessages){\n  if (newMessages != null) {\n    messages.addAll(0,newMessages);\n    UpdateMessageCount();\n  }\n}", "comment": "add a list of new messages to the end of the current message list .", "label": "done"}
{"id": "45731", "raw_code": "public static String buildPath(JsonPath jsonPath){\n  List<String> urlParts=new LinkedList<>();\n  JsonPath currentJsonPath=jsonPath;\n  String pathPart;\n  do {\n    if (currentJsonPath instanceof RelationshipsPath) {\n      pathPart=RELATIONSHIP_MARK + SEPARATOR + currentJsonPath.getElementName();\n    }\n else     if (currentJsonPath instanceof FieldPath) {\n      pathPart=currentJsonPath.getElementName();\n    }\n else {\n      pathPart=currentJsonPath.getElementName();\n      if (currentJsonPath.getIds() != null) {\n        pathPart+=SEPARATOR + mergeIds(currentJsonPath.getIds());\n      }\n    }\n    urlParts.add(pathPart);\n    currentJsonPath=currentJsonPath.getParentResource();\n  }\n while (currentJsonPath != null);\n  Collections.reverse(urlParts);\n  return SEPARATOR + StringUtils.join(SEPARATOR,urlParts) + SEPARATOR;\n}", "comment": "creates a path using the provided jsonpath structure .", "label": "done"}
{"id": "11675", "raw_code": "protected void groupFrames(Vector<Frame> frames,Vector<Group> groups,boolean isDchum) throws MakeTocException {\n  Frame frame;\n  Group group;\n  int groupCount;\n  int nFrames=frames.size();\n  Debug.message(\"maketoc\",\"MakeToc: *** grouping frames ***\");\n  for (int i=0; i < nFrames; i++) {\n    Debug.message(\"maketocdetail\",\"MakeToc: group addition, starting outer loop\");\n    frame=(Frame)frames.elementAt(i);\n    if (!frame.marked) {\n      groupCount=groups.size();\n      group=new Group();\n      group.left=maxSide / 2;\n      group.right=group.left + 1;\n      group.top=maxSide / 2;\n      group.bottom=group.top + 1;\n      group.horiz_pos[group.top]=frame.top;\n      group.horiz_pos[group.bottom]=frame.bottom;\n      group.vert_pos[group.left]=frame.left;\n      group.vert_pos[group.right]=frame.right;\n      group.h_interval=frame.h_interval;\n      group.v_interval=frame.v_interval;\n      group.h_resolution=frame.h_resolution;\n      group.v_resolution=frame.v_resolution;\n      group.scale=frame.scale;\n      group.zone=frame.zone;\n      group.cib=frame.cib;\n      group.cdted=frame.cdted;\n      frame.x=group.left;\n      frame.y=group.top;\n      frame.group=groupCount;\n      frame.marked=true;\n      Debug.message(\"maketocdetail\",\"Maketoc.groupFrames: created group \" + groupCount + \" for frame \"+ i+ \", - \"+ frame.filename+ \" checking other frames for neighbors\");\n      if (!isDchum) {\n        for (int j=0; j < nFrames; j++) {\n          if (i == j) {\n            Debug.message(\"maketocdetail\",\"Maketoc.groupFrames: inner loop, i = j = \" + i + \", frame that created group added to group, expecting false return\");\n            continue;\n          }\n          Frame f=(Frame)frames.elementAt(j);\n          if (addFrameToGroup(group,f,groupCount)) {\n            Debug.message(\"maketocdetail\",\"Maketoc.groupFrames: added frame \" + j + \" to group \"+ groupCount);\n            continue;\n          }\n        }\n      }\n      Debug.message(\"maketocdetail\",\"Maketoc.groupFrames: adding another group - \" + groupCount + \" *******************\\n\\n\");\n      groups.add(group);\n    }\n    fireProgressUpdate(ProgressEvent.UPDATE,\"Organizing frames\",i,nFrames);\n  }\n  if (Debug.debugging(\"maketoc\")) {\n    Debug.output(\"MakeToc: Number of boundary rectangles (groups): \" + groups.size());\n  }\n}", "comment": "take the vector of frames , and group them into boundary rectangles , represented by groups .", "label": "done"}
{"id": "39243", "raw_code": "public String toMatlab(){\n  StringBuffer result;\n  int i;\n  int n;\n  result=new StringBuffer();\n  result.append(\"[\");\n  for (i=0; i < getRowDimension(); i++) {\n    if (i > 0) {\n      result.append(\"; \");\n    }\n    for (n=0; n < getColumnDimension(); n++) {\n      if (n > 0) {\n        result.append(\" \");\n      }\n      result.append(Double.toString(get(i,n)));\n    }\n  }\n  result.append(\"]\");\n  return result.toString();\n}", "comment": "converts the matrix into a single line matlab string : matrix is enclosed by parentheses , rows are separated by semicolon and single cells by blanks , e . g . , [ 1 2 ; 3 4 ] .", "label": "done"}
{"id": "68200", "raw_code": "public static Object extractTypeChecked(List<Object> args,int i,Class clazz,Function<List<Object>,Object> extractFunc){\n  if (args.size() < i + 1) {\n    return null;\n  }\n else   if (clazz.isInstance(args.get(i))) {\n    return extractFunc.apply(args);\n  }\n else {\n    return null;\n  }\n}", "comment": "extract type - checked value from an argument list using the specified type check and extraction function", "label": "done"}
{"id": "20677", "raw_code": "public static String deflate(String previous,String current){\n  if (previous == null)   return current;\n  StringBuilder buf=new StringBuilder();\n  int start1=0;\n  int start2=0;\n  while (start1 < previous.length() && start2 < current.length()) {\n    int end1=start1;\n    int end2=start2;\n    while (end1 <= previous.length() && end2 <= current.length()) {\n      int c1=(end1 < previous.length() ? previous.charAt(end1) : '\\t');\n      int c2=(end2 < current.length() ? current.charAt(end2) : '\\t');\n      if (c1 == c2) {\n        if (c1 == '\\t') {\n          buf.append(\"&\");\n          break;\n        }\n else {\n          end1++;\n          end2++;\n        }\n      }\n else {\n        while (end1 < previous.length() && previous.charAt(end1) != '\\t') {\n          end1++;\n        }\n        while (end2 < current.length() && current.charAt(end2) != '\\t') {\n          end2++;\n        }\n        for (int i=start2; i < end2; i++)         buf.append(current.charAt(i));\n        break;\n      }\n    }\n    start1=end1 + 1;\n    start2=end2 + 1;\n    if (start2 < current.length())     buf.append(\"\\t\");\n  }\n  return buf.toString();\n}", "comment": "deflate current sam line by replacing all fields that equalovershorterofboth previous line by an ampersand", "label": "done"}
{"id": "32200", "raw_code": "private GridCacheVersion minVersion(Iterable<IgniteTxEntry> entries,GridCacheVersion min,IgniteInternalTx tx){\n  for (  IgniteTxEntry txEntry : entries) {\n    GridCacheEntryEx cached=txEntry.cached();\n    assert txEntry.isRead() || !cached.obsolete(tx.xidVersion()) : \"Invalid obsolete version for transaction [entry=\" + cached + \", tx=\"+ tx+ ']';\n    for (    GridCacheMvccCandidate cand : cached.remoteMvccSnapshot())     if (min == null || cand.version().isLess(min))     min=cand.version();\n  }\n  return min;\n}", "comment": "go through all candidates for entries involved in transaction and find their min version .", "label": "done"}
{"id": "4458", "raw_code": "public DimensionedScalar(String fieldValue) throws IllegalArgumentException {\n  super(\"\",\"\");\n  Matcher matcher=PATTERN.matcher(fieldValue);\n  if (matcher.find()) {\n    String name=matcher.group(1);\n    String dimensions=matcher.group(2);\n    String value=matcher.group(3);\n    setName(name);\n    setValue(value);\n    this.dimensions=new Dimensions(dimensions);\n  }\n else {\n    throw new DictionaryException(\"CANNOT PARSE:  >\" + fieldValue + \"<\");\n  }\n}", "comment": "la stringa contiene il value del field di cui bisogna fare il parsing per estrarre valore e unita ' di misura", "label": "done"}
{"id": "66397", "raw_code": "public void characters(char ch[],int start,int length) throws SAXException {\n  m_valueBuffer.append(ch,start,length);\n}", "comment": "characters read from xml are assigned to a variable , based on the current m _ context .", "label": "done"}
{"id": "15495", "raw_code": "private int currentDepth(){\n  try {\n    Integer oneBased=((Integer)DEPTH_FIELD.get(this));\n    return oneBased - 1;\n  }\n catch (  IllegalAccessException e) {\n    throw new AssertionError(e);\n  }\n}", "comment": "returns a 0 - based depth within the object graph of the current object being serialized .", "label": "property"}
{"id": "27016", "raw_code": "public final Sector union(Sector that){\n  if (that == null)   return this;\n  Angle minLat=this.minLatitude;\n  Angle maxLat=this.maxLatitude;\n  Angle minLon=this.minLongitude;\n  Angle maxLon=this.maxLongitude;\n  if (that.minLatitude.degrees < this.minLatitude.degrees)   minLat=that.minLatitude;\n  if (that.maxLatitude.degrees > this.maxLatitude.degrees)   maxLat=that.maxLatitude;\n  if (that.minLongitude.degrees < this.minLongitude.degrees)   minLon=that.minLongitude;\n  if (that.maxLongitude.degrees > this.maxLongitude.degrees)   maxLon=that.maxLongitude;\n  return new Sector(minLat,maxLat,minLon,maxLon);\n}", "comment": "returns a new sector whose angles are the extremes of the this sector and another .", "label": "property"}
{"id": "66883", "raw_code": "public static boolean isStringType(Type t){\n  return t.equals(RefType.v(\"java.lang.String\"));\n}", "comment": "returns true if specified type is java . lang . string", "label": "property"}
{"id": "38792", "raw_code": "@Override public boolean connectionAllowed(String eventName){\n  if (m_listenees.containsKey(eventName)) {\n    return false;\n  }\n  return true;\n}", "comment": "returns true if , at this time , the object will accept a connection with respect to the named event", "label": "property"}
{"id": "68051", "raw_code": "public boolean isPrefixed(){\n  return name.indexOf(':') >= 0;\n}", "comment": "it returns true if the attribute is prefixed ( used the \" : \" character ) .", "label": "property"}
{"id": "81546", "raw_code": "public synchronized void returnBuf(byte[] buf){\n  if (buf == null || buf.length > mSizeLimit) {\n    return;\n  }\n  mBuffersByLastUse.add(buf);\n  int pos=Collections.binarySearch(mBuffersBySize,buf,BUF_COMPARATOR);\n  if (pos < 0) {\n    pos=-pos - 1;\n  }\n  mBuffersBySize.add(pos,buf);\n  mCurrentSize+=buf.length;\n  trim();\n}", "comment": "returns a buffer to the pool , throwing away old buffers if the pool would exceed its allotted size .", "label": "property"}
{"id": "19112", "raw_code": "public void testisAutoIncrement(){\n  try {\n    assertFalse(rsmd.isAutoIncrement(1));\n  }\n catch (  SQLException e1) {\n    fail(\"ResultSetMetaDataTest.testGetScale()\" + e1.getMessage());\n    e1.printStackTrace();\n  }\n  try {\n    conn.close();\n    rsmd.getSchemaName(2);\n    fail(\"Exception expected\");\n  }\n catch (  SQLException e) {\n  }\n}", "comment": "tests fail : always returns false , failing statements commented out .", "label": "property"}
{"id": "33320", "raw_code": "public boolean isEmpty(){\n  return items.isEmpty();\n}", "comment": "returns true whether this page doesn ' t contain items , returns false if it does .", "label": "property"}
{"id": "30919", "raw_code": "private ServiceRegistrar[] buildServiceRegistrar(){\n  int k=0;\n  ServiceRegistrar[] proxys=new ServiceRegistrar[proxyRegSet.size()];\n  Iterator iter=proxyRegSet.iterator();\n  while (iter.hasNext()) {\n    ProxyReg reg=(ProxyReg)iter.next();\n    proxys[k++]=reg.proxy;\n  }\n  return proxys;\n}", "comment": "returns array of serviceregistrar created from the proxyregset", "label": "property"}
{"id": "6990", "raw_code": "@SuppressWarnings(\"unchecked\") public static <E extends Enum<? extends Style.HasCssName>>E fromStyleName(final String styleName,final Class<E> enumClass,final E defaultValue){\n  if (styleName == null || enumClass == null) {\n    return defaultValue;\n  }\n  for (  final Enum<? extends Style.HasCssName> constant : enumClass.getEnumConstants()) {\n    final Style.HasCssName anEnum=(Style.HasCssName)constant;\n    final String cssClass=anEnum.getCssName();\n    if (cssClass != null && StyleHelper.containsStyle(styleName,cssClass)) {\n      return (E)anEnum;\n    }\n  }\n  return defaultValue;\n}", "comment": "returns first enum constant found in at space - separated list of style names .", "label": "property"}
{"id": "21807", "raw_code": "private Map<URI,ExportMask> createExportMaskMap(Set<URI> placedMasks){\n  Map<URI,ExportMask> exportMaskMap=new HashMap<>();\n  Iterator<ExportMask> exportMaskIterator=dbClient.queryIterativeObjects(ExportMask.class,placedMasks,true);\n  while (exportMaskIterator.hasNext()) {\n    ExportMask exportMask=exportMaskIterator.next();\n    exportMaskMap.put(exportMask.getId(),exportMask);\n  }\n  return exportMaskMap;\n}", "comment": "given a set of exportmask uris , return a map of exportmask uri to exportmask object", "label": "property"}
{"id": "51480", "raw_code": "private static String descriptorForFieldSignature(String signature){\n  return signature.replace('.','/');\n}", "comment": "returns what the serialization specification calls \" descriptor \" given a field signature .", "label": "property"}
{"id": "60737", "raw_code": "static WorkQueue commonSubmitterQueue(){\n  ForkJoinPool p;\n  WorkQueue[] ws;\n  int m;\n  Submitter z;\n  return ((z=submitters.get()) != null && (p=commonPool) != null && (ws=p.workQueues) != null && (m=ws.length - 1) >= 0) ? ws[m & z.seed & SQMASK] : null;\n}", "comment": "returns common pool queue for a thread that has submitted at least one task .", "label": "property"}
{"id": "46349", "raw_code": "public Dimension minimumLayoutSize(Container target){\n  Dimension size;\nsynchronized (this) {\n    checkContainer(target);\n    checkRequests();\n    size=new Dimension(xTotal.minimum,yTotal.minimum);\n  }\n  Insets insets=target.getInsets();\n  size.width=(int)Math.min((long)size.width + (long)insets.left + (long)insets.right,Integer.MAX_VALUE);\n  size.height=(int)Math.min((long)size.height + (long)insets.top + (long)insets.bottom,Integer.MAX_VALUE);\n  return size;\n}", "comment": "returns the minimum dimensions needed to lay out the components contained in the specified target container .", "label": "property"}
{"id": "39357", "raw_code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> result=new Vector<Option>();\n  result.addElement(new Option(\"\\tUse double precision format.\\n\" + \"\\t(default: single precision)\",\"double\",0,\"-double\"));\n  result.addElement(new Option(\"\\tUse tabs as separator.\\n\" + \"\\t(default: blanks)\",\"tabs\",0,\"-tabs\"));\n  result.addAll(Collections.list(super.listOptions()));\n  return result.elements();\n}", "comment": "returns an enumeration describing the available options .", "label": "property"}
{"id": "35293", "raw_code": "private static final void waitForEditorToBeActive(IEditorPart internalFileEditor,IWorkbenchPage page){\n  long start=System.currentTimeMillis();\n  long end=start;\n  do {\n    end=System.currentTimeMillis();\n  }\n while (page.getActiveEditor() != internalFileEditor && (end - start) < 5000);\n  if (page.getActiveEditor() != internalFileEditor)   logger.warn(\"selected editor was not activated within timout\");\n}", "comment": "get editor for provided file , returns once editor is active or after timeout", "label": "property"}
{"id": "43019", "raw_code": "private Solution largestObjectiveValue(int objective,Population population){\n  Solution largest=null;\n  double value=Double.NEGATIVE_INFINITY;\n  for (  Solution solution : population) {\n    if (solution.getObjective(objective) > value) {\n      largest=solution;\n      value=solution.getObjective(objective);\n    }\n  }\n  return largest;\n}", "comment": "returns the solution with the largest objective value for the given objective .", "label": "property"}
{"id": "16143", "raw_code": "public static int convertLatmToY(int latm){\n  long v=Math.round((Mercator.MAX_Y - Mercator.lat2y(latm / LATLON_TO_LATLONM)) * MAX_AP_UNITS / (Mercator.MAX_Y * 2));\n  if (v > MAX_AP_UNITS)   return MAX_AP_UNITS;\n  if (v < 0)   return -1;\n  return (int)v;\n}", "comment": "returns the y position based on latitude .", "label": "property"}
{"id": "6431", "raw_code": "private static byte[] stringToByteArray(String str){\n  if (str == null) {\n    return null;\n  }\n  byte[] srcByte=str.getBytes();\n  int srcLength=srcByte.length;\n  byte[] result=new byte[srcLength + 1];\n  System.arraycopy(srcByte,0,result,0,srcLength);\n  result[srcLength]=0;\n  return result;\n}", "comment": "returns this java string as a null - terminated byte array", "label": "property"}
{"id": "62054", "raw_code": "@Override public boolean equals(Object o){\n  if (o instanceof Graph) {\n    return string.equals(o.toString());\n  }\n  return false;\n}", "comment": "returns true if the object is a graph with the same content .", "label": "property"}
{"id": "80868", "raw_code": "private static MappingObject ObjectAt(PCalLocation loc,MappingObject[][] map){\n  return map[loc.getLine()][loc.getColumn()];\n}", "comment": "returns the mappingobject at the location in map indicated by loc .", "label": "property"}
{"id": "57622", "raw_code": "public int countTokens(){\n  int count=0;\n  boolean inToken=false;\n  for (int i=position, length=string.length(); i < length; i++) {\n    if (delimiters.indexOf(string.charAt(i),0) >= 0) {\n      if (returnDelimiters)       count++;\n      if (inToken) {\n        count++;\n        inToken=false;\n      }\n    }\n else {\n      inToken=true;\n    }\n  }\n  if (inToken)   count++;\n  return count;\n}", "comment": "returns the number of unprocessed tokens remaining in the string .", "label": "property"}
{"id": "52844", "raw_code": "private ExtremumType extremumType(int n,double[] alpha_extreme,HyperBoundingBox interval){\n  if (n == alpha_extreme.length - 1) {\n    return extremumType;\n  }\n  double[] alpha_extreme_l=new double[alpha_extreme.length];\n  double[] alpha_extreme_r=new double[alpha_extreme.length];\n  double[] alpha_extreme_c=new double[alpha_extreme.length];\n  System.arraycopy(alpha_extreme,0,alpha_extreme_l,0,alpha_extreme.length);\n  System.arraycopy(alpha_extreme,0,alpha_extreme_r,0,alpha_extreme.length);\n  System.arraycopy(alpha_extreme,0,alpha_extreme_c,0,alpha_extreme.length);\n  double[] centroid=SpatialUtil.centroid(interval);\n  for (int i=0; i < n; i++) {\n    alpha_extreme_l[i]=centroid[i];\n    alpha_extreme_r[i]=centroid[i];\n    alpha_extreme_c[i]=centroid[i];\n  }\n  double intervalLength=interval.getMax(n) - interval.getMin(n);\n  alpha_extreme_l[n]=Math.random() * intervalLength + interval.getMin(n);\n  alpha_extreme_r[n]=Math.random() * intervalLength + interval.getMin(n);\n  double f_c=function(alpha_extreme_c);\n  double f_l=function(alpha_extreme_l);\n  double f_r=function(alpha_extreme_r);\n  if (f_l < f_c) {\n    if (f_r < f_c || Math.abs(f_r - f_c) < DELTA) {\n      return ExtremumType.MAXIMUM;\n    }\n  }\n  if (f_r < f_c) {\n    if (f_l < f_c || Math.abs(f_l - f_c) < DELTA) {\n      return ExtremumType.MAXIMUM;\n    }\n  }\n  if (f_l > f_c) {\n    if (f_r > f_c || Math.abs(f_r - f_c) < DELTA) {\n      return ExtremumType.MINIMUM;\n    }\n  }\n  if (f_r > f_c) {\n    if (f_l > f_c || Math.abs(f_l - f_c) < DELTA) {\n      return ExtremumType.MINIMUM;\n    }\n  }\n  if (Math.abs(f_l - f_c) < DELTA && Math.abs(f_r - f_c) < DELTA) {\n    return ExtremumType.CONSTANT;\n  }\n  throw new IllegalArgumentException(\"Houston, we have a problem!\\n\" + this + \"\\n\"+ \"f_l \"+ f_l+ \"\\n\"+ \"f_c \"+ f_c+ \"\\n\"+ \"f_r \"+ f_r+ \"\\n\"+ \"p \"+ vec.toArray()+ \"\\n\"+ \"alpha   \"+ FormatUtil.format(alpha_extreme_c)+ \"\\n\"+ \"alpha_l \"+ FormatUtil.format(alpha_extreme_l)+ \"\\n\"+ \"alpha_r \"+ FormatUtil.format(alpha_extreme_r)+ \"\\n\"+ \"n \"+ n);\n}", "comment": "returns the type of the extremum at the specified alpha values .", "label": "property"}
{"id": "44611", "raw_code": "public static String map2OID(String algName){\n  return alg2OidMap.get(algName.toUpperCase(Locale.US));\n}", "comment": "returns oid for algname", "label": "property"}
{"id": "31448", "raw_code": "private boolean hasNextPostponed(){\n  return !postponedRoutes.isEmpty();\n}", "comment": "returns true if there is another postponed route to try .", "label": "property"}
{"id": "51962", "raw_code": "public static String readFully(Reader reader) throws IOException {\n  try {\n    StringWriter writer=new StringWriter();\n    char[] buffer=new char[1024];\n    int count;\n    while ((count=reader.read(buffer)) != -1) {\n      writer.write(buffer,0,count);\n    }\n    return writer.toString();\n  }\n  finally {\n    reader.close();\n  }\n}", "comment": "returns the remainder of ' reader ' as a string , closing it when done .", "label": "property"}
{"id": "33562", "raw_code": "public boolean containsWordBreakingChar(final @NonNull CharSequence input){\n  if (!TextUtils.isEmpty(input)) {\n    for (int i=0; i < input.length(); i++) {\n      char c=input.charAt(i);\n      if (isWordBreakingChar(c)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "comment": "returns true if the input string contains a word - breaking character .", "label": "property"}
{"id": "30833", "raw_code": "private static int indexOf(Object[] array,int len,Object elt){\n  for (int i=0; i < len; i++) {\n    if (elt.equals(array[i]))     return i;\n  }\n  return -1;\n}", "comment": "returns the first index of elt in the array if < len , else - 1 .", "label": "property"}
{"id": "19738", "raw_code": "protected String buildCreateSchemaStatement() throws ReplicatorException {\n  return null;\n}", "comment": "return a statement that will create the schema , null if no create schema can be given", "label": "property"}
{"id": "53556", "raw_code": "public Sentence asSentence(){\n  return Sentence.newConjunction(sentences);\n}", "comment": "returns the list of sentences in the knowledge base chained together as a single sentence .", "label": "property"}
{"id": "62095", "raw_code": "@Override public boolean isRunning(){\n  return (frame != null && frame.isVisible());\n}", "comment": "returns true if the gui is started and not paused , and false otherwise .", "label": "property"}
{"id": "3705", "raw_code": "public boolean canRead(){\n  return _is != null;\n}", "comment": "returns true if there ' s an associated file .", "label": "property"}
{"id": "81267", "raw_code": "public static Object[] sortCopy(Object[] objects,Comparer comparer){\n  int len=objects.length;\n  Object[] copy=new Object[len];\n  System.arraycopy(objects,0,copy,0,len);\n  sort(copy,comparer);\n  return copy;\n}", "comment": "sorts an array of strings , returning a new array with the sorted items .", "label": "property"}
{"id": "56138", "raw_code": "public boolean updateStatsAndReturnIfAllowed(){\n  long now=SystemClock.elapsedRealtime();\n  long deltaMs=now - mLastRequestTimestamp;\n  if (deltaMs < mDelayMs)   return false;\n  mLastRequestTimestamp=now;\n  if (deltaMs < 2 * mDelayMs) {\n    mDelayMs=Math.min(MAX_DELAY,mDelayMs * 2);\n  }\n else {\n    mDelayMs=MIN_DELAY;\n  }\n  return true;\n}", "comment": "updates the prediction stats and return whether prediction is allowed .", "label": "property"}
{"id": "18375", "raw_code": "public boolean isExpired(final Date date){\n  if (date == null) {\n    throw new IllegalArgumentException(\"Date may not be null\");\n  }\n  return (cookieExpiryDate != null && cookieExpiryDate.getTime() <= date.getTime());\n}", "comment": "returns true if this cookie has expired .", "label": "property"}
{"id": "51264", "raw_code": "public int size(){\n  return al.size();\n}", "comment": "returns the number of elements in this set .", "label": "property"}
{"id": "47010", "raw_code": "public int hashCode(){\n  int h=hash;\n  if (h == -1) {\n    try {\n      h=Arrays.hashCode(X509CertImpl.getEncodedInternal(this));\n    }\n catch (    CertificateException e) {\n      h=0;\n    }\n    hash=h;\n  }\n  return h;\n}", "comment": "returns a hashcode value for this certificate from its encoded form .", "label": "property"}
{"id": "29443", "raw_code": "public static double sqrt(double x){\n  return Math.sqrt(x);\n}", "comment": "returns the positive square root of the specified value .", "label": "property"}
{"id": "37537", "raw_code": "public String toStringSummary(){\n  int resultsetLength;\n  String result;\n  String titles;\n  int i;\n  int j;\n  if (m_NonSigWins == null)   return \"-summary data not set-\";\n  resultsetLength=1 + Math.max((int)(Math.log(getColCount()) / Math.log(10)),(int)(Math.log(getRowCount()) / Math.log(10)));\n  result=\"\";\n  titles=\"\";\n  result+=\"{\\\\centering\\n\";\n  result+=\"\\\\begin{table}[thb]\\n\\\\caption{\\\\label{labelname}\" + \"Table Caption}\\n\";\n  result+=\"\\\\footnotesize\\n\";\n  result+=\"\\\\begin{tabular}{l\";\n  for (i=0; i < getColCount(); i++) {\n    if (getColHidden(i))     continue;\n    titles+=\" &\";\n    result+=\"c\";\n    titles+=' ' + Utils.padLeft(\"\" + getSummaryTitle(i),resultsetLength * 2 + 3);\n  }\n  result+=\"}\\\\\\\\\\n\\\\hline\\n\";\n  result+=titles + \" \\\\\\\\\\n\\\\hline\\n\";\n  for (i=0; i < getColCount(); i++) {\n    if (getColHidden(i))     continue;\n    for (j=0; j < getColCount(); j++) {\n      if (getColHidden(j))       continue;\n      if (j == 0)       result+=(char)((int)'a' + i % 26);\n      if (j == i)       result+=\" & - \";\n else       result+=\"& \" + m_NonSigWins[i][j] + \" (\"+ m_Wins[i][j]+ \") \";\n    }\n    result+=\"\\\\\\\\\\n\";\n  }\n  result+=\"\\\\hline\\n\\\\end{tabular} \\\\footnotesize \\\\par\\n\\\\end{table}}\";\n  return result;\n}", "comment": "returns the summary as string .", "label": "property"}
{"id": "32391", "raw_code": "@Nullable public String fileName(){\n  return JavaLogger.fileName(delegate);\n}", "comment": "returns current log file .", "label": "property"}
{"id": "21623", "raw_code": "private Workflow.Method createVolumesMethod(URI systemURI,URI poolURI,List<URI> volumeURIs,VirtualPoolCapabilityValuesWrapper capabilities){\n  return new Workflow.Method(\"createVolumes\",systemURI,poolURI,volumeURIs,capabilities);\n}", "comment": "return a workflow . method for createvolumes .", "label": "property"}
{"id": "78154", "raw_code": "static long checkPreambleSize(Memory mem){\n  final long cap=mem.getCapacity();\n  if (cap < 8) {\n    throwNotBigEnough(cap,8);\n  }\n  final long pre0=mem.getLong(0);\n  final int preLongs=(int)(pre0 & 0X3FL);\n  final int required=Math.max(preLongs << 3,8);\n  if (cap < required) {\n    throwNotBigEnough(cap,required);\n  }\n  return pre0;\n}", "comment": "checks memory for capacity to hold the preamble and returns the first 8 bytes .", "label": "property"}
{"id": "31961", "raw_code": "public static Collection<InetAddress> toInetAddresses(Collection<String> addrs,Collection<String> hostNames) throws IgniteCheckedException {\n  Set<InetAddress> res=new HashSet<>(addrs.size());\n  Iterator<String> hostNamesIt=hostNames.iterator();\n  for (  String addr : addrs) {\n    String hostName=hostNamesIt.hasNext() ? hostNamesIt.next() : null;\n    InetAddress inetAddr=null;\n    if (!F.isEmpty(hostName)) {\n      try {\n        inetAddr=InetAddress.getByName(hostName);\n      }\n catch (      UnknownHostException ignored) {\n      }\n    }\n    if (inetAddr == null || inetAddr.isLoopbackAddress()) {\n      try {\n        inetAddr=InetAddress.getByName(addr);\n      }\n catch (      UnknownHostException ignored) {\n      }\n    }\n    if (inetAddr != null)     res.add(inetAddr);\n  }\n  if (res.isEmpty())   throw new IgniteCheckedException(\"Addresses can not be resolved [addr=\" + addrs + \", hostNames=\"+ hostNames+ ']');\n  return res;\n}", "comment": "returns tha list of resolved inet addresses .", "label": "property"}
{"id": "81344", "raw_code": "public static ReferenceBinding[] substitute(Substitution substitution,ReferenceBinding[] originalTypes){\n  if (originalTypes == null)   return null;\n  ReferenceBinding[] substitutedTypes=originalTypes;\n  for (int i=0, length=originalTypes.length; i < length; i++) {\n    ReferenceBinding originalType=originalTypes[i];\n    TypeBinding substitutedType=substitute(substitution,originalType);\n    if (!(substitutedType instanceof ReferenceBinding)) {\n      return null;\n    }\n    if (substitutedType != originalType) {\n      if (substitutedTypes == originalTypes) {\n        System.arraycopy(originalTypes,0,substitutedTypes=new ReferenceBinding[length],0,i);\n      }\n      substitutedTypes[i]=(ReferenceBinding)substitutedType;\n    }\n else     if (substitutedTypes != originalTypes) {\n      substitutedTypes[i]=originalType;\n    }\n  }\n  return substitutedTypes;\n}", "comment": "returns an array of types , where original types got substituted given a substitution .", "label": "property"}
{"id": "48994", "raw_code": "private static Collection<TCPTransport> allKnownTransports(){\n  Set<TCPTransport> s;\nsynchronized (localEndpoints) {\n    s=new HashSet<TCPTransport>(localEndpoints.size());\n    for (    LinkedList<TCPEndpoint> epList : localEndpoints.values()) {\n      TCPEndpoint ep=epList.getFirst();\n      s.add(ep.transport);\n    }\n  }\n  return s;\n}", "comment": "returns the current list of known transports .", "label": "property"}
{"id": "71964", "raw_code": "public void requestSecondsUntilIdleLockout(){\n  operations.add(PasswordPolicyStateOperationType.GET_SECONDS_UNTIL_IDLE_LOCKOUT);\n}", "comment": "returns the seconds until idle lockout .", "label": "property"}
{"id": "37858", "raw_code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> newVector=new Vector<Option>(8);\n  newVector.addElement(new Option(\"\\tSet confidence threshold for pruning.\\n\" + \"\\t(default 0.25)\",\"C\",1,\"-C <pruning confidence>\"));\n  newVector.addElement(new Option(\"\\tSet minimum number of objects per leaf.\\n\" + \"\\t(default 2)\",\"M\",1,\"-M <minimum number of objects>\"));\n  newVector.addElement(new Option(\"\\tUse reduced error pruning.\",\"R\",0,\"-R\"));\n  newVector.addElement(new Option(\"\\tSet number of folds for reduced error\\n\" + \"\\tpruning. One fold is used as pruning set.\\n\" + \"\\t(default 3)\",\"N\",1,\"-N <number of folds>\"));\n  newVector.addElement(new Option(\"\\tUse binary splits only.\",\"B\",0,\"-B\"));\n  newVector.addElement(new Option(\"\\tGenerate unpruned decision list.\",\"U\",0,\"-U\"));\n  newVector.addElement(new Option(\"\\tDo not use MDL correction for info gain on numeric attributes.\",\"J\",0,\"-J\"));\n  newVector.addElement(new Option(\"\\tSeed for random data shuffling (default 1).\",\"Q\",1,\"-Q <seed>\"));\n  newVector.addElement(new Option(\"\\tDo not make split point actual value.\",\"-doNotMakeSplitPointActualValue\",0,\"-doNotMakeSplitPointActualValue\"));\n  newVector.addAll(Collections.list(super.listOptions()));\n  return newVector.elements();\n}", "comment": "returns an enumeration describing the available options .", "label": "property"}
{"id": "78015", "raw_code": "public static byte[] readFully(InputStream in) throws IOException {\n  try {\n    return readFullyNoClose(in);\n  }\n  finally {\n    in.close();\n  }\n}", "comment": "returns a byte [ ] containing the remainder of ' in ' , closing it when done .", "label": "property"}
{"id": "37859", "raw_code": "@Override public Enumeration<String> enumerateMeasures(){\n  Vector<String> newVector=new Vector<String>(1);\n  newVector.addElement(\"measureNumRules\");\n  return newVector.elements();\n}", "comment": "returns an enumeration of the additional measure names", "label": "property"}
{"id": "35674", "raw_code": "protected synchronized void onSendTaskCompleted(RecordBuffer<R> buffer){\n  logger.trace(\"{}:{} Send Completed\",name(),buffer);\n  activeSendTasks.decrementAndGet();\n}", "comment": "this method should not raise any exceptions .", "label": "property"}
{"id": "50891", "raw_code": "public boolean isStable(){\n  return myFeatures.contains(FEATURE_STABLE);\n}", "comment": "returns true if gapis is considered stable ( non - experimental ) :", "label": "property"}
{"id": "14398", "raw_code": "public static Set<String> listServers(SSOToken ssoToken,String siteName) throws SMSException, SSOException, ConfigurationException {\n  Set<String> members=new HashSet<>();\n  String siteId=getSiteId(ssoToken,siteName);\n  if (siteId != null) {\n    Set<String> allServers=ServerConfiguration.getServers(ssoToken);\n    for (    String svr : allServers) {\n      if (ServerConfiguration.belongToSite(ssoToken,svr,siteName)) {\n        members.add(svr);\n      }\n    }\n  }\n  return members;\n}", "comment": "returns the server instance names that belong to a site .", "label": "property"}
{"id": "35879", "raw_code": "public static List<BatchResponse> postWithSingleRequest(final RequestSpecification requestSpec,final ResponseSpecification responseSpec,final BatchRequest br){\n  final List<BatchRequest> batchRequests=new ArrayList<>();\n  batchRequests.add(br);\n  final String jsonifiedRequest=BatchHelper.toJsonString(batchRequests);\n  final List<BatchResponse> response=BatchHelper.postBatchRequestsWithoutEnclosingTransaction(requestSpec,responseSpec,jsonifiedRequest);\n  Assert.assertNotNull(response);\n  Assert.assertTrue(response.size() > 0);\n  return response;\n}", "comment": "returns a batchresponse based on the given batchrequest , by posting the request to the server .", "label": "property"}
{"id": "59889", "raw_code": "public File programDirectory(){\n  return programDirectory;\n}", "comment": "returns the directory in which the main program is located .", "label": "property"}
{"id": "34765", "raw_code": "@VisibleForTesting static boolean isPrecachingEnabled(Context context){\n  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);\n  return prefs.getBoolean(PREF_IS_PRECACHING_ENABLED,false);\n}", "comment": "returns true if precaching is able to run .", "label": "property"}
{"id": "41046", "raw_code": "public List<TypeId<?>> asList(){\n  return Collections.unmodifiableList(Arrays.asList(types));\n}", "comment": "returns an immutable list .", "label": "property"}
{"id": "16259", "raw_code": "public boolean isVisited(Object element){\n  return myVisitedElements.containsKey(element);\n}", "comment": "returns true if this element was already visited .", "label": "property"}
{"id": "53676", "raw_code": "public static <T>CompletableFuture<T> exceptionallyCompletedFuture(Throwable throwable){\n  final CompletableFuture<T> future=new CompletableFuture<T>();\n  future.completeExceptionally(throwable);\n  return future;\n}", "comment": "returns a new completablefuture that is already exceptionally completed with the given exception .", "label": "property"}
{"id": "61053", "raw_code": "public int size(){\n  return seq.size();\n}", "comment": "return the number of objects in this sequence .", "label": "property"}
{"id": "35296", "raw_code": "public static boolean isAccessorPair(TMember member,TMember member2){\n  return (member instanceof TGetter && member2 instanceof TSetter) || (member instanceof TSetter && member2 instanceof TGetter);\n}", "comment": "returns true if one of the members is a getter and the other one is a setter .", "label": "property"}
{"id": "80901", "raw_code": "private boolean fitsAsSingleLine(int col){\n  return (col + singleLineWidth() <= PcalTLAGen.wrapColumn) || (bodyFormulas.sf == null && (prcdFormulas == null || prcdFormulas.size() == 0));\n}", "comment": "returns true iff format ( col ) should return a single - line version of the formula .", "label": "property"}
{"id": "77520", "raw_code": "public boolean isPingDisabled(){\n  return (null != healthcheck && !healthcheck.exists());\n}", "comment": "returns true if the healthcheck flag - file is enabled but does not exist , otherwise ( no file configured , or file configured and exists ) returns false .", "label": "property"}
{"id": "71091", "raw_code": "public static double angle(Coordinate p0,Coordinate p1){\n  double dx=p1.x - p0.x;\n  double dy=p1.y - p0.y;\n  return Math.atan2(dy,dx);\n}", "comment": "returns the angle of the vector from p0 to p1 , relative to the positive x - axis .", "label": "property"}
{"id": "38681", "raw_code": "@Override public boolean connectionAllowed(EventSetDescriptor esd){\n  return connectionAllowed(esd.getName());\n}", "comment": "returns true if , at this time , the object will accept a connection via the named event", "label": "property"}
{"id": "75591", "raw_code": "private boolean linkFirst(Node<E> node){\n  if (count >= capacity)   return false;\n  Node<E> f=first;\n  node.next=f;\n  first=node;\n  if (last == null)   last=node;\n else   f.prev=node;\n  ++count;\n  notEmpty.signal();\n  return true;\n}", "comment": "links node as first element , or returns false if full .", "label": "property"}
{"id": "30679", "raw_code": "public boolean indicateDirtyRead(ITemplateHolder template){\n  return ((template.isReadOperation() && _useDirtyRead) || template.isDirtyReadRequested());\n}", "comment": "given an entry and a template , return true if dirty - read should be performed", "label": "property"}
{"id": "40244", "raw_code": "public static void closeQuietly(Closeable closeable){\n  if (closeable != null) {\n    try {\n      closeable.close();\n    }\n catch (    RuntimeException rethrown) {\n      throw rethrown;\n    }\ncatch (    Exception ignored) {\n    }\n  }\n}", "comment": "closes ' closeable ' , ignoring any checked exceptions .", "label": "property"}
{"id": "1760", "raw_code": "public AmqpMessage receiveNoWait() throws Exception {\n  checkClosed();\n  return prefetch.poll();\n}", "comment": "if a message is already available in this receiver ' s prefetch buffer then it is returned immediately otherwise this methods return null without waiting .", "label": "property"}
{"id": "386", "raw_code": "private static BufferedImage makeSquare(BufferedImage input){\n  if (input.getHeight() == input.getWidth()) {\n    return input;\n  }\n else {\n    int max=Math.max(input.getHeight(),input.getWidth());\n    int dx=(max - input.getWidth()) / 2;\n    int dy=(max - input.getHeight()) / 2;\n    return createImg(max,max,input.getType(),null);\n  }\n}", "comment": "returns an image where the input image is centered .", "label": "property"}
{"id": "35691", "raw_code": "public String findInterlanguageLink(String lang){\n  int start=page.indexOf(\"[[\" + lang + \":\");\n  if (start < 0)   return null;\n  int end=page.indexOf(\"]]\",start);\n  if (end < 0)   return null;\n  String link=page.substring(start + 3 + lang.length(),end);\n  if (link.indexOf(\"\\n\") != -1) {\n    return null;\n  }\n  if (link.length() == 0)   return null;\n  return link;\n}", "comment": "returns the inter - language link to a specific language ( if any ) .", "label": "property"}
{"id": "17844", "raw_code": "BigInteger copy(){\n  prepareJavaRepresentation();\n  int[] copyDigits=new int[numberLength];\n  System.arraycopy(digits,0,copyDigits,0,numberLength);\n  return new BigInteger(sign,numberLength,copyDigits);\n}", "comment": "returns a copy of the current instance to achieve immutability", "label": "property"}
{"id": "71999", "raw_code": "public String patchFixIds(){\n  return properties.getProperty(\"patch.fix.ids\");\n}", "comment": "returns the set of bug ids for fixes included in this build of the directory server .", "label": "property"}
{"id": "40745", "raw_code": "public static boolean isJellybeanOrLater(){\n  return Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN;\n}", "comment": "returns whether the sdk is the jellybean release or later .", "label": "property"}
{"id": "77069", "raw_code": "public static boolean hasDeadStatesFromInitial(Automaton a){\n  BitSet reachableFromInitial=getLiveStatesFromInitial(a);\n  BitSet reachableFromAccept=getLiveStatesToAccept(a);\n  reachableFromInitial.andNot(reachableFromAccept);\n  return reachableFromInitial.isEmpty() == false;\n}", "comment": "returns true if there are dead states reachable from an initial state .", "label": "property"}
{"id": "75755", "raw_code": "public static final String toBitString(int i[]){\n  StringBuilder sb=new StringBuilder(i.length);\n  for (  int b : i) {\n    sb.append(b);\n  }\n  return sb.toString();\n}", "comment": "tobitstring - returns a string representation of i [ ] .", "label": "property"}
{"id": "6930", "raw_code": "public static double cos(double radians){\n  return Math.cos(radians);\n}", "comment": "returns the trigonometric cosine of the specified angle in radians .", "label": "property"}
{"id": "66759", "raw_code": "public static String classNamePath(String className){\n  String filename=className.replace(\".\",File.separator);\n  filename=filename.replaceFirst(\"[$][0-9]+\",\"\");\n  if (filename.indexOf(\"$\") > 0) {\n    filename=filename.substring(0,filename.indexOf(\"$\"));\n  }\n  return \"src\" + File.separator + filename+ \".java\";\n}", "comment": "returns the relative path for a fully qualified classname .", "label": "property"}
{"id": "23356", "raw_code": "public static boolean hasTokenInformation(Bundle bundle){\n  if (bundle == null) {\n    return false;\n  }\n  String token=bundle.getString(TOKEN_KEY);\n  if ((token == null) || (token.length() == 0)) {\n    return false;\n  }\n  long expiresMilliseconds=bundle.getLong(EXPIRATION_DATE_KEY,0L);\n  if (expiresMilliseconds == 0L) {\n    return false;\n  }\n  return true;\n}", "comment": "returns a boolean indicating whether a bundle contains properties that could be a valid saved token .", "label": "property"}
{"id": "38741", "raw_code": "@Override public boolean connectionAllowed(String eventName){\n  if (eventName.equals(\"trainingSet\") && m_listenees.containsKey(eventName)) {\n    return false;\n  }\n  return true;\n}", "comment": "returns true if , at this time , the object will accept a connection with respect to the named event", "label": "property"}
{"id": "1427", "raw_code": "@Deprecated public static Integer Integer(int i){\n  return Integer.valueOf(i);\n}", "comment": "return a integer object with same value", "label": "property"}
{"id": "11482", "raw_code": "public Point2D inverseTransform(Point2D src,Point2D dst){\n  try {\n    src.setLocation(src.getX() + rotXOffset,src.getY() + rotYOffset);\n    dst=rotTransform.inverseTransform(src,dst);\n  }\n catch (  NoninvertibleTransformException e) {\n    logger.log(Level.FINE,e.getMessage(),e);\n  }\n  return dst;\n}", "comment": "returns dst , the unrotated pixel location of the map .", "label": "property"}
{"id": "8496", "raw_code": "public static Throwable shouldFail(Class clazz,Closure code){\n  Throwable th=null;\n  try {\n    code.call();\n  }\n catch (  GroovyRuntimeException gre) {\n    th=ScriptBytecodeAdapter.unwrap(gre);\n  }\ncatch (  Throwable e) {\n    th=e;\n  }\n  if (th == null) {\n    fail(\"Closure \" + code + \" should have failed with an exception of type \"+ clazz.getName());\n  }\n else   if (!clazz.isInstance(th)) {\n    fail(\"Closure \" + code + \" should have failed with an exception of type \"+ clazz.getName()+ \", instead got Exception \"+ th);\n  }\n  return th;\n}", "comment": "asserts that the given code closure fails when it is evaluated and that a particular type of exception is thrown .", "label": "property"}
{"id": "50427", "raw_code": "public Name join(String identifier){\n  validateLowerUnderscore(identifier);\n  List<NamePiece> newPieceList=new ArrayList<>();\n  newPieceList.addAll(namePieces);\n  newPieceList.add(new NamePiece(identifier,CaseFormat.LOWER_UNDERSCORE));\n  return new Name(newPieceList);\n}", "comment": "returns a new name containing the pieces from this name plus the given identifier added on the end .", "label": "property"}
{"id": "40231", "raw_code": "public int numCheckpoints(){\n  return checkpoints.size();\n}", "comment": "returns the number of checkpoints that were loaded .", "label": "property"}
{"id": "54121", "raw_code": "public void consume(int eventCount,long timeoutInMillis,Predicate<Event> condition) throws TimeoutException {\n  if (eventCount < 0)   throw new IllegalArgumentException(\"The eventCount may not be negative\");\n  if (eventCount == 0)   return;\n  int eventsRemaining=eventCount;\n  final long stopTime=System.currentTimeMillis() + timeoutInMillis;\n  while (eventsRemaining > 0 && System.currentTimeMillis() < stopTime) {\n    Event nextEvent=queue.poll();\n    if (nextEvent != null) {\n      if (condition.test(nextEvent)) {\n        --eventsRemaining;\n        consumedEvents.accept(nextEvent);\n      }\n else {\n        ignoredEvents.accept(nextEvent);\n      }\n    }\n  }\n  if (eventsRemaining > 0) {\n    throw new TimeoutException(\"Received \" + (eventCount - eventsRemaining) + \" of \"+ eventCount+ \" in \"+ timeoutInMillis+ \"ms\");\n  }\n}", "comment": "blocks until the listener has consume the specified number of matching events , blocking at most the specified number of milliseconds .", "label": "property"}
{"id": "81724", "raw_code": "@Override public int hashCode(){\n  int result=1;\n  Iterator<?> it=iterator();\n  while (it.hasNext()) {\n    Object object=it.next();\n    result=(31 * result) + (object == null ? 0 : object.hashCode());\n  }\n  return result;\n}", "comment": "returns the hash code of this list .", "label": "property"}
{"id": "7323", "raw_code": "public static int parseString(String value){\n  return Integer.parseInt(value);\n}", "comment": "parse string value returning a int .", "label": "property"}
{"id": "35431", "raw_code": "public static void assertExpectedOutputContains(String expectedString,String x){\n  if (!x.contains(expectedString)) {\n    fail(\"expected '\" + expectedString + \"' not found in '\"+ x+ \"'\");\n  }\n}", "comment": "fails if expectedstring is not found in x", "label": "property"}
{"id": "3813", "raw_code": "public static ThreadDump create(){\n  ThreadDump threadDump=_threadDumpRef.get();\n  if (threadDump == null) {\n    threadDump=new ThreadDumpPro();\n    _threadDumpRef.compareAndSet(null,threadDump);\n    threadDump=_threadDumpRef.get();\n  }\n  return threadDump;\n}", "comment": "returns the singleton instance , creating if necessary .", "label": "property"}
{"id": "69588", "raw_code": "private E unlinkFirst(){\n  Node<E> f=first;\n  if (f == null)   return null;\n  Node<E> n=f.next;\n  E item=f.item;\n  f.item=null;\n  f.next=f;\n  first=n;\n  if (n == null)   last=null;\n else   n.prev=null;\n  --count;\n  notFull.signal();\n  return item;\n}", "comment": "removes and returns first element , or null if empty .", "label": "property"}
{"id": "44005", "raw_code": "public double interceptStdErr(){\n  return Math.sqrt(svar0);\n}", "comment": "returns the standard error of the estimate for the intercept .", "label": "property"}
{"id": "17913", "raw_code": "public boolean hasUnsupportedCriticalExtension(){\n  Set extns=getCriticalExtensionOIDs();\n  if (extns == null) {\n    return false;\n  }\n  extns.remove(RFC3280CertPathUtilities.ISSUING_DISTRIBUTION_POINT);\n  extns.remove(RFC3280CertPathUtilities.DELTA_CRL_INDICATOR);\n  return !extns.isEmpty();\n}", "comment": "will return true if any extensions are present and marked as critical as we currently dont handle any extensions !", "label": "property"}
{"id": "80956", "raw_code": "private boolean isNotInArray(String str,String[] array){\n  for (int i=0; i < array.length; i++) {\n    if (str.equals(array[i])) {\n      return false;\n    }\n  }\n  return true;\n}", "comment": "returns true iff str is not an element of array .", "label": "property"}
{"id": "60646", "raw_code": "Node cloneOrImportNode(short operation,Node node,boolean deep){\n  NodeImpl copy=shallowCopy(operation,node);\n  if (deep) {\n    NodeList list=node.getChildNodes();\n    for (int i=0; i < list.getLength(); i++) {\n      copy.appendChild(cloneOrImportNode(operation,list.item(i),deep));\n    }\n  }\n  notifyUserDataHandlers(operation,node,copy);\n  return copy;\n}", "comment": "returns a copy of the given node or subtree with this document as its owner .", "label": "property"}
{"id": "29385", "raw_code": "private static int indexOf(int fromIndex,CharSequence csq){\n  if (csq == null)   return 0;\n  int length=csq.length();\n  int j=fromIndex;\n  int i=(j < length) ? csq.charAt(j++) : 0;\n  i<<=16;\n  i|=(j < length) ? csq.charAt(j++) : 0;\n  return i;\n}", "comment": "returns the index starting at the specified index ( two characters at a time ) .", "label": "property"}
{"id": "38006", "raw_code": "public Enumeration<String> enumerateMeasures(){\n  Vector<String> newVector=new Vector<String>(1);\n  newVector.addElement(\"measureNumIterations\");\n  return newVector.elements();\n}", "comment": "returns an enumeration of the additional measure names", "label": "property"}
{"id": "48169", "raw_code": "static CipherSuite valueOf(int id1,int id2){\n  id1&=0xff;\n  id2&=0xff;\n  int id=(id1 << 8) | id2;\n  CipherSuite c=idMap.get(id);\n  if (c == null) {\n    String h1=Integer.toString(id1,16);\n    String h2=Integer.toString(id2,16);\n    c=new CipherSuite(\"Unknown 0x\" + h1 + \":0x\"+ h2,id);\n  }\n  return c;\n}", "comment": "return a ciphersuite with the given id .", "label": "property"}
{"id": "57839", "raw_code": "public Collection engineGenerateCRLs(InputStream inStream) throws CRLException {\n  CRL crl;\n  List crls=new ArrayList();\n  while ((crl=engineGenerateCRL(inStream)) != null) {\n    crls.add(crl);\n  }\n  return crls;\n}", "comment": "returns a ( possibly empty ) collection view of the crls read from the given input stream instream .", "label": "property"}
{"id": "17071", "raw_code": "public static synchronized DataSourceViewsManager sharedInstance(){\n  if (sharedInstance == null)   sharedInstance=new DataSourceViewsManager();\n  return sharedInstance;\n}", "comment": "returns singleton instance of datasourceviewsmanager .", "label": "property"}
{"id": "51904", "raw_code": "public String tag(String inner,String c1,String c2){\n  boolean color=((attr & ATTR_COLOR) == ATTR_COLOR) && ToastBootstrap.color;\n  String s=\"[\";\n  if (color)   s+=\"<\" + c1 + \">\";\n  s+=inner;\n  if (color)   s+=\"<\" + c2 + \">\";\n  s+=\"] \";\n  if (color)   s+=\"<\" + c1 + \">\";\n  return color ? Pretty.format(s) : s;\n}", "comment": "return a tag , maybe formatted with color", "label": "property"}
{"id": "14667", "raw_code": "private static PolicyNotification extractPolicyNotification(String xml) throws PolicyEvaluationException {\n  PolicyNotification policyNotification=null;\n  try {\n    String notificationDataBlock=getNotificationDataBlock(xml);\n    if (notificationDataBlock != null) {\n      Document doc=XMLUtils.getXMLDocument(new ByteArrayInputStream(notificationDataBlock.getBytes()));\n      Node rootNode=XMLUtils.getRootNode(doc,NODE_POLICY_SERVICE);\n      if (rootNode != null) {\n        Node notificationNode=XMLUtils.getChildNode(rootNode,NODE_POLICY_NOTIFICATION);\n        if (notificationNode != null) {\n          policyNotification=PolicyNotification.parseXML(notificationNode);\n        }\n else {\n          debug.error(\"ResultsCacheUtil.\" + \"extractPolicyNotification():\" + \"cannot find notification node\");\n          throw new PolicyEvaluationException(ResBundleUtils.rbName,\"invalid_root_element\",null,null);\n        }\n      }\n else {\n        debug.error(\"ResultsCacheUtil.\" + \"extractPolicyNotification():\");\n      }\n    }\n else {\n      debug.error(\"ResultsCacheUtil:\" + \"extractPolicyNotification():\" + \"notification data block is null\");\n    }\n  }\n catch (  Exception xe) {\n    debug.error(\"ResultsCacheUtil.extractPolicyNotification():\",xe);\n    throw new PolicyEvaluationException(ResBundleUtils.rbName,\"xml_parsing_error\",null,xe);\n  }\n  return policyNotification;\n}", "comment": "returns the notification xml node", "label": "property"}
{"id": "22905", "raw_code": "public boolean isLoginSet(){\n  return (username != null && (password != null && !username.equals(\"\") && !password.equals(\"\"))) || oauth;\n}", "comment": "return true if either login / pass is set or if oauth is enabled", "label": "property"}
{"id": "5878", "raw_code": "public int size(){\n  final ReentrantLock lock=this.lock;\n  lock.lock();\n  try {\n    return count;\n  }\n  finally {\n    lock.unlock();\n  }\n}", "comment": "returns the number of elements in this deque .", "label": "property"}
{"id": "48707", "raw_code": "private static boolean isBufferTooLarge(ByteBuffer buf){\n  return isBufferTooLarge(buf.capacity());\n}", "comment": "returns true if the buffer is too large to be added to the buffer cache , false otherwise .", "label": "property"}
{"id": "79982", "raw_code": "public static String plnoun(final int quantity,final String noun){\n  final String enoun=fullForm(noun);\n  if (quantity == 1) {\n    return singular(enoun);\n  }\n else {\n    return plural(noun);\n  }\n}", "comment": "returns either the plural or singular form of the given noun , depending on the quantity .", "label": "property"}
{"id": "19463", "raw_code": "public int size(){\n  return names.size();\n}", "comment": "returns the number of members ( name / value pairs ) in this object .", "label": "property"}
{"id": "16147", "raw_code": "public double metersToPixels(){\n  double screenCenterLat=screenTopLeft.latitude - screenSize.latitude / 2;\n  double metersToLon=1 / (Util.LON_TO_METERS_AT_EQUATOR * Math.cos(screenCenterLat / 180 * Math.PI));\n  return screenSize.longitude / windowWidth * metersToLon;\n}", "comment": "returns the ratio of meters to pixels at the center of the screen", "label": "property"}
{"id": "59409", "raw_code": "public int hashCode(){\n  return _lowerNick.hashCode();\n}", "comment": "returns the hash code of this user object .", "label": "property"}
{"id": "79290", "raw_code": "public static BigDecimal parseBigDecimalForEntity(String bigDecimalString) throws NumberFormatException {\n  if (bigDecimalString == null) {\n    return null;\n  }\n  bigDecimalString=bigDecimalString.trim();\n  bigDecimalString=bigDecimalString.replaceAll(\",\",\"\");\n  if (bigDecimalString.length() < 1) {\n    return null;\n  }\n  return new BigDecimal(bigDecimalString);\n}", "comment": "return nulls for empty strings , as the entity engine can deal with nulls .", "label": "property"}
{"id": "59594", "raw_code": "static boolean lessThanUnsignedLong(long x1,long x2){\n  return (x1 + Long.MIN_VALUE) < (x2 + Long.MIN_VALUE);\n}", "comment": "returns true if x1 is less than x2 , when both values are treated as unsigned long .", "label": "property"}
{"id": "1890", "raw_code": "public static HashProvider best(HashParameters params){\n  return best(params,EnumSet.of(HashSupport.STATEFUL));\n}", "comment": "returns the best hash provider supporting at least a stateful implementation of a hash function with the given parameters .", "label": "property"}
{"id": "26459", "raw_code": "public static boolean isJavaScriptEnabled(HttpServletRequest request){\n  HttpSession session=request.getSession();\n  Boolean javaScriptEnabled=(Boolean)session.getAttribute(\"javaScriptEnabled\");\n  if (javaScriptEnabled != null) {\n    return javaScriptEnabled.booleanValue();\n  }\n  return false;\n}", "comment": "returns true if the user has javascript enabled .", "label": "property"}
{"id": "34361", "raw_code": "public String name(){\n  return theName;\n}", "comment": "returns the name of this element type .", "label": "property"}
{"id": "30832", "raw_code": "private static int indexOf(Object[] array,Object elt){\n  return indexOf(array,array.length,elt);\n}", "comment": "returns the first index of elt in the array , else - 1 .", "label": "property"}
{"id": "47822", "raw_code": "public Dimension maximumLayoutSize(Container target){\n  return new Dimension(Integer.MAX_VALUE,Integer.MAX_VALUE);\n}", "comment": "returns the maximum dimensions for this layout given the components in the specified target container .", "label": "property"}
{"id": "55959", "raw_code": "public static NativePage createNativePageForURL(String url,NativePage candidatePage,Tab tab,TabModelSelector tabModelSelector,Activity activity){\n  return createNativePageForURL(url,candidatePage,tab,tabModelSelector,activity,tab.isIncognito());\n}", "comment": "returns a nativepage for displaying the given url if the url is a valid chrome - native url , or null otherwise .", "label": "property"}
{"id": "67770", "raw_code": "protected void throwParseException(ParseException e) throws ParseException {\n  if (locator != null) {\n    String elementLocation=\"\";\n    if (curHandler != null) {\n      elementLocation+=\", element \" + curHandler.qName;\n    }\n    String location=\"[Line \" + String.valueOf(locator.getLineNumber()) + \", Column \"+ String.valueOf(locator.getColumnNumber())+ elementLocation+ \"] \";\n    LogUtils.logException(logger,Level.FINE,location,e);\n    throw new ParseException(location + e.getMessage(),e);\n  }\n else {\n    LogUtils.logException(logger,Level.FINE,null,e);\n    throw e;\n  }\n}", "comment": "throws a parse exception with line / column information .", "label": "property"}
{"id": "69888", "raw_code": "public BlazeValueFactory valueFactory(){\n  return vf;\n}", "comment": "return the factory used to round - trip between tinkerpop values and rdf values .", "label": "property"}
{"id": "24242", "raw_code": "private static String extractClientName(String clientId,String host){\n  String hostExcludedId=\"\";\n  if ((isIPv6(host) || isIPv4(host)) && clientId.startsWith(host)) {\n    hostExcludedId=clientId.substring(host.length());\n  }\n else {\n    int firstDotIndex=host.indexOf(\".\");\n    if (firstDotIndex != -1) {\n      String hostShortName=host.substring(0,firstDotIndex);\n      hostExcludedId=clientId.substring(hostShortName.length());\n    }\n  }\n  String vmPIDAndKindRegex=\"\\\\(\\\\w+:\\\\w+\\\\)\";\n  String regex=\"(\\\\<ec\\\\>)?:[0-9]+(:\\\\w+){2}+\";\n  String name=NOT_AVAILABLE;\n  String temp=hostExcludedId;\n  int openIndex=temp.indexOf(\"(\");\n  if (openIndex != -1) {\n    regex=vmPIDAndKindRegex + regex;\n  }\n  if (temp.matches(regex)) {\n    String[] splitted=temp.split(\":\");\n    name=splitted[splitted.length - 1];\n  }\n  return name;\n}", "comment": "excludes the host name from the client id and returns the string .", "label": "property"}
{"id": "39919", "raw_code": "private void throwArrayIndexOutOfBoundsException(int itemIndex){\n  throw new ArrayIndexOutOfBoundsException(\"Your item index can't be 0 or greater than space item size,\" + \" your items size is \" + spaceItems.size() + \", your current index is :\"+ itemIndex);\n}", "comment": "throw array index out of bounds exception", "label": "property"}
{"id": "32761", "raw_code": "public int count(){\n  return n;\n}", "comment": "returns the number of data values .", "label": "property"}
{"id": "2570", "raw_code": "public static String slurpURLNoExceptions(URL u){\n  try {\n    return slurpURL(u);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    return null;\n  }\n}", "comment": "returns all the text at the given url .", "label": "property"}
{"id": "69601", "raw_code": "public static <T,K,L extends List<T>>BiFunction<Partition<T,K,L>,T,Boolean> alwaysInsert(){\n  return null;\n}", "comment": "returns an insertion policy that indicates the tuple is to be inserted into the partition .", "label": "property"}
{"id": "2460", "raw_code": "public static Vector2 min(Vector2 o1,Vector2 o2){\n  return new Vector2(Math.min(o1.x,o2.x),Math.min(o1.z,o2.z));\n}", "comment": "returns a vector2 containing the smallest x and y values .", "label": "property"}
{"id": "43940", "raw_code": "public String render(ValueExpr theExpr) throws Exception {\n  theExpr.visit(this);\n  return mBuffer.toString();\n}", "comment": "return the rendering of the valueexpr object", "label": "property"}
{"id": "17710", "raw_code": "@Override public synchronized Object[] toArray(){\n  Object[] result=new Object[elementCount];\n  System.arraycopy(elementData,0,result,0,elementCount);\n  return result;\n}", "comment": "returns a new array containing all elements contained in this vector .", "label": "property"}
{"id": "16416", "raw_code": "protected static Vector convertToVector(final Object[] anArray){\n  if (anArray == null) {\n    return null;\n  }\n  final Vector v=new Vector(anArray.length);\n  for (  final Object element : anArray) {\n    v.addElement(element);\n  }\n  return v;\n}", "comment": "returns a vector that contains the same objects as the array .", "label": "property"}
{"id": "86244", "raw_code": "public Date modifiedDate(String path) throws IllegalStateException, IOException, FTPIllegalReplyException, FTPException {\nsynchronized (lock) {\n    if (!connected) {\n      throw new IllegalStateException(\"Client not connected\");\n    }\n    if (!authenticated) {\n      throw new IllegalStateException(\"Client not authenticated\");\n    }\n    communication.sendFTPCommand(\"MDTM \" + path);\n    FTPReply r=communication.readFTPReply();\n    touchAutoNoopTimer();\n    if (!r.isSuccessCode()) {\n      throw new FTPException(r);\n    }\n    String[] messages=r.getMessages();\n    if (messages.length != 1) {\n      throw new FTPIllegalReplyException();\n    }\n else {\n      try {\n        return MDTM_DATE_FORMAT.parse(messages[0]);\n      }\n catch (      ParseException e) {\n        throw new FTPIllegalReplyException();\n      }\n    }\n  }\n}", "comment": "this method asks and returns the last modification date of a file or directory .", "label": "property"}
{"id": "7806", "raw_code": "public double adjustedPow10(double val){\n  boolean negFlag=(val < 0.0);\n  if (negFlag) {\n    val=-val;\n  }\n  double res;\n  if (val < 1.0) {\n    res=(Math.pow(10,val + 1.0) - 10.0) / 9.0;\n  }\n else {\n    res=Math.pow(10,val);\n  }\n  return negFlag ? (-res) : res;\n}", "comment": "returns an adjusted power of 10 value for graphing purposes .", "label": "property"}
{"id": "4945", "raw_code": "public final int first_common_layer(BrdItem p_other){\n  int max_first_layer=Math.max(first_layer(),p_other.first_layer());\n  int min_last_layer=Math.min(last_layer(),p_other.last_layer());\n  if (max_first_layer > min_last_layer) {\n    return -1;\n  }\n  return max_first_layer;\n}", "comment": "returns the first layer , where both this item and p _ other have a shape .", "label": "property"}
{"id": "71882", "raw_code": "public static DereferenceAliasesPolicy valueOf(final int intValue){\n  if (intValue < 0 || intValue >= ELEMENTS.length) {\n    return null;\n  }\n  return ELEMENTS[intValue];\n}", "comment": "returns the alias dereferencing policy having the specified integer value as defined in rfc 4511 section 4 . 5 . 1 .", "label": "property"}
{"id": "37548", "raw_code": "public String globalInfo(){\n  return \"A SplitEvaluator that produces results for a classification \" + \"scheme on a numeric class attribute.\";\n}", "comment": "returns a string describing this split evaluator", "label": "property"}
{"id": "67336", "raw_code": "private static double pythonTime(){\n  return System.currentTimeMillis() / 1000;\n}", "comment": "returns the current millis the same way as python does since this is what ' s stored in the replay files * yay * .", "label": "property"}
{"id": "27393", "raw_code": "public boolean isLocked(){\n  return !queue.isEmpty();\n}", "comment": "true iff a lock is granted .", "label": "property"}
{"id": "47958", "raw_code": "private BigInteger oddModPow(BigInteger y,BigInteger z){\n  if (y.equals(ONE))   return this;\n  if (signum == 0)   return ZERO;\n  int[] base=mag.clone();\n  int[] exp=y.mag;\n  int[] mod=z.mag;\n  int modLen=mod.length;\n  if ((modLen & 1) != 0) {\n    int[] x=new int[modLen + 1];\n    System.arraycopy(mod,0,x,1,modLen);\n    mod=x;\n    modLen++;\n  }\n  int wbits=0;\n  int ebits=bitLength(exp,exp.length);\n  if ((ebits != 17) || (exp[0] != 65537)) {\n    while (ebits > bnExpModThreshTable[wbits]) {\n      wbits++;\n    }\n  }\n  int tblmask=1 << wbits;\n  int[][] table=new int[tblmask][];\n  for (int i=0; i < tblmask; i++)   table[i]=new int[modLen];\n  long n0=(mod[modLen - 1] & LONG_MASK) + ((mod[modLen - 2] & LONG_MASK) << 32);\n  long inv=-MutableBigInteger.inverseMod64(n0);\n  int[] a=leftShift(base,base.length,modLen << 5);\n  MutableBigInteger q=new MutableBigInteger(), a2=new MutableBigInteger(a), b2=new MutableBigInteger(mod);\n  b2.normalize();\n  MutableBigInteger r=a2.divide(b2,q);\n  table[0]=r.toIntArray();\n  if (table[0].length < modLen) {\n    int offset=modLen - table[0].length;\n    int[] t2=new int[modLen];\n    System.arraycopy(table[0],0,t2,offset,table[0].length);\n    table[0]=t2;\n  }\n  int[] b=montgomerySquare(table[0],mod,modLen,inv,null);\n  int[] t=Arrays.copyOf(b,modLen);\n  for (int i=1; i < tblmask; i++) {\n    table[i]=montgomeryMultiply(t,table[i - 1],mod,modLen,inv,null);\n  }\n  int bitpos=1 << ((ebits - 1) & (32 - 1));\n  int buf=0;\n  int elen=exp.length;\n  int eIndex=0;\n  for (int i=0; i <= wbits; i++) {\n    buf=(buf << 1) | (((exp[eIndex] & bitpos) != 0) ? 1 : 0);\n    bitpos>>>=1;\n    if (bitpos == 0) {\n      eIndex++;\n      bitpos=1 << (32 - 1);\n      elen--;\n    }\n  }\n  int multpos=ebits;\n  ebits--;\n  boolean isone=true;\n  multpos=ebits - wbits;\n  while ((buf & 1) == 0) {\n    buf>>>=1;\n    multpos++;\n  }\n  int[] mult=table[buf >>> 1];\n  buf=0;\n  if (multpos == ebits)   isone=false;\n  while (true) {\n    ebits--;\n    buf<<=1;\n    if (elen != 0) {\n      buf|=((exp[eIndex] & bitpos) != 0) ? 1 : 0;\n      bitpos>>>=1;\n      if (bitpos == 0) {\n        eIndex++;\n        bitpos=1 << (32 - 1);\n        elen--;\n      }\n    }\n    if ((buf & tblmask) != 0) {\n      multpos=ebits - wbits;\n      while ((buf & 1) == 0) {\n        buf>>>=1;\n        multpos++;\n      }\n      mult=table[buf >>> 1];\n      buf=0;\n    }\n    if (ebits == multpos) {\n      if (isone) {\n        b=mult.clone();\n        isone=false;\n      }\n else {\n        t=b;\n        a=montgomeryMultiply(t,mult,mod,modLen,inv,a);\n        t=a;\n        a=b;\n        b=t;\n      }\n    }\n    if (ebits == 0)     break;\n    if (!isone) {\n      t=b;\n      a=montgomerySquare(t,mod,modLen,inv,a);\n      t=a;\n      a=b;\n      b=t;\n    }\n  }\n  int[] t2=new int[2 * modLen];\n  System.arraycopy(b,0,t2,modLen,modLen);\n  b=montReduce(t2,mod,modLen,(int)inv);\n  t2=Arrays.copyOf(b,modLen);\n  return new BigInteger(1,t2);\n}", "comment": "returns a biginteger whose value is x to the power of y mod z .", "label": "property"}
{"id": "60415", "raw_code": "public int nextToken(){\n  while (index < length && Character.isWhitespace(expr[index])) {\n    index++;\n  }\n  tokenVal=null;\n  if (index == length)   return TOKEN_END;\n  int start=index;\n  char currentChar=expr[index];\n  char nextChar=(char)0;\n  index++;\n  if (index < length)   nextChar=expr[index];\nswitch (currentChar) {\ncase '(':\n    return TOKEN_LBRACE;\ncase ')':\n  return TOKEN_RBRACE;\ncase '=':\nreturn TOKEN_EQ;\ncase '!':\nif (nextChar == '=') {\nindex++;\nreturn TOKEN_NOT_EQ;\n}\nreturn TOKEN_NOT;\ncase '|':\nif (nextChar == '|') {\nindex++;\nreturn TOKEN_OR;\n}\nbreak;\ncase '&':\nif (nextChar == '&') {\nindex++;\nreturn TOKEN_AND;\n}\nbreak;\ncase '>':\nif (nextChar == '=') {\nindex++;\nreturn TOKEN_GE;\n}\nreturn TOKEN_GT;\ncase '<':\nif (nextChar == '=') {\nindex++;\nreturn TOKEN_LE;\n}\nreturn TOKEN_LT;\ndefault :\nbreak;\n}\nint end=index;\nif (currentChar == '\"' || currentChar == '\\'') {\nchar endChar=currentChar;\nboolean escaped=false;\nstart++;\nfor (; index < length; index++) {\nif (expr[index] == '\\\\' && !escaped) {\nescaped=true;\ncontinue;\n}\nif (expr[index] == endChar && !escaped) break;\nescaped=false;\n}\nend=index;\nindex++;\n}\n else if (currentChar == '/') {\nchar endChar=currentChar;\nboolean escaped=false;\nfor (; index < length; index++) {\nif (expr[index] == '\\\\' && !escaped) {\nescaped=true;\ncontinue;\n}\nif (expr[index] == endChar && !escaped) break;\nescaped=false;\n}\nend=++index;\n}\n else {\nfor (; index < length; index++) {\nif (isMetaChar(expr[index])) break;\n}\nend=index;\n}\nthis.tokenVal=new String(expr,start,end - start);\nreturn TOKEN_STRING;\n}", "comment": "returns the next token type and initializes any state variables accordingly .", "label": "property"}
{"id": "68413", "raw_code": "public static int countCSSPrimitiveNames(){\n  return ALL_PRIMITIVE_PROPERTY_NAMES.size();\n}", "comment": "returns a count of all css primitive ( non - shorthand ) properties known to this class .", "label": "property"}
{"id": "30224", "raw_code": "private StringBuilder generateParameters(){\n  StringBuilder parameters=new StringBuilder();\n  if (filterMap == null && expandParameters == null) {\n    return parameters;\n  }\n  parameters.append('?');\n  int filterParameterCounter=0;\n  if (filterMap != null && !filterMap.isEmpty()) {\n    parameters.append(FILTER_PREFIX);\n    for (    Map.Entry<String,String> filterEntry : filterMap.entrySet()) {\n      parameters.append(String.format(\"%s eq '%s'\",filterEntry.getKey(),filterEntry.getValue()));\n      if (++filterParameterCounter < filterMap.size()) {\n        parameters.append(\" and \");\n      }\n    }\n    if (expandParameters != null) {\n      parameters.append(\"&\");\n    }\n  }\n  if (expandParameters != null) {\n    parameters.append(EXPAND_PREFIX);\n    Iterator iterator=expandParameters.iterator();\n    parameters.append(String.format(\"%s\",iterator.next()));\n    while (iterator.hasNext()) {\n      parameters.append(String.format(\",%s\",iterator.next()));\n    }\n  }\n  return parameters;\n}", "comment": "returns a stringbuilder that is consisted of filtering and expanding parameters that in turn are appended to the query string used for odata client .", "label": "property"}
{"id": "59932", "raw_code": "public static Response invalidEntity(ConstraintViolationException e){\n  StringBuilder errorMessage=new StringBuilder();\n  boolean firstPass=true;\n  for (  ConstraintViolation error : e.getConstraintViolations()) {\n    if (!firstPass) {\n      errorMessage.append(\", \");\n    }\n    errorMessage.append(String.format(\"%s %s (was %s)\",error.getPropertyPath(),error.getMessage(),error.getInvalidValue()));\n    firstPass=false;\n  }\n  ExternalException externalException=new ExternalException(ErrorCode.INVALID_ENTITY,errorMessage.toString(),null);\n  return externalException(externalException);\n}", "comment": "return an error response generated by a validation failure , invalid json , etc .", "label": "property"}
{"id": "55828", "raw_code": "boolean suppressedBy(DNSIncoming msg){\n  try {\n    for (    DNSRecord answer : msg.getAllAnswers()) {\n      if (suppressedBy(answer)) {\n        return true;\n      }\n    }\n    return false;\n  }\n catch (  ArrayIndexOutOfBoundsException e) {\n    logger.log(Level.WARNING,\"suppressedBy() message \" + msg + \" exception \",e);\n    return false;\n  }\n}", "comment": "true if this record is suppressed by the answers in a message .", "label": "property"}
{"id": "11057", "raw_code": "public static String[] stringArrayFromProperties(Properties p,String propName,String tok){\n  String[] ret=null;\n  String raw=p.getProperty(propName);\n  if (raw != null && raw.length() > 0) {\n    try {\n      StringTokenizer token=new StringTokenizer(raw,tok);\n      int numPaths=token.countTokens();\n      ret=new String[numPaths];\n      for (int i=0; i < numPaths; i++) {\n        ret[i]=token.nextToken();\n      }\n      return ret;\n    }\n catch (    java.util.NoSuchElementException e) {\n      e.printStackTrace();\n    }\n  }\n  return ret;\n}", "comment": "takes a string of representing token separated properties and returns an array of parsed strings .", "label": "property"}
{"id": "86655", "raw_code": "public double nextGaussian(){\n  if (mHaveNextNextGaussian) {\n    mHaveNextNextGaussian=false;\n    return mNextNextGaussian;\n  }\n else {\n    double v1, v2, s;\n    do {\n      v1=2 * nextDouble() - 1;\n      v2=2 * nextDouble() - 1;\n      s=v1 * v1 + v2 * v2;\n    }\n while (s >= 1 || s == 0);\n    final double multiplier=StrictMath.sqrt(-2 * StrictMath.log(s) / s);\n    mNextNextGaussian=v2 * multiplier;\n    mHaveNextNextGaussian=true;\n    return v1 * multiplier;\n  }\n}", "comment": "return the next gaussian see knuth , acp , section 3 . 4 . 1 algorithm c .", "label": "property"}
{"id": "65376", "raw_code": "private Member nextMember(Member.Type type){\n  return new TestMember(type,new Address(\"localhost\",++port),new Address(\"localhost\",port + 1000));\n}", "comment": "returns the next server address .", "label": "property"}
{"id": "58323", "raw_code": "public String toURI(){\n  CharArrayBuffer buffer=new CharArrayBuffer(32);\n  buffer.append(this.schemeName);\n  buffer.append(\"://\");\n  buffer.append(this.hostname);\n  if (this.port != -1) {\n    buffer.append(':');\n    buffer.append(Integer.toString(this.port));\n  }\n  return buffer.toString();\n}", "comment": "return the host uri , as a string .", "label": "property"}
{"id": "86965", "raw_code": "public Phone createPhone(String value){\n  PhoneField phoneImpl=new PhoneField();\n  try {\n    phoneImpl.setValue(value);\n  }\n catch (  SdpException s) {\n    s.printStackTrace();\n  }\n  return phoneImpl;\n}", "comment": "returns phone object with the specified value .", "label": "property"}
{"id": "58192", "raw_code": "private ListResourceBundle loadResourceBundle(String resourceBundle) throws MissingResourceException {\n  m_resourceBundleName=resourceBundle;\n  Locale locale=getLocale();\n  ListResourceBundle lrb;\n  try {\n    ResourceBundle rb=ResourceBundle.getBundle(m_resourceBundleName,locale);\n    lrb=(ListResourceBundle)rb;\n  }\n catch (  MissingResourceException e) {\n    try {\n      lrb=(ListResourceBundle)ResourceBundle.getBundle(m_resourceBundleName,new Locale(\"en\",\"US\"));\n    }\n catch (    MissingResourceException e2) {\n      throw new MissingResourceException(\"Could not load any resource bundles.\" + m_resourceBundleName,m_resourceBundleName,\"\");\n    }\n  }\n  m_resourceBundle=lrb;\n  return lrb;\n}", "comment": "return a named resourcebundle for a particular locale .", "label": "property"}
{"id": "42920", "raw_code": "private List<double[]> initializeWeightsND(){\n  int N=50;\n  List<double[]> candidates=new ArrayList<double[]>(numberOfPoints * N);\n  for (int i=0; i < numberOfPoints * N; i++) {\n    double[] weight=new double[numberOfObjectives];\n    for (int j=0; j < numberOfObjectives; j++) {\n      weight[j]=PRNG.nextDouble();\n    }\n    double sum=StatUtils.sum(weight);\n    for (int j=0; j < numberOfObjectives; j++) {\n      weight[j]/=sum;\n    }\n    candidates.add(weight);\n  }\n  List<double[]> weights=new ArrayList<double[]>(numberOfPoints * N);\n  for (int i=0; i < numberOfObjectives; i++) {\n    double[] weight=new double[numberOfObjectives];\n    weight[i]=1.0;\n    weights.add(weight);\n  }\n  while (weights.size() < numberOfPoints) {\n    double[] weight=null;\n    double distance=Double.NEGATIVE_INFINITY;\n    for (int i=0; i < candidates.size(); i++) {\n      double d=Double.POSITIVE_INFINITY;\n      for (int j=0; j < weights.size(); j++) {\n        d=Math.min(d,MathArrays.distance(candidates.get(i),weights.get(j)));\n      }\n      if (d > distance) {\n        weight=candidates.get(i);\n        distance=d;\n      }\n    }\n    weights.add(weight);\n    candidates.remove(weight);\n  }\n  return weights;\n}", "comment": "returns the weights for problems of arbitrary dimension .", "label": "property"}
{"id": "5415", "raw_code": "public String info(){\n  StringBuilder sb=new StringBuilder(\"Report: size: \" + tableSize + \", elements: \"+ elements+ \", loadFactor: \"+ loadFactor+ \", threshold: \"+ threshold);\n  sb.append(\", empty bins:\" + numEmpty);\n  int size=0;\n  int min=elements;\n  int max=-1;\n  for (int i=0; i < tableSize; i++) {\n    LinkedList<String> list=bins[i];\n    if (list != null) {\n      int sz=list.size();\n      size+=sz;\n      if (sz < min) {\n        min=sz;\n      }\n      if (sz > max) {\n        max=sz;\n      }\n    }\n  }\n  float avg=size;\n  int base=(tableSize - numEmpty);\n  if (base == 0) {\n    sb.append(\", average:0\");\n    sb.append(\", minListSize:0\");\n    sb.append(\", maxListSize:0\");\n  }\n else {\n    avg/=base;\n    sb.append(\", average:\" + avg);\n    sb.append(\", minListSize:\" + min);\n    sb.append(\", maxListSize:\" + max);\n  }\n  return sb.toString();\n}", "comment": "return single line of output .", "label": "property"}
{"id": "62026", "raw_code": "@Override public int hashCode(){\n  return subconditions.hashCode() - operator.hashCode();\n}", "comment": "returns the hashcode for the condition", "label": "property"}
{"id": "84533", "raw_code": "static boolean isPackageAccess(final int modifiers){\n  return (modifiers & ACCESS_TEST) == 0;\n}", "comment": "returns whether a given set of modifiers implies package access .", "label": "property"}
{"id": "70515", "raw_code": "@Deprecated public boolean isFillBelowLine(){\n  return mFillBelowLine.size() > 0;\n}", "comment": "returns if the chart should be filled below the line .", "label": "property"}
{"id": "52690", "raw_code": "public static boolean isStanza(Packet packet){\n  if (packet instanceof Message)   return true;\n  if (packet instanceof IQ)   return true;\n  if (packet instanceof Presence)   return true;\n  return false;\n}", "comment": "returns true if the packet is a stanza as defined in rfc - 6121 - a message , iq or presence packet .", "label": "property"}
{"id": "26727", "raw_code": "public List<Node> listAvailableTerminals(Class<?> type){\n  List<Node> result=new ArrayList<Node>();\n  for (  Node node : availableNodes) {\n    if ((node.getNumberOfArguments() == 0) && type.isAssignableFrom(node.getReturnType())) {\n      result.add(node);\n    }\n  }\n  return result;\n}", "comment": "returns the list of all available terminal nodes with the given return type .", "label": "property"}
{"id": "70434", "raw_code": "public static PlaceholderFragment newInstance(int sectionNumber){\n  PlaceholderFragment fragment=new PlaceholderFragment();\n  Bundle args=new Bundle();\n  args.putInt(ARG_SECTION_NUMBER,sectionNumber);\n  fragment.setArguments(args);\n  return fragment;\n}", "comment": "returns a new instance of this fragment for the given section number .", "label": "property"}
{"id": "23127", "raw_code": "public boolean isReliable(){\n  return true;\n}", "comment": "returns \" true \" as this is a reliable transport .", "label": "property"}
{"id": "6477", "raw_code": "public Shape createCheckMark(final int x,final int y,final int w,final int h){\n  double xf=w / 12.0;\n  double hf=h / 12.0;\n  path.reset();\n  path.moveTo(x,y + 7.0 * hf);\n  path.lineTo(x + 2.0 * xf,y + 7.0 * hf);\n  path.lineTo(x + 4.75 * xf,y + 10.0 * hf);\n  path.lineTo(x + 9.0 * xf,y);\n  path.lineTo(x + 11.0 * xf,y);\n  path.lineTo(x + 5.0 * xf,y + 12.0 * hf);\n  path.closePath();\n  return path;\n}", "comment": "return a path for a check mark .", "label": "property"}
{"id": "19859", "raw_code": "public List<Map<String,String>> list(Database conn) throws SQLException {\n  ResultSet rs=null;\n  Statement statement=conn.createStatement();\n  List<Map<String,String>> shardToChannels=new ArrayList<Map<String,String>>();\n  try {\n    rs=statement.executeQuery(select);\n    while (rs.next()) {\n      Map<String,String> shard=new HashMap<String,String>();\n      shard.put(ShardChannelTable.SHARD_ID_COL,rs.getString(ShardChannelTable.SHARD_ID_COL));\n      shard.put(ShardChannelTable.CHANNEL_COL,rs.getString(ShardChannelTable.CHANNEL_COL));\n      shardToChannels.add(shard);\n    }\n  }\n  finally {\n    close(rs);\n    close(statement);\n  }\n  return shardToChannels;\n}", "comment": "return a list of currently known shard / channel assignments .", "label": "property"}
{"id": "14503", "raw_code": "protected static boolean networkMonitorExist(String nwMonName){\n  String classMethod=\"OpenSSOMonitoringUtil.networkMonitorExist: \";\n  if (debug.messageEnabled()) {\n    debug.message(classMethod + \"checking \" + nwMonName);\n  }\n  if ((nwMonName == null) || (nwMonName.length() == 0)) {\n    if (debug.warningEnabled()) {\n      debug.warning(classMethod + \"isNull\");\n    }\n    return false;\n  }\n  Set<String> ntwStats=NetworkMonitor.getInstanceNames();\n  String ss=nwMonName.toLowerCase();\n  if (ntwStats.contains(ss)) {\n    return true;\n  }\n else {\n    return false;\n  }\n}", "comment": "return whether the specified network monitor has been instantiated in the entitlements service yet", "label": "property"}
{"id": "6709", "raw_code": "public static void closeQuietly(final Closeable closeable){\n  if (closeable != null) {\n    try {\n      closeable.close();\n    }\n catch (    final RuntimeException rethrown) {\n      throw rethrown;\n    }\ncatch (    final Exception ignored) {\n    }\n  }\n}", "comment": "closes ' closeable ' , ignoring any checked exceptions .", "label": "property"}
{"id": "28706", "raw_code": "public static int randomRangeInt(int min,int max){\n  return (int)(Math.random() < 0.5 ? ((1 - Math.random()) * (max - min) + min) : (Math.random() * (max - min) + min));\n}", "comment": "returns a random integer between the value min and the value max .", "label": "property"}
{"id": "38956", "raw_code": "public String clusterDefinitionsTipText(){\n  return \"The clusters to use.\";\n}", "comment": "returns the tip text for this property", "label": "property"}
{"id": "50220", "raw_code": "public double patience(int k,F f,int N){\n  double pf=p(f);\n  BinomialDistribution dist=new BinomialDistribution(null,N,pf);\n  double p0=Math.pow(1 - pf,N);\n  return 1 - (dist.cumulativeProbability(k - 1) - p0) / (1 - p0);\n}", "comment": "return the patience , i . e . , the penalization of having a number of items with the same feature in a recommendation list of a given size .", "label": "property"}
{"id": "12641", "raw_code": "private static void expandNumberAt(String numberString,int startIndex,WordRelation wordRelation){\n  expandNumber(numberString.substring(startIndex,numberString.length()),wordRelation);\n}", "comment": "returns the number string list of the given string starting at the given index .", "label": "property"}
{"id": "21778", "raw_code": "private boolean usedAllRule17Directors(Set<String> allocatedDirectors,PortAllocationContext context){\n  Set<String> rule17Directors=getRule17Directors(context);\n  for (  String director : allocatedDirectors) {\n    rule17Directors.remove(director);\n  }\n  return rule17Directors.isEmpty();\n}", "comment": "returns true if already used all the rule17 directors .", "label": "property"}
{"id": "71996", "raw_code": "public String documentationHomePageUrl(){\n  return properties.getProperty(\"doc.homepage.url\");\n}", "comment": "returns the url of the product home page .", "label": "property"}
{"id": "86635", "raw_code": "public static boolean hasTaxonomyInfo(SequencesReader reader){\n  final File taxonFile=new File(reader.path(),TAXONOMY_FILE);\n  final File mappingFile=new File(reader.path(),TAXONOMY_TO_SEQUENCE_FILE);\n  if (taxonFile.exists() && mappingFile.exists()) {\n    return true;\n  }\n else   if (taxonFile.exists() || mappingFile.exists()) {\n    throw new NoTalkbackSlimException(\"Reference SDF does not contain both taxonomy and sequences lookup\");\n  }\n else {\n    return false;\n  }\n}", "comment": "returns true if the supplied reader contains taxonomy information", "label": "property"}
{"id": "70323", "raw_code": "public boolean isInside(Point point){\n  return bounds.contains(point);\n}", "comment": "returns true if the point is inside this sprite .", "label": "property"}
{"id": "31064", "raw_code": "public Object putResource(Object key,Object value){\n  return (objectCache.put(key,value));\n}", "comment": "return the resource for the specified key", "label": "property"}
{"id": "34896", "raw_code": "public int hashCode(){\n  return name.hashCode();\n}", "comment": "returns the hash code value for this entry .", "label": "property"}
{"id": "54317", "raw_code": "public AttributeInfo copy(ConstPool newCp,Map classnames){\n  Copier copier=new Copier(info,constPool,newCp,classnames);\n  try {\n    copier.parameters();\n    return new ParameterAnnotationsAttribute(newCp,getName(),copier.close());\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e.toString());\n  }\n}", "comment": "copies this attribute and returns a new copy .", "label": "property"}
{"id": "71839", "raw_code": "@Override public int hashCode(){\n  return oid.hashCode();\n}", "comment": "returns the hash code for this name form .", "label": "property"}
{"id": "87087", "raw_code": "public int size(){\n  if (hmap == null) {\n    return 0;\n  }\n  return hmap.size();\n}", "comment": "return the size of the embedded map", "label": "property"}
{"id": "38143", "raw_code": "public String associatorTipText(){\n  return \"The base associator to be used.\";\n}", "comment": "returns the tip text for this property", "label": "property"}
{"id": "12663", "raw_code": "public boolean isPronounceable(String word){\n  String lowerCaseWord=word.toLowerCase();\n  return (prefixFSM.accept(lowerCaseWord) && suffixFSM.accept(lowerCaseWord));\n}", "comment": "returns true if the given word is pronounceable .", "label": "property"}
{"id": "1994", "raw_code": "public static double probToLogOdds(double prob){\n  if (gr(prob,1) || (sm(prob,0))) {\n    throw new IllegalArgumentException(\"probToLogOdds: probability must \" + \"be in [0,1] \" + prob);\n  }\n  double p=SMALL + (1.0 - 2 * SMALL) * prob;\n  return Math.log(p / (1 - p));\n}", "comment": "returns the log - odds for a given probabilitiy .", "label": "property"}
{"id": "22915", "raw_code": "public int nodeCount(){\n  return nodes == null ? 0 : nodes.size();\n}", "comment": "return the number of nodes in the is way", "label": "property"}
{"id": "5252", "raw_code": "public static EjbJarXmlVersion valueOf(DocumentType docType) throws NullPointerException {\n  return valueOf(docType.getPublicId());\n}", "comment": "returns the version corresponding to the given document type .", "label": "property"}
{"id": "30710", "raw_code": "private FastConcurrentSkipListMap.Node<K,V> loNode(){\n  if (lo == null)   return m.findFirst();\n else   if (loInclusive)   return m.findNear(lo,m.GT | m.EQ);\n else   return m.findNear(lo,m.GT);\n}", "comment": "returns lowest node .", "label": "property"}
{"id": "13", "raw_code": "public static byte[] asUnsignedByteArray(BigInteger value){\n  byte[] bytes=value.toByteArray();\n  if (bytes[0] == 0) {\n    byte[] tmp=new byte[bytes.length - 1];\n    System.arraycopy(bytes,1,tmp,0,tmp.length);\n    return tmp;\n  }\n  return bytes;\n}", "comment": "return the passed in value as an unsigned byte array .", "label": "property"}
{"id": "80592", "raw_code": "protected List<URI> load(final InputStream in) throws SAXException, IOException {\n  SAXParser saxParser;\n  final SAXParserFactory factory=SAXParserFactory.newInstance();\n  try {\n    saxParser=factory.newSAXParser();\n  }\n catch (  final ParserConfigurationException ex) {\n    throw new SAXException(ex);\n  }\n  groups=new LinkedList<URI>();\n  saxParser.parse(in,this);\n  return groups;\n}", "comment": "load and returns the list of files .", "label": "property"}
{"id": "60650", "raw_code": "private static List<Object> createEqualityKey(Node node){\n  List<Object> values=new ArrayList<Object>();\n  values.add(node.getNodeType());\n  values.add(node.getNodeName());\n  values.add(node.getLocalName());\n  values.add(node.getNamespaceURI());\n  values.add(node.getPrefix());\n  values.add(node.getNodeValue());\n  for (Node child=node.getFirstChild(); child != null; child=child.getNextSibling()) {\n    values.add(child);\n  }\nswitch (node.getNodeType()) {\ncase DOCUMENT_TYPE_NODE:\n    DocumentTypeImpl doctype=(DocumentTypeImpl)node;\n  values.add(doctype.getPublicId());\nvalues.add(doctype.getSystemId());\nvalues.add(doctype.getInternalSubset());\nvalues.add(doctype.getEntities());\nvalues.add(doctype.getNotations());\nbreak;\ncase ELEMENT_NODE:\nElement element=(Element)node;\nvalues.add(element.getAttributes());\nbreak;\n}\nreturn values;\n}", "comment": "returns a list of objects such that two nodes are equal if their lists are equal .", "label": "property"}
{"id": "38234", "raw_code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> newVector=new Vector<Option>(3);\n  newVector.addElement(new Option(\"\\tSets the attribute index.\",\"C\",1,\"-C <col>\"));\n  newVector.addElement(new Option(\"\\tSpecify the list of values to indicate. First and last are\\n\" + \"\\tvalid indexes (default last)\",\"V\",1,\"-V <index1,index2-index4,...>\"));\n  newVector.addElement(new Option(\"\\tSet if new boolean attribute nominal.\",\"N\",0,\"-N <index>\"));\n  return newVector.elements();\n}", "comment": "returns an enumeration describing the available options .", "label": "property"}
{"id": "27949", "raw_code": "public static double sampleSkewStandardError(int size){\n  int n=size;\n  return Math.sqrt(6.0 * n * (n - 1) / ((n - 2) * (n + 1) * (n + 3)));\n}", "comment": "return the standard error of the sample skew .", "label": "property"}
{"id": "46067", "raw_code": "MarkerSegment findMarkerSegment(Class cls,boolean first){\n  if (first) {\n    Iterator iter=markerSequence.iterator();\n    while (iter.hasNext()) {\n      MarkerSegment seg=(MarkerSegment)iter.next();\n      if (cls.isInstance(seg)) {\n        return seg;\n      }\n    }\n  }\n else {\n    ListIterator iter=markerSequence.listIterator(markerSequence.size());\n    while (iter.hasPrevious()) {\n      MarkerSegment seg=(MarkerSegment)iter.previous();\n      if (cls.isInstance(seg)) {\n        return seg;\n      }\n    }\n  }\n  return null;\n}", "comment": "returns the first or last markersegment object in the list of the given class , or null if none is found .", "label": "property"}
{"id": "29985", "raw_code": "public static final double calcNiceNumber(final double RANGE,final boolean ROUND){\n  double niceFraction;\n  double exponent=Math.floor(Math.log10(RANGE));\n  double fraction=RANGE / Math.pow(10,exponent);\n  if (ROUND) {\n    if (Double.compare(fraction,1.5) < 0) {\n      niceFraction=1;\n    }\n else     if (Double.compare(fraction,3) < 0) {\n      niceFraction=2;\n    }\n else     if (Double.compare(fraction,7) < 0) {\n      niceFraction=5;\n    }\n else {\n      niceFraction=10;\n    }\n  }\n else {\n    if (Double.compare(fraction,1) <= 0) {\n      niceFraction=1;\n    }\n else     if (Double.compare(fraction,2) <= 0) {\n      niceFraction=2;\n    }\n else     if (Double.compare(fraction,5) <= 0) {\n      niceFraction=5;\n    }\n else {\n      niceFraction=10;\n    }\n  }\n  return niceFraction * Math.pow(10,exponent);\n}", "comment": "returns a \" nicescaling \" number approximately equal to the range .", "label": "property"}
{"id": "46969", "raw_code": "public boolean isSpecified(int index){\n  if ((index < 0) || (index >= mLength)) {\n    throw new ArrayIndexOutOfBoundsException(\"\");\n  }\n  String str=mItems[(index << 3) + 5];\n  return ((str != null) ? (str.charAt(0) == 'd') : true);\n}", "comment": "returns true unless the attribute value was provided by dtd defaulting .", "label": "property"}
{"id": "46345", "raw_code": "public boolean isExpanded(int row){\n  TreeUI tree=getUI();\n  if (tree != null) {\n    TreePath path=tree.getPathForRow(this,row);\n    if (path != null) {\n      Boolean value=expandedState.get(path);\n      return (value != null && value.booleanValue());\n    }\n  }\n  return false;\n}", "comment": "returns true if the node at the specified display row is currently expanded .", "label": "property"}
{"id": "71980", "raw_code": "private static LDAPFilter createORFilter(FilterSet filterSet) throws LDAPException, IOException {\n  List<JAXBElement<?>> list=filterSet.getFilterGroup();\n  ArrayList<RawFilter> filters=new ArrayList<>(list.size());\n  for (  JAXBElement<?> filter : list) {\n    filters.add(createFilter(filter));\n  }\n  return LDAPFilter.createORFilter(filters);\n}", "comment": "returns a new or search filter with the provided filter components .", "label": "property"}
{"id": "27485", "raw_code": "boolean thresholdExceeded(final Set<IBindingSet> distinctProjectionBuffer,final int distinctProjectionBufferThreshold,final List<IBindingSet> incomingBindingsBuffer,final int incomingBindingsBufferThreshold){\n  return distinctProjectionBuffer.size() >= distinctProjectionBufferThreshold || incomingBindingsBuffer.size() >= incomingBindingsBufferThreshold;\n}", "comment": "returns true if , for one of the buffers , the threshold has been exceeded .", "label": "property"}
{"id": "49156", "raw_code": "int maxLength(){\n  FontMetrics fm=getFontMetrics(getFont());\n  int m=0;\n  int end=items.size();\n  for (int i=0; i < end; i++) {\n    int l=fm.stringWidth(((String)items.elementAt(i)));\n    m=Math.max(m,l);\n  }\n  return m;\n}", "comment": "return the length of the largest item in the list", "label": "property"}
{"id": "48792", "raw_code": "public Object[] toArray(){\n  return Arrays.copyOf(elementData,size);\n}", "comment": "returns an array containing all of the elements in this list in proper sequence ( from first to last element ) .", "label": "property"}
{"id": "33745", "raw_code": "private static Object invokeOrDie(final Method method,final Object object,final Object... params){\n  try {\n    return method.invoke(object,params);\n  }\n catch (  IllegalAccessException e) {\n    throw new RuntimeException(\"Couldn't use Java reflection to implement protocol message \" + \"reflection.\",e);\n  }\ncatch (  InvocationTargetException e) {\n    final Throwable cause=e.getCause();\n    if (cause instanceof RuntimeException) {\n      throw (RuntimeException)cause;\n    }\n else     if (cause instanceof Error) {\n      throw (Error)cause;\n    }\n else {\n      throw new RuntimeException(\"Unexpected exception thrown by generated accessor method.\",cause);\n    }\n  }\n}", "comment": "calls invoke and throws a runtimeexception if it fails .", "label": "property"}
{"id": "49240", "raw_code": "private static byte[] WindowsRegEnumKeyEx1(int hKey,int subKeyIndex,int maxKeyLength){\n  byte[] result=WindowsRegEnumKeyEx(hKey,subKeyIndex,maxKeyLength);\n  if (result != null) {\n    return result;\n  }\n else {\n    long sleepTime=INIT_SLEEP_TIME;\n    for (int i=0; i < MAX_ATTEMPTS; i++) {\n      try {\n        Thread.sleep(sleepTime);\n      }\n catch (      InterruptedException e) {\n        return result;\n      }\n      sleepTime*=2;\n      result=WindowsRegEnumKeyEx(hKey,subKeyIndex,maxKeyLength);\n      if (result != null) {\n        return result;\n      }\n    }\n  }\n  return result;\n}", "comment": "retries regenumkeyex ( ) max _ attempts times before giving up .", "label": "property"}
{"id": "38842", "raw_code": "@Override public boolean connectionAllowed(String eventName){\n  if (m_listenee != null || !eventName.equals(\"instance\")) {\n    return false;\n  }\n  return true;\n}", "comment": "returns true if , at this time , the object will accept a connection with respect to the named event", "label": "property"}
{"id": "48100", "raw_code": "@Override public boolean isInitial(){\n  return init;\n}", "comment": "returns a boolean flag indicating if the state is initial ( just starting )", "label": "property"}
{"id": "8127", "raw_code": "public static String denormalize(final CharSequence self){\n  if (lineSeparator == null) {\n    final StringWriter sw=new StringWriter(2);\n    try {\n      final BufferedWriter bw=new BufferedWriter(sw);\n      bw.newLine();\n      bw.flush();\n      lineSeparator=sw.toString();\n    }\n catch (    IOException ioe) {\n      lineSeparator=\"\\n\";\n    }\n  }\n  final int len=self.length();\n  if (len < 1) {\n    return self.toString();\n  }\n  final StringBuilder sb=new StringBuilder((110 * len) / 100);\n  int i=0;\n  CharSequence cs=(self instanceof GString) ? self.toString() : self;\n  while (i < len) {\n    final char ch=cs.charAt(i++);\nswitch (ch) {\ncase '\\r':\n      sb.append(lineSeparator);\n    if ((i < len) && (cs.charAt(i) == '\\n')) {\n      ++i;\n    }\n  break;\ncase '\\n':\nsb.append(lineSeparator);\nbreak;\ndefault :\nsb.append(ch);\nbreak;\n}\n}\nreturn sb.toString();\n}", "comment": "return a charsequence with lines ( separated by lf , cr / lf , or cr ) terminated by the platform specific line separator .", "label": "property"}
{"id": "48427", "raw_code": "public boolean isAborted(){\n  return isAborted.get();\n}", "comment": "returns whether the printng was aborted using this printingstatus", "label": "property"}
{"id": "60880", "raw_code": "public boolean find(int start){\n  if (start < 0 || start > input.length()) {\n    throw new IndexOutOfBoundsException(\"start=\" + start + \"; length=\"+ input.length());\n  }\nsynchronized (this) {\n    matchFound=findImpl(address,input,start,matchOffsets);\n  }\n  return matchFound;\n}", "comment": "returns true if there is another match in the input , starting from the given position .", "label": "property"}
{"id": "54391", "raw_code": "public static long firstFieldOffset(Class clazz){\n  long minSize=roundUpTo8(headerSize(clazz));\n  while (clazz != Object.class) {\n    for (    Field f : clazz.getDeclaredFields()) {\n      if ((f.getModifiers() & Modifier.STATIC) == 0) {\n        long offset=unsafe.objectFieldOffset(f);\n        if (offset < minSize) {\n          minSize=offset;\n        }\n      }\n    }\n    clazz=clazz.getSuperclass();\n  }\n  return minSize;\n}", "comment": "returns the offset of the first field in the range [ headersize , sizeof ] .", "label": "property"}
{"id": "47123", "raw_code": "public final void quietlyJoin(){\n  doJoin();\n}", "comment": "joins this task , without returning its result or throwing its exception .", "label": "property"}
{"id": "60790", "raw_code": "private E awaitMatch(Node s,Node pred,E e,boolean timed,long nanos){\n  final long deadline=timed ? System.nanoTime() + nanos : 0L;\n  Thread w=Thread.currentThread();\n  int spins=-1;\n  ThreadLocalRandom randomYields=null;\n  for (; ; ) {\n    Object item=s.item;\n    if (item != e) {\n      s.forgetContents();\n      return LinkedTransferQueue.<E>cast(item);\n    }\n    if ((w.isInterrupted() || (timed && nanos <= 0)) && s.casItem(e,s)) {\n      unsplice(pred,s);\n      return e;\n    }\n    if (spins < 0) {\n      if ((spins=spinsFor(pred,s.isData)) > 0)       randomYields=ThreadLocalRandom.current();\n    }\n else     if (spins > 0) {\n      --spins;\n      if (randomYields.nextInt(CHAINED_SPINS) == 0)       Thread.yield();\n    }\n else     if (s.waiter == null) {\n      s.waiter=w;\n    }\n else     if (timed) {\n      nanos=deadline - System.nanoTime();\n      if (nanos > 0L)       LockSupport.parkNanos(this,nanos);\n    }\n else {\n      LockSupport.park(this);\n    }\n  }\n}", "comment": "spins / yields / blocks until node s is matched or caller gives up .", "label": "property"}
{"id": "4053", "raw_code": "private <T>BindingAmp<T> findObjectBinding(Key<T> key){\n  Objects.requireNonNull(key);\n  if (key.qualifiers().length != 1) {\n    throw new IllegalArgumentException();\n  }\n  return (BindingAmp)findBinding(Key.of(Object.class,key.qualifiers()[0]));\n}", "comment": "returns an object producer .", "label": "property"}
{"id": "17900", "raw_code": "public boolean isEmpty(){\n  return extOrdering.isEmpty();\n}", "comment": "return true if there are no extension present in this generator .", "label": "property"}
{"id": "44944", "raw_code": "public String random(Object omin,Object omax){\n  int min=FunctionHandler.getInt(omin);\n  int max=FunctionHandler.getInt(omax);\n  if (max > min) {\n    return Integer.toString(rnd.nextInt(max - min) + min);\n  }\n  return \"0\";\n}", "comment": "returns a random number between min ( inclusive ) and max ( exclusive )", "label": "property"}
{"id": "85378", "raw_code": "public static File searchPaths(Iterable<? extends File> paths,String relFile){\n  for (  File path : paths) {\n    File f=new File(path,relFile);\n    if (f.exists()) {\n      return path;\n    }\n  }\n  return null;\n}", "comment": "given a relative file path and a list of \" search paths \" returns the search path where the file was located", "label": "property"}
{"id": "17946", "raw_code": "public boolean hasUnsupportedCriticalExtension(){\n  Set extns=getCriticalExtensionOIDs();\n  return extns != null && !extns.isEmpty();\n}", "comment": "will return true if any extensions are present and marked as critical as we currently don ' t handle any extensions !", "label": "property"}
{"id": "57713", "raw_code": "static String pathToCookiePath(String path){\n  if (path == null) {\n    return \"/\";\n  }\n  int lastSlash=path.lastIndexOf('/');\n  return path.substring(0,lastSlash + 1);\n}", "comment": "returns a cookie - safe path by truncating everything after the last \" / \" .", "label": "property"}
{"id": "86184", "raw_code": "public static String formatSimpleDecimal(double d){\n  return simpleFormat.format(d);\n}", "comment": "returns string from double formatted to decimalformat ( \" # # # . # # \" )", "label": "property"}
{"id": "47026", "raw_code": "@Override public int hashCode(){\n  if (location != null)   return location.hashCode();\n else   return 0;\n}", "comment": "returns the hash code value for this object .", "label": "property"}
{"id": "14245", "raw_code": "public static Subject createAMIdentitySubject(PolicyManager pm,AMIdentity user) throws PolicyException {\n  SubjectTypeManager mgr=pm.getSubjectTypeManager();\n  Subject subject=mgr.getSubject(\"AMIdentitySubject\");\n  Set<String> set=new HashSet<String>();\n  set.add(user.getUniversalId());\n  subject.setValues(set);\n  return subject;\n}", "comment": "returns a subject for the given amidentity .", "label": "property"}
{"id": "75585", "raw_code": "private String excludeDestinationStatement(String text){\n  int idx=-1;\n  if ((idx=text.indexOf(\"Destination will be\")) != -1) {\n    text=text.substring(0,idx);\n  }\n  return text;\n}", "comment": "parses the specified string to return the portion not containing the destination statement .", "label": "property"}
{"id": "48603", "raw_code": "public IntBuffer majorVersionBuffer(){\n  int[] holder=new int[1];\n  holder[0]=getMajorVersion();\n  IntBuffer ib=IntBuffer.wrap(holder);\n  ib.limit(1);\n  return ib;\n}", "comment": "return an intbuffer that accesses the major version number .", "label": "property"}
{"id": "62630", "raw_code": "public static String slurpURLNoExceptions(URL u,String encoding){\n  try {\n    return slurpURL(u,encoding);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    return null;\n  }\n}", "comment": "returns all the text at the given url .", "label": "property"}
{"id": "17248", "raw_code": "public static String of(CtClass type){\n  StringBuffer sbuf=new StringBuffer();\n  toDescriptor(sbuf,type);\n  return sbuf.toString();\n}", "comment": "returns the descriptor representing the given type .", "label": "property"}
{"id": "85402", "raw_code": "public List<String> reset(List<String> replace){\n  ArrayList<String> copy=new ArrayList<String>(retainedVars.size());\n  copy.addAll(retainedVars);\n  retainedVars.clear();\n  if (replace != null) {\n    retainedVars.addAll(replace);\n  }\n  return copy;\n}", "comment": "replaces the list of retained vars with the specified list , returning the old list .", "label": "property"}
{"id": "601", "raw_code": "public int numHits(String query) throws ParseException, IOException {\n  Integer count;\n  if ((count=(Integer)m_hitCountCache.get(query)) == null) {\n    Hits hits=search(query);\n    count=new Integer(hits.length());\n    m_hitCountCache.put(query,count);\n  }\n  return count.intValue();\n}", "comment": "return the result count for the given search query .", "label": "property"}
{"id": "81460", "raw_code": "public static String extractIndentString(String line,int tabWidth,int indentWidth){\n  if (tabWidth < 0 || indentWidth < 0 || line == null) {\n    throw new IllegalArgumentException();\n  }\n  int size=line.length();\n  int end=0;\n  int spaceEquivs=0;\n  int characters=0;\n  for (int i=0; i < size; i++) {\n    char c=line.charAt(i);\n    if (c == '\\t') {\n      spaceEquivs=calculateSpaceEquivalents(tabWidth,spaceEquivs);\n      characters++;\n    }\n else     if (isIndentChar(c)) {\n      spaceEquivs++;\n      characters++;\n    }\n else {\n      break;\n    }\n    if (spaceEquivs >= indentWidth) {\n      end+=characters;\n      characters=0;\n      if (indentWidth == 0) {\n        spaceEquivs=0;\n      }\n else {\n        spaceEquivs=spaceEquivs % indentWidth;\n      }\n    }\n  }\n  if (end == 0) {\n    return Util.EMPTY_STRING;\n  }\n else   if (end == size) {\n    return line;\n  }\n else {\n    return line.substring(0,end);\n  }\n}", "comment": "returns the leading indentation string of the given line .", "label": "property"}
{"id": "8781", "raw_code": "@LayoutlibDelegate static float sin(float angle){\n  return (float)Math.sin(angle);\n}", "comment": "returns the closest float approximation of the sine of the argument .", "label": "property"}
{"id": "41329", "raw_code": "public boolean checkRootBySuperUserApk(){\n  File suApk=new File(SU_APK);\n  if (suApk != null && suApk.exists()) {\n    return true;\n  }\n  return false;\n}", "comment": "returns true if the device contains superuser . apk which is stored into the device in the rooting process .", "label": "property"}
{"id": "86966", "raw_code": "public EMail createEMail(String value){\n  EmailField emailImpl=new EmailField();\n  try {\n    emailImpl.setValue(value);\n  }\n catch (  SdpException s) {\n    s.printStackTrace();\n  }\n  return emailImpl;\n}", "comment": "returns email object with the specified value .", "label": "property"}
{"id": "81487", "raw_code": "@Override protected String extractKey(final String name){\n  final String key=unescape(name.substring(0,name.length() - 4));\n  return key.equals(\"\\0\") ? null : key;\n}", "comment": "given a filename , the unescape method returns the key which originated it .", "label": "property"}
{"id": "902", "raw_code": "private static float spacing(MotionEvent event){\n  float x=event.getX(0) - event.getX(1);\n  float y=event.getY(0) - event.getY(1);\n  return (float)Math.sqrt(x * x + y * y);\n}", "comment": "returns the distance between two pointer touch points", "label": "property"}
{"id": "69208", "raw_code": "public static final byte[] unzip(byte[] in) throws IOException {\n  ByteArrayOutputStream outStream=new ByteArrayOutputStream(EXPECTED_COMPRESSION_RATIO * in.length);\n  GZIPInputStream inStream=new GZIPInputStream(new ByteArrayInputStream(in));\n  byte[] buf=new byte[BUF_SIZE];\n  while (true) {\n    int size=inStream.read(buf);\n    if (size <= 0)     break;\n    outStream.write(buf,0,size);\n  }\n  outStream.close();\n  return outStream.toByteArray();\n}", "comment": "returns an gunzipped copy of the input array .", "label": "property"}
{"id": "27492", "raw_code": "private static String indent(final int height){\n  return CoreBaseBOp.indent(height);\n}", "comment": "returns a string that may be used to indent a dump of the nodes in the tree .", "label": "property"}
{"id": "44738", "raw_code": "public static boolean isCommand(IElementType type){\n  return type == SQFTypes.COMMAND_TOKEN || type == SQFTypes.COMMAND || type == SQFTypes.CASE || type == SQFTypes.CASE_COMMAND;\n}", "comment": "return true if the given type refers to a command , false otherwise", "label": "property"}
{"id": "8800", "raw_code": "@LayoutlibDelegate static long currentThreadTimeMillis(){\n  return System.currentTimeMillis();\n}", "comment": "returns milliseconds running in the current thread .", "label": "property"}
{"id": "66787", "raw_code": "public boolean longLabel(){\n  return fState.longLabel;\n}", "comment": "returns true if long labels are uses in the indicator display .", "label": "property"}
{"id": "25280", "raw_code": "private boolean decodeHandshake(ByteBuffer socketBufferNew){\n  ByteBuffer socketBuffer;\n  if (tmpHandshakeBytes.capacity() == 0) {\n    socketBuffer=socketBufferNew;\n  }\n else {\n    if (tmpHandshakeBytes.remaining() < socketBufferNew.remaining()) {\n      ByteBuffer buf=ByteBuffer.allocate(tmpHandshakeBytes.capacity() + socketBufferNew.remaining());\n      tmpHandshakeBytes.flip();\n      buf.put(tmpHandshakeBytes);\n      tmpHandshakeBytes=buf;\n    }\n    tmpHandshakeBytes.put(socketBufferNew);\n    tmpHandshakeBytes.flip();\n    socketBuffer=tmpHandshakeBytes;\n  }\n  socketBuffer.mark();\n  try {\n    if (draft == null) {\n      HandshakeState isflashedgecase=isFlashEdgeCase(socketBuffer);\n      if (isflashedgecase == HandshakeState.MATCHED) {\n        try {\n          write(ByteBuffer.wrap(Charsetfunctions.utf8Bytes(wsl.getFlashPolicy(this))));\n          close(CloseFrame.FLASHPOLICY,\"\");\n        }\n catch (        InvalidDataException e) {\n          close(CloseFrame.ABNORMAL_CLOSE,\"remote peer closed connection before flashpolicy could be transmitted\",true);\n        }\n        return false;\n      }\n    }\n    HandshakeState handshakestate=null;\n    try {\n      if (role == Role.SERVER) {\n        if (draft == null) {\n          for (          Draft d : knownDrafts) {\n            d=d.copyInstance();\n            try {\n              d.setParseMode(role);\n              socketBuffer.reset();\n              Handshakedata tmphandshake=d.translateHandshake(socketBuffer);\n              if (tmphandshake instanceof ClientHandshake == false) {\n                flushAndClose(CloseFrame.PROTOCOL_ERROR,\"wrong http function\",false);\n                return false;\n              }\n              ClientHandshake handshake=(ClientHandshake)tmphandshake;\n              handshakestate=d.acceptHandshakeAsServer(handshake);\n              if (handshakestate == HandshakeState.MATCHED) {\n                resourceDescriptor=handshake.getResourceDescriptor();\n                ServerHandshakeBuilder response;\n                try {\n                  response=wsl.onWebsocketHandshakeReceivedAsServer(this,d,handshake);\n                }\n catch (                InvalidDataException e) {\n                  flushAndClose(e.getCloseCode(),e.getMessage(),false);\n                  return false;\n                }\ncatch (                RuntimeException e) {\n                  wsl.onWebsocketError(this,e);\n                  flushAndClose(CloseFrame.NEVER_CONNECTED,e.getMessage(),false);\n                  return false;\n                }\n                write(d.createHandshake(d.postProcessHandshakeResponseAsServer(handshake,response),role));\n                draft=d;\n                open(handshake);\n                return true;\n              }\n            }\n catch (            InvalidHandshakeException e) {\n            }\n          }\n          if (draft == null) {\n            close(CloseFrame.PROTOCOL_ERROR,\"no draft matches\");\n          }\n          return false;\n        }\n else {\n          Handshakedata tmphandshake=draft.translateHandshake(socketBuffer);\n          if (tmphandshake instanceof ClientHandshake == false) {\n            flushAndClose(CloseFrame.PROTOCOL_ERROR,\"wrong http function\",false);\n            return false;\n          }\n          ClientHandshake handshake=(ClientHandshake)tmphandshake;\n          handshakestate=draft.acceptHandshakeAsServer(handshake);\n          if (handshakestate == HandshakeState.MATCHED) {\n            open(handshake);\n            return true;\n          }\n else {\n            close(CloseFrame.PROTOCOL_ERROR,\"the handshake did finaly not match\");\n          }\n          return false;\n        }\n      }\n else       if (role == Role.CLIENT) {\n        draft.setParseMode(role);\n        Handshakedata tmphandshake=draft.translateHandshake(socketBuffer);\n        if (tmphandshake instanceof ServerHandshake == false) {\n          flushAndClose(CloseFrame.PROTOCOL_ERROR,\"wrong http function\",false);\n          return false;\n        }\n        ServerHandshake handshake=(ServerHandshake)tmphandshake;\n        handshakestate=draft.acceptHandshakeAsClient(handshakerequest,handshake);\n        if (handshakestate == HandshakeState.MATCHED) {\n          try {\n            wsl.onWebsocketHandshakeReceivedAsClient(this,handshakerequest,handshake);\n          }\n catch (          InvalidDataException e) {\n            flushAndClose(e.getCloseCode(),e.getMessage(),false);\n            return false;\n          }\ncatch (          RuntimeException e) {\n            wsl.onWebsocketError(this,e);\n            flushAndClose(CloseFrame.NEVER_CONNECTED,e.getMessage(),false);\n            return false;\n          }\n          open(handshake);\n          return true;\n        }\n else {\n          close(CloseFrame.PROTOCOL_ERROR,\"draft \" + draft + \" refuses handshake\");\n        }\n      }\n    }\n catch (    InvalidHandshakeException e) {\n      close(e);\n    }\n  }\n catch (  IncompleteHandshakeException e) {\n    if (tmpHandshakeBytes.capacity() == 0) {\n      socketBuffer.reset();\n      int newsize=e.getPreferedSize();\n      if (newsize == 0) {\n        newsize=socketBuffer.capacity() + 16;\n      }\n else {\n        assert (e.getPreferedSize() >= socketBuffer.remaining());\n      }\n      tmpHandshakeBytes=ByteBuffer.allocate(newsize);\n      tmpHandshakeBytes.put(socketBufferNew);\n    }\n else {\n      tmpHandshakeBytes.position(tmpHandshakeBytes.limit());\n      tmpHandshakeBytes.limit(tmpHandshakeBytes.capacity());\n    }\n  }\n  return false;\n}", "comment": "returns whether the handshake phase has is completed .", "label": "property"}
{"id": "29520", "raw_code": "public static Map<String,String> allNamespaces(SOAPElement ele){\n  Map<String,String> nsList=new TreeMap<String,String>();\n  log.trace(\"Starting Namespace Lookup in \" + ele.getNodeName());\n  allNamespaces(ele,nsList);\n  log.trace(\"Namespace Lookup done: \" + nsList);\n  return nsList;\n}", "comment": "returns a list of all namespaces below an element ( recursive )", "label": "property"}
{"id": "37690", "raw_code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> newVector=new Vector<Option>(4);\n  newVector.addElement(new Option(\"\\tTabu list length\",\"L\",1,\"-L <integer>\"));\n  newVector.addElement(new Option(\"\\tNumber of runs\",\"U\",1,\"-U <integer>\"));\n  newVector.addElement(new Option(\"\\tMaximum number of parents\",\"P\",1,\"-P <nr of parents>\"));\n  newVector.addElement(new Option(\"\\tUse arc reversal operation.\\n\\t(default false)\",\"R\",0,\"-R\"));\n  newVector.addAll(Collections.list(super.listOptions()));\n  return newVector.elements();\n}", "comment": "returns an enumeration describing the available options .", "label": "property"}
{"id": "55845", "raw_code": "public final ArrayList<Move> removeNonOptimal(Position pos,ArrayList<Move> moveList){\n  ArrayList<Move> optimalMoves=new ArrayList<Move>();\n  ArrayList<Move> unknownMoves=new ArrayList<Move>();\n  final int MATE0=100000;\n  int bestScore=-1000000;\n  UndoInfo ui=new UndoInfo();\n  for (  Move m : moveList) {\n    pos.makeMove(m,ui);\n    int pliesToDraw=Math.max(100 - pos.halfMoveClock,1);\n    GtbProbeResult res=gtbProbe(pos);\n    pos.unMakeMove(m,ui);\n    if (res.result == GtbProbeResult.UNKNOWN) {\n      unknownMoves.add(m);\n    }\n else {\n      int wScore;\n      if (res.result == GtbProbeResult.WMATE) {\n        if (res.pliesToMate <= pliesToDraw)         wScore=MATE0 - res.pliesToMate;\n else         wScore=1;\n      }\n else       if (res.result == GtbProbeResult.BMATE) {\n        if (res.pliesToMate <= pliesToDraw)         wScore=-(MATE0 - res.pliesToMate);\n else         wScore=-1;\n      }\n else {\n        wScore=0;\n      }\n      int score=pos.whiteMove ? wScore : -wScore;\n      if (score > bestScore) {\n        optimalMoves.clear();\n        optimalMoves.add(m);\n        bestScore=score;\n      }\n else       if (score == bestScore) {\n        optimalMoves.add(m);\n      }\n else {\n      }\n    }\n  }\n  for (  Move m : unknownMoves)   optimalMoves.add(m);\n  return (optimalMoves.size() < moveList.size()) ? optimalMoves : null;\n}", "comment": "return a list of all moves in movelist that are not known to be non - optimal .", "label": "property"}
{"id": "17706", "raw_code": "public MatchResult match(){\n  if (!matchSuccessful) {\n    throw new IllegalStateException();\n  }\n  return matcher.toMatchResult();\n}", "comment": "returns the result of the last matching operation .", "label": "property"}
{"id": "47612", "raw_code": "@CallerSensitive public Class<?> forClass(){\n  if (cl == null) {\n    return null;\n  }\n  requireInitialized();\n  if (System.getSecurityManager() != null) {\n    Class<?> caller=Reflection.getCallerClass();\n    if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(),cl.getClassLoader())) {\n      ReflectUtil.checkPackageAccess(cl);\n    }\n  }\n  return cl;\n}", "comment": "return the class in the local vm that this version is mapped to .", "label": "property"}
{"id": "61943", "raw_code": "@Override public int length(){\n  return set.size();\n}", "comment": "returns the set length", "label": "property"}
{"id": "35454", "raw_code": "private E unlinkLast(){\n  Node<E> l=last;\n  if (l == null)   return null;\n  Node<E> p=l.prev;\n  E item=l.item;\n  l.item=null;\n  l.prev=l;\n  last=p;\n  if (p == null)   first=null;\n else   p.next=null;\n  --count;\n  notFull.signal();\n  return item;\n}", "comment": "removes and returns last element , or null if empty .", "label": "property"}
{"id": "15738", "raw_code": "public int length(){\n  return text.length();\n}", "comment": "retruns the length of the text .", "label": "property"}
{"id": "20649", "raw_code": "public Pair<Integer,List<Long>> next(){\n  try {\n    classesProcessed++;\n    Integer key=iterator.next();\n    long pos=classificationBlockRMA2.getPos(key);\n    int count=classificationBlockRMA2.getSum(key);\n    classDumpReader.seek(pos);\n    List<Long> list=new LinkedList<>();\n    for (int i=0; i < count; i++)     list.add(classDumpReader.readLong());\n    return new Pair<>(key,list);\n  }\n catch (  Exception e) {\n    Basic.caught(e);\n    error=true;\n    return null;\n  }\n}", "comment": "returns the next element in the iteration .", "label": "property"}
{"id": "47058", "raw_code": "private Node<K,V> findNode(Object key){\n  if (key == null)   throw new NullPointerException();\n  Comparator<? super K> cmp=comparator;\n  outer:   for (; ; ) {\n    for (Node<K,V> b=findPredecessor(key,cmp), n=b.next; ; ) {\n      Object v;\n      int c;\n      if (n == null)       break outer;\n      Node<K,V> f=n.next;\n      if (n != b.next)       break;\n      if ((v=n.value) == null) {\n        n.helpDelete(b,f);\n        break;\n      }\n      if (b.value == null || v == n)       break;\n      if ((c=cpr(cmp,key,n.key)) == 0)       return n;\n      if (c < 0)       break outer;\n      b=n;\n      n=f;\n    }\n  }\n  return null;\n}", "comment": "returns node holding key or null if no such , clearing out any deleted nodes seen along the way .", "label": "property"}
{"id": "19570", "raw_code": "@NotNull private Optional<TypeConversion> findConversionFromDbValue(@NotNull Type source,@NotNull Type target){\n  if (isAssignable(target,source))   return Optional.of(TypeConversion.identity());\n  Optional<TypeConversion> directConversion=typeConversionRegistry.findConversionFromDbValue(source,target);\n  if (directConversion.isPresent())   return directConversion;\n  Optional<TypeConversion> arrayConversion=findArrayConversion(source,target);\n  if (arrayConversion.isPresent())   return arrayConversion;\n  Optional<TypeConversion> optionalConversion=findOptionalConversion(source,target);\n  if (optionalConversion.isPresent())   return optionalConversion;\n  Optional<TypeConversion> enumConversion=findEnumConversion(target);\n  if (enumConversion.isPresent())   return enumConversion;\n  return Optional.empty();\n}", "comment": "returns conversion for converting value of source to target , or returns null if there ' s no such conversion .", "label": "property"}
{"id": "29747", "raw_code": "public static String createHash(String password) throws NoSuchAlgorithmException, InvalidKeySpecException {\n  return createHash(password.toCharArray());\n}", "comment": "returns a salted pbkdf2 hash of the password .", "label": "property"}
{"id": "47812", "raw_code": "public int hashCode(){\n  long bits=Double.doubleToLongBits(m00);\n  bits=bits * 31 + Double.doubleToLongBits(m01);\n  bits=bits * 31 + Double.doubleToLongBits(m02);\n  bits=bits * 31 + Double.doubleToLongBits(m10);\n  bits=bits * 31 + Double.doubleToLongBits(m11);\n  bits=bits * 31 + Double.doubleToLongBits(m12);\n  return (((int)bits) ^ ((int)(bits >> 32)));\n}", "comment": "returns the hashcode for this transform .", "label": "property"}
{"id": "80933", "raw_code": "public long next(){\n  long result=-1l;\n  if (cache < 0L && bufferElements > 0) {\n    result=getNextFromBuffer();\n    bufferElements--;\n  }\n else {\n    result=cache;\n    cache=-1L;\n  }\n  if (!cs.isEmpty()) {\n    long first=cs.first();\n    if (result > first || result == -1L) {\n      cs.remove(first);\n      cache=result;\n      result=first;\n    }\n  }\n  if (result == -1L) {\n    throw new NoSuchElementException();\n  }\n  Assert.check(previous < result,EC.GENERAL);\n  previous=result;\n  readElements++;\n  return result;\n}", "comment": "returns the next element in the iteration .", "label": "property"}
{"id": "78277", "raw_code": "public boolean isSetQueueSize(){\n  return __isset_bit_vector.get(__QUEUESIZE_ISSET_ID);\n}", "comment": "returns true if field queuesize is set ( has been assigned a value ) and false otherwise", "label": "property"}
{"id": "6972", "raw_code": "static public final int random(int start,int end){\n  return start + random.nextInt(end - start + 1);\n}", "comment": "returns a random number between start ( inclusive ) and end ( inclusive ) .", "label": "property"}
{"id": "27163", "raw_code": "private static URI refragUri(URI uri,String frag) throws URISyntaxException {\n  return new URI(uri.getScheme(),uri.getSchemeSpecificPart(),frag);\n}", "comment": "return a new uri with a different fragment .", "label": "property"}
{"id": "70927", "raw_code": "public final boolean isCancelled(){\n  if (cancelled) {\n    pass(\"cancelled\",cancelled);\n  }\n else {\n    fail(\"cancelled\");\n  }\n  return cancelled;\n}", "comment": "returns true if this testsubscriber has been cancelled .", "label": "property"}
{"id": "38801", "raw_code": "@Override public boolean eventGeneratable(String eventName){\n  if (m_listenee == null) {\n    return false;\n  }\n  if (!eventName.equals(\"instance\") && !eventName.equals(\"dataSet\")) {\n    return false;\n  }\n  if (m_listenee instanceof DataSource) {\n    if (m_listenee instanceof EventConstraints) {\n      EventConstraints ec=(EventConstraints)m_listenee;\n      return ec.eventGeneratable(eventName);\n    }\n  }\n  if (m_listenee instanceof TrainingSetProducer) {\n    if (m_listenee instanceof EventConstraints) {\n      EventConstraints ec=(EventConstraints)m_listenee;\n      if (!eventName.equals(\"dataSet\")) {\n        return false;\n      }\n      if (!ec.eventGeneratable(\"trainingSet\")) {\n        return false;\n      }\n    }\n  }\n  if (m_listenee instanceof TestSetProducer) {\n    if (m_listenee instanceof EventConstraints) {\n      EventConstraints ec=(EventConstraints)m_listenee;\n      if (!eventName.equals(\"dataSet\")) {\n        return false;\n      }\n      if (!ec.eventGeneratable(\"testSet\")) {\n        return false;\n      }\n    }\n  }\n  return true;\n}", "comment": "returns true if , at the current time , the named event could be generated .", "label": "property"}
{"id": "10464", "raw_code": "public Builder untilDate(Date date){\n  untilDate=QUERY_DATE.format(date);\n  return this;\n}", "comment": "returns tweets generated before the given date .", "label": "property"}
{"id": "63605", "raw_code": "@Override public boolean canBeCollidedWith(){\n  return true;\n}", "comment": "returns true if other entities should be prevented from moving through this entity .", "label": "property"}
{"id": "52911", "raw_code": "private double[] max(double[] distances1,double[] distances2){\n  if (distances1.length != distances2.length) {\n    throw new RuntimeException(\"different lengths!\");\n  }\n  double[] result=new double[distances1.length];\n  for (int i=0; i < distances1.length; i++) {\n    result[i]=Math.max(distances1[i],distances2[i]);\n  }\n  return result;\n}", "comment": "returns an array that holds the maximum values of the both specified arrays in each index .", "label": "property"}
{"id": "61863", "raw_code": "public static <T>UnaryOperator<List<T>> from(Collection<String> commandLineUdids,Function<T,ICloud.MBSBackup> mbsBackup,Function<ICloud.MBSBackup,String> formatter,Printer out,InputStream in){\n  return commandLineUdids.isEmpty() ? new User(mbsBackup,out,in,formatter) : new Udid(mbsBackup,out,in,new ArrayList<>(commandLineUdids));\n}", "comment": "returns a new instance .", "label": "property"}
{"id": "85424", "raw_code": "public static List<String> expandWildcards(Iterable<File> dirs,List<String> names,Backend forBackend){\n  List<String> result=new ArrayList<String>(names.size());\n  for (  String name : names) {\n    expandWildcard(result,dirs,name,forBackend);\n  }\n  return result;\n}", "comment": "given a list of source directories and a list of module names that possibly contain wildcards it returns a expanded list of module names of modules that were actually found in the given source directories .", "label": "property"}
{"id": "44706", "raw_code": "public Matcher next() throws IOException {\n  readahead();\n  if (matches == null) {\n    throw new NoSuchElementException();\n  }\n  Matcher matcher=matches.next();\n  if (discard) {\n    Pattern pattern=matcher.pattern();\n    for (int n=0; n < patterns.length; n++) {\n      if (patterns[n] == pattern) {\n        patterns[n]=null;\n        break;\n      }\n    }\n  }\n  return matcher;\n}", "comment": "returns the next match from the character stream .", "label": "property"}
{"id": "23173", "raw_code": "public boolean hasNameValue(String name){\n  return nameValueMap.containsKey(name.toLowerCase());\n}", "comment": "returns a boolean telling if this namevaluelist has a record with this name", "label": "property"}
{"id": "71020", "raw_code": "public static String stringOfChar(char ch,int count){\n  StringBuffer buf=new StringBuffer();\n  for (int i=0; i < count; i++) {\n    buf.append(ch);\n  }\n  return buf.toString();\n}", "comment": "returns a string of the given length consisting entirely of the given character", "label": "property"}
{"id": "67666", "raw_code": "public int countIn(CharSequence sequence){\n  int count=0;\n  for (int i=0; i < sequence.length(); i++) {\n    if (matches(sequence.charAt(i))) {\n      count++;\n    }\n  }\n  return count;\n}", "comment": "returns the number of matching characters found in a character sequence .", "label": "property"}
{"id": "56201", "raw_code": "public boolean isRunning(){\n  return this.running;\n}", "comment": "return whether the stop watch is currently running .", "label": "property"}
{"id": "22904", "raw_code": "public OsmElement pasteFrom(){\n  List<Way> ways=storage.getWays();\n  List<Node> nodes=storage.getNodes();\n  if (mode == Mode.CUT) {\n    reset();\n    if (ways != null && ways.size() == 1) {\n      Way w=ways.get(0);\n      w.setState(savedState);\n      for (      Node nd : w.getNodes()) {\n        Log.d(\"PasteFrom\",\"Restoring state for \" + nd.getOsmId());\n        nd.setState(savedNdState.get(nd));\n      }\n      return w;\n    }\n else     if (nodes != null && nodes.size() == 1) {\n      Node n=nodes.get(0);\n      n.setState(savedState);\n      return n;\n    }\n  }\n else {\n    if (ways != null && ways.size() == 1) {\n      return ways.get(0);\n    }\n else     if (nodes != null && nodes.size() == 1) {\n      return nodes.get(0);\n    }\n  }\n  return null;\n}", "comment": "returns whatever is in the clipboard", "label": "property"}
{"id": "46715", "raw_code": "public static boolean isMiddleMouseButton(MouseEvent anEvent){\n  return ((anEvent.getModifiersEx() & InputEvent.BUTTON2_DOWN_MASK) != 0 || anEvent.getButton() == MouseEvent.BUTTON2);\n}", "comment": "returns true if the mouse event specifies the middle mouse button .", "label": "property"}
{"id": "83489", "raw_code": "@Override public boolean hasQueuedReaderThreads(){\n  return readerLock.hasQueuedThreads();\n}", "comment": "returns whether there are threads waiting for read access to the guacamole instruction stream .", "label": "property"}
{"id": "36655", "raw_code": "public long inactiveTimeMillis(){\n  return System.currentTimeMillis() - lastTimeMillis;\n}", "comment": "returns the number of milliseconds this session has been inactive .", "label": "property"}
{"id": "34301", "raw_code": "QName toQName(Class<?> outputClass){\n  String localPart;\n  String namespaceUri;\n  if (outputClass.isAnnotationPresent(XmlRootElement.class)) {\n    XmlRootElement annotation=outputClass.getAnnotation(XmlRootElement.class);\n    localPart=annotation.name();\n    namespaceUri=annotation.namespace();\n  }\n else   if (outputClass.isAnnotationPresent(XmlType.class)) {\n    XmlType annotation=outputClass.getAnnotation(XmlType.class);\n    localPart=annotation.name();\n    namespaceUri=annotation.namespace();\n  }\n else {\n    throw new IllegalArgumentException(\"Outputclass [\" + outputClass + \"] is \"+ \"neither annotated with @XmlRootElement nor @XmlType\");\n  }\n  if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {\n    localPart=ClassUtils.getShortNameAsProperty(outputClass);\n  }\n  if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {\n    Package outputClassPackage=outputClass.getPackage();\n    if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {\n      XmlSchema annotation=outputClassPackage.getAnnotation(XmlSchema.class);\n      namespaceUri=annotation.namespace();\n    }\n else {\n      namespaceUri=XMLConstants.NULL_NS_URI;\n    }\n  }\n  return new QName(namespaceUri,localPart);\n}", "comment": "returns the qualified name for the given class , according to the mapping rules in the jaxb specification .", "label": "property"}
{"id": "17653", "raw_code": "static boolean isFulfilling(int m){\n  return (m & FULFILLING) != 0;\n}", "comment": "returns true if m has fulfilling bit set .", "label": "property"}
{"id": "70661", "raw_code": "List<Entry> killAll(boolean rootIncluded){\n  List<Entry> killed=new ArrayList<>(rootIncluded ? entries.size() : entries.size() - 1);\n  Entry entry;\n  for (int i=entries.size() - 1; i > (rootIncluded ? -1 : 0); i--) {\n    entry=entries.get(i);\n    if (entry.dead)     continue;\n    entry.dead=true;\n    if (i != 0) {\n      killed.add(entry);\n    }\n  }\n  return killed;\n}", "comment": "kill all , including root or not the returned entries don ' t include the root entry though", "label": "property"}
{"id": "31119", "raw_code": "private static boolean isTrusted(Object obj,TrustVerifier.Context ctx) throws RemoteException {\n  Object saved=state.get();\n  try {\n    state.set(obj);\n    return ctx.isTrustedObject(obj);\n  }\n  finally {\n    state.set(saved);\n  }\n}", "comment": "returns result of calling ctx . istrustedobject ( obj ) with thread - local state set to obj .", "label": "property"}
{"id": "8143", "raw_code": "public static String normalize(final CharSequence self){\n  final String s=self.toString();\n  int nx=s.indexOf('\\r');\n  if (nx < 0) {\n    return s;\n  }\n  final int len=s.length();\n  final StringBuilder sb=new StringBuilder(len);\n  int i=0;\n  do {\n    sb.append(s,i,nx);\n    sb.append('\\n');\n    if ((i=nx + 1) >= len)     break;\n    if (s.charAt(i) == '\\n') {\n      if (++i >= len)       break;\n    }\n    nx=s.indexOf('\\r',i);\n  }\n while (nx > 0);\n  sb.append(s,i,len);\n  return sb.toString();\n}", "comment": "return a string with linefeeds and carriage returns normalized to linefeeds .", "label": "property"}
{"id": "73507", "raw_code": "public List<T> asFlatList(){\n  List<T> list=new ArrayList<T>();\n  for (int i=0; i < getRowCount(); i++) {\n    for (int j=0; j < getColumnCount(); j++) {\n      list.add(getLogicalValueAt(i,j));\n    }\n  }\n  return list;\n}", "comment": "returns the contents of the table as a flat list .", "label": "property"}
{"id": "38963", "raw_code": "protected double defaultMaxRadius(){\n  return Math.sqrt(2.0);\n}", "comment": "returns the default max radius", "label": "property"}
{"id": "72657", "raw_code": "public char[] toCharArray(){\n  char[] newValue=new char[count];\n  System.arraycopy(buf,0,newValue,0,count);\n  return newValue;\n}", "comment": "returns a copy of the input data .", "label": "property"}
{"id": "75192", "raw_code": "public char next(){\n  return pos < in.length() ? in.charAt(pos++) : '\\0';\n}", "comment": "returns the next available character , or the null character ' \\ 0 ' if all input has been exhausted .", "label": "property"}
{"id": "47063", "raw_code": "private Map.Entry<K,V> doRemoveFirstEntry(){\n  for (Node<K,V> b, n; ; ) {\n    if ((n=(b=head.node).next) == null)     return null;\n    Node<K,V> f=n.next;\n    if (n != b.next)     continue;\n    Object v=n.value;\n    if (v == null) {\n      n.helpDelete(b,f);\n      continue;\n    }\n    if (!n.casValue(v,null))     continue;\n    if (!n.appendMarker(f) || !b.casNext(n,f))     findFirst();\n    clearIndexToFirst();\n    @SuppressWarnings(\"unchecked\") V vv=(V)v;\n    return new AbstractMap.SimpleImmutableEntry<K,V>(n.key,vv);\n  }\n}", "comment": "removes first entry ; returns its snapshot .", "label": "property"}
{"id": "2124", "raw_code": "public static boolean isValidIfd(int ifdId){\n  return ifdId == IfdId.TYPE_IFD_0 || ifdId == IfdId.TYPE_IFD_1 || ifdId == IfdId.TYPE_IFD_EXIF || ifdId == IfdId.TYPE_IFD_INTEROPERABILITY || ifdId == IfdId.TYPE_IFD_GPS;\n}", "comment": "returns true if the given ifd is a valid ifd .", "label": "property"}
{"id": "66736", "raw_code": "protected boolean customShouldTakeFocus(){\n  if (customArea instanceof Label) {\n    return false;\n  }\n  if (customArea instanceof CLabel) {\n    return (customArea.getStyle() & SWT.NO_FOCUS) > 0;\n  }\n  return true;\n}", "comment": "return whether or not we should apply the workaround where we take focus for the default button or if that should be determined by the dialog .", "label": "property"}
{"id": "79366", "raw_code": "public static List<? extends Node> childNodeList(Node node){\n  if (node == null)   return null;\n  List<Node> nodes=new LinkedList<Node>();\n  do {\n    if (node.getNodeType() == Node.ELEMENT_NODE || node.getNodeType() == Node.COMMENT_NODE) {\n      nodes.add(node);\n    }\n  }\n while ((node=node.getNextSibling()) != null);\n  return nodes;\n}", "comment": "return a list of node objects that have the given name and are immediate children of the given element ; if name is null , all child elements will be included .", "label": "property"}
{"id": "29350", "raw_code": "public boolean isExpired(){\n  return this.ttl < System.currentTimeMillis();\n}", "comment": "true if the entry is expired .", "label": "property"}
{"id": "51028", "raw_code": "public static Direction directionForArrowKey(KeyEvent e){\n  int index=Math.max(0,Math.min(e.getKeyCode(),KeyEvent.VK_DOWN) - KeyEvent.VK_LEFT);\n  return Direction.values()[index];\n}", "comment": "returns a direction corresponding to the specified arrow key .", "label": "property"}
{"id": "4326", "raw_code": "public static String valueOf(Boolean value){\n  return value != null ? String.valueOf(value) : null;\n}", "comment": "returns the string value of the given boolean .", "label": "property"}
{"id": "74686", "raw_code": "public static LatLon[] greatCircleExtremeLocations(LatLon location,Angle azimuth){\n  if (location == null) {\n    throw new IllegalArgumentException(\"Location Is Null\");\n  }\n  if (azimuth == null) {\n    throw new IllegalArgumentException(\"Azimuth Is Null\");\n  }\n  double lat0=location.getLatitude().radians;\n  double az=azimuth.radians;\n  double tanDistance=-Math.tan(lat0) / Math.cos(az);\n  double distance=Math.atan(tanDistance);\n  Angle extremeDistance1=Angle.fromRadians(distance + (Math.PI / 2.0));\n  Angle extremeDistance2=Angle.fromRadians(distance - (Math.PI / 2.0));\n  return new LatLon[]{greatCircleEndPosition(location,azimuth,extremeDistance1),greatCircleEndPosition(location,azimuth,extremeDistance2)};\n}", "comment": "returns two locations with the most extreme latitudes on the great circle with the given starting location and azimuth .", "label": "property"}
{"id": "32111", "raw_code": "public Collection<GridPortRecord> records(){\nsynchronized (recs) {\n    return Collections.unmodifiableCollection(new ArrayList<>(recs));\n  }\n}", "comment": "returns unmodifiable collections of records .", "label": "property"}
{"id": "25961", "raw_code": "public String convertToLowerCase(String table){\n  return table.toLowerCase();\n}", "comment": "returns the given string in lowercase", "label": "property"}
{"id": "3975", "raw_code": "public static int nextInt(int n){\n  Random random=getRandom();\n  int value=random.nextInt(n);\n  if (!_isTest)   _freeRandomList.free(random);\n  return value;\n}", "comment": "returns the next random int .", "label": "property"}
{"id": "46111", "raw_code": "@Override public boolean accept(File f){\n  if (f != null) {\n    if (f.isDirectory()) {\n      return true;\n    }\n    String extension=getExtension(f);\n    if (extension != null && filters.get(getExtension(f)) != null) {\n      return true;\n    }\n    ;\n  }\n  return false;\n}", "comment": "return true if this file should be shown in the directory pane , false if it shouldn ' t .", "label": "property"}
{"id": "60555", "raw_code": "@Override public boolean execute(@NotNull PsiElement pe,@NotNull ResolveState state){\n  if (pe instanceof PsiVariable) {\n    final PsiVariable pvar=(PsiVariable)pe;\n    if (!myStaticSensitiveFlag || !myStaticScopeFlag || pvar.hasModifierProperty(PsiModifier.STATIC)) {\n      if (check(pvar,state)) {\n        myResultList.add(pvar);\n      }\n    }\n  }\n  return true;\n}", "comment": "always return true since we wanna get all vars in scope", "label": "property"}
{"id": "30876", "raw_code": "ProxyVerifier(TxnManager serverProxy,Uuid proxyID){\n  if (!(serverProxy instanceof RemoteMethodControl)) {\n    throw new UnsupportedOperationException(\"No verifier available for non-constrainable service\");\n  }\n else   if (!(serverProxy instanceof TrustEquivalence)) {\n    throw new UnsupportedOperationException(\"Verifier requires service proxy to implement \" + \"TrustEquivalence\");\n  }\n else   if (proxyID == null) {\n    throw new IllegalArgumentException(\"Proxy id cannot be null\");\n  }\n  this.serverProxy=(RemoteMethodControl)serverProxy;\n  this.proxyID=proxyID;\n}", "comment": "returns a verifier for the smart proxies of the specified mahalo server proxy .", "label": "property"}
{"id": "43077", "raw_code": "protected int selectOperator(){\n  lastUpdate++;\n  if ((lastUpdate >= UPDATE_WINDOW) || (probabilities == null)) {\n    lastUpdate=0;\n    probabilities=getOperatorProbabilities();\n  }\n  double rand=PRNG.nextDouble();\n  double sum=0.0;\n  for (int i=0; i < operators.size(); i++) {\n    sum+=probabilities[i];\n    if (sum > rand) {\n      return i;\n    }\n  }\n  throw new IllegalStateException();\n}", "comment": "returns the index of one of the available operators randomly selected using the probabilities .", "label": "property"}
{"id": "72991", "raw_code": "@Override public List chunkString(String sToChunk){\n  Integer[] iRes=splitPointsByDelimiterList(sToChunk,getDelimiters());\n  String[] sRes=splitStringByDelimiterPoints(sToChunk,iRes);\n  return Arrays.asList(sRes);\n}", "comment": "returns a list of string chunks , derived from a given string .", "label": "property"}
{"id": "79441", "raw_code": "public static DateFormat toDateTimeFormat(String dateTimeFormat,TimeZone tz,Locale locale){\n  DateFormat df=null;\n  if (UtilValidate.isEmpty(dateTimeFormat)) {\n    df=DateFormat.getDateTimeInstance(DateFormat.SHORT,DateFormat.MEDIUM,locale);\n  }\n else {\n    df=new SimpleDateFormat(dateTimeFormat,locale == null ? Locale.getDefault() : locale);\n  }\n  df.setTimeZone(tz);\n  return df;\n}", "comment": "returns an initialized dateformat object .", "label": "property"}
{"id": "38126", "raw_code": "private double Poisson(double x){\n  return Math.exp(-m_Lambda + (x * Math.log(m_Lambda)) - logFac(x));\n}", "comment": "returns value for poisson distribution", "label": "property"}
{"id": "61981", "raw_code": "public Value sample(){\n  int index=sampler.nextInt(actionValues.size());\n  if (actionValuesAsArray == null) {\n    actionValuesAsArray=actionValues.toArray(new Value[actionValues.size()]);\n  }\n  return actionValuesAsArray[index];\n}", "comment": "returns a sample point for the action , assuming a uniform distribution over the action values", "label": "property"}
{"id": "13709", "raw_code": "public PropertyXMLBuilder(ServiceSchema serviceSchema,AMModel model,Set attributeSchemas) throws SMSException, SSOException {\n  this.model=model;\n  this.serviceName=serviceSchema.getServiceName();\n  getServiceResourceBundle(serviceSchema);\n  if (serviceBundle != null) {\n    mapTypeToAttributeSchema=new HashMap(attributeSchemas.size() * 2);\n    mapTypeToAttributeSchema.put(NULL_TYPE,attributeSchemas);\n  }\n}", "comment": "returns a xml for displaying attribute in property sheet .", "label": "property"}
{"id": "11045", "raw_code": "public boolean is(String arg,boolean allowAbbr){\n  if (name.equalsIgnoreCase(arg)) {\n    return true;\n  }\n  if (allowAbbr && arg.length() == 1) {\n    if (arg.charAt(0) == c) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "returns true if the atg string matches the name of the arg , or , if allowabbr is true , returns true if the arg length is one and it matches the first letter of the arg name .", "label": "property"}
{"id": "50310", "raw_code": "default ClassDeclaration asClass(){\n  throw new UnsupportedOperationException(String.format(\"%s is not a class\",this));\n}", "comment": "return this as a classdeclaration or throw unsupportedoperationexception .", "label": "property"}
{"id": "59892", "raw_code": "@Override public SelectableChannel selectableChannel(){\n  return socketChannel;\n}", "comment": "returns the socketchannel underlying this socketcommchannel", "label": "property"}
{"id": "49241", "raw_code": "private static byte[] WindowsRegEnumValue1(int hKey,int valueIndex,int maxValueNameLength){\n  byte[] result=WindowsRegEnumValue(hKey,valueIndex,maxValueNameLength);\n  if (result != null) {\n    return result;\n  }\n else {\n    long sleepTime=INIT_SLEEP_TIME;\n    for (int i=0; i < MAX_ATTEMPTS; i++) {\n      try {\n        Thread.sleep(sleepTime);\n      }\n catch (      InterruptedException e) {\n        return result;\n      }\n      sleepTime*=2;\n      result=WindowsRegEnumValue(hKey,valueIndex,maxValueNameLength);\n      if (result != null) {\n        return result;\n      }\n    }\n  }\n  return result;\n}", "comment": "retries regenumvalueex ( ) max _ attempts times before giving up .", "label": "property"}
{"id": "49784", "raw_code": "protected int countToken(String token,String target){\n  int tokenIndex=0;\n  int count=0;\n  while (tokenIndex != -1) {\n    tokenIndex=target.indexOf(token,tokenIndex);\n    if (tokenIndex > -1) {\n      tokenIndex++;\n      count++;\n    }\n  }\n  return count;\n}", "comment": "returns the number of times the token appears in the target .", "label": "property"}
{"id": "86911", "raw_code": "public static long[] interpose(long[] vector,int vectorLen,int offset,int len){\n  long[] updated=create(vectorLen + len);\n  int idx=offset >> 6;\n  System.arraycopy(vector,0,updated,0,idx);\n  if (idx < vector.length) {\n    int delta=offset & 63;\n    updated[idx]|=vector[idx] & maskBelow(delta);\n  }\n  copy(vector,offset,updated,offset + len,vectorLen - offset);\n  return updated;\n}", "comment": "returns a copy of the vector , with an empty bit range inserted at the specified location .", "label": "property"}
{"id": "37560", "raw_code": "public String globalInfo(){\n  return \"Generates a single train/test split and calls the appropriate \" + \"SplitEvaluator to generate some results.\";\n}", "comment": "returns a string describing this result producer", "label": "property"}
{"id": "26808", "raw_code": "private ScriptEngine newScriptEngine(File file) throws ScriptException {\n  String filename=file.getName();\n  int index=filename.lastIndexOf('.');\n  if ((index < 0) || (index >= filename.length() - 1)) {\n    throw new ScriptException(\"file has no extension\");\n  }\n  String extension=filename.substring(index + 1);\n  ScriptEngineManager manager=new ScriptEngineManager();\n  ScriptEngine engine=manager.getEngineByExtension(extension);\n  if (engine == null) {\n    throw new ScriptException(\"no scripting engine for extension .\" + extension);\n  }\n  return engine;\n}", "comment": "returns a new scripting engine for the scripting language identified by the file name extension .", "label": "property"}
{"id": "36839", "raw_code": "protected static INaviRawModule findRawModule(final int rawModuleId,final List<INaviRawModule> rawModules){\n  Preconditions.checkArgument(rawModuleId > 0,\"Raw module id %s must be positive integer\",rawModuleId);\n  Preconditions.checkNotNull(rawModules,\"IE02263: raw modules argument can not be null\");\n  for (  final INaviRawModule rawModule : rawModules) {\n    if (rawModule.getId() == rawModuleId) {\n      return rawModule;\n    }\n  }\n  throw new IllegalStateException(\"IE00160: Could not find raw module\");\n}", "comment": "returns the raw module with the given id .", "label": "property"}
{"id": "49625", "raw_code": "public static @Nonnull <T>T valueOrDefault(@Nullable T value,@Nonnull T defaultValue){\n  return value == null ? defaultValue : value;\n}", "comment": "returns a value if that value is not null , or a specified default value otherwise .", "label": "property"}
{"id": "14091", "raw_code": "public String chooseServerAlias(String keyType,Principal[] issuers,Socket socket){\n  return defaultX509KM.chooseServerAlias(keyType,issuers,socket);\n}", "comment": "returns an alias to authenticate the server side of a secure socket given the public key type and the list of certificate issuer authorities recognized by the peer ( if any ) .", "label": "property"}
{"id": "14015", "raw_code": "public static RequestSecurityTokenResponse parseXML(String xml) throws WSFederationException {\n  Document doc=XMLUtils.toDOMDocument(xml,debug);\n  Element root=doc.getDocumentElement();\n  return new RequestSecurityTokenResponse(root);\n}", "comment": "returns requestsecuritytokenresponse object based on the xml document received from server .", "label": "property"}
{"id": "70541", "raw_code": "public static int binarySearchFloor(long[] a,long key,boolean inclusive,boolean stayInBounds){\n  int index=Arrays.binarySearch(a,key);\n  index=index < 0 ? -(index + 2) : (inclusive ? index : (index - 1));\n  return stayInBounds ? Math.max(0,index) : index;\n}", "comment": "returns the index of the largest value in an array that is less than ( or optionally equal to ) a specified key .", "label": "property"}
{"id": "15674", "raw_code": "public final int size(){\n  if (GWT.isScript()) {\n    return jsArray.size();\n  }\n else {\n    return javaArray.size();\n  }\n}", "comment": "return the list size", "label": "property"}
{"id": "62594", "raw_code": "public List<LocalTime> bottom(int n){\n  List<LocalTime> bottom=new ArrayList<>();\n  int[] values=data.toIntArray();\n  IntArrays.parallelQuickSort(values);\n  for (int i=0; i < n && i < values.length; i++) {\n    bottom.add(PackedLocalTime.asLocalTime(values[i]));\n  }\n  return bottom;\n}", "comment": "returns the smallest ( \" bottom \" ) n values in the column", "label": "property"}
{"id": "61971", "raw_code": "public boolean hasDescendant(Pattern pattern){\n  Queue<BNode> nodesToProcess=new LinkedList<BNode>();\n  nodesToProcess.add(this);\n  while (!nodesToProcess.isEmpty()) {\n    BNode currentNode=nodesToProcess.poll();\n    for (    BNode descendantNode : currentNode.getOutputNodes()) {\n      Matcher matcher=pattern.matcher(descendantNode.getId());\n      if (matcher.matches()) {\n        return true;\n      }\n      if (!nodesToProcess.contains(descendantNode)) {\n        nodesToProcess.add(descendantNode);\n      }\n    }\n  }\n  return false;\n}", "comment": "returns true if at there exists at least one descendant whose identifier matches the regular expression pattern , and false otherwise", "label": "property"}
{"id": "7322", "raw_code": "public EventBean[] toArray(){\n  if (firstEvent == null) {\n    return new EventBean[0];\n  }\n  if (additionalEvents == null) {\n    return new EventBean[]{firstEvent};\n  }\n  EventBean[] events=new EventBean[1 + additionalEvents.size()];\n  events[0]=firstEvent;\n  int count=1;\n  for (  EventBean theEvent : additionalEvents) {\n    events[count]=theEvent;\n    count++;\n  }\n  return events;\n}", "comment": "returns an array holding the collected events .", "label": "property"}
{"id": "17504", "raw_code": "public static boolean hasMimeType(String mimeType){\n  if (mimeType == null || mimeType.isEmpty()) {\n    return false;\n  }\n  return mimeTypeToExtensionMap.containsKey(mimeType);\n}", "comment": "returns true if the given mime type has an entry in the map .", "label": "property"}
{"id": "55209", "raw_code": "public Iterable<Notification> skip(@Nonnull final Iterable<Notification> notifications,final long startId,final boolean inclusive,final int limitSize){\n  Objects.requireNonNull(notifications);\n  final int position=indexOf(notifications,startId);\n  if (position == -1) {\n    return Iterables.limit(notifications,limitSize);\n  }\n  if (inclusive) {\n    return Iterables.limit(Iterables.skip(notifications,position),limitSize);\n  }\n  return Iterables.limit(Iterables.skip(notifications,position + 1),limitSize);\n}", "comment": "returns an iterable that skips forward to a given notification id then only returns count more notifications .", "label": "property"}
{"id": "26533", "raw_code": "public long next(long startTime,long fromTime,long currentCount){\n  if (startTime == 0)   startTime=RecurrenceUtil.now();\n  if (fromTime == 0)   fromTime=startTime;\n  if (getEndTime() != 0 && getEndTime() <= RecurrenceUtil.now())   return 0;\n  Debug.logVerbose(\"Rule NOT expired by end time.\",module);\n  if (getCount() != -1 && currentCount >= getCount())   return 0;\n  Debug.logVerbose(\"Rule NOT expired by max count.\",module);\n  boolean isSeeking=true;\n  long nextRuntime=0;\n  long seekTime=fromTime;\n  int loopProtection=0;\n  int maxLoop=(10 * 10 * 10* 10* 10);\n  while (isSeeking && loopProtection < maxLoop) {\n    Date nextRun=getNextFreq(startTime,seekTime);\n    seekTime=nextRun.getTime();\n    if (validByRule(nextRun)) {\n      isSeeking=false;\n      nextRuntime=nextRun.getTime();\n    }\n    loopProtection++;\n  }\n  return nextRuntime;\n}", "comment": "returns the next recurrence of this rule .", "label": "property"}
{"id": "45644", "raw_code": "private static double norm(final double[] v){\n  double agg=0;\n  for (int i=0; i < v.length; i++) {\n    agg+=(v[i] * v[i]);\n  }\n  return Math.sqrt(agg);\n}", "comment": "returns the norm l2 .", "label": "property"}
{"id": "41090", "raw_code": "private static boolean equalsHandlesNulls(Object a,Object b){\n  return a == b || (a != null && a.equals(b));\n}", "comment": "returns true if a and b are equal or are both null .", "label": "property"}
{"id": "71019", "raw_code": "public static String replace(String str,char oldChar,String newStr){\n  StringBuffer buf=new StringBuffer();\n  for (int i=0; i < str.length(); i++) {\n    char ch=str.charAt(i);\n    if (ch == oldChar) {\n      buf.append(newStr);\n    }\n else {\n      buf.append(ch);\n    }\n  }\n  return buf.toString();\n}", "comment": "returns a string with all occurrences of oldchar replaced by newstr", "label": "property"}
{"id": "84675", "raw_code": "protected boolean isCompatible(Taxa taxa,List<Taxon> availableTaxa){\n  for (int i=0; i < taxa.getTaxonCount(); i++) {\n    Taxon taxon=taxa.getTaxon(i);\n    if (!availableTaxa.contains(taxon)) {\n      return false;\n    }\n  }\n  return true;\n}", "comment": "returns true if taxa are all found in availabletaxa", "label": "property"}
{"id": "42148", "raw_code": "public java.util.Collection<ObjectReference> dumpThreadRoots(int width){\n  return Collections.emptyList();\n}", "comment": "print the thread roots and return them for processing .", "label": "property"}
{"id": "84703", "raw_code": "public Dimension minimumLayoutSize(Container target){\nsynchronized (target.getTreeLock()) {\n    Dimension dim=new Dimension(0,0);\n    if ((chart != null) && chart.isVisible()) {\n      Dimension d=chart.getMinimumSize();\n      dim.width=d.width;\n      dim.height=d.height;\n    }\n    if ((xLabel != null) && xLabel.isVisible()) {\n      Dimension d=xLabel.getMinimumSize();\n      dim.width=Math.max(d.width,dim.width);\n      dim.height+=d.height + vgap;\n    }\n    if ((yLabel != null) && yLabel.isVisible()) {\n      Dimension d=yLabel.getMinimumSize();\n      dim.width+=d.width + hgap;\n      dim.height=Math.max(d.height,dim.height);\n    }\n    if ((title != null) && title.isVisible()) {\n      Dimension d=title.getMinimumSize();\n      dim.width=Math.max(d.width,dim.width);\n      dim.height+=d.height + vgap;\n    }\n    Insets insets=target.getInsets();\n    dim.width+=insets.left + insets.right;\n    dim.height+=insets.top + insets.bottom;\n    return dim;\n  }\n}", "comment": "returns the minimum dimensions needed to layout the components contained in the specified target container .", "label": "property"}
{"id": "43348", "raw_code": "public OptionalInt maxByInt(IntUnaryOperator keyExtractor){\n  int[] result=collect(null,null,null);\n  return result[2] == 1 ? OptionalInt.of(result[0]) : OptionalInt.empty();\n}", "comment": "returns the maximum element of this stream according to the provided key extractor function .", "label": "property"}
{"id": "871", "raw_code": "public Set keySet(){\n  return totalKeySet();\n}", "comment": "returns the total key set of all scopes .", "label": "property"}
{"id": "30292", "raw_code": "public boolean consumeEncumbranceBudget(final Map<String,Object> detailsMap){\n  if (detailsMap == null)   throw new ValidationException(Arrays.asList(new ValidationError(\"required input is null\",\"required input is null\")));\n  detailsMap.put(Constants.CONSUMEORRELEASE,true);\n  final BigDecimal bd=getDetails(detailsMap);\n  return bd.intValue() == 1;\n}", "comment": "this api is to check whether the planning budget is available or not . for the amount passed if there is sufficient budget available api will return true .", "label": "property"}
{"id": "38962", "raw_code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> result=enumToVector(super.listOptions());\n  result.addElement(new Option(\"\\tThe number of clusters (default \" + defaultNumClusters() + \")\",\"k\",1,\"-k <num>\"));\n  result.addElement(new Option(\"\\tSet pattern to grid (default is random).\\n\" + \"\\tThis flag cannot be used at the same time as flag I.\\n\" + \"\\tThe pattern is random, if neither flag G nor flag I is set.\",\"G\",0,\"-G\"));\n  result.addElement(new Option(\"\\tSet pattern to sine (default is random).\\n\" + \"\\tThis flag cannot be used at the same time as flag I.\\n\" + \"\\tThe pattern is random, if neither flag G nor flag I is set.\",\"I\",0,\"-I\"));\n  result.addElement(new Option(\"\\tThe range of number of instances per cluster (default \" + defaultMinInstNum() + \"..\"+ defaultMaxInstNum()+ \").\\n\"+ \"\\tLower number must be between 0 and 2500,\\n\"+ \"\\tupper number must be between 50 and 2500.\",\"N\",1,\"-N <num>..<num>\"));\n  result.addElement(new Option(\"\\tThe range of radius per cluster (default \" + defaultMinRadius() + \"..\"+ defaultMaxRadius()+ \").\\n\"+ \"\\tLower number must be between 0 and SQRT(2), \\n\"+ \"\\tupper number must be between SQRT(2) and SQRT(32).\",\"R\",1,\"-R <num>..<num>\"));\n  result.addElement(new Option(\"\\tThe distance multiplier (default \" + defaultDistMult() + \").\",\"M\",1,\"-M <num>\"));\n  result.addElement(new Option(\"\\tThe number of cycles (default \" + defaultNumCycles() + \").\",\"C\",1,\"-C <num>\"));\n  result.addElement(new Option(\"\\tFlag for input order is ORDERED. If flag is not set then \\n\" + \"\\tinput order is RANDOMIZED. RANDOMIZED is currently not \\n\" + \"\\timplemented, therefore is the input order always ORDERED.\",\"O\",0,\"-O\"));\n  result.addElement(new Option(\"\\tThe noise rate in percent (default \" + defaultNoiseRate() + \").\\n\"+ \"\\tCan be between 0% and 30%. (Remark: The original \\n\"+ \"\\talgorithm only allows noise up to 10%.)\",\"P\",1,\"-P <num>\"));\n  return result.elements();\n}", "comment": "returns an enumeration describing the available options .", "label": "property"}
{"id": "67696", "raw_code": "public static void appendHexJavaScriptRepresentation(StringBuilder sb,char c){\n  sb.append(\"\\\\u\");\n  String val=Integer.toHexString(c);\n  for (int j=val.length(); j < 4; j++) {\n    sb.append('0');\n  }\n  sb.append(val);\n}", "comment": "returns a javascript representation of the character in a hex escaped format .", "label": "property"}
{"id": "86739", "raw_code": "public static long[] asLongArray(final List<Long> l){\n  final long[] a=new long[l.size()];\n  for (int i=0; i < a.length; i++) {\n    a[i]=l.get(i);\n  }\n  return a;\n}", "comment": "return list of boxed longs as a primitive array .", "label": "property"}
{"id": "85421", "raw_code": "public static List<ModuleSpec> expandSpecWildcards(File dir,List<ModuleSpec> modules,Backend forBackend){\n  List<File> dirs=new ArrayList<File>();\n  dirs.add(dir);\n  return expandSpecWildcards(dirs,modules,forBackend);\n}", "comment": "given a source directory and a list of modulespecs that possibly contain wildcards it returns a expanded list of modulespecs of modules that were actually found in the given source directory .", "label": "property"}
{"id": "61456", "raw_code": "public static boolean isAbsolutePath(String systemId){\n  if (systemId == null)   return false;\n  final File file=new File(systemId);\n  return file.isAbsolute();\n}", "comment": "return true if the local path is an absolute path .", "label": "property"}
{"id": "11091", "raw_code": "private Socket connect(String host,String portString) throws IOException {\n  int port=0;\n  Socket sock=null;\n  boolean DEBUG=Debug.debugging(\"netmap\");\n  try {\n    port=Integer.parseInt(portString,10);\n  }\n catch (  NumberFormatException e) {\n    if (DEBUG)     Debug.output(\"Illegal name \" + host + \":\"+ portString);\n    throw new IOException(\"Illegal port: \" + portString);\n  }\n  if (DEBUG)   Debug.output(\"Connecting to server \" + host + \":\"+ port);\n  try {\n    sock=new Socket(host,port);\n  }\n catch (  IOException e) {\n    if (sock != null)     sock.close();\n    if (DEBUG) {\n      Debug.output(\"Can't connect to \" + host + \":\"+ port+ \"\\n   \"+ e);\n    }\n    throw e;\n  }\n  return sock;\n}", "comment": "a general connection method that returns a socket for a host and port .", "label": "property"}
{"id": "84326", "raw_code": "public static String flagNames(long flags){\n  StringBuilder sbuf=new StringBuilder();\n  int i=0;\n  long f=flags & StandardFlags;\n  while (f != 0) {\n    if ((f & 1) != 0) {\n      sbuf.append(\" \");\n      sbuf.append(flagName[i]);\n    }\n    f=f >> 1;\n    i++;\n  }\n  return sbuf.toString();\n}", "comment": "return flags as a string , separated by \" \" .", "label": "property"}
{"id": "72", "raw_code": "public String formatSQL(Object obj,Object expr){\n  String sql=null;\n  if (expr instanceof String) {\n    sql=(String)expr;\n    if (log.isLoggable(Level.FINEST)) {\n      log.finest(\"SQL retrieved from state = \" + sql);\n    }\n  }\n else   if (obj != null) {\n    sql=toString(obj);\n    if (sql != null) {\n      if (sql.startsWith(\"prep\")) {\n        sql=sql.replaceFirst(\"prep[0-9]*: \",\"\");\n      }\n      sql=sql.replaceAll(\"X'.*'\",BINARY_SQL_MARKER);\n    }\n    if (log.isLoggable(Level.FINEST)) {\n      log.finest(\"SQL derived from context = \" + sql);\n    }\n  }\n  return sql;\n}", "comment": "this method attempts to return a sql statement .", "label": "property"}
{"id": "1269", "raw_code": "public static int len(String list,String delimiter,boolean ignoreEmpty){\n  if (delimiter.length() == 1)   return len(list,delimiter.charAt(0),ignoreEmpty);\n  char[] del=delimiter.toCharArray();\n  int len=StringUtil.length(list);\n  if (len == 0)   return 0;\n  int count=0;\n  int last=0;\n  char c;\n  for (int i=0; i < len; i++) {\n    c=list.charAt(i);\n    for (int y=0; y < del.length; y++) {\n      if (c == del[y]) {\n        if (!ignoreEmpty || last < i)         count++;\n        last=i + 1;\n        break;\n      }\n    }\n  }\n  if (!ignoreEmpty || last < len)   count++;\n  return count;\n}", "comment": "returns count of items in the list", "label": "property"}
{"id": "81437", "raw_code": "int listSize(){\n  int result=memSize();\n  for (Iterator it=iterator(); it.hasNext(); ) {\n    ASTNode child=(ASTNode)it.next();\n    result+=child.treeSize();\n  }\n  return result;\n}", "comment": "returns an estimate of the memory footprint in bytes of this node list and all its subtrees .", "label": "property"}
{"id": "56227", "raw_code": "public static boolean hasBinding(Injector injector,Key<?> key){\n  Binding<?> binding=getBinding(injector,key);\n  return binding != null;\n}", "comment": "returns true if a binding exists for the given key", "label": "property"}
{"id": "3995", "raw_code": "@Override public String findLibrary(String name){\n  String systemName=System.mapLibraryName(name);\n  ArrayList<Loader> loaders=getLoaders();\n  for (int i=0; i < loaders.size(); i++) {\n    Loader loader=loaders.get(i);\n    Path path=loader.getPath(systemName);\n    if (path != null && path.canRead()) {\n      return path.getNativePath();\n    }\n    path=loader.getPath(\"native/\" + systemName);\n    if (path != null && path.canRead()) {\n      return path.getNativePath();\n    }\n  }\n  for (int i=0; i < _nativePath.size(); i++) {\n    Path path=_nativePath.get(i);\n    if (path.canRead())     return path.getNativePath();\n  }\n  return super.findLibrary(name);\n}", "comment": "returns the full library path for the name .", "label": "property"}
{"id": "25982", "raw_code": "public static boolean isEmpty(CharSequence text){\n  return text == null || text.length() == 0;\n}", "comment": "returns true if the string is null or 0 - length .", "label": "property"}
{"id": "53514", "raw_code": "public double distance(Point2D pt){\n  final double x_distance=(pt.getX() - x) * (pt.getX() - x);\n  final double y_distance=(pt.getY() - y) * (pt.getY() - y);\n  return Math.sqrt(x_distance + y_distance);\n}", "comment": "returns the euclidean distance between a specified point and this point .", "label": "property"}
{"id": "27987", "raw_code": "public double nextDouble(double alpha,double lambda){\n  double a=alpha;\n  double aa=-1.0, aaa=-1.0, b=0.0, c=0.0, d=0.0, e, r, s=0.0, si=0.0, ss=0.0, q0=0.0, q1=0.0416666664, q2=0.0208333723, q3=0.0079849875, q4=0.0015746717, q5=-0.0003349403, q6=0.0003340332, q7=0.0006053049, q8=-0.0004701849, q9=0.0001710320, a1=0.333333333, a2=-0.249999949, a3=0.199999867, a4=-0.166677482, a5=0.142873973, a6=-0.124385581, a7=0.110368310, a8=-0.112750886, a9=0.104089866, e1=1.000000000, e2=0.499999994, e3=0.166666848, e4=0.041664508, e5=0.008345522, e6=0.001353826, e7=0.000247453;\n  double gds, p, q, t, sign_u, u, v, w, x;\n  double v1, v2, v12;\n  if (a <= 0.0)   throw new IllegalArgumentException();\n  if (lambda <= 0.0)   new IllegalArgumentException();\n  if (a < 1.0) {\n    b=1.0 + 0.36788794412 * a;\n    for (; ; ) {\n      p=b * randomGenerator.raw();\n      if (p <= 1.0) {\n        gds=Math.exp(Math.log(p) / a);\n        if (Math.log(randomGenerator.raw()) <= -gds)         return (gds / lambda);\n      }\n else {\n        gds=-Math.log((b - p) / a);\n        if (Math.log(randomGenerator.raw()) <= ((a - 1.0) * Math.log(gds)))         return (gds / lambda);\n      }\n    }\n  }\n else {\n    if (a != aa) {\n      aa=a;\n      ss=a - 0.5;\n      s=Math.sqrt(ss);\n      d=5.656854249 - 12.0 * s;\n    }\n    do {\n      v1=2.0 * randomGenerator.raw() - 1.0;\n      v2=2.0 * randomGenerator.raw() - 1.0;\n      v12=v1 * v1 + v2 * v2;\n    }\n while (v12 > 1.0);\n    t=v1 * Math.sqrt(-2.0 * Math.log(v12) / v12);\n    x=s + 0.5 * t;\n    gds=x * x;\n    if (t >= 0.0)     return (gds / lambda);\n    u=randomGenerator.raw();\n    if (d * u <= t * t * t)     return (gds / lambda);\n    if (a != aaa) {\n      aaa=a;\n      r=1.0 / a;\n      q0=((((((((q9 * r + q8) * r + q7) * r + q6) * r + q5) * r + q4) * r + q3) * r + q2) * r + q1) * r;\n      if (a > 3.686) {\n        if (a > 13.022) {\n          b=1.77;\n          si=0.75;\n          c=0.1515 / s;\n        }\n else {\n          b=1.654 + 0.0076 * ss;\n          si=1.68 / s + 0.275;\n          c=0.062 / s + 0.024;\n        }\n      }\n else {\n        b=0.463 + s - 0.178 * ss;\n        si=1.235;\n        c=0.195 / s - 0.079 + 0.016 * s;\n      }\n    }\n    if (x > 0.0) {\n      v=t / (s + s);\n      if (Math.abs(v) > 0.25) {\n        q=q0 - s * t + 0.25 * t * t + (ss + ss) * Math.log(1.0 + v);\n      }\n else {\n        q=q0 + 0.5 * t * t* ((((((((a9 * v + a8) * v + a7) * v + a6) * v + a5) * v + a4) * v + a3) * v + a2) * v + a1)* v;\n      }\n      if (Math.log(1.0 - u) <= q)       return (gds / lambda);\n    }\n    for (; ; ) {\n      do {\n        e=-Math.log(randomGenerator.raw());\n        u=randomGenerator.raw();\n        u=u + u - 1.0;\n        sign_u=(u > 0) ? 1.0 : -1.0;\n        t=b + (e * si) * sign_u;\n      }\n while (t <= -0.71874483771719);\n      v=t / (s + s);\n      if (Math.abs(v) > 0.25) {\n        q=q0 - s * t + 0.25 * t * t + (ss + ss) * Math.log(1.0 + v);\n      }\n else {\n        q=q0 + 0.5 * t * t* ((((((((a9 * v + a8) * v + a7) * v + a6) * v + a5) * v + a4) * v + a3) * v + a2) * v + a1)* v;\n      }\n      if (q <= 0.0)       continue;\n      if (q > 0.5) {\n        w=Math.exp(q) - 1.0;\n      }\n else {\n        w=((((((e7 * q + e6) * q + e5) * q + e4) * q + e3) * q + e2) * q + e1) * q;\n      }\n      if (c * u * sign_u <= w * Math.exp(e - 0.5 * t * t)) {\n        x=s + 0.5 * t;\n        return (x * x / lambda);\n      }\n    }\n  }\n}", "comment": "returns a random number from the distribution ; bypasses the internal state .", "label": "property"}
{"id": "62004", "raw_code": "@Override public boolean equals(Object o){\n  return o.hashCode() == hashCode();\n}", "comment": "returns true if the object is a complex effect with an identical content", "label": "property"}
{"id": "81263", "raw_code": "public static boolean isValidTypeSignature(String sig,boolean allowVoid){\n  int len=sig.length();\n  return checkTypeSignature(sig,0,len,allowVoid) == len;\n}", "comment": "returns true if the given type signature is valid , false if it is not .", "label": "property"}
{"id": "33299", "raw_code": "public static boolean hasVisibleChildren(ActionGroup group,PresentationFactory factory,ActionManager actionManager,PerspectiveManager perspectiveManager){\n  ActionEvent event=new ActionEvent(factory.getPresentation(group),actionManager,perspectiveManager);\n  for (  Action anAction : group.getChildren(event)) {\n    if (anAction == null) {\n      Log.error(Utils.class,\"Null action found in group \" + group + \", \"+ factory.getPresentation(group));\n      continue;\n    }\n    if (anAction instanceof Separator) {\n      continue;\n    }\n    final Presentation presentation=factory.getPresentation(anAction);\n    anAction.update(new ActionEvent(presentation,actionManager,perspectiveManager));\n    if (anAction instanceof ActionGroup) {\n      ActionGroup childGroup=(ActionGroup)anAction;\n      if (childGroup.isPopup()) {\n        if (!presentation.isVisible()) {\n          continue;\n        }\n      }\n      if (hasVisibleChildren(childGroup,factory,actionManager,perspectiveManager)) {\n        return true;\n      }\n    }\n else     if (presentation.isVisible()) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "returns true if action group has visible children .", "label": "property"}
{"id": "52359", "raw_code": "public String toZString(){\n  StringBuilder buffer=new StringBuilder(32);\n  try {\n    printZ(buffer);\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"Exception printing to StringBuilder\",e);\n  }\n  return buffer.toString();\n}", "comment": "returns the string representation ( in ion format ) of this timestamp in utc .", "label": "property"}
{"id": "52350", "raw_code": "public int writeUTF8(final CharSequence chars,int off,int len){\n  if (len > remaining()) {\n    return writeUTF8Slow(chars,off,len);\n  }\n  final Block block=current;\n  int limit=block.limit;\n  char ch='\\0';\n  int octets=0;\n  while (len > 0) {\n    ch=chars.charAt(off);\n    if (ch >= UTF8_2_OCTET_MIN_VALUE) {\n      break;\n    }\n    block.data[limit++]=(byte)ch;\n    octets++;\n    off++;\n    len--;\n  }\n  block.limit=limit;\n  if (len > 0) {\n    if (ch < UTF8_3_OCTET_MIN_VALUE) {\n      return octets + writeUTF8UpTo2Byte(chars,off,len);\n    }\n    if (ch >= LOW_SURROGATE_FIRST && ch <= LOW_SURROGATE_LAST) {\n      throw new IllegalArgumentException(\"Unpaired low surrogate: \" + ch);\n    }\n    if (ch >= HIGH_SURROGATE_FIRST && ch <= HIGH_SURROGATE_LAST) {\n      return octets + writeUTF8Slow(chars,off,len);\n    }\n    return octets + writeUTF8UpTo3Byte(chars,off,len);\n  }\n  return octets;\n}", "comment": "returns the number of octets written .", "label": "property"}
{"id": "70738", "raw_code": "static boolean verifyZipFile(File file){\n  try {\n    ZipFile zipFile=new ZipFile(file);\n    try {\n      zipFile.close();\n      return true;\n    }\n catch (    IOException e) {\n      Log.w(TAG,\"Failed to close zip file: \" + file.getAbsolutePath());\n    }\n  }\n catch (  ZipException ex) {\n    Log.w(TAG,\"File \" + file.getAbsolutePath() + \" is not a valid zip file.\",ex);\n  }\ncatch (  IOException ex) {\n    Log.w(TAG,\"Got an IOException trying to open zip file: \" + file.getAbsolutePath(),ex);\n  }\n  return false;\n}", "comment": "returns whether the file is a valid zip file .", "label": "property"}
{"id": "61217", "raw_code": "boolean needToCheckExclude(){\n  return false;\n}", "comment": "return whether we need to check namespace prefixes against and exclude result prefixes list .", "label": "property"}
{"id": "57393", "raw_code": "protected <T extends KeySpec>T engineGetKeySpec(Key key,Class<T> keySpec) throws InvalidKeySpecException {\n  BigInteger p, q, g, x, y;\n  if (key != null) {\n    if (keySpec == null) {\n      throw new NullPointerException(\"keySpec == null\");\n    }\n    if (key instanceof DSAPrivateKey) {\n      DSAPrivateKey privateKey=(DSAPrivateKey)key;\n      if (keySpec.equals(DSAPrivateKeySpec.class)) {\n        x=privateKey.getX();\n        DSAParams params=privateKey.getParams();\n        p=params.getP();\n        q=params.getQ();\n        g=params.getG();\n        return (T)(new DSAPrivateKeySpec(x,p,q,g));\n      }\n      if (keySpec.equals(PKCS8EncodedKeySpec.class)) {\n        return (T)(new PKCS8EncodedKeySpec(key.getEncoded()));\n      }\n      throw new InvalidKeySpecException(\"'keySpec' is neither DSAPrivateKeySpec nor PKCS8EncodedKeySpec\");\n    }\n    if (key instanceof DSAPublicKey) {\n      DSAPublicKey publicKey=(DSAPublicKey)key;\n      if (keySpec.equals(DSAPublicKeySpec.class)) {\n        y=publicKey.getY();\n        DSAParams params=publicKey.getParams();\n        p=params.getP();\n        q=params.getQ();\n        g=params.getG();\n        return (T)(new DSAPublicKeySpec(y,p,q,g));\n      }\n      if (keySpec.equals(X509EncodedKeySpec.class)) {\n        return (T)(new X509EncodedKeySpec(key.getEncoded()));\n      }\n      throw new InvalidKeySpecException(\"'keySpec' is neither DSAPublicKeySpec nor X509EncodedKeySpec\");\n    }\n  }\n  throw new InvalidKeySpecException(\"'key' is neither DSAPublicKey nor DSAPrivateKey\");\n}", "comment": "this method returns a specification for the supplied key .", "label": "property"}
{"id": "48437", "raw_code": "public static boolean pointOutsidePrefSize(JTable table,int row,int column,Point p){\n  if (table.convertColumnIndexToModel(column) != 0 || row == -1) {\n    return true;\n  }\n  TableCellRenderer tcr=table.getCellRenderer(row,column);\n  Object value=table.getValueAt(row,column);\n  Component cell=tcr.getTableCellRendererComponent(table,value,false,false,row,column);\n  Dimension itemSize=cell.getPreferredSize();\n  Rectangle cellBounds=table.getCellRect(row,column,false);\n  cellBounds.width=itemSize.width;\n  cellBounds.height=itemSize.height;\n  assert (p.x >= cellBounds.x && p.y >= cellBounds.y);\n  return p.x > cellBounds.x + cellBounds.width || p.y > cellBounds.y + cellBounds.height;\n}", "comment": "returns true if the given point is outside the preferredsize of the item at the given row of the table .", "label": "property"}
{"id": "21877", "raw_code": "public Method suspendSRDFGroupMethod(final URI systemURI,final RemoteDirectorGroup group,final List<URI> sourceVolumes,final List<URI> targetVolumes){\n  return new Workflow.Method(SUSPEND_SRDF_GROUP_METHOD,systemURI,group,sourceVolumes,targetVolumes);\n}", "comment": "returns a workflow . method for suspending srdf group", "label": "property"}
{"id": "4709", "raw_code": "public boolean isExpired(){\n  return (cookieExpiryDate != null && cookieExpiryDate.getTime() <= System.currentTimeMillis());\n}", "comment": "returns true if this cookie has expired .", "label": "property"}
{"id": "16779", "raw_code": "public static String[] parseTitle(String title){\n  String v[]={\"\",\"\"};\n  if (title == null)   return v;\n  Pattern p=Pattern.compile(\"(.*)\\\\s+\\\\(?([0-9]{4})\\\\)?\",Pattern.CASE_INSENSITIVE);\n  Matcher m=p.matcher(title);\n  if (m.find()) {\n    v[0]=m.group(1);\n    v[1]=m.group(2);\n  }\n else {\n    v[0]=title;\n  }\n  return v;\n}", "comment": "return a 2 element array .", "label": "property"}
{"id": "75558", "raw_code": "public String sel(){\n  return mSelection.toString();\n}", "comment": "returns the selection produced by this object .", "label": "property"}
{"id": "38404", "raw_code": "private int indexOfElementInLevel(int element,int level[]) throws Exception {\n  for (int i=0; i < level.length; i++) {\n    if (level[i] == element) {\n      return i;\n    }\n  }\n  throw new Exception(\"Error. Didn't find element \" + m_nodes.get(element).ID + \" in level. Inspect code for \"+ \"weka.gui.graphvisualizer.HierarchicalBCEngine\");\n}", "comment": "returns the index of an element in a level .", "label": "property"}
{"id": "51004", "raw_code": "public final CharSequence yytext(){\n  return zzBuffer.subSequence(zzStartRead,zzMarkedPos);\n}", "comment": "returns the text matched by the current regular expression .", "label": "property"}
{"id": "17509", "raw_code": "public static String canonicalizePath(String path,boolean discardRelativePrefix){\n  int segmentStart=0;\n  int deletableSegments=0;\n  for (int i=0; i <= path.length(); ) {\n    int nextSegmentStart;\n    if (i == path.length()) {\n      nextSegmentStart=i;\n    }\n else     if (path.charAt(i) == '/') {\n      nextSegmentStart=i + 1;\n    }\n else {\n      i++;\n      continue;\n    }\n    if (i == segmentStart + 1 && path.regionMatches(segmentStart,\".\",0,1)) {\n      path=path.substring(0,segmentStart) + path.substring(nextSegmentStart);\n      i=segmentStart;\n    }\n else     if (i == segmentStart + 2 && path.regionMatches(segmentStart,\"..\",0,2)) {\n      if (deletableSegments > 0 || discardRelativePrefix) {\n        deletableSegments--;\n        int prevSegmentStart=path.lastIndexOf('/',segmentStart - 2) + 1;\n        path=path.substring(0,prevSegmentStart) + path.substring(nextSegmentStart);\n        i=segmentStart=prevSegmentStart;\n      }\n else {\n        i++;\n        segmentStart=i;\n      }\n    }\n else {\n      if (i > 0) {\n        deletableSegments++;\n      }\n      i++;\n      segmentStart=i;\n    }\n  }\n  return path;\n}", "comment": "returns the path will relative path segments like \" . . \" and \" . \" resolved .", "label": "property"}
{"id": "37583", "raw_code": "protected String[][] toArray(){\n  int i;\n  int n;\n  int ii;\n  int nn;\n  int x;\n  int y;\n  String[][] result;\n  String[][] tmpResult;\n  int cols;\n  int rows;\n  boolean valueExists;\n  rows=getVisibleRowCount();\n  if (getShowAverage()) {\n    rows++;\n  }\n  cols=getVisibleColCount();\n  if (getShowStdDev()) {\n    cols=cols * 3;\n  }\n else {\n    cols=cols * 2;\n  }\n  result=new String[rows + 2][cols + 1];\n  result[0][0]=trimString(\"Dataset\",getRowNameWidth());\n  x=1;\n  for (ii=0; ii < getColCount(); ii++) {\n    i=getDisplayCol(ii);\n    if (getColHidden(i)) {\n      continue;\n    }\n    result[0][x]=trimString(removeFilterName(getColName(i)),getColNameWidth());\n    x++;\n    if (getShowStdDev()) {\n      result[0][x]=\"\";\n      x++;\n    }\n    result[0][x]=\"\";\n    x++;\n  }\n  y=1;\n  for (ii=0; ii < getRowCount(); ii++) {\n    i=getDisplayRow(ii);\n    if (!getRowHidden(i)) {\n      result[y][0]=trimString(removeFilterName(getRowName(i)),getRowNameWidth());\n      y++;\n    }\n  }\n  y=1;\n  for (ii=0; ii < getRowCount(); ii++) {\n    i=getDisplayRow(ii);\n    if (getRowHidden(i)) {\n      continue;\n    }\n    x=1;\n    for (nn=0; nn < getColCount(); nn++) {\n      n=getDisplayCol(nn);\n      if (getColHidden(n)) {\n        continue;\n      }\n      valueExists=(!Double.isNaN(getMean(n,i)));\n      if (!valueExists) {\n        result[y][x]=\"\";\n      }\n else {\n        result[y][x]=doubleToString(getMean(n,i),getMeanPrec());\n      }\n      x++;\n      if (getShowStdDev()) {\n        if (!valueExists) {\n          result[y][x]=\"\";\n        }\n else         if (Double.isInfinite(getStdDev(n,i))) {\n          result[y][x]=\"Inf\";\n        }\n else {\n          result[y][x]=doubleToString(getStdDev(n,i),getStdDevPrec());\n        }\n        x++;\n      }\n      if (!valueExists) {\n        result[y][x]=\"\";\n      }\n else {\nswitch (getSignificance(n,i)) {\ncase SIGNIFICANCE_TIE:\n          result[y][x]=TIE_STRING;\n        break;\ncase SIGNIFICANCE_WIN:\n      result[y][x]=WIN_STRING;\n    break;\ncase SIGNIFICANCE_LOSS:\n  result[y][x]=LOSS_STRING;\nbreak;\n}\n}\nx++;\n}\ny++;\n}\nif (getShowAverage()) {\ny=result.length - 2;\nx=0;\nresult[y][0]=\"Average\";\nx++;\nfor (ii=0; ii < getColCount(); ii++) {\ni=getDisplayCol(ii);\nif (getColHidden(i)) {\ncontinue;\n}\nresult[y][x]=doubleToString(getAverage(i),getMeanPrec());\nx++;\nif (getShowStdDev()) {\nresult[y][x]=\"\";\nx++;\n}\nresult[y][x]=\"\";\nx++;\n}\n}\ny=result.length - 1;\nx=0;\nresult[y][0]=LEFT_PARENTHESES + WIN_STRING + \"/\"+ TIE_STRING+ \"/\"+ LOSS_STRING+ RIGHT_PARENTHESES;\nx++;\nfor (ii=0; ii < getColCount(); ii++) {\ni=getDisplayCol(ii);\nif (getColHidden(i)) {\ncontinue;\n}\nresult[y][x]=\"\";\nx++;\nif (getShowStdDev()) {\nresult[y][x]=\"\";\nx++;\n}\nresult[y][x]=LEFT_PARENTHESES + getSignificanceCount(i,SIGNIFICANCE_WIN) + \"/\"+ getSignificanceCount(i,SIGNIFICANCE_TIE)+ \"/\"+ getSignificanceCount(i,SIGNIFICANCE_LOSS)+ RIGHT_PARENTHESES;\nx++;\n}\ntmpResult=new String[result.length][result[0].length - 1];\nx=0;\nfor (i=0; i < result[0].length; i++) {\nif (((i == 3) && (getShowStdDev())) || ((i == 2) && (!getShowStdDev()))) {\ncontinue;\n}\nfor (n=0; n < result.length; n++) {\ntmpResult[n][x]=result[n][i];\n}\nx++;\n}\nresult=tmpResult;\nreturn result;\n}", "comment": "returns a 2 - dimensional array with the prepared data .", "label": "property"}
{"id": "23837", "raw_code": "static boolean causedByRDE(DiskAccessException dae){\n  boolean result=false;\n  if (dae != null) {\n    Throwable cause=dae.getCause();\n    while (cause != null) {\n      if (cause instanceof RegionDestroyedException) {\n        result=true;\n        break;\n      }\n      cause=cause.getCause();\n    }\n  }\n  return result;\n}", "comment": "return true if dae was caused by a regiondestroyedexception .", "label": "property"}
{"id": "16445", "raw_code": "public static <K,V>Map<K,V> of(K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,K k5,V v5){\n  Map map=of();\n  map.put(k1,v1);\n  map.put(k2,v2);\n  map.put(k3,v3);\n  map.put(k4,v4);\n  map.put(k5,v5);\n  return map;\n}", "comment": "returns map containing the given entries .", "label": "property"}
{"id": "38931", "raw_code": "protected int chooseRandomIndexBasedOnProportions(double[] proportionArray,Random random){\n  double probSum;\n  double val;\n  int index;\n  double sum;\n  probSum=Utils.sum(proportionArray);\n  val=random.nextDouble() * probSum;\n  index=0;\n  sum=0.0;\n  while ((sum <= val) && (index < proportionArray.length)) {\n    sum+=proportionArray[index++];\n  }\n  return index - 1;\n}", "comment": "returns a random index based on the given proportions", "label": "property"}
{"id": "4135", "raw_code": "public String description(){\n  StringBuilder sb=new StringBuilder();\n  if (isCombo()) {\n    int i=0;\n    for (    NewComboLeg leg : m_comboLegs) {\n      if (i++ > 0) {\n        sb.append(\"/\");\n      }\n      sb.append(leg.toString());\n    }\n  }\n else {\n    sb.append(m_symbol);\n    app(sb,m_secType);\n    app(sb,m_exchange);\n    if (m_exchange != null && m_exchange.equals(\"SMART\") && m_primaryExch != null) {\n      app(sb,m_primaryExch);\n    }\n    app(sb,m_expiry);\n    if (m_strike != 0) {\n      app(sb,m_strike);\n    }\n    if (m_right != Right.None) {\n      app(sb,m_right);\n    }\n  }\n  return sb.toString();\n}", "comment": "returns a text description that can be used for display .", "label": "property"}
{"id": "43175", "raw_code": "protected <T extends TaskServiceDocument<E>,E extends Enum<E>>T waitForTaskCompletion(String documentSelfLink,Class<T> type) throws Throwable {\n  return waitForPropertyValue(documentSelfLink,type,TaskServiceDocument.FIELD_NAME_TASK_STAGE,Arrays.asList(TaskStage.FINISHED,TaskStage.FAILED,TaskStage.CANCELLED),true,waitForStageChangeCountLonger());\n}", "comment": "waits until the given task completes and returns its final state .", "label": "property"}
{"id": "76498", "raw_code": "private List<EndIsland> findSurroundingIslands(int chunkX,int chunkY,int chunksPerFragmentX,int chunksPerFragmentY){\n  List<EndIsland> result=new LinkedList<EndIsland>();\n  for (int y=-SURROUNDING_CHUNKS; y <= chunksPerFragmentY + SURROUNDING_CHUNKS; y++) {\n    for (int x=-SURROUNDING_CHUNKS; x <= chunksPerFragmentX + SURROUNDING_CHUNKS; x++) {\n      EndIsland island=tryCreateEndIsland(chunkX + x,chunkY + y);\n      if (island != null) {\n        result.add(island);\n      }\n    }\n  }\n  return result;\n}", "comment": "returns a list of all islands that might be touching a chunk - area .", "label": "property"}
{"id": "48363", "raw_code": "private boolean isSelfSigned(X509Certificate cert){\n  return signedBy(cert,cert);\n}", "comment": "returns true if the certificate is self - signed , false otherwise .", "label": "property"}
{"id": "57774", "raw_code": "public Object newNonMovableArray(Class<?> componentType,int length){\n  return Array.newInstance(componentType,length);\n}", "comment": "returns an array allocated in an area of the java heap where it will never be moved .", "label": "property"}
{"id": "44250", "raw_code": "public static int uriType(String uri){\n  if (uri.indexOf(':') != -1) {\n    return ABS_URI;\n  }\n else   if (uri.startsWith(\"/\")) {\n    return ROOT_REL_URI;\n  }\n else {\n    return NOROOT_REL_URI;\n  }\n}", "comment": "returns the type of a uri : abs _ uri root _ rel _ uri noroot _ rel _ uri", "label": "property"}
{"id": "9510", "raw_code": "public static boolean isResourceReference(String str){\n  return str.startsWith(BIG_QUOTE_LEFT) && str.endsWith(BIG_QUOTE_RIGHT) && str.charAt(1) == AT.charAt(0);\n}", "comment": "return the str is resource reference or not .", "label": "property"}
{"id": "46008", "raw_code": "public Enumeration<? extends Principal> members(){\n  Vector<Principal> v=new Vector<Principal>(1);\n  v.addElement(this);\n  return v.elements();\n}", "comment": "returns an enumeration which contains the subnet mask .", "label": "property"}
{"id": "34516", "raw_code": "private long cacheResponseAge(){\n  long apparentReceivedAge=servedDate != null ? Math.max(0,receivedResponseMillis - servedDate.getTime()) : 0;\n  long receivedAge=ageSeconds != -1 ? Math.max(apparentReceivedAge,SECONDS.toMillis(ageSeconds)) : apparentReceivedAge;\n  long responseDuration=receivedResponseMillis - sentRequestMillis;\n  long residentDuration=nowMillis - receivedResponseMillis;\n  return receivedAge + responseDuration + residentDuration;\n}", "comment": "returns the current age of the response , in milliseconds .", "label": "property"}
{"id": "18194", "raw_code": "private static int arrayIndex(int i){\n  return (i >> SHIFT_PER_WORD);\n}", "comment": "returns the array element holding the bit value for the given integer", "label": "property"}
{"id": "48523", "raw_code": "public int rgbFor(int pixel){\n  return surfaceType.rgbFor(pixel,colorModel);\n}", "comment": "returns the argb representation for the specified integer value which is packed in the format of the associated colormodel .", "label": "property"}
{"id": "60971", "raw_code": "public synchronized byte[] toByteArray(){\n  byte[] newArray=new byte[count];\n  System.arraycopy(buf,0,newArray,0,count);\n  return newArray;\n}", "comment": "returns the contents of this bytearrayoutputstream as a byte array .", "label": "property"}
{"id": "38021", "raw_code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> newVector=new Vector<Option>(3);\n  newVector.addElement(new Option(\"\\tSize of each bag, as a percentage of the\\n\" + \"\\ttraining set size. (default 100)\",\"P\",1,\"-P\"));\n  newVector.addElement(new Option(\"\\tCalculate the out of bag error.\",\"O\",0,\"-O\"));\n  newVector.addElement(new Option(\"\\tRepresent copies of instances using weights rather than explicitly.\",\"-represent-copies-using-weights\",0,\"-represent-copies-using-weights\"));\n  newVector.addAll(Collections.list(super.listOptions()));\n  return newVector.elements();\n}", "comment": "returns an enumeration describing the available options .", "label": "property"}
{"id": "57411", "raw_code": "private boolean isValid(CharSequence text){\n  for (int i=0; i < text.length(); i++) {\n    char c=text.charAt(i);\n    boolean valid=c == 0x9 || c == 0xA || c == 0xD || (c >= 0x20 && c <= 0xd7ff) || (c >= 0xe000 && c <= 0xfffd);\n    if (!valid) {\n      return false;\n    }\n  }\n  return true;\n}", "comment": "returns true if all of the characters in the text are permitted for use in xml documents .", "label": "property"}
{"id": "3124", "raw_code": "public static boolean isSQL99NonReservedKeyword(String identifier){\n  if (identifier == null) {\n    throw new NullPointerException(\"The identifier cannot be null\");\n  }\n  return Arrays.binarySearch(SQL99_NON_RESERVED,identifier.toUpperCase()) >= 0;\n}", "comment": "returns true if the given identifier is a sql - 99 non - reserved keyword .", "label": "property"}
{"id": "16114", "raw_code": "ConverterSet add(Converter converter,Converter[] removed){\n  Converter[] converters=iConverters;\n  int length=converters.length;\n  for (int i=0; i < length; i++) {\n    Converter existing=converters[i];\n    if (converter.equals(existing)) {\n      if (removed != null) {\n        removed[0]=null;\n      }\n      return this;\n    }\n    if (converter.getSupportedType() == existing.getSupportedType()) {\n      Converter[] copy=new Converter[length];\n      for (int j=0; j < length; j++) {\n        if (j != i) {\n          copy[j]=converters[j];\n        }\n else {\n          copy[j]=converter;\n        }\n      }\n      if (removed != null) {\n        removed[0]=existing;\n      }\n      return new ConverterSet(copy);\n    }\n  }\n  Converter[] copy=new Converter[length + 1];\n  System.arraycopy(converters,0,copy,0,length);\n  copy[length]=converter;\n  if (removed != null) {\n    removed[0]=null;\n  }\n  return new ConverterSet(copy);\n}", "comment": "returns a copy of this set , with the given converter added .", "label": "property"}
{"id": "28563", "raw_code": "public Iterator<JsonElement> iterator(){\n  return elements.iterator();\n}", "comment": "returns an iterator to navigate the elements of the array .", "label": "property"}
{"id": "17175", "raw_code": "public static final int typeIndex(Class type){\n  Class[] list=primitiveTypes;\n  int n=list.length;\n  for (int i=0; i < n; i++)   if (list[i] == type)   return i;\n  throw new RuntimeException(\"bad type:\" + type.getName());\n}", "comment": "returns an index for accessing arrays in this class .", "label": "property"}
{"id": "17229", "raw_code": "public Block block(){\n  return block;\n}", "comment": "returns the basic block indicated by this node .", "label": "property"}
{"id": "81345", "raw_code": "public static TypeBinding[] substitute(Substitution substitution,TypeBinding[] originalTypes){\n  if (originalTypes == null)   return null;\n  TypeBinding[] substitutedTypes=originalTypes;\n  for (int i=0, length=originalTypes.length; i < length; i++) {\n    TypeBinding originalType=originalTypes[i];\n    TypeBinding substitutedParameter=substitute(substitution,originalType);\n    if (substitutedParameter != originalType) {\n      if (substitutedTypes == originalTypes) {\n        System.arraycopy(originalTypes,0,substitutedTypes=new TypeBinding[length],0,i);\n      }\n      substitutedTypes[i]=substitutedParameter;\n    }\n else     if (substitutedTypes != originalTypes) {\n      substitutedTypes[i]=originalType;\n    }\n  }\n  return substitutedTypes;\n}", "comment": "returns an array of types , where original types got substituted given a substitution .", "label": "property"}
{"id": "56387", "raw_code": "public final boolean isOpen(){\n  return closed.get() == false;\n}", "comment": "returns true if this lock is still open ie . has not been closed yet .", "label": "property"}
{"id": "76121", "raw_code": "@TCB static String stripBannedCodeunits(String s){\n  int safeLimit=longestPrefixOfGoodCodeunits(s);\n  if (safeLimit < 0) {\n    return s;\n  }\n  StringBuilder sb=new StringBuilder(s);\n  stripBannedCodeunits(sb,safeLimit);\n  return sb.toString();\n}", "comment": "returns the portion of its input that consists of xml safe chars .", "label": "property"}
{"id": "60876", "raw_code": "private static Locale strip(Locale locale){\n  String language=locale.getLanguage();\n  String country=locale.getCountry();\n  String variant=locale.getVariant();\n  if (!variant.isEmpty()) {\n    variant=\"\";\n  }\n else   if (!country.isEmpty()) {\n    country=\"\";\n  }\n else   if (!language.isEmpty()) {\n    language=\"\";\n  }\n else {\n    return null;\n  }\n  return new Locale(language,country,variant);\n}", "comment": "returns a locale with the most - specific field removed , or null if this locale had an empty language , country and variant .", "label": "property"}
{"id": "57635", "raw_code": "public String next(Pattern pattern){\n  checkOpen();\n  checkNotNull(pattern);\n  matchSuccessful=false;\n  saveCurrentStatus();\n  if (!setTokenRegion()) {\n    recoverPreviousStatus();\n    throw new NoSuchElementException();\n  }\n  matcher.usePattern(pattern);\n  if (!matcher.matches()) {\n    recoverPreviousStatus();\n    throw new InputMismatchException();\n  }\n  matchSuccessful=true;\n  return matcher.group();\n}", "comment": "returns the next token if it matches the specified pattern .", "label": "property"}
{"id": "23147", "raw_code": "private String encodeProduct(){\n  StringBuffer tokens=new StringBuffer();\n  ListIterator it=productTokens.listIterator();\n  while (it.hasNext()) {\n    tokens.append((String)it.next());\n  }\n  return tokens.toString();\n}", "comment": "return canonical form .", "label": "property"}
{"id": "21412", "raw_code": "protected String toMessage(Map<String,String> results){\n  StringBuilder builder=new StringBuilder();\n  if (results != null) {\n    for (    Map.Entry<String,String> entry : results.entrySet()) {\n      builder.append(entry.getKey() + \": \" + entry.getValue()+ \";\\n\");\n    }\n  }\n  return builder.toString();\n}", "comment": "returns a formatted string of the results .", "label": "property"}
{"id": "39032", "raw_code": "public Enumeration<Option> listOptions(){\n  Vector<Option> result=new Vector<Option>();\n  result.add(new Option(\"\\tSkip identical instances (distances equal to zero).\\n\",\"S\",1,\"-S\"));\n  result.addAll(Collections.list(super.listOptions()));\n  return result.elements();\n}", "comment": "returns an enumeration describing the available options .", "label": "property"}
{"id": "72505", "raw_code": "public double[] levelZeroData(){\n  List<Buffer> levelZeroBuffers=bufferMap.get(0);\n  int length=0;\n  for (  Buffer buffer : levelZeroBuffers) {\n    if (!buffer.hasCapacity()) {\n      length+=buffer.size;\n    }\n else {\n      length+=buffer.next;\n    }\n  }\n  int pos=0;\n  int currLen;\n  final double[] out=new double[length];\n  for (  Buffer buffer : levelZeroBuffers) {\n    if (!buffer.hasCapacity()) {\n      currLen=buffer.size;\n    }\n else {\n      currLen=buffer.next;\n    }\n    System.arraycopy(buffer.data,0,out,pos,currLen);\n    pos+=currLen;\n  }\n  return out;\n}", "comment": "returns a fresh copy of all data from level 0 buffers .", "label": "property"}
{"id": "21423", "raw_code": "public String[] showVersion() throws NetworkDeviceControllerException {\n  String[] returnVal=new String[2];\n  SSHPrompt[] prompts={SSHPrompt.MDS_POUND,SSHPrompt.MDS_GREATER_THAN};\n  StringBuilder buf=new StringBuilder();\n  SSHPrompt prompt=sendWaitFor(MDSDialogProperties.getString(\"MDSDialog.showVersion.cmd\"),10000,prompts,buf);\n  String[] lines=getLines(buf);\n  String[] regex={MDSDialogProperties.getString(\"MDSDialog.showVersion.version.match\"),MDSDialogProperties.getString(\"MDSDialog.showVersion.MDS.match\"),MDSDialogProperties.getString(\"MDSDialog.showVersion.Nexus.match\")};\n  String[] groups=new String[2];\n  for (  String line : lines) {\n    int index=match(line,regex,groups);\nswitch (index) {\ncase 0:\n      returnVal[1]=groups[0];\n    break;\ncase 1:\n  returnVal[0]=groups[0];\nbreak;\ncase 2:\nreturnVal[0]=groups[0];\nbreak;\n}\n}\nreturn returnVal;\n}", "comment": "returns the device type and software version", "label": "property"}
{"id": "15936", "raw_code": "public static byte[] readAllLimited(InputStream inStr,int limit) throws IOException {\n  ByteArrayOutputStream buf=new ByteArrayOutputStream();\n  pipeAllLimited(inStr,limit,buf);\n  return buf.toByteArray();\n}", "comment": "read from instr up to a maximum number of bytes , throwing an exception if more the maximum amount of requested data is available .", "label": "property"}
{"id": "75196", "raw_code": "private Scope peek() throws JSONException {\n  if (stack.isEmpty()) {\n    throw new JSONException(\"Nesting problem\");\n  }\n  return stack.get(stack.size() - 1);\n}", "comment": "returns the value on the top of the stack .", "label": "property"}
{"id": "32070", "raw_code": "public static int indexOfLastSeparator(String filename){\n  if (filename == null)   return -1;\n  int lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos,lastWindowsPos);\n}", "comment": "returns the index of the last directory separator character .", "label": "property"}
{"id": "62660", "raw_code": "public static double rootMeansSquaredError(double[] real,double[] predicted){\n  double ret=0.0;\n  for (int i=0; i < real.length; i++) {\n    ret+=Math.pow((real[i] - predicted[i]),2);\n  }\n  return Math.sqrt(ret / real.length);\n}", "comment": "this returns the root mean squared error of two data sets", "label": "property"}
{"id": "50435", "raw_code": "public String linkForMessage(ProtoElement element){\n  if (isExternalFile(element.getFile())) {\n    String fullName=element.getFullName();\n    return String.format(\"[%s]{@link external:\\\"%s\\\"}\",fullName,fullName);\n  }\n else {\n    String simpleName=element.getSimpleName();\n    return String.format(\"[%s]{@link %s}\",simpleName,simpleName);\n  }\n}", "comment": "returns the jsdoc format of link to the element .", "label": "property"}
{"id": "46416", "raw_code": "private int convertLocationToColumn(int x,int y){\n  if (cellWidth > 0) {\n    if (layoutOrientation == JList.VERTICAL) {\n      return 0;\n    }\n    Insets insets=list.getInsets();\n    int col;\n    if (isLeftToRight) {\n      col=(x - insets.left) / cellWidth;\n    }\n else {\n      col=(list.getWidth() - x - insets.right- 1) / cellWidth;\n    }\n    if (col < 0) {\n      return 0;\n    }\n else     if (col >= columnCount) {\n      return columnCount - 1;\n    }\n    return col;\n  }\n  return 0;\n}", "comment": "returns the closest column to the passed in location .", "label": "property"}
{"id": "17155", "raw_code": "boolean isScrollOutOfBounds(){\n  return Float.compare(getScrollAmountOutOfBounds(mStackScrollP),0f) != 0;\n}", "comment": "returns whether the specified scroll is out of bounds", "label": "property"}
{"id": "67462", "raw_code": "public List<Instruction> reduceInstructions(final List<Instruction> instructions){\n  lock.lock();\n  try {\n    this.instructions=instructions;\n    stackSizeSimulator.buildStackSizes(instructions);\n    return reduceInstructionsInternal(instructions);\n  }\n  finally {\n    lock.unlock();\n  }\n}", "comment": "returns all instructions which are somewhat \" relevant \" for the returned object of the method .", "label": "property"}
{"id": "46645", "raw_code": "protected boolean arePathsContiguous(TreePath[] paths){\n  if (rowMapper == null || paths.length < 2)   return true;\n else {\n    BitSet bitSet=new BitSet(32);\n    int anIndex, counter, min;\n    int pathCount=paths.length;\n    int validCount=0;\n    TreePath[] tempPath=new TreePath[1];\n    tempPath[0]=paths[0];\n    min=rowMapper.getRowsForPaths(tempPath)[0];\n    for (counter=0; counter < pathCount; counter++) {\n      if (paths[counter] != null) {\n        tempPath[0]=paths[counter];\n        int[] rows=rowMapper.getRowsForPaths(tempPath);\n        if (rows == null) {\n          return false;\n        }\n        anIndex=rows[0];\n        if (anIndex == -1 || anIndex < (min - pathCount) || anIndex > (min + pathCount))         return false;\n        if (anIndex < min)         min=anIndex;\n        if (!bitSet.get(anIndex)) {\n          bitSet.set(anIndex);\n          validCount++;\n        }\n      }\n    }\n    int maxCounter=validCount + min;\n    for (counter=min; counter < maxCounter; counter++)     if (!bitSet.get(counter))     return false;\n  }\n  return true;\n}", "comment": "returns true if the paths are contiguous , or this object has no rowmapper .", "label": "property"}
{"id": "79425", "raw_code": "public static String nowDateString(String format){\n  SimpleDateFormat df=new SimpleDateFormat(format);\n  return df.format(new Date());\n}", "comment": "return a string formatted as format", "label": "property"}
{"id": "3428", "raw_code": "public final void sample(){\n  long sum=_sum.getAndSet(0);\n  int count=_count.getAndSet(0);\n  if (count != 0)   _value=sum / (double)count;\n else   _value=0;\n}", "comment": "return the probe ' s next sample .", "label": "property"}
{"id": "82178", "raw_code": "private boolean isMediaTypeSupported(String media){\n  for (int i=0; i < SUPPORTED_MEDIA_TYPES.length; i++) {\n    if (media.equalsIgnoreCase(SUPPORTED_MEDIA_TYPES[i])) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "returns true if the specified css media type is unsupported , false otherwise", "label": "property"}
{"id": "41261", "raw_code": "public static boolean isNetworkAvailable(Context context){\n  ConnectivityManager connectivityManager=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);\n  NetworkInfo info=connectivityManager.getActiveNetworkInfo();\n  return info != null && info.isConnected();\n}", "comment": "returns network availability status .", "label": "property"}
